<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AgriCart - Staff Dashboard</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        /* Modern Staff Dashboard Styles */
        * {
            box-sizing: border-box;
        }

        /* Design tokens for modern staff look - matching admin dashboard */
        :root {
            --bg: #f3f7ed;             /* soft greenish background */
            --surface: #ffffff;        /* card surface */
            --surface-2: #f6f8fb;      /* subtle surface */
            --text: #1e293b;           /* slate-800 */
            --muted: #64748b;          /* slate-500 */
            --brand: #9ad061;          /* light green accent from screenshot */
            --brand-strong: #74b43a;   /* stronger accent */
            --amber: #ebad2d;          /* sidebar amber */
            --radius: 14px;
            --shadow: 0 8px 24px rgba(2, 6, 23, .06);
        }

        html, body {
            font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
        }
        
        body {
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
        }

        /* Main Layout */
        .screen {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            background: #f8fafc;
            position: relative;
        }

        .dashboard-container {
            display: flex;
            flex: 1;
            min-height: 100vh;
        }


        /* Sidebar */
        .sidebar {
            width: 240px; /* fixed expanded width */
            background: #243a27;
            border-right: 1px solid #e2e8f0;
            padding: 18px 0;
            flex-shrink: 0;
            overflow: visible !important;
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }

        /* Sidebar Brand Logo */
        .sidebar-brand {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 16px 16px 16px;
            margin-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sidebar-brand .brand-staff {
            color: #ffffff;
            font-weight: 700;
            letter-spacing: .3px;
            line-height: 1;
            font-size: 16px;
        }

        .sidebar-brand .brand-leaf {
            color: #ffffff; /* white leaf icon */
            font-size: 16px;
            position: relative;
            top: -1px; /* nudge up slightly like the leaf in logo */
        }

        /* Keep sidebar always expanded - no hover effects */
        body.sidebar-open .sidebar {
            width: 240px; /* same as default */
            padding: 18px 0;
        }

        .sidebar.collapsed {
            width: 240px; /* same as expanded width */
        }

        .sidebar.collapsed .menu-item span {
            display: block; /* titles always visible */
        }

        .sidebar.collapsed .menu-item {
			justify-content: center;
			padding: 8px 0; /* remove left/right gaps even when collapsed */
        }

        .sidebar-menu {
            list-style: none;
			margin: 0;
			padding: 0; /* no left/right padding on list */
			width: 100%;
            flex: 1;
        }

        /* Sidebar Profile Section */
        .sidebar-profile {
            margin-top: auto;
            padding: 16px 16px 0 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: visible !important;
            margin-bottom: 0;
        }

        .sidebar-profile .profile-dropdown {
            position: relative;
            width: 100%;
            margin: 0;
        }

        .sidebar-profile .profile-section {
            display: flex;
            align-items: center;
            padding: 5px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s ease;
            background: transparent;
            pointer-events: auto !important;
            user-select: none;
            margin: 0;
            border: none !important;
        }

        .sidebar-profile .profile-section:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .sidebar-profile .profile-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #30442d;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
        }

        .sidebar-profile .profile-avatar i {
            color: white;
            font-size: 14px;
        }

        .sidebar-profile .profile-info {
            flex: 1;
        }

        .sidebar-profile .profile-name {
            color: white;
            font-weight: 500;
            font-size: 14px;
            line-height: 1.2;
        }

        .sidebar-profile .profile-role {
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            line-height: 1.2;
        }

        .sidebar-profile .dropdown-menu {
            position: fixed !important;
            background: white !important;
            border-radius: 8px !important;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1) !important;
            min-width: 200px !important;
            z-index: 9999 !important;
            opacity: 0 !important;
            visibility: hidden !important;
            transform: translateY(-10px) !important;
            transition: all 0.3s ease !important;
            border: 0.2px solid rgba(0, 0, 0, 0.08) !important;
            overflow: hidden !important;
            display: block !important;
            pointer-events: none !important;
            width: 200px !important;
            max-height: 300px !important;
        }

        /* Ensure dropdown is always clickable */
        .sidebar-profile .dropdown-menu {
            pointer-events: auto !important;
            user-select: none !important;
            cursor: pointer !important;
        }

        .sidebar-profile .dropdown-menu * {
            pointer-events: auto !important;
            cursor: pointer !important;
        }

        .sidebar-profile .dropdown-menu .dropdown-item {
            pointer-events: auto !important;
            cursor: pointer !important;
        }

        .sidebar-profile .dropdown-menu .dropdown-item:hover {
            pointer-events: auto !important;
            cursor: pointer !important;
        }

        .sidebar-profile .dropdown-menu.show {
            opacity: 1 !important;
            visibility: visible !important;
            transform: translateY(0) !important;
            pointer-events: auto !important;
            display: block !important;
            z-index: 9999 !important;
        }

        .menu-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 12px;
            width: 100%;
            box-sizing: border-box;
            margin: 4px 0 !important;
            color: #ebad2d;
            text-decoration: none;
            transition: none !important;
            cursor: pointer;
            border-bottom: 0;
            border-left: 0 !important;
            position: relative;
            background: transparent !important;
            box-shadow: none !important;
            min-height: 48px;
            height: 48px;
        }

		/* Disable any decorative left pseudo-element if present */
		.sidebar .menu-item::before {
			content: none !important;
		}

        .menu-item:hover {
            background: rgba(244, 166, 43, 0.12) !important;
            padding: 12px 12px;
            margin-left: 0 !important;
            margin-right: 0 !important;
            color: #ebad2d;
            transform: none !important;
            height: 48px;
            transition: none !important;
        }

		/* Ensure no green appears on hover within the sidebar menu */
		.sidebar .menu-item:hover,
		.sidebar .menu-item:hover *,
		.sidebar .menu-item:hover a {
			color: #ebad2d !important;
		}

		.menu-item.active { 
			background: transparent !important; 
			color: white !important;
			transform: translateX(5px);
			border-left: 3px solid #ebad2d;
			box-shadow: 0 4px 12px rgba(244, 166, 43, 0.28);
		}

		.menu-item.active span {
			color: white !important;
		}

		.menu-item.active i {
			color: white !important;
		}

		/* Optional: use left border as the active indicator by adding .left-indicator */
		.menu-item.active.left-indicator {
			border-bottom: 0;
			border-left: 2px solid #f4c460;
		}
		/* separators removed for a clean, flat style; active item shows only an underline */

        /* Icon hover animation */
        .menu-item i {
            width: 20px;
            text-align: center;
            font-size: 13px;
            flex-shrink: 0;
            color: #ebad2d;
            transition: all 0.3s ease;
        }

        .menu-item:hover i {
            transform: scale(1.1);
            color: #ebad2d;
        }

        .menu-item span { 
            opacity: 1; 
            display: block; 
            font-weight: 500;
        }

        /* Wrap delivery settings text only when sidebar is expanded - no transitions */
        /* Removed specific delivery-settings text wrapping overrides to use general menu styling */

        /* Ensure delivery settings menu item has completely fixed properties with maximum specificity */
        /* Removed specific delivery-settings overrides to use general menu styling */

        /* Removed specific delivery-settings hover overrides to use general menu styling */

        /* Removed specific delivery-settings span overrides to use general menu styling */

        /* Ensure the icon inside delivery-settings has no movement with maximum specificity */
        /* Removed specific delivery-settings icon overrides to use general menu styling */

        /* Removed specific delivery-settings hover icon overrides to use general menu styling */

        /* Menu items always visible - no hover effects */
        .sidebar .menu-item span {
            opacity: 1;
            display: block;
        }

        /* Keep text always visible */
        body.sidebar-open .sidebar .menu-item span {
            opacity: 1;
            display: block;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            margin-left: 240px; /* Account for fixed sidebar width */
            min-height: 100vh;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            position: relative;
        }


        /* Chat Toggle Button - Floating */
        .chat-toggle-btn {
            position: absolute;
            top: 58px;
            right: 65px;
            background: var(--brand);
            color: white;
            border: none;
            border-radius: 50%;
            width: 56px;
            height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
            z-index: 999999 !important;
        }
        
        /* Ensure body and html don't create containing blocks */
        html, body {
            transform: none !important;
            will-change: auto !important;
            backface-visibility: visible !important;
        }

        .chat-toggle-btn:hover {
            background: var(--brand-strong);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .chat-toggle-btn i {
            font-size: 18px;
        }

        .chat-badge {
            position: absolute;
            top: -4px;
            right: -4px;
            background: #ef4444;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
            min-width: 20px;
            opacity: 0;
            /* Removed transform to avoid creating containing block */
            pointer-events: none;
            transition: opacity 0.2s ease-in;
        }

        /* Smooth fade-in when showing badge */
        .chat-badge.showing {
            display: flex !important;
            opacity: 1 !important;
            transition: opacity 0.2s ease-in !important;
        }

        /* Instant hide when badge is hidden */
        .chat-badge.hidden {
            display: none !important;
            opacity: 0 !important;
            transition: none !important;
        }
        
        .no-conversations {
            text-align: center;
            padding: 20px;
            color: #666;
            font-style: italic;
        }

        /* Chat notification animations */
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.2);
            }
            100% {
                transform: scale(1);
            }
        }

        .chat-notification {
            animation: slideIn 0.3s ease-out;
        }

        /* Contact Customer Button Styling */
        .contact-customer-btn {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 16px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 12px;
            width: 100%;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
        }

        .contact-customer-btn:hover {
            background: linear-gradient(135deg, #45a049, #4CAF50);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }

        .contact-customer-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
        }

        .contact-customer-btn i {
            font-size: 16px;
        }

        /* Fix for confirm button in pending orders - ensure it's clickable */
        .order-actions button {
            position: relative !important;
            z-index: 10 !important;
            pointer-events: auto !important;
        }

        /* Specifically target confirm button */
        .order-actions button:first-child,
        .order-actions button[onclick*="confirm"],
        .order-actions button[onclick*="Confirm"] {
            position: relative !important;
            z-index: 100 !important;
            pointer-events: auto !important;
            cursor: pointer !important;
        }

        /* Fix for refund and reschedule buttons during cut-off time - ensure they're clickable */
        .order-actions button[onclick*="showRefundModal"],
        .order-actions button[onclick*="showRescheduleConfirmation"],
        .order-actions .reschedule-btn-cutoff,
        .order-actions .refund-btn-cutoff {
            position: relative !important;
            z-index: 10001 !important;
            pointer-events: auto !important;
            cursor: pointer !important;
            display: inline-block !important;
        }

        /* Ensure order-actions container doesn't block clicks */
        .order-actions {
            position: relative !important;
            z-index: 10000 !important;
            pointer-events: auto !important;
            isolation: isolate !important;
        }

        /* Ensure order-info doesn't block clicks on order-actions */
        .order-info {
            position: relative !important;
            z-index: 1 !important;
            pointer-events: auto !important;
            isolation: isolate !important;
        }

        /* Ensure order-details doesn't block clicks */
        .order-details {
            position: relative !important;
            z-index: 1 !important;
            pointer-events: auto !important;
            isolation: isolate !important;
        }

        /* Ensure order-details children don't block order-actions */
        .order-details > * {
            position: relative !important;
        }

        /* Specifically ensure order-actions is above order-info */
        .order-details .order-info {
            z-index: 1 !important;
            pointer-events: auto !important;
        }

        .order-details .order-actions {
            z-index: 10000 !important;
            position: relative !important;
            pointer-events: auto !important;
        }

        /* Prevent any overlay from blocking buttons */
        .order-card .order-details .order-info::after,
        .order-card .order-details .order-info::before {
            display: none !important;
            pointer-events: none !important;
        }

        /* Ensure cut-off buttons are always clickable */
        .reschedule-btn-cutoff,
        .refund-btn-cutoff {
            position: relative !important;
            z-index: 99999 !important;
            pointer-events: auto !important;
            cursor: pointer !important;
            display: inline-block !important;
            user-select: none !important;
            -webkit-user-select: none !important;
            touch-action: manipulation !important;
        }

        .reschedule-btn-cutoff:hover,
        .refund-btn-cutoff:hover {
            opacity: 0.9 !important;
            transform: translateY(-1px) !important;
        }

        .reschedule-btn-cutoff:active,
        .refund-btn-cutoff:active {
            transform: translateY(0) !important;
            opacity: 0.8 !important;
        }

        /* Ensure order-header doesn't block buttons */
        .order-header.clickable {
            pointer-events: auto !important;
        }

        .order-header.clickable * {
            pointer-events: auto !important;
        }

        /* Make sure order-actions buttons are not blocked by order-header */
        .order-card .order-actions {
            position: relative !important;
            z-index: 9999 !important;
            pointer-events: auto !important;
        }

        .order-card .order-actions button {
            pointer-events: auto !important;
        }

        /* Ensure no overlay is blocking the buttons */
        .order-card,
        .order-details,
        [id^="order-details-"] {
            position: relative !important;
            overflow: visible !important;
        }

        /* Fix for any element that might be overlaying the confirm button */
        .order-actions::before,
        .order-actions::after {
            display: none !important;
            pointer-events: none !important;
        }

        /* Shopee-style Chatbox */
        .chatbox-overlay {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background: rgba(0, 0, 0, 0.3);
            z-index: 9999;
            display: none;
            align-items: flex-end;
            justify-content: flex-end;
            padding: 20px;
            pointer-events: none;
            transform: none !important;
            -webkit-transform: none !important;
        }
        
        .chatbox-overlay.active {
            display: flex !important;
            pointer-events: auto !important;
        }

        .chatbox-container {
            width: 800px;
            height: 600px;
            background: white;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transform: translateX(100%) translateY(100%);
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .chatbox-overlay.active .chatbox-container {
            transform: translateX(0) translateY(0);
        }

        .chatbox-overlay.closing .chatbox-container {
            transform: translateX(100%) translateY(0);
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .chatbox-header {
            background: var(--brand);
            color: white;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            min-height: 40px;
            height: 40px;
            overflow: visible;
        }

        .chatbox-header h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chatbox-close {
            background: white;
            border: none;
            color: #666;
            font-size: 16px;
            cursor: pointer;
            padding: 8px;
            border-radius: 0 16px 0 8px;
            transition: all 0.2s ease;
            position: absolute;
            top: 0;
            right: 0;
            height: 32px;
            width: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 5;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .chatbox-close:hover {
            background: #dc2626;
            color: white;
        }

        .chatbox-close-container {
            position: absolute;
            top: 0;
            right: 0;
            width: 32px;
            height: 80px;
            pointer-events: none;
        }

        .chatbox-close-container .chatbox-close {
            pointer-events: auto;
        }

        .chatbox-content {
            flex: 1;
            display: flex;
            flex-direction: row;
            height: 100%;
            overflow: hidden;
        }

        /* Left Panel - Conversations List */
        .chatbox-left-panel {
            width: 250px;
            border-right: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            background: #ffffff;
            flex-shrink: 0;
            height: 100%;
            overflow: hidden;
        }

        .chatbox-left-header {
            padding: 16px 18px 12px 18px;
            background: white;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .chatbox-left-header h4 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: var(--text);
        }

        /* Chatbox tabs */
        .chatbox-tabs {
            display: flex;
            border-bottom: 1px solid #e2e8f0;
            background: #f8fafc;
        }

        .chatbox-tab {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 12px 16px;
            border: none;
            background: transparent;
            color: #64748b;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            border-bottom: 2px solid transparent;
        }

        .chatbox-tab:hover {
            background: #f1f5f9;
            color: #475569;
        }

        .chatbox-tab.active {
            color: var(--brand);
            background: white;
            border-bottom-color: var(--brand);
        }

        .chatbox-tab i {
            font-size: 12px;
        }

        .chatbox-search {
            padding: 12px 16px;
            background: white;
            border-bottom: 1px solid #e2e8f0;
        }

        .chatbox-search-input {
            width: 100%;
            padding: 8px 14px;
            border: 1px solid #e2e8f0;
            border-radius: 20px;
            font-size: 13px;
            background: #f8fafc;
            transition: all 0.2s ease;
            box-sizing: border-box;
        }

        .chatbox-search-input:focus {
            outline: none;
            border-color: var(--brand);
            background: white;
            box-shadow: 0 0 0 3px rgba(154, 208, 97, 0.1);
        }

        /* Right Panel - Chat Messages */
        .chatbox-right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
            min-width: 0;
            height: 100%;
            overflow: hidden;
        }

        .chatbox-right-header {
            padding: 20px 24px;
            background: white;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            flex-shrink: 0;
        }

        .chatbox-right-header h4 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: var(--text);
        }

        /* Conversation action buttons */
        .chatbox-conversation-actions {
            display: flex;
            gap: 8px;
            margin-left: auto;
            margin-right: 50px;
        }

        .conversation-action-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            background: #f8fafc;
            color: #64748b;
        }

        .conversation-action-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .conversation-action-btn.archive-btn {
            color: #3182ce;
            background: #ebf8ff;
        }

        .conversation-action-btn.archive-btn:hover {
            background: #bee3f8;
            color: #2c5282;
        }

        .conversation-action-btn.unarchive-btn {
            color: #10b981;
            background: #ecfdf5;
        }

        .conversation-action-btn.unarchive-btn:hover {
            background: #d1fae5;
            color: #059669;
        }

        .conversation-action-btn.delete-btn {
            color: #e53e3e;
            background: #fed7d7;
        }

        .conversation-action-btn.delete-btn:hover {
            background: #feb2b2;
            color: #c53030;
        }

        .conversation-action-btn i {
            font-size: 11px;
        }

        /* Restore conversation button */
        .restore-conversation-btn {
            background: none;
            border: none;
            color: #10b981;
            cursor: pointer;
            padding: 4px 6px;
            border-radius: 4px;
            transition: all 0.2s ease;
            opacity: 0.6;
            font-size: 12px;
        }

        .conversation-item:hover .restore-conversation-btn {
            opacity: 1;
        }

        .restore-conversation-btn:hover {
            background: #d1fae5;
            color: #059669;
        }

        .restore-conversation-btn:active {
            transform: scale(0.95);
        }

        /* Archived conversation styling */
        .conversation-item.archived {
            opacity: 0.8;
            background: #f8fafc;
        }

        .conversation-item.archived:hover {
            background: #f1f5f9;
        }

        .conversation-item.archived .conversation-name {
            color: #64748b;
        }

        .conversation-item.archived .conversation-preview {
            color: #94a3b8;
        }

        .chatbox-customer-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .chatbox-customer-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--brand);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            flex-shrink: 0;
        }

        .chatbox-customer-name {
            font-weight: 600;
            color: var(--text);
            font-size: 16px;
        }

        .chatbox-tabs {
            display: flex;
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
        }

        .chatbox-tab {
            flex: 1;
            padding: 12px 16px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: var(--muted);
            transition: all 0.2s ease;
            border-bottom: 2px solid transparent;
        }

        .chatbox-tab.active {
            color: var(--brand);
            border-bottom-color: var(--brand);
            background: white;
        }

        .chatbox-tab:hover:not(.active) {
            color: var(--text);
            background: rgba(0, 0, 0, 0.02);
        }

        .chatbox-body {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Conversations List */
        .conversations-list {
            flex: 1;
            overflow-y: auto;
            background: white;
            padding: 0;
            min-height: 200px;
        }
        
        /* Hide scrollbar but keep functionality */
        .conversations-list::-webkit-scrollbar {
            display: none;
        }
        
        .conversations-list {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .conversation-item {
            display: flex;
            align-items: center;
            padding: 14px 16px;
            cursor: pointer;
            transition: background-color 0.2s ease, border-left-color 0.2s ease;
            border-bottom: 1px solid #f1f5f9;
            border-left: 4px solid transparent;
            position: relative;
            min-height: 68px;
            width: 100%;
            overflow: hidden;
            box-sizing: border-box;
        }
        /* Disable transitions when programmatically switching conversations */
        .conversation-item.no-transition {
            transition: none !important;
        }
        .conversation-item:hover {
            background: #f8fafc;
        }

        .conversation-item.active {
            background: #e8f5e9;
            border-left-color: var(--brand);
        }

        .conversation-item.active::before {
            content: '';
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: var(--brand);
            z-index: 1;
        }

        .conversation-avatar {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            background: var(--brand);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            margin-right: 12px;
            flex-shrink: 0;
            position: relative;
        }

        .conversation-avatar.online::after {
            content: '';
            position: absolute;
            bottom: 1px;
            right: 1px;
            width: 12px;
            height: 12px;
            background: #10b981;
            border: 2px solid white;
            border-radius: 50%;
        }

        .conversation-info {
            flex: 1 1 0%;
            min-width: 0;
            max-width: calc(250px - 42px - 24px - 16px - 4px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding-right: 8px;
            overflow: hidden;
            box-sizing: border-box;
            width: 100%;
        }

        .conversation-details {
            flex: 1 1 0%;
            min-width: 0;
            max-width: calc(250px - 42px - 24px - 16px - 4px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding-right: 8px;
            overflow: hidden;
            box-sizing: border-box;
            width: 100%;
        }

        .conversation-name {
            font-weight: 600;
            font-size: 14px;
            color: var(--text);
            margin: 0 0 4px 0;
            white-space: nowrap !important;
            overflow: hidden !important;
            text-overflow: ellipsis !important;
            line-height: 1.3;
            letter-spacing: -0.01em;
            max-width: 100%;
            width: 100%;
            display: block;
            min-width: 0;
        }

        .conversation-preview-container {
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 0;
            width: 100%;
        }

        .conversation-preview {
            font-size: 12px;
            color: var(--muted);
            white-space: nowrap !important;
            overflow: hidden !important;
            text-overflow: ellipsis !important;
            margin: 0;
            line-height: 1.4;
            font-weight: 400;
            flex: 1;
            min-width: 0;
            max-width: 100%;
        }

        /* Unread message styling */
        .conversation-name.unread,
        .conversation-preview.unread {
            font-weight: 700 !important;
            color: var(--text);
        }

        .conversation-name.unread {
            color: #1a365d !important;
            font-weight: 700 !important;
        }

        .conversation-preview.unread {
            color: #2d3748 !important;
            font-weight: 700 !important;
        }

        /* Unread indicator dot */
        .conversation-item.unread::before {
            content: '';
            position: absolute;
            left: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 8px;
            background: #10b981;
            border-radius: 50%;
            z-index: 1;
        }
        .conversation-item.unread {
            position: relative;
            background: rgba(16, 185, 129, 0.05);
            border-left: 3px solid #10b981;
        }
        /* Conversation actions container */
        .conversation-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
        }

        /* Delete conversation button */
        .delete-conversation-btn {
            background: none;
            border: none;
            color: #e53e3e;
            cursor: pointer;
            padding: 4px 6px;
            border-radius: 4px;
            transition: all 0.2s ease;
            opacity: 0.6;
            font-size: 12px;
        }

        .conversation-item:hover .delete-conversation-btn {
            opacity: 1;
        }

        .delete-conversation-btn:hover {
            background: #fed7d7;
            color: #c53030;
        }

        .delete-conversation-btn:active {
            transform: scale(0.95);
        }

        /* Context menu styles */
        .conversation-context-menu {
            position: fixed;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            min-width: 120px;
            overflow: hidden;
        }

        .context-menu-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            font-size: 14px;
            color: #2d3748;
        }

        .context-menu-item:hover {
            background: #f7fafc;
        }

        .context-menu-item.archive {
            color: #3182ce;
        }

        .context-menu-item.delete {
            color: #e53e3e;
        }

        .context-menu-item i {
            margin-right: 8px;
            width: 16px;
            text-align: center;
        }

        .conversation-meta {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
            flex-shrink: 0;
            justify-content: center;
        }

        .conversation-time {
            font-size: 11px;
            color: var(--muted);
            font-weight: 500;
            line-height: 1.4;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .conversation-badge {
            background: #ef4444;
            color: white;
            border-radius: 10px;
            padding: 2px 6px;
            font-size: 10px;
            font-weight: 600;
            min-width: 16px;
            height: 16px;
            text-align: center;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .conversation-badge.hidden {
            display: none;
        }

        /* Chat Messages */
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
            background: #f8fafc;
            display: none;
            min-height: 0;
            height: 0;
        }

        .chat-messages.active {
            display: flex !important;
            flex-direction: column !important;
            height: auto;
            min-height: 0;
            align-items: stretch;
        }

        .chat-messages-container {
            max-width: 100%;
            margin: 0 auto;
        }

        .message {
            margin-bottom: 18px;
            display: flex !important;
            align-items: flex-start;
            gap: 10px;
            width: 100%;
            animation: messageSlideIn 0.3s ease-out;
            flex-shrink: 0;
            visibility: visible !important;
            opacity: 1 !important;
            position: relative !important;
        }

        @keyframes messageSlideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message-left {
            justify-content: flex-start !important;
            align-items: flex-start;
        }

        .message-right {
            justify-content: flex-end !important;
            align-items: flex-start;
        }

        .message-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--brand);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            flex-shrink: 0;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        }

        .message-left .message-avatar {
            background: #9ca3af;
            color: white;
        }

        .message-right .message-avatar {
            background: linear-gradient(135deg, #9ad061, #7db635);
            color: white;
        }

        .message-content {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            position: relative;
            word-wrap: break-word;
            font-size: 14px;
            line-height: 1.4;
            transition: all 0.2s ease;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        .message-content:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .message-left .message-content {
            border-bottom-left-radius: 8px !important;
            background: white !important;
            color: #6b7280 !important;
            border: 1px solid #e5e7eb !important;
            margin-right: auto;
        }

        .message-right .message-content {
            background: #9ad061 !important;
            color: #1f2937 !important;
            border-bottom-right-radius: 8px !important;
            margin-left: auto !important;
            border: 1px solid #7db635 !important;
        }

        .message-text {
            margin: 0;
            font-size: 14px;
            line-height: 1.5;
            word-wrap: break-word;
        }

        .message-sender {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .message-left .message-sender {
            color: #6b7280;
        }

        .message-right .message-sender {
            color: #1f2937;
        }

        .message-sender-role {
            font-size: 11px;
            font-weight: 500;
            opacity: 0.7;
            padding: 2px 6px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.05);
        }

        .message-left .message-sender-role {
            background: rgba(107, 114, 128, 0.1);
            color: #6b7280;
        }

        .message-right .message-sender-role {
            background: rgba(31, 41, 55, 0.1);
            color: #1f2937;
        }

        .message-time {
            font-size: 11px;
            margin-top: 6px;
            opacity: 0.8;
            font-weight: 500;
        }

        .message-left .message-time {
            color: #9ca3af;
        }

        .message-right .message-time {
            color: #1f2937;
        }

        /* Additional specificity for message alignment */
        .chat-messages .message.message-left {
            justify-content: flex-start !important;
        }

        /* Date header styles */
        .date-header {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 24px 0 16px 0;
            gap: 12px;
            width: 100%;
        }

        .date-header-line {
            flex: 1;
            height: 1px;
            background: linear-gradient(to right, transparent, #e5e7eb, transparent);
        }

        .date-header-text {
            font-size: 12px;
            font-weight: 600;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 4px 12px;
            background: #f9fafb;
            border-radius: 12px;
            white-space: nowrap;
            border: 1px solid #e5e7eb;
        }

        .chat-messages .message.message-right {
            justify-content: flex-end !important;
        }

        .chat-messages .message.message-left .message-content {
            margin-right: auto !important;
            margin-left: 0 !important;
        }

        .chat-messages .message.message-right .message-content {
            margin-left: auto !important;
            margin-right: 0 !important;
        }

        /* Message Media Styles */
        .message-media {
            position: relative;
            transition: all 0.3s ease;
        }

        .message-media img,
        .message-media video {
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            z-index: 1;
        }

        .message-media:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .message-media:hover img,
        .message-media:hover video {
            opacity: 0.9;
        }

        .message-media::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0);
            transition: background 0.3s ease;
            pointer-events: none;
            border-radius: 12px;
            z-index: 0;
        }

        .message-media:hover::after {
            background: rgba(0, 0, 0, 0.1);
        }

        /* Media Action Buttons */
        .media-action-buttons {
            position: absolute;
            top: 8px;
            right: 8px;
            display: flex;
            gap: 6px;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 10;
            pointer-events: none;
        }

        .message-media:hover .media-action-buttons {
            opacity: 1;
            pointer-events: auto;
        }

        .media-action-btn {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .media-action-btn:hover {
            background: rgba(0, 0, 0, 0.9);
            transform: scale(1.1);
        }

        .media-action-btn i {
            pointer-events: none;
        }

        /* Image Lightbox Styles */
        .image-lightbox-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10001;
            cursor: pointer;
            animation: fadeIn 0.3s ease;
        }

        .image-lightbox-overlay.active {
            display: flex;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .image-lightbox-container {
            position: relative;
            max-width: 90vw;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
        }

        .image-lightbox-image {
            max-width: 100%;
            max-height: 85vh;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            cursor: default;
        }

        .image-lightbox-actions {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .image-lightbox-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .image-lightbox-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px);
        }

        .image-lightbox-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .image-lightbox-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg);
        }

        /* Chat Input */
        .chat-input-area {
            padding: 20px 24px;
            background: white;
            border-top: 1px solid #e2e8f0;
            display: none;
            flex-shrink: 0;
        }

        .chat-input-area.active {
            display: flex;
            flex-direction: column;
        }

        .chat-input-container {
            display: flex;
            gap: 12px;
            align-items: flex-end;
        }

        .chat-input {
            flex: 1;
            border: 1px solid #e2e8f0;
            border-radius: 24px;
            padding: 12px 20px;
            font-size: 14px;
            resize: none;
            max-height: 120px;
            min-height: 44px;
            outline: none;
            transition: all 0.2s ease;
            line-height: 1.4;
        }

        .chat-input:focus {
            border-color: var(--brand);
            box-shadow: 0 0 0 3px rgba(154, 208, 97, 0.1);
        }

        .chat-attach-btn {
            background: transparent;
            color: #64748b;
            border: none;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .chat-attach-btn:hover {
            background: #f1f5f9;
            color: #9ad061;
        }
        
        .chat-send-btn {
            background: #9ad061;
            color: white;
            border: none;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            flex-shrink: 0;
            box-shadow: 0 2px 6px rgba(154, 208, 97, 0.3);
        }

        .chat-send-btn:hover {
            background: #74b43a;
            transform: scale(1.05);
            box-shadow: 0 3px 8px rgba(116, 180, 58, 0.4);
        }

        .chat-send-btn:disabled {
            background: #cbd5e1;
            cursor: not-allowed;
            transform: none;
        }

        /* Media Preview Area */
        .media-preview-container {
            display: none;
            padding: 12px;
            margin-bottom: 12px;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            max-height: 200px;
            overflow-y: auto;
        }

        .media-preview-container.active {
            display: block;
        }

        .media-preview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 12px;
        }

        .media-preview-item {
            position: relative;
            width: 100%;
            aspect-ratio: 1;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #e2e8f0;
            cursor: pointer;
            transition: all 0.2s ease;
            background: #000;
        }

        .media-preview-item:hover {
            border-color: #9ad061;
            transform: scale(1.05);
        }

        .media-preview-item img,
        .media-preview-item video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .media-preview-item .remove-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 24px;
            height: 24px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.2s ease;
            z-index: 10;
        }

        .media-preview-item .remove-btn:hover {
            background: rgba(220, 38, 38, 0.9);
            transform: scale(1.1);
        }

        .media-preview-item .video-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            z-index: 5;
        }

        /* Enhanced Lightbox for Videos */
        .image-lightbox-container video {
            max-width: 100%;
            max-height: 85vh;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            cursor: default;
        }

        /* Empty States */
        .chat-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--muted);
            text-align: center;
            padding: 40px 20px;
        }

        .chat-empty i {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .chat-empty h4 {
            margin: 0 0 8px 0;
            font-size: 16px;
            font-weight: 600;
        }

        .chat-empty p {
            margin: 0;
            font-size: 14px;
        }

        /* Loading and Error States */
        .chat-loading, .chat-error {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: #666;
            padding: 40px 20px;
        }

        .chat-loading i, .chat-error i {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.7;
        }

        .chat-loading h4, .chat-error h4 {
            margin: 0 0 8px 0;
            font-size: 16px;
            font-weight: 600;
        }

        .chat-loading p, .chat-error p {
            margin: 0;
            font-size: 14px;
        }

        .chat-error {
            color: #e53e3e;
        }

        .chat-error i {
            color: #e53e3e;
        }

        /* Message date separators */
        .message-date-separator {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 20px 0;
            position: relative;
        }

        .message-date-separator::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 1px;
            background: #e2e8f0;
            z-index: 1;
        }

        .message-date-separator .date-text {
            background: #f8fafc;
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
            color: #64748b;
            border: 1px solid #e2e7eb;
            position: relative;
            z-index: 2;
        }
        /* Responsive Design */
        @media (max-width: 768px) {
            .chatbox-container {
                width: 100vw;
                height: 100vh;
                border-radius: 0;
                max-width: none;
                flex-direction: column;
                transform: translateX(100%) translateY(0);
            }
            
            .chatbox-overlay.active .chatbox-container {
                transform: translateX(0) translateY(0);
            }
            
            .chatbox-overlay.closing .chatbox-container {
                transform: translateX(100%) translateY(0);
            }
            
            .chatbox-left-panel {
                width: 100%;
                height: 40%;
                border-right: none;
                border-bottom: 1px solid #e2e8f0;
                overflow: hidden;
            }
            
            .chatbox-right-panel {
                height: 60%;
                overflow: hidden;
            }
            
            .conversations-list {
                min-height: 150px;
            }
            
            .chat-messages {
                height: 0;
                min-height: 0;
            }
            
            .chat-messages.active {
                height: auto;
                min-height: 0;
            }
            
            .chatbox-left-header,
            .chatbox-right-header {
                padding: 16px 20px;
            }
            
            .chatbox-search {
                padding: 12px 16px;
            }
            
            .conversation-item {
                padding: 12px 14px;
                min-height: 60px;
            }
            
            .conversation-avatar {
                width: 38px;
                height: 38px;
                margin-right: 10px;
            }
            
            .chat-messages {
                padding: 16px;
            }
            
            .chat-input-area {
                padding: 16px;
            }
            
            .chatbox-overlay {
                padding: 0 !important;
                transform: none !important;
                -webkit-transform: none !important;
            }
            
            .chat-toggle-btn {
                width: 48px;
                height: 48px;
                top: 16px !important;
                right: 16px !important;
                position: absolute !important;
            }
        }

        /* Dark Theme Support */
        .dark-theme .chatbox-container {
            background: #1a1a1a;
            color: #e0e0e0;
        }

        .dark-theme .chatbox-tabs {
            background: #2d2d2d;
            border-bottom-color: #404040;
        }

        .dark-theme .chatbox-tab {
            color: #a0a0a0;
        }

        .dark-theme .chatbox-tab.active {
            color: var(--brand);
            background: #1a1a1a;
        }

        .dark-theme .conversation-item {
            border-bottom-color: #404040;
        }

        .dark-theme .conversation-item:hover {
            background: #2d2d2d;
        }

        .dark-theme .conversation-item.active {
            background: #1a3d1a;
        }

        .dark-theme .chat-messages {
            background: #1a1a1a;
        }

        .dark-theme .message-content {
            background: #2d2d2d;
            color: #e0e0e0;
        }

        .dark-theme .chat-input-area {
            background: #1a1a1a;
            border-top-color: #404040;
        }

        .dark-theme .chat-input {
            background: #2d2d2d;
            border-color: #404040;
            color: #e0e0e0;
        }

        .dark-theme .chat-input:focus {
            border-color: var(--brand);
        }

        .search-container {
            flex: 1;
            max-width: 400px;
        }

        .search-box {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
            background: var(--surface-2);
            border: 1px solid #e5e7eb;
            padding: 8px 10px;
            border-radius: 8px;
        }

        .search-box i {
            color: var(--muted);
        }

        .search-box input {
            flex: 1;
            border: none;
            outline: none;
            background: transparent;
            color: var(--text);
        }

        .profile-section {
            position: relative;
        }

        /* Profile Section Elegant Styling */
        .profile-section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 16px;
        }

        .profile-section-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #61a029 0%, #4f8a22 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
        }

        .profile-content {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .profile-field {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: var(--surface-2);
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .profile-field-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #61a029 0%, #4f8a22 100%);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
        }

        .profile-field-info {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .profile-field-info label {
            font-weight: 600;
            color: var(--text);
            min-width: 120px;
        }

        .profile-field-info span {
            font-weight: 500;
            color: var(--muted);
        }

        .stat-item-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .stat-item-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #61a029 0%, #4f8a22 100%);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 16px;
            box-shadow: 0 4px 12px rgba(97, 160, 41, 0.3);
        }

        .stat-item-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .stat-item-info .stat-number {
            font-size: 24px;
            font-weight: 700;
            color: var(--text);
            margin-bottom: 4px;
        }

        .stat-item-info .stat-label {
            font-size: 12px;
            color: var(--muted);
        }

        /* Settings Section Elegant Styling */
        .settings-section-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .settings-section-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #61a029 0%, #4f8a22 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
        }
        .setting-item-info {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .setting-item-info label {
            font-weight: 600;
            color: var(--text);
            min-width: 120px;
        }

        .setting-item-info select {
            padding: 8px 12px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            background: white;
            color: var(--text);
            font-size: 14px;
        }

        /* Enhanced Profile Container Styling */
        .profile-container {
            background: #ffffff;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            overflow: hidden;
            border: 1px solid #e5e7eb;
        }
        .profile-header {
            background: linear-gradient(135deg, #61a029 0%, #4f8a22 100%);
            padding: 32px 24px;
            color: white;
            display: flex;
            align-items: center;
            gap: 20px;
            position: relative;
        }
        .profile-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(97, 160, 41, 0.1) 0%, rgba(79, 138, 34, 0.1) 100%);
            pointer-events: none;
        }

        .profile-header .profile-avatar {
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            color: white;
            border: 3px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            position: relative;
            z-index: 1;
        }

        .profile-header .profile-info {
            flex: 1;
            position: relative;
            z-index: 1;
        }

        .profile-header .profile-info h3 {
            font-size: 28px;
            font-weight: 700;
            margin: 0 0 8px 0;
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .profile-header .profile-role {
            font-size: 16px;
            font-weight: 500;
            margin: 0 0 4px 0;
            color: rgba(255, 255, 255, 0.9);
        }

        .profile-header .profile-email {
            font-size: 14px;
            margin: 0;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .profile-avatar-container {
            position: relative;
            display: inline-block;
        }
        
        .change-picture-btn {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: #4CAF50;
            color: white;
            border: 2px solid white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            z-index: 2;
        }
        
        .change-picture-btn:hover {
            background: #45a049;
            transform: scale(1.1);
        }
        
        .edit-profile-btn, .save-profile-btn, .cancel-edit-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            white-space: nowrap;
        }
        
        .edit-profile-btn {
            background: #2196F3;
            color: white;
        }
        
        .edit-profile-btn:hover {
            background: #1976D2;
        }
        
        .save-profile-btn {
            background: #4CAF50;
            color: white;
            margin-right: 10px;
        }
        
        .save-profile-btn:hover {
            background: #45a049;
        }
        
        .cancel-edit-btn {
            background: #f44336;
            color: white;
        }
        
        .cancel-edit-btn:hover {
            background: #da190b;
        }
        
        .profile-edit-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.95em;
            margin-top: 4px;
            font-family: inherit;
        }
        
        .profile-edit-input:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.1);
        }

        .profile-details {
            padding: 32px 24px;
            display: flex;
            flex-direction: column;
            gap: 32px;
        }

        .profile-section {
            background: #ffffff;
            border-radius: 12px;
            padding: 24px;
            border: 1px solid #e5e7eb;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
            transition: all 0.3s ease;
        }

        .profile-section:hover {
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
            transform: translateY(-2px);
        }

        .profile-section h4 {
            font-size: 20px;
            font-weight: 600;
            color: var(--text);
            margin: 0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 8px;
        }

        .stat-item {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #e2e8f0;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .stat-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(135deg, #61a029 0%, #4f8a22 100%);
        }

        .stat-item:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(97, 160, 41, 0.15);
            border-color: #61a029;
        }

        .stat-item .stat-number {
            font-size: 32px;
            font-weight: 800;
            color: #1a202c;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #61a029 0%, #4f8a22 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stat-item .stat-label {
            font-size: 14px;
            font-weight: 500;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Enhanced Settings Container Styling */
        .settings-container {
            background: #ffffff;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            overflow: hidden;
            border: 1px solid #e5e7eb;
        }

        .settings-section {
            padding: 32px 24px;
            border-bottom: 1px solid #f1f5f9;
        }

        .settings-section:last-child {
            border-bottom: none;
        }

        .settings-section h3 {
            font-size: 24px;
            font-weight: 700;
            color: var(--text);
            margin: 0 0 24px 0;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .settings-section h3::before {
            content: '';
            width: 4px;
            height: 24px;
            background: linear-gradient(135deg, #61a029 0%, #4f8a22 100%);
            border-radius: 2px;
        }

        .setting-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px;
            background: #f8fafc;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            margin-bottom: 16px;
            transition: all 0.3s ease;
        }

        .setting-item:last-child {
            margin-bottom: 0;
        }

        .setting-item:hover {
            background: #ffffff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            border-color: #61a029;
            transform: translateY(-2px);
        }

        .setting-info {
            flex: 1;
        }

        .setting-info h4 {
            font-size: 16px;
            font-weight: 600;
            color: var(--text);
            margin: 0 0 4px 0;
        }

        .setting-info p {
            font-size: 14px;
            color: var(--muted);
            margin: 0;
        }

        .setting-select {
            padding: 12px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: white;
            color: var(--text);
            font-size: 14px;
            font-weight: 500;
            min-width: 160px;
            transition: all 0.3s ease;
        }

        .setting-select:focus {
            outline: none;
            border-color: #61a029;
            box-shadow: 0 0 0 3px rgba(97, 160, 41, 0.1);
        }

        /* Compact Settings Grid Layout */
        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 16px;
            margin-top: 8px;
        }

        .setting-item.compact {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px;
            background: #f8fafc;
            border-radius: 10px;
            border: 1px solid #e2e8f0;
            margin-bottom: 0;
            transition: all 0.3s ease;
        }

        .setting-item.compact:hover {
            background: #ffffff;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            border-color: #61a029;
            transform: translateY(-1px);
        }

        .setting-item.compact .setting-info {
            flex: 1;
            margin-right: 16px;
        }

        .setting-item.compact .setting-info h4 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text);
            margin: 0 0 4px 0;
        }

        .setting-item.compact .setting-info p {
            font-size: 12px;
            color: var(--muted);
            margin: 0;
            line-height: 1.4;
        }

        /* Featured Media Preview Styling */
        #featuredMediaPreviewArea {
            background: #f8fafc;
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #e2e8f0;
        }

        #featuredMediaPreviewArea h4 {
            font-size: 16px;
            font-weight: 600;
            color: var(--text);
            margin: 0 0 15px 0;
        }

        #featuredMediaListContainer {
            background: #f8fafc;
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #e2e8f0;
        }

        #featuredMediaListContainer h4 {
            font-size: 16px;
            font-weight: 600;
            color: var(--text);
            margin: 0 0 15px 0;
        }

        .featured-media-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
        }

        #featuredMediaUploadProgress {
            background: #f8fafc;
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #e2e8f0;
        }

        /* Featured Media Button Styles */
        .featured-media-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .featured-media-btn-primary {
            background: #61a029;
            color: white;
        }

        .featured-media-btn-primary:hover {
            background: #4f8a22;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(97, 160, 41, 0.3);
        }

        .featured-media-btn-secondary {
            background: #dc3545;
            color: white;
        }

        .featured-media-btn-secondary:hover {
            background: #c82333;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);
        }

        .featured-media-btn:active {
            transform: translateY(0);
        }
        .setting-select.compact {
            padding: 8px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            background: white;
            color: var(--text);
            font-size: 13px;
            font-weight: 500;
            min-width: 120px;
            transition: all 0.3s ease;
        }

        .setting-select.compact:focus {
            outline: none;
            border-color: #61a029;
            box-shadow: 0 0 0 2px rgba(97, 160, 41, 0.1);
        }

        .compact-btn {
            width: 36px;
            height: 36px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background: white;
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }
        .compact-btn:hover {
            background: #61a029;
            color: white;
            border-color: #61a029;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(97, 160, 41, 0.3);
        }

        .compact-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(97, 160, 41, 0.2);
        }

        /* Dark theme for compact settings */
        .dark-theme .setting-item.compact {
            background: #2d2d2d;
            border-color: #404040;
        }

        .dark-theme .setting-item.compact:hover {
            background: #333333;
            border-color: #61a029;
        }

        .dark-theme .setting-item.compact .setting-info h4 {
            color: #ffffff;
        }

        .dark-theme .setting-item.compact .setting-info p {
            color: #a0a0a0;
        }

        .dark-theme .setting-select.compact {
            background: #2d2d2d;
            border-color: #404040;
            color: #ffffff;
        }

        .dark-theme .setting-select.compact:focus {
            border-color: #61a029;
            background: #333333;
        }

        .dark-theme .compact-btn {
            background: #2d2d2d;
            border-color: #404040;
            color: #ffffff;
        }

        .dark-theme .compact-btn:hover {
            background: #61a029;
            color: white;
            border-color: #61a029;
        }
        
        /* Toggle Switch Styles */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        
        .toggle-input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-label {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 24px;
        }
        
        .toggle-label:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }
        
        .toggle-input:checked + .toggle-label {
            background-color: #6FAA3C;
        }
        
        .toggle-input:checked + .toggle-label:before {
            transform: translateX(26px);
        }
        
        .toggle-slider {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 24px;
        }
        
        .toggle-input:checked + .toggle-label .toggle-slider {
            background-color: #6FAA3C;
        }
        
        /* Dark theme toggle switch */
        .dark-theme .toggle-label {
            background-color: #404040;
        }
        
        .dark-theme .toggle-input:checked + .toggle-label {
            background-color: #8BC34A;
        }
        
        .dark-theme .toggle-input:checked + .toggle-label .toggle-slider {
            background-color: #8BC34A;
        }

        .setting-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .setting-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #61a029;
        }

        .setting-toggle span {
            font-size: 14px;
            color: var(--muted);
        }

        .content-wrapper {
            padding: 8px 16px 16px 16px;
            flex: 1;
        }

        /* Top search bar */
        .topbar {
            display: flex; align-items: center; gap: 12px;
            padding: 12px 16px; background: var(--surface);
            border-bottom: 1px solid #e2e8f0; position: sticky; top: 0; z-index: 2;
            border-radius: 12px;
            margin-top: 16px;
            margin-bottom: 16px;
        }
        .topbar .search {
            flex: 1; display: flex; align-items: center; gap: 8px;
            background: var(--surface-2); border: 1px solid #e5e7eb;
            padding: 8px 10px; border-radius: 8px;
        }
        .topbar .search i { color: var(--muted); }
        .topbar .search input { flex: 1; border: none; outline: none; background: transparent; color: var(--text); }

        .content-section {
            display: none;
            background: transparent;
            border-radius: var(--radius);
            box-shadow: none;
            border: none;
            margin-bottom: 16px;
        }

        .content-section.active {
            display: block;
        }

        /* CALCOA Header Styles - Override default h2 styles */
        /* Match sidebar green color (#243a27) */
        #staff-overview > div:first-child h2 {
            font-weight: 900 !important;
            color: #243a27 !important;
            font-size: 28px !important;
            text-align: center !important;
            margin-bottom: 8px !important;
            letter-spacing: 0.5px !important;
            line-height: 1.3 !important;
        }
        
        #staff-overview > div:first-child p {
            font-style: italic !important;
            color: #2d5016 !important;
            font-size: 14px !important;
            text-align: center !important;
            margin: 0 !important;
            font-weight: 500 !important;
            line-height: 1.5 !important;
        }
        
        .content-section h2 {
            font-size: 28px;
            font-weight: 600;
            color: var(--text);
            margin: 0;
            padding: 20px 24px 16px 24px;
            border-bottom: 1px solid #f1f5f9;
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 24px;
            margin: 24px;
            padding: 0;
        }

        .stat-card {
            background: var(--surface);
            border: 1px solid #e2e8f0;
            padding: 24px;
            display: flex;
            align-items: center;
            gap: 16px;
            transition: all 0.2s ease;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
        }

        .stat-card:hover {
            box-shadow: 0 12px 32px rgba(2, 6, 23, 0.12);
            transform: translateY(-2px);
        }

        /* Dark theme support */
        .dark-theme body {
            background: #121212;
        }

        .dark-theme .content-section {
            background: #1f1f1f !important;
            border-color: #2b2b2b !important;
            color: #e0e0e0 !important;
        }

        .dark-theme .content-section h2 {
            color: #e0e0e0 !important;
            border-color: #2b2b2b !important;
        }
        
        /* Ensure CALCOA header stays green even in dark theme */
        .dark-theme #staff-overview > div:first-child h2 {
            color: #243a27 !important;
        }
        
        .dark-theme #staff-overview > div:first-child p {
            color: #2d5016 !important;
        }

        /* Modern Analytics Dark Theme */
        .dark-theme {
            background-color: #0D0D0D !important;
            color: #FFFFFF !important;
        }
        
        .dark-theme .main-content,
        .dark-theme .content-wrapper {
            background-color: #0D0D0D !important;
            color: #FFFFFF !important;
        }
        
        .dark-theme .card,
        .dark-theme .stat-card,
        .dark-theme .content-section,
        .dark-theme .settings-container,
        .dark-theme .profile-container {
            background-color: #1E1E1E !important;
            color: #FFFFFF !important;
            border: 1px solid #333333 !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            transition: all 0.3s ease !important;
        }
        
        .dark-theme .card:hover,
        .dark-theme .stat-card:hover {
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4) !important;
            transform: translateY(-2px) !important;
        }
        
        .dark-theme h1,
        .dark-theme h2,
        .dark-theme h3,
        .dark-theme h4,
        .dark-theme h5,
        .dark-theme h6 {
            color: #FFFFFF !important;
        }
        
        .dark-theme p,
        .dark-theme span,
        .dark-theme label {
            color: #B3B3B3 !important;
        }
        
        .dark-theme input,
        .dark-theme select,
        .dark-theme textarea {
            background-color: #1E1E1E !important;
            color: #FFFFFF !important;
            border: 1px solid #333333 !important;
            border-radius: 6px !important;
        }
        
        .dark-theme input:focus,
        .dark-theme select:focus,
        .dark-theme textarea:focus {
            border-color: #8BC34A !important;
            box-shadow: 0 0 0 2px rgba(139, 195, 74, 0.2) !important;
        }
        
        .dark-theme button,
        .dark-theme .btn {
            background-color: #6FAA3C !important;
            color: #FFFFFF !important;
            border: none !important;
            border-radius: 6px !important;
            transition: all 0.3s ease !important;
        }
        
        .dark-theme button:hover,
        .dark-theme .btn:hover {
            background-color: #8BC34A !important;
            transform: translateY(-1px) !important;
            box-shadow: 0 4px 12px rgba(139, 195, 74, 0.3) !important;
        }
        
        .dark-theme button:disabled,
        .dark-theme .btn:disabled {
            background-color: #3A3A3A !important;
            color: #666666 !important;
            cursor: not-allowed !important;
        }
        
        .dark-theme table,
        .dark-theme td,
        .dark-theme th {
            background-color: #1E1E1E !important;
            color: #FFFFFF !important;
            border-color: #333333 !important;
        }
        
        .dark-theme a {
            color: #8BC34A !important;
        }
        
        .dark-theme a:hover {
            color: #A4D46F !important;
        }
        
        /* Dark-theme overrides to keep staff look */
        .dark-theme .sidebar { background-color: #243a27 !important; border-right: 1px solid #2f4a33 !important; }
        .dark-theme .menu-item { color: #ebad2d !important; }
        .dark-theme .menu-item i { color: #ebad2d !important; }
        .dark-theme .menu-item:hover { background: rgba(244, 166, 43, 0.12) !important; }
        .dark-theme .menu-item:hover i { 
            transform: scale(1.1) !important; 
            color: #ebad2d !important; 
        }
        .dark-theme .menu-item.active { background: transparent !important; color: white !important; }
        .dark-theme .menu-item.active i { color: white !important; }
        /* System theme detection for automatic dark mode */
        @media (prefers-color-scheme: dark) {
            /* Auto dark theme - clean and minimal system colors */
            :root {
                --auto-bg: #1a1a1a;
                --auto-surface: #2d2d2d;
                --auto-surface-elevated: #3a3a3a;
                --auto-text: #ffffff;
                --auto-text-secondary: #b3b3b3;
                --auto-text-muted: #808080;
                --auto-border: #404040;
                --auto-accent: #60a5fa;
                --auto-primary: #3b82f6;
                --auto-primary-hover: #2563eb;
                --auto-success: #10b981;
                --auto-warning: #f59e0b;
                --auto-error: #ef4444;
            }
            
            /* Auto dark theme body */
            body.auto-theme {
                background-color: var(--auto-bg) !important;
                color: var(--auto-text) !important;
            }
            
            /* Auto dark theme main content */
            body.auto-theme .main-content,
            body.auto-theme .content-wrapper {
                background-color: var(--auto-bg) !important;
                color: var(--auto-text) !important;
            }
            
            /* Auto dark theme cards and sections */
            body.auto-theme .card,
            body.auto-theme .stat-card,
            body.auto-theme .content-section,
            body.auto-theme .settings-container,
            body.auto-theme .profile-container {
                background-color: var(--auto-surface) !important;
                color: var(--auto-text) !important;
                border-color: var(--auto-border) !important;
            }
            
            /* Auto dark theme form elements */
            body.auto-theme input,
            body.auto-theme select,
            body.auto-theme textarea {
                background-color: var(--auto-surface) !important;
                color: var(--auto-text) !important;
                border-color: var(--auto-border) !important;
            }
            
            /* Auto dark theme buttons */
            body.auto-theme button,
            body.auto-theme .btn {
                background-color: var(--auto-primary) !important;
                color: var(--auto-text) !important;
                border-color: var(--auto-border) !important;
            }
            
            body.auto-theme button:hover,
            body.auto-theme .btn:hover {
                background-color: var(--auto-primary-hover) !important;
            }
            
            /* Auto dark theme tables */
            body.auto-theme table,
            body.auto-theme td,
            body.auto-theme th {
                background-color: var(--auto-surface) !important;
                color: var(--auto-text) !important;
                border-color: var(--auto-border) !important;
            }
            
            /* Auto dark theme headers */
            body.auto-theme h1,
            body.auto-theme h2,
            body.auto-theme h3,
            body.auto-theme h4,
            body.auto-theme h5,
            body.auto-theme h6 {
                color: var(--auto-text) !important;
            }
            
            /* Auto dark theme links */
            body.auto-theme a {
                color: var(--auto-accent) !important;
            }
            
            body.auto-theme a:hover {
                color: var(--auto-primary-hover) !important;
            }
            
            /* Keep sidebar green in auto theme */
            body.auto-theme .sidebar {
                background-color: #243a27 !important;
            }
            
            body.auto-theme .menu-item {
                color: #ebad2d !important;
            }
            
            body.auto-theme .menu-item i {
                color: #ebad2d !important;
            }
            
            body.auto-theme .menu-item:hover {
                background: rgba(244, 166, 43, 0.12) !important;
            }
            
            body.auto-theme .menu-item.active {
                background: transparent !important;
                color: white !important;
            }
            
            body.auto-theme .menu-item.active i {
                color: white !important;
            }
        }

        /* Mobile - fixed sidebar */
        @media (max-width: 768px) {
            .sidebar {
                width: 240px;
                border-right: none;
                border-bottom: 1px solid #e2e8f0;
                position: fixed;
                top: 0;
                left: -240px; /* Hidden by default on mobile */
                height: 100vh;
                z-index: 1000;
                transition: left 0.3s ease;
            }
            .sidebar:hover { width: 240px; left: 0; }
            body.sidebar-open .sidebar { left: 0; width: 240px; }
            
            .main-content {
                margin-left: 0; /* No margin on mobile */
                position: relative;
            }
        }
        .dark-theme .stat-card {
            background: #1f1f1f !important;
            border-color: #2b2b2b !important;
            color: #e0e0e0 !important;
        }
        .dark-theme .stat-card:hover {
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.3);
        }

        /* Admin Dashboard Content Styles - Applied to Staff Dashboard */
        .overview-grid {
            display: grid; 
            grid-template-columns: 1fr; 
            gap: 16px; 
            padding: 16px;
            align-items: stretch;
        }
        .overview-left { 
            display: grid; 
            gap: 16px; 
            grid-template-rows: auto auto;
            height: 100%;
        }
        .records-and-sales-container {
            display: grid;
            grid-template-columns: 1fr 0.4fr;
            gap: 16px;
            align-items: stretch;
        }
        .sales-and-status-container {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        body:not(.admin-user) .sales-and-status-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        body:not(.admin-user) .weekly-sales-container {
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        body:not(.admin-user) .weekly-sales-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .overview-right { 
            display: none; 
        }

        /* Records Table Container */
        .records-table-container {
            background: var(--surface);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        body:not(.admin-user) .records-table-container {
            height: 100%;
        }
        .records-table-header {
            padding: 20px 24px;
            border-bottom: 1px solid #e5e7eb;
            background: linear-gradient(135deg, var(--brand) 0%, var(--brand-strong) 100%);
        }
        .records-table-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 700;
            color: white;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .records-table-header h3 i {
            font-size: 20px;
        }
        .records-table {
            overflow-x: auto;
        }
        .records-table-content {
            width: 100%;
            border-collapse: collapse;
        }
        .records-table-content thead {
            background: var(--surface-2);
        }
        .records-table-content thead th {
            padding: 16px 20px;
            text-align: center;
            font-size: 13px;
            font-weight: 600;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 2px solid #e5e7eb;
            border-right: 1px solid #e5e7eb;
        }
        .records-table-content thead th:first-child {
            border-right: none;
        }
        .records-table-content thead th:last-child {
            border-right: none;
        }
        .record-type-header {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        .record-type-header i {
            font-size: 24px;
            color: var(--brand);
        }
        .record-type-header span {
            font-size: 12px;
            font-weight: 600;
            color: var(--text);
        }
        .records-table-content tbody th {
            padding: 20px 24px;
            text-align: left;
            font-size: 14px;
            font-weight: 600;
            color: var(--muted);
            background: var(--surface-2);
            border-right: 2px solid #e5e7eb;
            border-bottom: 1px solid #e5e7eb;
            vertical-align: middle;
            width: 150px;
        }
        .records-table-content tbody tr {
            border-bottom: 1px solid #e5e7eb;
            transition: background-color 0.2s ease;
        }
        .records-table-content tbody tr:hover {
            background: var(--surface-2);
        }
        .records-table-content tbody tr:last-child {
            border-bottom: none;
        }
        .records-table-content tbody tr:last-child th {
            border-bottom: none;
        }
        .records-table-content tbody td {
            padding: 20px 24px;
            text-align: center;
            vertical-align: middle;
            border-right: 1px solid #e5e7eb;
            border-bottom: 1px solid #e5e7eb;
        }
        .records-table-content tbody td:last-child {
            border-right: none;
        }
        .records-table-content tbody tr:last-child td {
            border-bottom: none;
        }
        .record-type {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        .record-type i {
            font-size: 24px;
            color: var(--brand);
        }
        .record-type span {
            font-size: 13px;
            font-weight: 600;
            color: var(--text);
        }
        .record-count {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .record-count .num {
            font-size: 28px;
            font-weight: 700;
            color: var(--text);
        }
        .record-additional {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        .record-additional .additional-label {
            font-size: 12px;
            color: var(--muted);
        }
        .record-additional .additional-value {
            font-size: 18px;
            font-weight: 700;
            color: var(--brand-strong);
        }
        /* Hide admin-only columns for staff users */
        body:not(.admin-user) .admin-only-col {
            display: none;
        }
        /* Hide admin-only sections for staff users */
        body:not(.admin-user) .admin-only-section {
            display: none;
        }
        
        /* Weekly Sales Container */
        .weekly-sales-container {
            background: var(--surface);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            overflow: hidden;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        .weekly-sales-container:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
            border-color: var(--brand);
        }
        .weekly-sales-header {
            padding: 20px 24px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .weekly-sales-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 700;
            color: white;
        }
        .weekly-sales-icon {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
        }
        .weekly-sales-content {
            padding: 24px;
        }
        body.admin-user .weekly-sales-content {
            padding: 16px 20px;
        }
        body:not(.admin-user) .weekly-sales-content {
            padding: 24px;
        }
        .weekly-sales-amount {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 16px;
        }
        body.admin-user .weekly-sales-amount {
            margin-bottom: 12px;
            gap: 6px;
        }
        body.admin-user .weekly-sales-footer {
            padding-top: 12px;
        }
        body.admin-user .weekly-sales-value {
            font-size: 28px;
        }
        .weekly-sales-label {
            font-size: 13px;
            color: var(--muted);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .weekly-sales-value {
            font-size: 32px;
            font-weight: 700;
            color: var(--brand-strong);
            font-family: 'Courier New', monospace;
        }
        .weekly-sales-footer {
            padding-top: 16px;
            border-top: 1px solid #e5e7eb;
            font-size: 12px;
            color: var(--muted);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .weekly-sales-footer i {
            transition: transform 0.3s ease;
        }
        .weekly-sales-container:hover .weekly-sales-footer i {
            transform: translateX(4px);
        }
        .dark-theme .weekly-sales-footer {
            border-top-color: #2b2b2b;
        }
        /* Hide staff-only sections for admin users */
        body.admin-user .staff-only-section {
            display: none;
        }
        /* Dark theme styles */
        .dark-theme .records-table-header {
            background: linear-gradient(135deg, var(--brand) 0%, var(--brand-strong) 100%);
        }
        .dark-theme .records-table-content thead {
            background: #2d2d2d;
        }
        .dark-theme .records-table-content thead th {
            border-bottom-color: #2b2b2b;
            border-right-color: #2b2b2b;
            color: #a0a0a0;
        }
        .dark-theme .records-table-content tbody th {
            background: #2d2d2d;
            border-right-color: #2b2b2b;
            border-bottom-color: #2b2b2b;
            color: #a0a0a0;
        }
        .dark-theme .records-table-content tbody td {
            border-right-color: #2b2b2b;
            border-bottom-color: #2b2b2b;
        }
        .dark-theme .records-table-content tbody tr {
            border-bottom-color: #2b2b2b;
        }
        .dark-theme .records-table-content tbody tr:hover {
            background: #2d2d2d;
        }

        .hero {
            background: transparent;
            border-radius: 0;
            box-shadow: none;
            overflow: visible;
            height: auto;
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 16px;
        }
        body:not(.admin-user) .hero {
            grid-template-columns: 1fr;
        }
        .hero > .quick-actions-card {
            background: var(--surface);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            overflow: hidden;
            height: 100%;
        }
        .hero img { 
            width: 100%; 
            display: block; 
        }
        .hero .hero-footer { 
            padding: 12px 16px; 
            color: var(--muted); 
            font-size: 13px; 
        }

        .weather, .harvest-cost { 
            background: var(--surface); 
            border-radius: var(--radius); 
            box-shadow: var(--shadow);
            height: fit-content;
        }
        .weather { 
            padding: 16px; 
        }
        .weather h4 { 
            margin: 0 0 8px 0; 
            font-size: 14px; 
        }
        .weather .rows { 
            display: grid; 
            gap: 10px; 
        }
        .weather .row { 
            display:flex; 
            align-items:center; 
            justify-content: space-between; 
            color: var(--muted); 
            font-size: 13px; 
        }

        .predictive { 
            padding: 20px; 
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        .predictive h4 { 
            margin: 0 0 10px 0; 
            font-size: 14px; 
        }
        .predictive .months { 
            display: grid; 
            grid-template-columns: repeat(2, 1fr); 
            gap: 12px; 
            flex: 1;
        }
        .predictive .month-card { 
            background: var(--surface-2); 
            border: 1px solid #e5e7eb; 
            border-radius: 12px; 
            padding: 14px; 
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .predictive .month-title { 
            font-size: 12px; 
            color: var(--muted); 
            margin-bottom: 6px; 
        }
        .predictive .row { 
            display:flex; 
            align-items:center; 
            justify-content: space-between; 
            font-size: 12px; 
            color: var(--muted); 
            padding: 3px 0; 
        }
        .predictive .row strong { 
            color: var(--text); 
        }

        .harvest-cost { 
            padding: 16px; 
        }
        .harvest-cost h4 { 
            margin: 0 0 8px 0; 
            font-size: 14px; 
        }
        .harvest-cost .big { 
            font-size: 22px; 
            font-weight: 800; 
            color: #0f172a; 
        }

        /* Quick Actions Styling */
        .quick-actions-card {
            background: var(--surface);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 24px;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .quick-actions-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }
        .quick-actions-icon {
            width: 40px;
            height: 40px;
            background: var(--brand);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }
        .quick-actions-header h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: var(--text);
        }
        .quick-actions-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            flex: 1;
            align-content: start;
        }
        .quick-action-btn {
            padding: 12px 16px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background: var(--surface);
            color: var(--text);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .quick-action-btn:hover {
            background: var(--brand);
            color: white;
            border-color: var(--brand);
            transform: translateY(-1px);
        }
        .quick-action-btn.primary {
            background: var(--brand);
            color: white;
            border-color: var(--brand);
        }
        .quick-action-btn.primary:hover {
            background: var(--brand-strong);
            border-color: var(--brand-strong);
        }

        /* System Overview Styling */
        .system-overview-header, .system-status-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }
        .system-overview-icon, .system-status-icon {
            width: 32px;
            height: 32px;
            background: var(--brand);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
        }
        .system-overview-header h4, .system-status-header h4 {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
            color: var(--text);
        }

        /* Month Card Styling */
        .month-card-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        .month-icon {
            width: 24px;
            height: 24px;
            background: var(--brand);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
        }
        .month-title {
            font-size: 12px;
            color: var(--muted);
            margin-bottom: 6px;
        }

        /* Status Row Styling */
        .status-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
        }
        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .status-online {
            color: #10b981;
        }
        .status-offline {
            color: #ef4444;
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .overview-grid { 
                grid-template-columns: 1fr; 
                min-height: auto;
            }
            .overview-left {
                grid-template-rows: auto;
                height: auto;
            }
            .records-and-sales-container {
                grid-template-columns: 1fr;
            }
            .hero {
                grid-template-columns: 1fr;
            }
            .hero, .predictive {
                height: auto;
            }
            .quick-actions-buttons {
                grid-template-columns: 1fr;
            }
            .predictive .months {
                grid-template-columns: repeat(2, 1fr);
            }
            .content-section {
                min-height: auto;
            }
            .records-table-content thead th,
            .records-table-content tbody th,
            .records-table-content tbody td {
                padding: 14px 16px;
            }
            .records-table-content tbody th {
                width: 120px;
                font-size: 13px;
            }
            .record-type-header span,
            .record-type span {
                font-size: 11px;
            }
            .record-type-header i,
            .record-type i {
                font-size: 20px;
            }
            .record-count .num {
                font-size: 22px;
            }
            .record-additional .additional-value {
                font-size: 16px;
            }
        }
        @media (max-width: 640px) {
            .predictive .months {
                grid-template-columns: 1fr;
            }
            .records-table-header {
                padding: 16px 20px;
            }
            .records-table-header h3 {
                font-size: 16px;
            }
            .records-table-content thead th,
            .records-table-content tbody th,
            .records-table-content tbody td {
                padding: 12px 10px;
                font-size: 12px;
            }
            .records-table-content tbody th {
                width: 100px;
                font-size: 12px;
                padding: 12px 14px;
            }
            .record-type-header,
            .record-type {
                gap: 6px;
            }
            .record-type-header i,
            .record-type i {
                font-size: 18px;
            }
            .record-type-header span,
            .record-type span {
                font-size: 10px;
            }
            .record-count .num {
                font-size: 18px;
            }
            .record-additional {
                gap: 3px;
            }
            .record-additional .additional-label {
                font-size: 10px;
            }
            .record-additional .additional-value {
                font-size: 14px;
            }
            .records-and-sales-container {
                grid-template-columns: 1fr;
            }
            .weekly-sales-value {
                font-size: 24px;
            }
            .hero {
                grid-template-columns: 1fr;
            }
        }

        /* Dark theme for new components */
        .dark-theme .summary-card, .dark-theme .hero, .dark-theme .weather, .dark-theme .predictive, .dark-theme .harvest-cost, .dark-theme .quick-actions-card { 
            background: #1f1f1f !important; 
            border-color: #2b2b2b !important; 
        }
        .dark-theme .summary-card, .dark-theme .hero, .dark-theme .weather, .dark-theme .predictive, .dark-theme .harvest-cost, .dark-theme .quick-actions-card { 
            box-shadow: none; 
        }
        .dark-theme .predictive .month-card { 
            background: #202325; 
            border-color: #2b2b2b; 
        }
        .dark-theme .quick-action-btn {
            background: #2d2d2d !important;
            border-color: #404040 !important;
            color: #e0e0e0 !important;
        }
        .dark-theme .quick-action-btn:hover {
            background: var(--brand) !important;
            color: white !important;
        }

        /* Additional styles for admin dashboard compatibility */
        .summary-card-header {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .summary-icon {
            width: 40px;
            height: 40px;
            background: var(--brand);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 16px;
        }
        .summary-info {
            flex: 1;
        }
        .summary-label {
            font-size: 12px;
            color: var(--muted);
            margin-top: 4px;
        }
        .month-content {
            margin-top: 8px;
        }
        .status-active {
            color: #10b981;
        }
        .status-updated {
            color: #3b82f6;
        }
        .status-value {
            font-weight: 600;
        }
        .status-value.online {
            color: #10b981;
        }
        .quick-action-btn.secondary {
            background: #6b7280;
            color: white;
            border-color: #6b7280;
        }
        .quick-action-btn.secondary:hover {
            background: #4b5563;
            border-color: #4b5563;
        }

        /* Profile Dropdown Styles */
        .profile-dropdown {
            position: relative;
            display: inline-block;
        }

        .profile-btn {
            background: #30442d;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            font-weight: 500;
            box-shadow: 0 2px 8px rgba(48, 68, 45, 0.3);
        }

        .profile-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(48, 68, 45, 0.4);
        }

        .profile-btn span,
        .profile-btn i {
            color: white !important;
        }

        .profile-btn i {
            font-size: 1.2em;
        }

        /* General dropdown menu - removed to prevent conflicts with sidebar profile dropdown */

        .dropdown-header {
            padding: 12px 16px;
            background: #30442d;
            color: white;
        }

        .dropdown-header .user-name,
        .dropdown-header .user-role,
        .dropdown-header span,
        .dropdown-header * {
            color: white !important;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .user-avatar {
            width: 32px;
            height: 32px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1em;
            position: relative;
        }

        .user-shield {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 0.6em;
            color: white;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .user-details {
            display: flex;
            flex-direction: column;
        }

        .user-name {
            font-weight: 600;
            font-size: 0.95em;
            margin-bottom: 2px;
            color: white;
        }

        .user-role {
            font-size: 0.75em;
            opacity: 0.9;
            color: rgba(255, 255, 255, 0.9);
        }

        .dropdown-divider {
            height: 1px;
            background: #e9ecef;
            margin: 8px 0;
        }

        .dropdown-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            color: #333;
            text-decoration: none;
            transition: all 0.2s ease;
            font-weight: 500;
            font-size: 14px;
        }

        .dropdown-item:hover {
            background: #efe8c0;
            color: #30442d;
        }

        .dropdown-item {
            color: #333;
        }

        .dropdown-item i {
            width: 16px;
            text-align: center;
            color: #6c757d;
        }

        .dropdown-item:hover i {
            color: #30442d;
        }

        .logout-item {
            color: #dc3545;
        }

        .logout-item:hover {
            background: #fff5f5;
            color: #dc3545;
        }

        .logout-item i {
            color: #dc3545;
        }

        /* Dark theme for profile dropdown */
        .dark-theme .profile-dropdown .dropdown-menu {
            background-color: #2d2d2d !important;
            border: 1px solid #404040 !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3) !important;
        }

        .dark-theme .dropdown-header {
            background-color: #404040 !important;
        }

        .dark-theme .dropdown-item {
            color: #e0e0e0 !important;
        }

        .dark-theme .dropdown-item:hover {
            background-color: #404040 !important;
        }

        .dark-theme .dropdown-item.logout-item:hover {
            background-color: #f44336 !important;
            color: #ffffff !important;
        }

        /* Dark theme alignments for topbar */
        .dark-theme .topbar { background:#1f1f1f !important; border-color:#2b2b2b !important; }

        /* Dark theme overrides for profile and settings */
        .dark-theme .profile-section-icon,
        .dark-theme .profile-field-icon,
        .dark-theme .stat-item-icon,
        .dark-theme .settings-section-icon,
        .dark-theme .setting-item-icon {
            background: linear-gradient(135deg, #61a029 0%, #4f8a22 100%);
        }

        .dark-theme .profile-section {
            background-color: #1a1a1a !important;
            border: 1px solid #404040 !important;
        }

        .dark-theme .settings-container {
            background-color: #2d2d2d !important;
            border: 1px solid #404040 !important;
        }

        .dark-theme .settings-section {
            background-color: #1a1a1a !important;
            border: 1px solid #404040 !important;
        }

        .dark-theme .profile-field,
        .dark-theme .setting-item {
            background: #2d2d2d;
            border-color: #404040;
        }

        .dark-theme .setting-item-info select {
            background: #2d2d2d;
            border-color: #404040;
            color: var(--text);
        }

        /* Dark theme for enhanced profile and settings */
        .dark-theme .profile-container {
            background: #1a1a1a;
            border-color: #404040;
        }

        .dark-theme .profile-header {
            background: linear-gradient(135deg, #61a029 0%, #4f8a22 100%);
        }

        .dark-theme .profile-details {
            background: #1a1a1a;
        }

        .dark-theme .profile-section {
            background: #2d2d2d;
            border-color: #404040;
        }

        .dark-theme .profile-section:hover {
            background: #333333;
            border-color: #61a029;
        }

        .dark-theme .stat-item {
            background: linear-gradient(135deg, #2d2d2d 0%, #333333 100%);
            border-color: #404040;
        }

        .dark-theme .stat-item:hover {
            background: linear-gradient(135deg, #333333 0%, #404040 100%);
            border-color: #61a029;
        }

        .dark-theme .stat-item .stat-number {
            color: #ffffff;
        }

        .dark-theme .stat-item .stat-label {
            color: #a0a0a0;
        }

        .dark-theme .settings-container {
            background: #1a1a1a;
            border-color: #404040;
        }

        .dark-theme .settings-section {
            background: #1a1a1a;
            border-color: #404040;
        }

        .dark-theme .setting-item {
            background: #2d2d2d;
            border-color: #404040;
        }

        .dark-theme .setting-item:hover {
            background: #333333;
            border-color: #61a029;
        }

        .dark-theme .setting-info h4 {
            color: #ffffff;
        }

        .dark-theme .setting-info p {
            color: #a0a0a0;
        }

        .dark-theme .setting-select {
            background: #2d2d2d;
            border-color: #404040;
            color: #ffffff;
        }
        .dark-theme .setting-select:focus {
            border-color: #61a029;
            background: #333333;
        }

        .dark-theme .profile-field-info label {
            color: #999999 !important;
        }

        .dark-theme .profile-field-info span {
            color: #e0e0e0 !important;
        }


        .stat-card i {
            font-size: 32px;
            color: #61a029;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f0fff4;
            border: 1px solid #e6fffa;
        }

        .stat-info h3 {
            font-size: 24px;
            font-weight: 700;
            color: #2d3748;
            margin: 0 0 4px 0;
        }

        .stat-info p {
            color: #718096;
            margin: 0;
            font-size: 14px;
        }

        /* Quick Actions */
        .quick-actions {
            background: #ffffff;
            border: 1px solid #e2e8f0;
            padding: 24px;
            margin-bottom: 32px;
        }

        .quick-actions h3 {
            font-size: 18px;
            font-weight: 600;
            color: #2d3748;
            margin: 0 0 16px 0;
        }

        .action-buttons {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .action-btn {
            background: #61a029;
            color: #ffffff;
            border: none;
            padding: 12px 20px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .action-btn:hover {
            background: #4f8a22;
            transform: translateY(-1px);
        }

        /* Buttons */
        .primary-btn {
            background: #61a029;
            color: #ffffff;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .primary-btn:hover {
            background: #4f8a22;
            transform: translateY(-1px);
        }

        .secondary-btn {
            background: #ffffff;
            color: #4a5568;
            border: 1px solid #e2e8f0;
            padding: 12px 24px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        .secondary-btn:hover {
            background: #f7fafc;
            border-color: #cbd5e0;
        }

        /* Forms */
        .form-field {
            margin-bottom: 20px;
        }

        .form-field label {
            display: block;
            font-weight: 500;
            color: #2d3748;
            margin-bottom: 6px;
            font-size: 14px;
        }
        .form-field input,
        .form-field select,
        .form-field textarea {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-size: 14px;
            transition: all 0.2s ease;
            background: #ffffff;
        }
        .form-field input:focus,
        .form-field select:focus,
        .form-field textarea:focus {
            outline: none;
            border-color: #61a029;
            box-shadow: 0 0 0 3px rgba(97, 160, 41, 0.1);
        }
        /* Cards */
        .card {
            background: #ffffff;
            border: 1px solid #e2e8f0;
            padding: 24px;
            margin-bottom: 24px;
            border-radius: 0;
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid #e2e8f0;
        }

        .card-title {
            font-size: 18px;
            font-weight: 600;
            color: #2d3748;
            margin: 0;
        }

        /* Tables */
        .table {
            width: 100%;
            border-collapse: collapse;
            background: #ffffff;
            border: 1px solid #e2e8f0;
        }

        .table th {
            background: #f7fafc;
            padding: 16px;
            text-align: left;
            font-weight: 600;
            color: #2d3748;
            border-bottom: 1px solid #e2e8f0;
        }

        .table td {
            padding: 16px;
            border-bottom: 1px solid #f1f5f9;
        }

        .table tr:hover {
            background: #f7fafc;
        }

        /* Status Badges */
        .status-badge {
            display: inline-flex;
            align-items: center;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status-badge.active {
            background: #f0fff4;
            color: #2d5016;
            border: 1px solid #9ae6b4;
        }

        .status-badge.pending {
            background: #fffbeb;
            color: #92400e;
            border: 1px solid #fcd34d;
        }

        .status-badge.inactive {
            background: #fef2f2;
            color: #991b1b;
            border: 1px solid #fca5a5;
        }

        /* Modern Checkbox Styling */
        .modern-checkbox {
            position: relative;
            display: inline-flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
            font-size: 14px;
            color: #495057;
        }

        .modern-checkbox input[type="checkbox"] {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            height: 0;
            width: 0;
        }

        .checkmark {
            position: relative;
            height: 18px;
            width: 18px;
            background-color: #ffffff;
            border: 2px solid #dee2e6;
            border-radius: 4px;
            margin-right: 8px;
            transition: all 0.2s ease;
        }

        .modern-checkbox:hover .checkmark {
            border-color: #61a029;
            background-color: #f8f9fa;
        }

        .modern-checkbox input:checked ~ .checkmark {
            background-color: #61a029;
            border-color: #61a029;
        }

        .checkmark:after {
            content: "";
            position: absolute;
            display: none;
            left: 5px;
            top: 2px;
            width: 4px;
            height: 8px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }

        .modern-checkbox input:checked ~ .checkmark:after {
            display: block;
        }

        .modern-checkbox input:indeterminate ~ .checkmark {
            background-color: #61a029;
            border-color: #61a029;
        }

        .modern-checkbox input:indeterminate ~ .checkmark:after {
            display: block;
            left: 3px;
            top: 6px;
            width: 8px;
            height: 2px;
            border: solid white;
            border-width: 0 0 2px 0;
            transform: none;
        }

        .checkbox-label {
            font-weight: 500;
            color: #495057;
        }

        /* Modern Remove Button */
        .modern-remove-btn {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            box-shadow: 0 2px 4px rgba(220, 53, 69, 0.2);
        }

        .modern-remove-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #c82333 0%, #a71e2a 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(220, 53, 69, 0.3);
        }

        .modern-remove-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .modern-remove-btn i {
            font-size: 12px;
        }

        /* Danger button styling */
        .danger-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
            margin-top: 8px;
        }

        .danger-btn:hover {
            background: #c82333;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);
        }

        .danger-btn:active {
            transform: translateY(0);
        }

        /* Enhanced Product Actions Styling */
        .product-actions-panel {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .action-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .action-group h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
            font-weight: 600;
            color: var(--text);
            border-bottom: 1px solid #e2e8f0;
            padding-bottom: 4px;
        }

        /* Enhanced Button Hover Effects */
        .primary-btn:hover,
        .secondary-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .primary-btn {
            background: var(--brand-strong);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
            width: 100%;
            justify-content: center;
        }

        .primary-btn:hover {
            background: var(--brand);
            color: white;
        }

        .secondary-btn {
            background: #f8fafc;
            color: var(--text);
            border: 1px solid #e2e8f0;
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s ease;
            width: 100%;
            justify-content: center;
        }

        .secondary-btn:hover {
            background: #e2e8f0;
            border-color: var(--brand);
            color: var(--text);
        }

        /* Enhanced Filter Dropdown Styling */
        .filter-select {
            width: 100%;
            padding: 10px 35px 10px 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            background: white;
            color: var(--text);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 12px center;
            background-repeat: no-repeat;
            background-size: 16px;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }

        .filter-select:focus {
            outline: none;
            border-color: var(--brand);
            box-shadow: 0 0 0 3px rgba(116, 180, 58, 0.1);
        }

        .filter-select:hover {
            border-color: #9ca3af;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
        }

        /* Style the dropdown options */
        .filter-select option {
            padding: 8px 12px;
            font-weight: 500;
            color: var(--text);
            background: white;
        }

        .filter-select option:hover,
        .filter-select option:focus,
        .filter-select option:checked {
            background-color: var(--brand);
            color: white;
        }

        /* Custom dropdown arrow styling */
        .filter-select::-ms-expand {
            display: none;
        }

        /* For better cross-browser compatibility */
        .filter-select::-webkit-outer-spin-button,
        .filter-select::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        /* Search Section - Minimal Styling */
        .search-section {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-bottom: 20px;
            width: 100%;
        }



        /* Product Grid */
        .products-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 24px;
        }

        /* Filtered out products - hide while maintaining grid layout */
        .product-card.filtered-out {
            display: none;
        }

        .product-card {
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            padding: 0;
            transition: all 0.3s ease;
            overflow: hidden;
            position: relative;
        }

        .product-card:hover {
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            transform: translateY(-4px);
            border-color: #61a029;
        }

        .product-image {
            width: 100%;
            height: 180px;
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
            border-bottom: 1px solid #e2e8f0;
            position: relative;
            overflow: hidden;
            color: #a0aec0;
        }

        .product-image.has-image {
            background: #0f172a;
            color: #fff;
        }

        .product-image.has-image::before {
            content: none;
        }

        .product-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .product-image-placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: center;
            justify-content: center;
            color: #a0aec0;
            font-size: 0.9rem;
        }

        .product-image-placeholder i {
            font-size: 2.5rem;
            opacity: 0.6;
        }

        .product-image-carousel {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .product-image-track {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .product-image-slide {
            position: absolute;
            inset: 0;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .product-image-slide.active {
            opacity: 1;
        }

        .product-image-slide img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .product-carousel-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.45);
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 2;
            transition: background 0.2s ease;
        }

        .product-carousel-btn:hover {
            background: rgba(0, 0, 0, 0.65);
        }

        .product-carousel-btn.prev {
            left: 10px;
        }

        .product-carousel-btn.next {
            right: 10px;
        }

        .product-carousel-dots {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 6px;
            z-index: 2;
        }

        .product-carousel-dot {
            width: 8px;
            height: 8px;
            border-radius: 999px;
            border: none;
            padding: 0;
            background: rgba(255, 255, 255, 0.4);
            cursor: pointer;
            transition: background 0.2s ease, transform 0.2s ease;
        }

        .product-carousel-dot.active {
            background: #ffffff;
            transform: scale(1.2);
        }

        .product-image.product-image--modal {
            width: 500px;
            max-width: 100%;
            height: 500px;
            max-height: 500px;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            background: #f8fafc;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .product-image.product-image--modal .product-image-carousel {
            width: 100%;
            height: 100%;
        }

        .product-image.product-image--modal .product-image-track {
            width: 100%;
            height: 100%;
        }

        .product-image.product-image--modal .product-image-slide {
            width: 100%;
            height: 100%;
        }

        .product-image.product-image--modal .product-image-slide img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .product-image.product-image--modal .product-carousel-btn {
            width: 40px;
            height: 40px;
            font-size: 16px;
        }

        .product-image.product-image--modal .product-carousel-dot {
            width: 10px;
            height: 10px;
        }

        @media (max-width: 768px) {
            .product-image.product-image--modal {
                width: 100%;
                max-width: 100%;
                height: 300px;
                max-height: 300px;
            }

            .product-image.product-image--modal .product-carousel-btn {
                width: 32px;
                height: 32px;
                font-size: 14px;
            }
        }

        .product-content {
            padding: 20px;
        }

        .product-name {
            font-size: 18px;
            font-weight: 600;
            color: #2d3748;
            margin: 0 0 12px 0;
            line-height: 1.3;
        }

        .product-category {
            display: inline-block;
            background: #e6fffa;
            color: #61a029;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 16px;
        }

        .product-details {
            display: grid;
            gap: 8px;
            margin-bottom: 16px;
        }

        .product-detail-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #f7fafc;
        }

        .product-detail-row:last-child {
            border-bottom: none;
        }

        .product-detail-label {
            font-size: 12px;
            font-weight: 600;
            color: #718096;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .product-detail-value {
            font-size: 14px;
            font-weight: 600;
            color: #2d3748;
        }

        .product-description {
            background: #f8fafc;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            color: #718096;
            line-height: 1.4;
            margin-top: 12px;
            border-left: 3px solid #61a029;
        }

        .product-status {
            position: absolute;
            top: 12px;
            right: 12px;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .product-status.active {
            background: #d4edda;
            color: #155724;
        }

        .product-status.inactive {
            background: #f8d7da;
            color: #721c24;
        }

        .product-status.out-of-stock {
            background: #fff3cd;
            color: #856404;
        }

        /* Search Container */
        .search-container {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .search-box {
            position: relative;
            flex: 1;
            max-width: 400px;
        }


        .search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #a0aec0;
        }

        .refresh-btn {
            background: #ffffff;
            border: 1px solid #e2e8f0;
            width: 40px;
            height: 40px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #4a5568;
        }

        .refresh-btn:hover {
            background: #f7fafc;
            border-color: #cbd5e0;
        }

        /* Order Management */
        .order-management-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 24px;
            border-bottom: 1px solid #e2e8f0;
        }

        .tab-btn {
            background: none;
            border: none;
            padding: 12px 20px;
            color: #718096;
            cursor: pointer;
            transition: all 0.2s ease;
            border-bottom: 2px solid transparent;
            font-size: 14px;
            font-weight: 500;
        }

        .tab-btn:hover {
            color: #4a5568;
            background: #f7fafc;
        }

        .tab-btn.active {
            color: #61a029;
            border-bottom-color: #61a029;
            background: #f0fff4;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Confirmed subtab content visibility */
        .confirmed-subtab-content {
            display: none;
        }

        .confirmed-subtab-content.active {
            display: block;
        }

        /* To Receive subtab content visibility */
        .to-receive-subtab-content {
            display: none;
        }

        .to-receive-subtab-content.active {
            display: block;
        }

        /* Order Cards */
        .order-card {
            background: #ffffff;
            border: 1px solid #e2e8f0;
            padding: 20px;
            margin-bottom: 16px;
            transition: all 0.2s ease;
            min-height: auto;
            overflow: visible;
            position: relative;
        }

        .order-card:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .order-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid #f1f5f9;
        }

        .order-id {
            font-weight: 600;
            color: #2d3748;
            font-size: 16px;
        }
        .order-status {
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status-pending {
            background: #fffbeb;
            color: #92400e;
            border: 1px solid #fcd34d;
        }

        .status-confirmed {
            background: #f0fff4;
            color: #2d5016;
            border: 1px solid #9ae6b4;
        }

        .status-processing {
            background: #eff6ff;
            color: #1e40af;
            border: 1px solid #93c5fd;
        }

        .status-delivered {
            background: #f0fff4;
            color: #2d5016;
            border: 1px solid #9ae6b4;
        }

        .status-failed {
            background: #fee2e2;
            color: #dc2626;
            border: 1px solid #fca5a5;
        }
        /* Responsive Design */
        @media (max-width: 768px) {
            .dashboard-container {
                flex-direction: column;
            }

            .sidebar {
                width: 240px;
                border-right: none;
                border-bottom: 1px solid #e2e8f0;
                position: fixed;
                top: 70px;
                left: 0;
                height: calc(100vh - 70px);
                z-index: 1000;
            }

            /* No hover effects on mobile */
            .sidebar:hover {
                width: 240px;
                left: 0;
            }

            body.sidebar-open .sidebar {
                left: 0;
                width: 240px;
            }

            .sidebar.mobile-open {
                left: 0;
                width: 280px;
            }

            .sidebar.collapsed {
                width: 60px;
            }

            .main-content {
                padding: 20px;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .products-grid {
                grid-template-columns: 1fr;
            }

            .search-container {
                flex-direction: column;
                align-items: stretch;
            }

            .search-box {
                max-width: none;
            }
        }

        /* Modal Styles - Enable Scrolling */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            padding: 20px;
            overflow-y: auto;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .modal-overlay.scrollable-overlay {
            align-items: flex-start;
            padding: 40px 20px;
        }

        .modal-content {
            background: white;
            border-radius: 15px;
            padding: 0;
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            transform: scale(0.9);
            transition: transform 0.3s ease;
            overflow: hidden;
        }

        .modal-overlay.show .modal-content {
            transform: scale(1);
        }

        .modal-content.scrollable-modal {
            max-width: 900px;
            max-height: 90vh;
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* Ensure modal content body can scroll when scrollable-modal is applied */
        .modal-content.scrollable-modal > .customer-details,
        .modal-content.scrollable-modal > .modern-customer-details,
        .modal-content.scrollable-modal > .farmer-details-view,
        .modal-content.scrollable-modal > .product-details-view {
            max-height: none;
            overflow-y: visible;
            overflow-x: visible;
        }

        .modal-content.scrollable-modal::-webkit-scrollbar {
            width: 8px;
        }

        .modal-content.scrollable-modal::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        .modal-content.scrollable-modal::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }

        .modal-content.scrollable-modal::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #f8fafc;
            border-radius: 15px 15px 0 0;
            flex-shrink: 0;
        }

        .modal-header h3 {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
            color: var(--text);
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .close-modal:hover {
            background: #e2e8f0;
            color: #333;
        }

        .modern-customer-details,
        .farmer-details-view,
        .customer-details,
        .product-details-view {
            padding: 24px;
            overflow-y: auto;
            overflow-x: hidden;
            flex: 1;
            min-height: 0;
        }

        /* Ensure customer details container can scroll when NOT in scrollable-modal */
        .modal-content:not(.scrollable-modal) .modern-customer-details,
        .modal-content:not(.scrollable-modal) .farmer-details-view,
        .modal-content:not(.scrollable-modal) .customer-details {
            max-height: calc(90vh - 80px); /* Subtract header height */
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* Fix compressed form layout in customer details */
        .modern-customer-details .form-grid,
        .customer-details .form-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            padding: 0;
        }

        .modern-customer-details .form-field,
        .customer-details .form-field {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 0;
        }

        .customer-details .form-field label {
            font-weight: 600;
            font-size: 14px;
            color: #374151;
            margin: 0;
        }

        .customer-details .form-field p {
            margin: 0;
            padding: 0;
            font-size: 14px;
            color: #1f2937;
        }

        .modern-customer-details .form-field label {
            font-weight: 600;
            font-size: 14px;
            color: #374151;
            margin: 0;
        }

        .modern-customer-details .form-field input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 14px;
            background: #f9fafb;
            box-sizing: border-box;
        }

        .modern-customer-details .form-field input[readonly] {
            background: #f3f4f6;
            cursor: default;
        }

        /* ID Photo Display Section */
        .modern-customer-details .id-photo-display,
        .modern-customer-details .info-section {
            margin-top: 24px;
            padding-top: 24px;
            border-top: 1px solid #e5e7eb;
        }

        .modern-customer-details .id-photo-display {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
        }

        .modern-customer-details .id-photo-item {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .modern-customer-details .id-photo-item strong {
            font-weight: 600;
            font-size: 14px;
            color: #374151;
        }

        .modern-customer-details .id-photo-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .modern-customer-details .id-photo-container img {
            max-width: 100%;
            max-height: 250px;
            width: auto;
            height: auto;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            object-fit: contain;
            background: #f9fafb;
        }

        /* Image Lightbox/Enlarged View */
        .image-lightbox-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            cursor: pointer;
        }

        .image-lightbox-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .image-lightbox-container {
            position: relative;
            max-width: 90vw;
            max-height: 90vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .image-lightbox-container img {
            max-width: 100%;
            max-height: 90vh;
            width: auto;
            height: auto;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            cursor: default;
        }

        .image-lightbox-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #333;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.2s ease;
            z-index: 1;
        }

        .image-lightbox-close:hover {
            background: rgba(255, 255, 255, 1);
            transform: scale(1.1);
        }

        .image-lightbox-label {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
        }

        /* Make ID images clickable */
        .customer-details img,
        .modern-customer-details img,
        .id-photo-container img,
        .profile-id-card img,
        .id-photos-grid img,
        .staff-details-view img,
        .user-form-right img {
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .customer-details img:hover,
        .modern-customer-details img:hover,
        .id-photo-container img:hover,
        .profile-id-card img:hover,
        .id-photos-grid img:hover,
        .staff-details-view img:hover,
        .user-form-right img:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        /* Staff ID Photo Card Styling */
        .profile-id-card {
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            overflow: hidden;
            background: #f9fafb;
        }

        .profile-id-image-wrapper {
            position: relative;
            width: 100%;
            cursor: pointer;
            overflow: hidden;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .profile-id-image-wrapper:hover {
            transform: scale(1.02);
        }
        
        .profile-id-card img {
            width: 100%;
            max-height: 250px;
            height: auto;
            object-fit: contain;
            display: block;
            border-radius: 0;
            pointer-events: none !important;
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-drag: none;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .profile-id-image-wrapper:hover img {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        /* Prevent any link-like behavior on profile ID card images */
        .profile-id-card a,
        .profile-id-card a img {
            pointer-events: none !important;
            text-decoration: none;
            display: none !important;
        }
        
        .profile-id-card {
            position: relative;
        }
        
        /* Remove any link styling from within profile ID cards */
        .profile-id-card .profile-id-actions {
            display: none !important;
        }
        
        /* Prevent browser from treating image as downloadable/linkable */
        .profile-id-card img {
            -webkit-user-drag: none !important;
            -khtml-user-drag: none !important;
            -moz-user-drag: none !important;
            -o-user-drag: none !important;
        }
        
        /* Ensure image wrapper handles all clicks, images cannot be clicked */
        .profile-id-image-wrapper img {
            pointer-events: none !important;
        }
        
        /* Ensure wrapper is clickable */
        .profile-id-image-wrapper {
            pointer-events: auto !important;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .modern-customer-details .form-grid {
                grid-template-columns: 1fr;
            }

            .modern-customer-details .id-photo-display {
                grid-template-columns: 1fr;
            }

            .modal-content.scrollable-modal {
                max-width: 95%;
            }
        }

        /* System Health Status Styles */
        .heartbeat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            margin-bottom: 8px;
            background: var(--surface-2);
            border-radius: 8px;
            border: 1px solid #e5e7eb;
            transition: all 0.3s ease;
        }

        .heartbeat-item:hover {
            background: #f8fafc;
        }

        .health-label {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 500;
            color: var(--text);
        }

        .health-label i {
            font-size: 16px;
            width: 20px;
            text-align: center;
        }

        .health-status {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            animation: pulse 2s infinite;
        }

        .status-indicator[data-status="online"] .status-dot {
            background-color: #10b981;
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.5);
        }

        .status-indicator[data-status="offline"] .status-dot {
            background-color: #ef4444;
            animation: none;
        }

        .status-indicator[data-status="warning"] .status-dot {
            background-color: #f59e0b;
            box-shadow: 0 0 8px rgba(245, 158, 11, 0.5);
        }

        .status-indicator[data-status="checking"] .status-dot {
            background-color: #6b7280;
            animation: pulse-checking 1s infinite;
        }

        .status-text {
            color: var(--text);
        }

        .status-indicator[data-status="online"] .status-text {
            color: #10b981;
        }

        .status-indicator[data-status="offline"] .status-text {
            color: #ef4444;
        }

        .status-indicator[data-status="warning"] .status-text {
            color: #f59e0b;
        }

        .status-indicator[data-status="checking"] .status-text {
            color: #6b7280;
        }

        .health-time {
            font-size: 12px;
            color: var(--muted);
            font-weight: 400;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        @keyframes pulse-checking {
            0%, 100% {
                opacity: 0.5;
            }
            50% {
                opacity: 1;
            }
        }

        /* Authoritative Time Source Badge (Admin Only) */
        .authoritative-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 8px;
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
            animation: pulse-glow 2s ease-in-out infinite;
        }

        .authoritative-badge i {
            font-size: 10px;
        }

        @keyframes pulse-glow {
            0%, 100% {
                box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
            }
            50% {
                box-shadow: 0 2px 8px rgba(102, 126, 234, 0.6);
            }
        }

        /* Time Validation Warning (Admin Only) */
        .time-validation-warning {
            margin-top: 12px;
            padding: 12px 16px;
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
            animation: shake-warning 0.5s ease-in-out;
        }

        .dark-theme .time-validation-warning {
            background: #3d2e1f;
            border-color: #f59e0b;
        }

        .warning-content {
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .warning-content i {
            color: #f59e0b;
            font-size: 20px;
            margin-top: 2px;
            flex-shrink: 0;
        }

        .warning-text {
            flex: 1;
        }

        .warning-text strong {
            display: block;
            color: #856404;
            margin-bottom: 4px;
            font-size: 14px;
        }

        .dark-theme .warning-text strong {
            color: #fbbf24;
        }

        .warning-text p {
            margin: 0;
            color: #856404;
            font-size: 13px;
            line-height: 1.5;
        }

        .dark-theme .warning-text p {
            color: #fbbf24;
        }

        @keyframes shake-warning {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        /* Loading Screen Styles */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 99999;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .loading-screen.hidden {
            display: none !important;
            opacity: 0 !important;
            visibility: hidden !important;
            pointer-events: none !important;
        }
        
        /* Ensure dashboard content is always visible */
        .dashboard-container,
        .main-content,
        .screen {
            opacity: 1 !important;
            visibility: visible !important;
        }
        
        /* Hide loading screen after initialization as fallback */
        body:not(.loading) #loadingScreen {
            display: none !important;
        }

        .loading-content {
            text-align: center;
            color: white;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
        
        /* Section Loading Message Styles - Green Theme */
        .section-loading-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
            border: 2px solid #10b981;
            padding: 20px 30px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(16, 185, 129, 0.2);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 16px;
            font-weight: 600;
            color: #059669;
            min-width: 250px;
            justify-content: center;
        }

        .section-loading-message i {
            color: #10b981;
            font-size: 18px;
            animation: spin 1s linear infinite;
        }

        .section-loading-message span {
            color: #059669;
        }

        .section-loading-message.error {
            background: rgba(254, 242, 242, 0.95);
            border: 2px solid #ef4444;
        }

        .section-loading-message.error i {
            color: #ef4444;
            animation: none;
        }

        .section-loading-message.error span {
            color: #dc2626;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .section-loading-message.hidden {
            display: none !important;
        }

        .content-section {
            position: relative;
        }
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .loading-subtext {
            font-size: 14px;
            opacity: 0.9;
        }

        .dashboard-content {
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .dashboard-content.loaded {
            opacity: 1;
        }
    </style>
</head>
<body>
    <!-- Loading Screen (shown by default until auth completes) -->
    <div id="loadingScreen" class="loading-screen" style="display: flex;">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-text">Loading Dashboard...</div>
            <div class="loading-subtext">Authenticating and initializing...</div>
        </div>
    </div>

    <!-- Staff Dashboard (hidden until auth completes) -->
    <div id="staffDashboard" class="screen active dashboard-content" style="opacity: 0;">
        <script>
            // Ensure loading class is set on body immediately on page load/refresh
            document.body.classList.add('loading');
        </script>
        <script>
            // Fallback definitions to guarantee availability for inline onclick
            (function(){
                if (!window.openChatBox) {
                    window.openChatBox = function(){
                        console.log('Opening chatbox...');
                        isChatboxOpen = true;
                        const overlay = document.getElementById('chatboxOverlay');
                        console.log('Overlay element:', overlay);
                        if (overlay) {
                            overlay.classList.add('active');
                            document.body.style.overflow = 'hidden';
                            console.log('Chatbox opened successfully');
                            try {
                                // Default to Active tab and show loading only if needed
                                if (typeof switchConversationTab === 'function') {
                                    switchConversationTab('active');
                                }
                                const list = document.getElementById('conversationsList');
                                // Check if we already have conversations
                                const hasConversations = list && list.querySelectorAll('.conversation-item').length > 0;
                                // Load conversations silently in background if needed (no loading message)
                                if (!hasConversations && typeof loadActiveConversations === 'function') {
                                    loadActiveConversations();
                                }
                                // Start realtime listener if not already active
                                if (isFirebaseChatAvailable()) {
                                    if (!window.__conversationsListener) {
                                        const ref = firebase.database().ref('conversations');
                                        window.__conversationsListener = ref;
                                        ref.on('value', async (snapshot) => {
                                            const data = snapshot.val() || {};
                                            const active = {};
                                            Object.keys(data).forEach(id => {
                                                const c = data[id] || {};
                                                if (c.archived !== true) active[id] = c;
                                            });
                                            try {
                                                if (typeof updateConversationList === 'function') {
                                                    await updateConversationList(active);
                                                }
                                                if (typeof updateBadgeCount === 'function') {
                                                    updateBadgeCount();
                                                }
                                            } catch(e) { console.warn('Realtime updateConversationList error', e); }
                                        });
                                    }
                                }
                                // If Firebase isn't ready yet, retry briefly so we don't stick on Loading...
                                if (!(isFirebaseChatAvailable())) {
                                    try {
                                        window.__chatInitRetries = (window.__chatInitRetries || 0) + 1;
                                        if (window.__chatInitRetries <= 5 && typeof loadActiveConversations === 'function') {
                                            setTimeout(() => {
                                                console.log('Retrying loadActiveConversations (attempt)', window.__chatInitRetries);
                                                loadActiveConversations();
                                            }, 1000 * window.__chatInitRetries);
                                        } else if (window.__chatInitRetries > 5) {
                                            const listEl = document.getElementById('conversationsList');
                                            if (listEl) {
                                                listEl.innerHTML = '<div class="no-conversations">No conversations available</div>';
                                            }
                                        }
                                    } catch(_) {}
                                }
                            } catch(e) { console.warn('Chat load init error:', e); }
                        } else {
                            console.error('Chatbox overlay not found!');
                        }
                    };
                }
                if (!window.closeChatBox) {
                    window.closeChatBox = function(){
                        console.log('Closing chatbox...');
                        isChatboxOpen = false;
                        const overlay = document.getElementById('chatboxOverlay');
                        if (overlay) {
                            overlay.classList.remove('active');
                            document.body.style.overflow = '';
                            console.log('Chatbox closed successfully');
                        }
                        // Detach realtime listener when closing to avoid duplicates
                        try {
                            if (window.__conversationsListener) {
                                window.__conversationsListener.off();
                                window.__conversationsListener = null;
                            }
                        } catch(_) {}
                    };
                }
                if (!window.toggleChatBox) {
                    window.toggleChatBox = function(){
                        const overlay = document.getElementById('chatboxOverlay');
                        const isOpen = overlay && overlay.classList.contains('active');
                        if (isOpen) { window.closeChatBox(); } else { window.openChatBox(); }
                    };
                }
            })();
        </script>
        <!-- Chat Button (Floating) -->
        <button class="chat-toggle-btn" id="chatToggleBtn" onclick="toggleChatBox()" style="z-index: 99999 !important;">
            <i class="fas fa-comments"></i>
            <span class="chat-badge hidden" id="chatBadge"></span>
        </button>
        
        <!-- Fix Data Button (Hidden by default, appears on double-click chat button) -->
        <button class="chat-toggle-btn" id="fixDataBtn" onclick="fixCorruptedUnreadData()" 
                style="z-index: 99998 !important; bottom: 90px; right: 20px; display: none; background: #f59e0b;"
                title="Click to fix corrupted unread message data">
            <i class="fas fa-wrench"></i>
        </button>
        <div class="dashboard-container">
            <sidebar class="sidebar">
                <div class="sidebar-brand">
                    <i class="fas fa-seedling brand-leaf"></i>
                    <span class="brand-staff" id="dashboard-brand">Staff</span>
                </div>
                <ul class="sidebar-menu">
                    <li class="menu-item active" data-section="staff-overview" onclick="switchToSection('staff-overview')">
                        <i class="fas fa-tachometer-alt"></i>
                        <span>Dashboard</span>
                    </li>
                    <li class="menu-item" data-section="product-listing" onclick="switchToSection('product-listing')">
                        <i class="fas fa-plus-circle"></i>
                        <span>Product Listing</span>
                    </li>
                    <li class="menu-item" data-section="order-management" onclick="switchToSection('order-management')">
                        <i class="fas fa-shopping-cart"></i>
                        <span>Orders</span>
                    </li>
                    <li class="menu-item" data-section="assign-orders" onclick="switchToSection('assign-orders')">
                        <i class="fas fa-tasks"></i>
                        <span>Order Management</span>
                    </li>
                    <li class="menu-item" data-section="user-management" onclick="switchToSection('user-management')">
                        <i class="fas fa-users-cog"></i>
                        <span>User Management</span>
                    </li>
                    <li class="menu-item" data-section="reports-analytics" onclick="switchToSection('reports-analytics')">
                        <i class="fas fa-chart-bar"></i>
                        <span>Sales and Reports</span>
                    </li>
                    <li class="menu-item" data-section="delivery-settings" onclick="switchToSection('delivery-settings')">
                        <i class="fas fa-truck"></i>
                        <span>Delivery Fee and Pick Up Area</span>
                    </li>
                </ul>
                
                <!-- User Profile Section at Bottom -->
                <div class="sidebar-profile">
                    <div class="profile-dropdown">
                        <div class="profile-section" id="staffProfileBtn">
                            <div class="profile-avatar">
                                <i class="fas fa-user"></i>
                            </div>
                            <div class="profile-info">
                                <div class="profile-name" id="profileName">Loading...</div>
                                <div class="profile-role" id="profileRole">Loading...</div>
                            </div>
                        </div>
                        <div id="profileDropdownMenu" class="dropdown-menu">
                            <div class="dropdown-header">
                                <div class="user-info">
                                    <div class="user-avatar">
                                        <i class="fas fa-user"></i>
                                        <i class="fas fa-shield-alt user-shield"></i>
                                    </div>
                                    <div class="user-details">
                                        <span class="user-name" id="dropdownStaffName">Loading...</span>
                                        <span class="user-role" id="dropdownStaffRole">Loading...</span>
                                    </div>
                                </div>
                            </div>
                            <div class="dropdown-divider"></div>
                            <a href="#" class="dropdown-item" id="profileMenuItem" onclick="showProfileSection()">
                                <i class="fas fa-user-circle"></i>
                                <span>Profile</span>
                            </a>
                            <a href="#" class="dropdown-item" id="settingsMenuItem" onclick="showSettingsSection()">
                                <i class="fas fa-cog"></i>
                                <span>Settings</span>
                            </a>
                            <div class="dropdown-divider"></div>
                            <a href="#" class="dropdown-item logout-item" id="logoutMenuItem" onclick="logoutStaff()">
                                <i class="fas fa-sign-out-alt"></i>
                                <span>Logout</span>
                            </a>
                        </div>
                    </div>
                </div>
            </sidebar>

            <main class="main-content">
                <div class="content-wrapper">
                    <!-- Staff Overview Section -->
                    <section id="staff-overview" class="content-section active" style="background:transparent;">
                    <div style="margin-bottom: 24px; text-align: center; padding: 0 20px;">
                        <h2 style="font-weight: 900 !important; color: #243a27 !important; font-size: 28px !important; margin-bottom: 8px !important; letter-spacing: 0.5px !important; line-height: 1.3 !important; text-align: center !important;">Cabintan Livelihood Community Agriculture  Cooperative (CALCOA)</h2>
                        <p style="font-style: italic !important; color: #2d5016 !important; font-size: 14px !important; margin: 0 !important; font-weight: 500 !important; line-height: 1.5 !important; text-align: center !important;">This system is officially managed by the cooperative in partnership with Eastern Visayas State University</p>
                    </div>
                    <div class="overview-grid">
                        <div class="overview-left">
                            <div class="records-and-sales-container">
                                <div class="records-table-container">
                                <div class="records-table-header">
                                    <h3><i class="fas fa-chart-bar"></i> System Records Overview</h3>
                                </div>
                                <div class="records-table">
                                    <table class="records-table-content">
                                        <thead>
                                            <tr>
                                                <th></th>
                                                <th>
                                                    <div class="record-type-header">
                                                        <i class="fas fa-shopping-cart"></i>
                                                        <span>All Orders</span>
                                                    </div>
                                                </th>
                                                <th>
                                                    <div class="record-type-header">
                                                        <i class="fas fa-seedling"></i>
                                                        <span>Farmer Records</span>
                                                    </div>
                                                </th>
                                                <th>
                                                    <div class="record-type-header">
                                                        <i class="fas fa-users"></i>
                                                        <span>Customer Records</span>
                                                    </div>
                                                </th>
                                                <th class="admin-only-col">
                                                    <div class="record-type-header">
                                                        <i class="fas fa-user-tie"></i>
                                                        <span>Staff Records</span>
                                                    </div>
                                                </th>
                                                <th class="admin-only-col">
                                                    <div class="record-type-header">
                                                        <i class="fas fa-motorcycle"></i>
                                                        <span>Rider Records</span>
                                                    </div>
                                                </th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <th>Total Count</th>
                                                <td>
                                                    <div class="record-count">
                                                        <span class="num" id="allOrdersCount">0</span>
                                                    </div>
                                                </td>
                                                <td>
                                                    <div class="record-count">
                                                        <span class="num" id="farmerCount">0</span>
                                                    </div>
                                                </td>
                                                <td>
                                                    <div class="record-count">
                                                        <span class="num" id="customerCount">0</span>
                                                    </div>
                                                </td>
                                                <td class="admin-only-col">
                                                    <div class="record-count">
                                                        <span class="num" id="staffCount">0</span>
                                                    </div>
                                                </td>
                                                <td class="admin-only-col">
                                                    <div class="record-count">
                                                        <span class="num" id="riderCount">0</span>
                                                    </div>
                                                </td>
                                            </tr>
                                            <tr>
                                                <th>Additional Info</th>
                                                <td>
                                                    <div class="record-additional">
                                                        <span class="additional-label">Pending:</span>
                                                        <span class="additional-value" id="pendingOrdersCount">0</span>
                                                    </div>
                                                </td>
                                                <td>
                                                    <div class="record-additional">
                                                        <span class="additional-label">-</span>
                                                    </div>
                                                </td>
                                                <td>
                                                    <div class="record-additional">
                                                        <span class="additional-label">Pending Verifications:</span>
                                                        <span class="additional-value pending-customer-verifications" id="pendingCustomerVerificationsSummary">0</span>
                                                    </div>
                                                </td>
                                                <td class="admin-only-col">
                                                    <div class="record-additional">
                                                        <span class="additional-label">-</span>
                                                    </div>
                                                </td>
                                                <td class="admin-only-col">
                                                    <div class="record-additional">
                                                        <span class="additional-label">-</span>
                                                    </div>
                                                </td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                            </div>

                            <!-- Weekly Sales and System Time Container (Admin Side) -->
                            <div class="sales-and-status-container">
                                <!-- Weekly Sales Container -->
                                <div class="weekly-sales-container" onclick="switchToSection('reports-analytics')" style="cursor: pointer;">
                                    <div class="weekly-sales-header">
                                        <div class="weekly-sales-icon">
                                            <i class="fas fa-chart-line"></i>
                                        </div>
                                        <h3>Weekly Sales</h3>
                                    </div>
                                    <div class="weekly-sales-content">
                                        <div class="weekly-sales-amount">
                                            <span class="weekly-sales-label">Total Amount</span>
                                            <span class="weekly-sales-value" id="weeklySalesTotal">0</span>
                                        </div>
                                        <div class="weekly-sales-footer">
                                            <span>Click to view details <i class="fas fa-arrow-right"></i></span>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- System Time & Status (Admin Only) - Below Weekly Sales -->
                                <div class="weather admin-only-section" id="authoritativeTimeContainer" style="display: none; max-height: fit-content; padding-bottom: 12px;">
                                    <div class="system-status-header" style="margin-bottom: 10px;">
                                        <div class="system-status-icon">
                                            <i class="fas fa-clock"></i>
                                        </div>
                                        <h4 style="margin: 0; display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
                                            System Time & Status
                                            <!-- Authoritative Source Badge (Admin Only) -->
                                            <span id="authoritativeTimeBadge" class="authoritative-badge" style="display: none;">
                                                <i class="fas fa-crown"></i>
                                                <span>Authoritative</span>
                                            </span>
                                        </h4>
                                    </div>
                                    <div style="display: flex; flex-direction: column; gap: 8px;">
                                        <!-- Current PC Time Display (Modern Compact) -->
                                        <div id="currentPCTimeDisplay" style="display: none; padding: 10px 12px; background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border-radius: 8px; border: 1px solid #86efac; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);">
                                            <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;">
                                                <i class="fas fa-clock" style="color: #16a34a; font-size: 11px;"></i>
                                                <span style="font-size: 10px; color: #166534; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;">PC Time</span>
                                            </div>
                                            <div style="font-size: 12px; font-weight: 700; color: #15803d; font-family: 'Courier New', monospace; line-height: 1.3;" id="currentPCTimeValue">-</div>
                                        </div>
                                        
                                        <!-- Supabase Status (Modern Compact) -->
                                        <div id="supabaseStatusDisplay" style="display: none; padding: 10px 12px; background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%); border-radius: 8px; border: 1px solid #93c5fd; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);">
                                            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 4px;">
                                                <div style="display: flex; align-items: center; gap: 6px;">
                                                    <i class="fas fa-database" style="color: #2563eb; font-size: 11px;"></i>
                                                    <span style="font-size: 10px; color: #1e40af; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;">Supabase</span>
                                                </div>
                                                <div style="display: flex; align-items: center; gap: 6px;">
                                                    <span class="status-dot" id="supabaseStatusDot" style="width: 8px; height: 8px; border-radius: 50%; background: #9ca3af; display: inline-block; box-shadow: 0 0 4px rgba(0, 0, 0, 0.2); transition: all 0.3s ease;"></span>
                                                    <span style="font-size: 11px; font-weight: 600; color: #374151; transition: color 0.3s ease;" id="supabaseStatusText">Checking...</span>
                                                </div>
                                            </div>
                                            <div style="font-size: 9px; color: #6b7280; line-height: 1.2;" id="supabaseStatusTime">-</div>
                                        </div>
                                        
                                        <!-- Time Validation Warning (Compact) -->
                                        <div id="timeValidationWarning" class="time-validation-warning" style="display: none; margin-top: 0; padding: 10px 12px; font-size: 11px;">
                                            <div class="warning-content" style="gap: 8px;">
                                                <i class="fas fa-exclamation-triangle" style="font-size: 12px;"></i>
                                                <div class="warning-text" style="flex: 1;">
                                                    <strong style="font-size: 11px;">PC Time Warning</strong>
                                                    <p id="timeValidationMessage" style="font-size: 10px; margin-top: 4px; line-height: 1.3;"></p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            </div>

                            <div class="hero">
                                <div class="quick-actions-card">
                                    <div class="quick-actions-header">
                                        <div class="quick-actions-icon">
                                            <i class="fas fa-bolt"></i>
                                        </div>
                                        <h3>Quick Actions</h3>
                                    </div>
                                    <div class="quick-actions-buttons">
                                        <button class="quick-action-btn primary" onclick="switchToSection('product-listing')">
                                            <i class="fas fa-plus-circle"></i>
                                            <span>Add Product</span>
                                        </button>
                                        <button class="quick-action-btn secondary" onclick="switchToSection('order-management')">
                                            <i class="fas fa-shopping-cart"></i>
                                            <span>View Orders</span>
                                        </button>
                                        <button class="quick-action-btn" onclick="switchToSection('user-management')">
                                            <i class="fas fa-users"></i>
                                            <span>Manage Users</span>
                                        </button>
                                        <button class="quick-action-btn" onclick="switchToSection('delivery-settings')">
                                            <i class="fas fa-truck"></i>
                                            <span>Delivery Settings</span>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Product Listing Section -->
                <section id="product-listing" class="content-section">
                    <h2>Product Management</h2>
                    
                    <div class="dashboard-layout">
                        <!-- Left Column - Search and Products -->
                        <div class="dashboard-left">
                            <!-- Search Bar Section (matches Orders/Farmers/Customers cards position) -->
                            <div class="search-section">
                                <div class="search-input-container">
                                    <i class="fas fa-search"></i>
                                    <input type="text" id="productSearchInput" placeholder="Search products..." class="search-input">
                                </div>
                                <button id="refreshProductsBtn" class="secondary-btn" onclick="staffManager.forceRefreshProducts()">
                                    <i class="fas fa-sync-alt"></i>
                                </button>
                            </div>
                            
                            <!-- Products Grid -->
                            <div class="products-grid" id="productsGrid">
                                <!-- Products will be populated here -->
                            </div>
                        </div>
                        
                        <!-- Right Column - Product Actions (matches System Status/Staff Performance position) -->
                        <div class="dashboard-right">
                            <!-- Product Actions Card -->
                            <div class="data-card">
                                <div class="data-card-header">
                                    <h3><i class="fas fa-cogs"></i> Product Actions</h3>
                                </div>
                                <div class="product-actions-panel">
                                    <button id="addProductBtn" class="primary-btn" onclick="staffManager.showAddProductModal()">
                                        <i class="fas fa-plus"></i>
                                        Add Product
                                    </button>
                                    
                                    <div class="action-group">
                                        <h4>Bulk Actions</h4>
                                        <button id="toggleSelectBtn" class="secondary-btn" onclick="toggleSelectAllProducts()">
                                            <i class="fas fa-check-square"></i>
                                            Select All
                                        </button>
                                        <button id="deleteSelectedBtn" class="danger-btn" onclick="deleteSelectedProducts()" style="display: none;">
                                            <i class="fas fa-trash"></i>
                                            Delete Selected
                                        </button>
                                        <div id="selectedCount" style="margin-top: 8px; color: #666; font-size: 14px; font-weight: 500;">
                                            0 selected
                                        </div>
                                    </div>
                                    
                                    <div class="action-group">
                                        <h4>Filters</h4>
                                        <select id="categoryFilter" class="filter-select" data-filter="category">
                                            <option value="">All Categories</option>
                                            <option value="vegetables">Vegetables</option>
                                            <option value="fruits">Fruits</option>
                                            <option value="grains">Grains</option>
                                            <option value="dairy">Dairy</option>
                                            <option value="meat">Meat</option>
                                            <option value="seafood">Seafood</option>
                                        </select>
                                        
                                        <select id="statusFilter" class="filter-select" data-filter="status">
                                            <option value="">All Status</option>
                                            <option value="active">Active</option>
                                            <option value="inactive">Inactive</option>
                                            <option value="out-of-stock">Out of Stock</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Product Stats Card -->
                            <div class="data-card">
                                <div class="data-card-header">
                                    <h3><i class="fas fa-chart-bar"></i> Product Statistics</h3>
                                </div>
                                <div class="product-stats">
                                    <div class="stat-item">
                                        <span class="stat-label">Total Products</span>
                                        <span class="stat-value" id="totalProducts">0</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Active Products</span>
                                        <span class="stat-value" id="activeProducts">0</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Out of Stock</span>
                                        <span class="stat-value" id="outOfStock">0</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Order Management Section -->
                <section id="order-management" class="content-section">
                    <h2>Orders</h2>
                    
					<div class="order-management-tabs">
						<button type="button" class="tab-btn active" data-tab="pending-orders" id="pending-orders-btn" onclick="switchOrderManagementTab('pending-orders')">Pending</button>
						<button type="button" class="tab-btn" data-tab="rejected-orders" id="rejected-orders-btn" onclick="switchOrderManagementTab('rejected-orders')">Rejected</button>
						<button type="button" class="tab-btn" data-tab="cancelled-orders" id="cancelled-orders-btn" onclick="switchOrderManagementTab('cancelled-orders')">Cancelled</button>
					</div>
                    
                    <div class="order-management-content">
                        <!-- Pending Orders Tab -->
                        <div id="pending-orders-tab" class="tab-content active">
                            <div class="orders-container" id="ordersContainer">
                                <!-- Pending orders will be populated here -->
                            </div>
                        </div>
                        
                        <!-- Rejected Orders Tab -->
                        <div id="rejected-orders-tab" class="tab-content">
                            <div class="rejected-orders-header">
                                <div class="rejected-stats">
                                    <div class="stat-item">
                                        <span class="stat-label">Total Rejected Orders:</span>
                                        <span class="stat-value" id="rejectedCount">0</span>
                                    </div>
                                </div>
                            </div>
                            <div class="rejected-products-container" id="rejectedProductsContainer">
                                <!-- Rejected orders will be populated here -->
                            </div>
                        </div>
                        
                        <!-- Cancelled Orders Tab -->
                        <div id="cancelled-orders-tab" class="tab-content">
                            <div class="rejected-orders-header">
                                <div class="rejected-stats">
                                    <div class="stat-item">
                                        <span class="stat-label">Total Cancelled:</span>
                                        <span class="stat-value" id="cancelledCount">0</span>
                                    </div>
                                </div>
                            </div>
                            <div class="rejected-products-container" id="cancelledProductsContainer">
                                <!-- Cancelled (refunded) orders will be populated here -->
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Order Management Section -->
                <section id="assign-orders" class="content-section">
                    <h2>Order Management</h2>
                    <div class="assigned-orders-header">
                        <div class="assigned-stats">
                            <div class="stat-item">
                                <span class="stat-label">Order Records:</span>
                                <span class="stat-value" id="assignedOrdersCount">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Total Order (Weekly):</span>
                                <span class="stat-value" id="inProgressCount">0</span>
                            </div>
                        </div>
                    </div>
                    <div class="order-management-tabs" style="display:flex; gap:8px; margin-bottom:12px;">
                        <button class="tab-btn assign-tab-btn active" data-assign-tab="confirmed" onclick="window.staffManager && staffManager.switchAssignTab('confirmed')">Confirmed</button>
                        <button class="tab-btn assign-tab-btn" data-assign-tab="to-receive" onclick="window.staffManager && staffManager.switchAssignTab('to-receive')">To Receive</button>
                        <button class="tab-btn assign-tab-btn" data-assign-tab="successful" onclick="window.staffManager && staffManager.switchAssignTab('successful')">Successful</button>
                        <button class="tab-btn assign-tab-btn" data-assign-tab="failed" onclick="window.staffManager && staffManager.switchAssignTab('failed')">Failed</button>
                    </div>
                    <div class="assign-orders-tabs">
                        <div id="assign-tab-confirmed" class="tab-content active">
                            <div class="confirmed-subtabs" style="display:flex; gap:8px; margin-bottom:12px;">
                                <button class="tab-btn confirmed-subtab-btn active" data-confirmed-subtab="delivery" onclick="window.staffManager && staffManager.switchConfirmedSubTab('delivery')">Delivery</button>
                                <button class="tab-btn confirmed-subtab-btn" data-confirmed-subtab="pickup" onclick="window.staffManager && staffManager.switchConfirmedSubTab('pickup')">Pickup</button>
                            </div>
                            <div id="confirmed-subtab-delivery" class="confirmed-subtab-content active">
                                <div class="assigned-orders-container" id="assignedOrdersContainerConfirmedDelivery"></div>
                            </div>
                            <div id="confirmed-subtab-pickup" class="confirmed-subtab-content">
                                <div class="assigned-orders-container" id="assignedOrdersContainerConfirmedPickup"></div>
                            </div>
                        </div>
                        <div id="assign-tab-to-receive" class="tab-content">
                            <div class="to-receive-subtabs" style="display:flex; gap:8px; margin-bottom:12px;">
                                <button class="tab-btn to-receive-subtab-btn active" data-to-receive-subtab="delivery" onclick="window.staffManager && staffManager.switchToReceiveSubTab('delivery')">Delivery</button>
                                <button class="tab-btn to-receive-subtab-btn" data-to-receive-subtab="pickup" onclick="window.staffManager && staffManager.switchToReceiveSubTab('pickup')">Pickup</button>
                            </div>
                            <div id="to-receive-subtab-delivery" class="to-receive-subtab-content active">
                                <div class="assigned-orders-container" id="assignedOrdersContainerToReceiveDelivery"></div>
                            </div>
                            <div id="to-receive-subtab-pickup" class="to-receive-subtab-content">
                                <div class="assigned-orders-container" id="assignedOrdersContainerToReceivePickup"></div>
                            </div>
                        </div>
                        <div id="assign-tab-successful" class="tab-content">
                            <div class="assigned-orders-container" id="assignedOrdersContainerSuccessful"></div>
                        </div>
                        <div id="assign-tab-failed" class="tab-content">
                            <div class="assigned-orders-container" id="assignedOrdersContainerFailed"></div>
                        </div>
                    </div>
                </section>

                

                <!-- User Management Section -->
                <section id="user-management" class="content-section">
                    <h2>User Management</h2>
                    
                    <div class="user-management-tabs">
                        <button class="tab-btn admin-only" data-tab="staff-users" id="staff-users-tab-btn" style="display: none;">Staff</button>
                        <button class="tab-btn active" data-tab="farmer-users">Farmers</button>
                        <button class="tab-btn" data-tab="customer-users">Customers</button>
                        <button class="tab-btn admin-only" data-tab="rider-users" id="rider-users-tab-btn" style="display: none;">Riders</button>
                    </div>
                    
                    <div class="user-management-content">
                        <!-- Staff Tab (Admin Only) -->
                        <div id="staff-users-tab" class="tab-content admin-only" style="display: none;">
                            <div class="tab-header">
                                <h3>Staff Management</h3>
                                <div class="header-actions">
                                    <div class="search-container">
                                        <div class="search-box">
                                            <i class="fas fa-search"></i>
                                            <input type="text" id="staffSearchInput" placeholder="Search staff by name, email, or employee ID..." onkeyup="staffManager.searchUsers('staff', this.value)">
                                            <button class="clear-search-btn" onclick="document.getElementById('staffSearchInput').value=''; staffManager.searchUsers('staff', '');">
                                                <i class="fas fa-times"></i>
                                            </button>
                                        </div>
                                    </div>
                                    <button id="addStaffBtn" class="primary-btn">
                                        <i class="fas fa-plus"></i>
                                        Add New Staff
                                    </button>
                                </div>
                            </div>
                            <div class="user-list" id="staffList">
                                <!-- Staff members will be populated here -->
                            </div>
                        </div>
                        
                        <!-- Farmers Tab -->
                        <div id="farmer-users-tab" class="tab-content active">
                            <div class="tab-header">
                                <h3>Farmer Management</h3>
                                <div class="header-actions">
                                    <div class="search-container">
                                        <div class="search-box">
                                            <i class="fas fa-search"></i>
                                            <input type="text" id="farmerSearchInput" placeholder="Search farmers by name, email, or location..." onkeyup="staffManager.searchUsers('farmer', this.value)">
                                            <button class="clear-search-btn" onclick="document.getElementById('farmerSearchInput').value=''; staffManager.searchUsers('farmer', '');">
                                                <i class="fas fa-times"></i>
                                            </button>
                                        </div>
                                    </div>
                                    <button id="addFarmerBtn" class="primary-btn">
                                        <i class="fas fa-plus"></i>
                                        Add New Farmer
                                    </button>
                                </div>
                            </div>
                            <div class="user-list" id="farmerList">
                                <!-- Farmers will be populated here -->
                            </div>
                        </div>
                        
                        <!-- Customers Tab -->
                        <div id="customer-users-tab" class="tab-content">
                            <div class="tab-header">
                                <h3>Customer Management</h3>
                                <p class="tab-description">View customer profiles and manage their accounts</p>
                            </div>
                            
                            <!-- Customer Management Tabs (Rejected Verifications removed) -->
                            <div class="customer-management-tabs">
                                <button class="sub-tab-btn active" data-tab="pending-verifications" id="pending-verifications-btn" onclick="if(window.staffManager) window.staffManager.switchCustomerManagementTab('pending-verifications')">Pending Verifications</button>
                                <button class="sub-tab-btn" data-tab="approved-customers" id="approved-customers-btn" onclick="if(window.staffManager) window.staffManager.switchCustomerManagementTab('approved-customers')">Customer Record</button>
                            </div>
                            
                            <div class="customer-management-content">
                                <!-- Pending Verifications Tab -->
                                <div id="pending-verifications-tab" class="sub-tab-content active">
                                    <div class="verification-header" style="display: flex; justify-content: flex-end; align-items: center;">
                                        <div class="search-container">
                                            <div class="search-box">
                                                <i class="fas fa-search"></i>
                                                <input type="text" id="pendingCustomerSearchInput" placeholder="Search pending customers...">
                                                <button class="clear-search-btn">
                                                    <i class="fas fa-times"></i>
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="pending-verifications" id="customerVerificationsManagement">
                                        <!-- Pending verifications will be populated here -->
                                    </div>
                                </div>
                                
                                <!-- Rejected Verifications Tab removed (rejected accounts are now fully deleted) -->
                                
                                <!-- Customer Record Tab -->
                                <div id="approved-customers-tab" class="sub-tab-content">
                                    <div class="tab-header">
                                        <h3>Customer Records</h3>
                                        <div class="header-actions">
                                            <div class="search-container">
                                                <div class="search-box">
                                                    <i class="fas fa-search"></i>
                                                    <input type="text" id="approvedCustomerSearchInput" placeholder="Search approved customers...">
                                                    <button class="clear-search-btn" style="display:none;">
                                                        <i class="fas fa-times"></i>
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="user-list" id="customerList">
                                        <!-- Approved customers will be populated here -->
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Riders Tab (Admin Only) -->
                        <div id="rider-users-tab" class="tab-content admin-only" style="display: none;">
                            <div class="tab-header">
                                <h3>Rider Management</h3>
                                <div class="header-actions">
                                    <div class="search-container">
                                        <div class="search-box">
                                            <i class="fas fa-search"></i>
                                            <input type="text" id="riderSearchInput" placeholder="Search riders by name, email, or vehicle number..." onkeyup="staffManager.searchUsers('rider', this.value)">
                                            <button class="clear-search-btn" onclick="document.getElementById('riderSearchInput').value=''; staffManager.searchUsers('rider', '');">
                                                <i class="fas fa-times"></i>
                                            </button>
                                        </div>
                                    </div>
                                    <button id="addRiderBtn" class="primary-btn">
                                        <i class="fas fa-plus"></i>
                                        Add New Rider
                                    </button>
                                </div>
                            </div>
                            <div class="user-list" id="riderList">
                                <!-- Riders will be populated here -->
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Sales and Reports Section -->
                <section id="reports-analytics" class="content-section">
                    <h2>Sales and Reports</h2>
                    
                    <!-- Sales Overview -->
                    <div class="sales-overview-section">
                        <h3>Organization Sales Tracking</h3>
                        <div class="time-period-selector">
                            <button class="time-btn active" data-period="weekly">Weekly</button>
                            <button class="time-btn" data-period="monthly">Monthly</button>
                            <button class="secondary-btn" onclick="staffManager.exportSalesReport()">
                                <i class="fas fa-download"></i>
                                Export Report
                            </button>
                        </div>
                        
                        <!-- Sales Chart -->
                        <div class="chart-container">
                            <canvas id="salesChart" width="800" height="400"></canvas>
                        </div>
                        
                        <!-- Sales Summary Stats -->
                        <div class="sales-summary">
                            <div class="summary-stat">
                                <h4 id="totalSales">0</h4>
                                <p>Total Sales</p>
                            </div>
                            <div class="summary-stat">
                                <h4 id="totalOrders">0</h4>
                                <p>Total Orders</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Sales Table -->
                    <div class="sales-table-section">
                        <h3>Sales Data Table</h3>
                        <div class="table-container">
                            <table id="salesTable" class="data-table">
                                <thead>
                                    <tr>
                                        <th>Period</th>
                                        <th>Total Sales</th>
                                        <th>Orders</th>
                                        <th>Product Kilos Yielded</th>
                                    </tr>
                                </thead>
                                <tbody id="salesTableBody">
                                    <!-- Sales data will be populated here -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- Additional Analytics -->
                    <div class="analytics-grid">
                        <div class="analytics-card">
                            <h4>Top Customers</h4>
                            <div id="topCustomersList" class="top-items-list">
                                <!-- Top customers will be populated here -->
                            </div>
                        </div>
                        <div class="analytics-card">
                            <h4>Top Products</h4>
                            <div id="topProductsList" class="top-items-list">
                                <!-- Top products will be populated here -->
                            </div>
                        </div>
                        <div class="analytics-card">
                            <h4>Farmer's Contributions</h4>
                            <div id="farmerPerformanceList" class="top-items-list">
                                <!-- Farmer contributions will be populated here -->
                            </div>
                        </div>
                    </div>
                </section>
                <!-- Delivery Fee and Pick Up Area Section -->
                <section id="delivery-settings" class="content-section">
                    <h2>Delivery Fee and Pick Up Area</h2>
                    <div class="settings-container">
                        <div class="settings-section">
                            <h3>Ormoc Barangay Delivery Fees</h3>
                            <p style="margin:6px 0 12px 0; color:#666;">Manage delivery fees for each barangay based on Geopy-calculated distances from Cabintan (reference point). Fees are used by the customer app at checkout.</p>
                            
                            <!-- Reference Point Information -->
                            <div id="referencePointInfo" style="margin-bottom:16px; padding:12px; background:#e8f5e8; border:1px solid #4caf50; border-radius:6px; display:none;">
                                <h4 style="margin:0 0 8px 0; color:#2e7d32;"><i class="fas fa-map-marker-alt"></i> Reference Point: Cabintan</h4>
                                <p style="margin:0; color:#388e3c; font-size:14px;">All distances are calculated from Cabintan, Ormoc City using Geopy geographic coordinates.</p>
                            </div>
                            
                            <!-- Search and Filter Controls -->
                            <div style="display:flex; gap:12px; margin-bottom:16px; align-items:center; flex-wrap:wrap;">
                                <div style="flex:1; min-width:200px;">
                                    <input type="text" id="barangaySearch" placeholder="Search barangays..." style="width:100%; padding:8px 12px; border:1px solid #ddd; border-radius:6px;" />
                                </div>
                                <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
                                    <div class="sort-dropdown" style="display:flex; gap:8px; align-items:center;">
                                        <label for="sortSelect" style="font-weight:600; color:#444;">Sort Data</label>
                                        <select id="sortSelect" style="padding:8px 12px; border:1px solid #ddd; border-radius:6px;" onchange="(function(s){window.sortBarangays && window.sortBarangays(s.value)})(this)">
                                            <option value="nearer">Nearer (distance asc)</option>
                                            <option value="farther">Farther (distance desc)</option>
                                            <option value="az">AZ (barangay name)</option>
                                        </select>
                                    </div>
                                </div>
                                <button class="secondary-btn" onclick="window.staffManager && staffManager.reloadDeliverySettings()">
                                    <i class="fas fa-sync"></i> Reload
                                </button>
                            </div>

                            <div style="overflow:auto; max-height:500px; border:1px solid #e0e0e0; border-radius:8px;">
                                <table class="data-table" style="min-width:800px;">
                                    <thead style="position:sticky; top:0; background:#f8f9fa; z-index:10;">
                                        <tr>
                                            <th style="width:6%"><input type="checkbox" id="selectAllBarangays" title="Select All" /></th>
                                            <th style="width:35%">Barangay</th>
                                            <th style="width:20%">Distance</th>
                                            <th style="width:20%">Current Fee</th>
                                            <th style="width:19%">New Fee</th>
                                        </tr>
                                    </thead>
                                    <tbody id="deliveryFeesTableBody">
                                        <!-- Rows populated by staff.js -->
                                    </tbody>
                                </table>
                                <style>
                                    /* Table styling for delivery fees */
                                    #delivery-settings table.data-table {
                                        border-collapse: collapse;
                                    }
                                    #delivery-settings table.data-table th,
                                    #delivery-settings table.data-table td {
                                        border: 1px solid #e0e0e0;
                                        padding: 8px;
                                    }
                                </style>
                            </div>
                            <script>
                                (function(){
                                    function parseKm(cell){
                                        if(!cell) return Number.POSITIVE_INFINITY;
                                        const t = (cell.textContent||'').trim().toLowerCase().replace('km','').trim();
                                        const v = parseFloat(t);
                                        return isNaN(v) ? Number.POSITIVE_INFINITY : v;
                                    }
                                    function sortRows(mode){
                                        const tbody = document.getElementById('deliveryFeesTableBody');
                                        if(!tbody) return;
                                        const rows = Array.from(tbody.querySelectorAll('tr'));
                                        if(rows.length === 0) return;
                                        const byName = (a,b)=>{
                                            const an = (a.cells[0]?.textContent||'').toLowerCase();
                                            const bn = (b.cells[0]?.textContent||'').toLowerCase();
                                            if(an < bn) return -1; if(an > bn) return 1; return 0;
                                        };
                                        const byDistAsc = (a,b)=> parseKm(a.cells[1]) - parseKm(b.cells[1]);
                                        const byDistDesc = (a,b)=> parseKm(b.cells[1]) - parseKm(a.cells[1]);
                                        let sorter = byName;
                                        if(mode === 'nearer') sorter = byDistAsc;
                                        else if(mode === 'farther') sorter = byDistDesc;
                                        else if(mode === 'az') sorter = byName;
                                        rows.sort(sorter);
                                        const frag = document.createDocumentFragment();
                                        rows.forEach(r=>frag.appendChild(r));
                                        tbody.appendChild(frag);
                                    }
                                    window.sortBarangays = sortRows;
                                })();
                                // Show Current Fee (read-only from DB) and New Fee (editable input)
                                (function(){
                                  function toNumber(v){
                                    const n = parseFloat(String(v || '').replace(/[^0-9.\-]/g, ''));
                                    return isNaN(n) ? 0 : n;
                                  }
                                  function sanitizeKey(name){
                                    let s = String(name == null ? '' : name);
                                    s = s.replace('Z.', 'Z');
                                    s = s.replace(/[.#$/\[\]]/g, '_');
                                    s = s.trim();
                                    return s === '' ? '_' : s;
                                  }
                                  function enhance(){
                                    const table = document.querySelector('#delivery-settings table.data-table');
                                    if (!table) return;
                                    const thead = table.querySelector('thead');
                                    const tbody = table.querySelector('tbody#deliveryFeesTableBody');
                                    if (!thead || !tbody) return;
                                    // Find Current Fee and New Fee column indices
                                    const ths = Array.from(thead.querySelectorAll('th'));
                                    let currentIdx = ths.findIndex(th => (th.textContent||'').toLowerCase().includes('current fee'));
                                    let newIdx = ths.findIndex(th => (th.textContent||'').toLowerCase().includes('new fee'));
                                    let nameIdx = ths.findIndex(th => (th.textContent||'').toLowerCase().includes('barangay'));
                                    if (currentIdx === -1 || newIdx === -1) return;
                                    // Convert to zero-based cell index
                                    // For nth-child, index starts at 1; for cells array, starts at 0
                                    Array.from(tbody.querySelectorAll('tr')).forEach(tr => {
                                      const cells = tr.cells || [];
                                      const currentCell = cells[currentIdx];
                                      const newCell = cells[newIdx];
                                      // Capture and persist barangay name for reliable mapping after refresh
                                      try {
                                        const nameCell = (nameIdx >= 0 && cells[nameIdx]) ? cells[nameIdx] : null;
                                        const brgyName = nameCell ? (nameCell.textContent||'').trim() : '';
                                        if (brgyName) tr.dataset.brgyName = brgyName;
                                      } catch(_) {}
                                      if (!currentCell || !newCell) return;
                                      // Current fee is read-only text; New Fee is editable input
                                      // Ensure current fee has a span container
                                      let currentFeeSpan = currentCell.querySelector('span.current-fee-text');
                                      if (!currentFeeSpan) {
                                        currentFeeSpan = document.createElement('span');
                                        currentFeeSpan.className = 'current-fee-text';
                                        // Simple fee display - no caching
                                        currentFeeSpan.textContent = '-';
                                        currentCell.innerHTML = '';
                                        currentCell.appendChild(currentFeeSpan);
                                      } else {
                                        // Ensure existing fee display has peso sign
                                        const currentText = currentFeeSpan.textContent || '';
                                        // If it's a number without peso sign, format it
                                        if (currentText && currentText !== '-' && !currentText.includes('')) {
                                          const feeNum = parseFloat(String(currentText).replace(/[^0-9.\-]/g, '')) || 0;
                                          currentFeeSpan.textContent = feeNum > 0 ? `${feeNum}` : '0';
                                        }
                                      }
                                      // Ensure new fee input exists
                                      const existingInput = newCell.querySelector('input');
                                      if (!existingInput) {
                                        const input = document.createElement('input');
                                        input.type = 'number';
                                        input.min = '0';
                                        input.step = '1';
                                        input.value = '';
                                        input.placeholder = 'Enter fee';
                                        input.className = 'new-fee-input';
                                        input.style.width = '100%';
                                        input.style.boxSizing = 'border-box';
                                        newCell.innerHTML = '';
                                        newCell.appendChild(input);
                                      }
                                    });
                                    // Select All handling
                                    const selectAll = document.getElementById('selectAllBarangays');
                                    if (selectAll) {
                                      selectAll.onchange = function(){
                                        const boxes = tbody.querySelectorAll('input.barangay-checkbox');
                                        boxes.forEach(b => { b.checked = !!selectAll.checked; });
                                      };
                                    }
                                    // Bulk apply handling
                                    const bulkBtn = document.getElementById('applyBulkFeeBtn');
                                    const bulkInput = document.getElementById('bulkFeeInput');
                                    if (bulkBtn && bulkInput) {
                                      bulkBtn.onclick = function(){
                                        const val = parseFloat(String(bulkInput.value||'').replace(/[^0-9.\-]/g, ''));
                                        if (isNaN(val) || val < 0) {
                                          alert('Please enter a valid fee amount (0 or greater)');
                                          return;
                                        }
                                        
                                        const rows = Array.from(tbody.querySelectorAll('tr[data-barangay]'));
                                        let appliedCount = 0;
                                        
                                        // Collect all selected rows first
                                        const selectedRows = [];
                                        rows.forEach(tr => {
                                          const cb = tr.querySelector('input.barangay-checkbox');
                                          if (cb && cb.checked) {
                                            const input = tr.querySelector('input.brgy-fee-input');
                                            if (input) {
                                              input.value = String(val);
                                              selectedRows.push(tr);
                                              appliedCount++;
                                            }
                                          }
                                        });
                                        
                                        // Update visual styling for applied fees (but don't save yet)
                                        if (selectedRows.length > 0 && window.staffManager) {
                                          selectedRows.forEach(tr => {
                                            const input = tr.querySelector('input.brgy-fee-input');
                                            if (input && window.staffManager._onFeeChange) {
                                              window.staffManager._onFeeChange(input);
                                            }
                                          });
                                        }
                                        
                                        // Show message that fees are applied but not saved yet
                                        if (appliedCount > 0) {
                                          alert(`Applied fee of ${val} to ${appliedCount} selected barangay(s). Click "Save All Fees" to save the changes.`);
                                        } else {
                                          alert('Please select at least one barangay first');
                                        }
                                      };
                                    }
                                  }
                                  // Enhance after initial render and on reload
                                  setTimeout(enhance, 500);
                                  const originalReload = (window.staffManager && window.staffManager.reloadDeliverySettings) ? window.staffManager.reloadDeliverySettings.bind(window.staffManager) : null;
                                  if (originalReload && window.staffManager) {
                                    window.staffManager.reloadDeliverySettings = function(){
                                      const r = originalReload();
                                      setTimeout(enhance, 400);
                                      return r;
                                    };
                                  }
                                  // Observe tbody for changes
                                  const tbody = document.getElementById('deliveryFeesTableBody');
                                  if (tbody && window.MutationObserver) {
                                    const mo = new MutationObserver(() => setTimeout(() => {
                                      try { enhance(); } catch(_){}
                                      // Caching removed
                                    }, 50));
                                    mo.observe(tbody, { childList: true, subtree: true });
                                  }
                                })();
                                // Simple fee display system - no complex caching
                                console.log('Simple fee display system initialized');
                            </script>
                            
                            <div style="margin-top:12px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
                                <div style="display:flex; gap:8px; align-items:center;">
                                    <input type="number" id="bulkFeeInput" placeholder="New fee for selected" min="0" step="1" style="padding:8px 10px; width:180px; border:1px solid #ddd; border-radius:6px;" />
                                    <button class="secondary-btn" id="applyBulkFeeBtn"><i class="fas fa-check-double"></i> Apply to Selected</button>
                                </div>
                                <div style="flex:1"></div>
                                <button class="confirm-btn" onclick="window.staffManager && staffManager.saveDeliveryFees()">
                                    <i class="fas fa-save"></i> Save All Fees
                                </button>
                            </div>
                            
                            <!-- Bulk Actions -->
                            <div style="margin-top:16px; padding:12px; background:#f8f9fa; border-radius:6px; display:none;" id="bulkActionsContainer">
                                <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
                                    <span style="font-weight:600; color:#444;">Bulk Actions:</span>
                                    <button class="secondary-btn" onclick="window.staffManager && staffManager.bulkUpdateFees()">
                                        <i class="fas fa-edit"></i> Update Selected Fees
                                    </button>
                                    <button class="secondary-btn" onclick="window.staffManager && staffManager.bulkResetFees()">
                                        <i class="fas fa-undo"></i> Reset Selected
                                    </button>
                                    <span id="selectedCount" style="color:#666; font-size:14px;">0 selected</span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Pickup Area Management Section -->
                        <div class="settings-section" style="margin-top: 30px;">
                            <h3>Pickup Area Management</h3>
                            <p style="margin:6px 0 12px 0; color:#666;">Manage pickup locations where customers can collect their orders. These locations are displayed in the customer app.</p>
                            
                            <!-- Add/Edit form -->
                            <div id="pickupAreaForm" style="border:1px solid #e0e0e0; border-radius:8px; padding:16px; background:#f8f9fa; display:none; margin-bottom: 20px;">
                                <h4 style="margin:0 0 12px 0;">Add Pickup Area</h4>
                                <div style="display:grid; grid-template-columns:1fr 1fr; gap:16px;">
                                    <div style="margin-bottom: 8px;">
                                        <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Area Name</label>
                                        <input type="text" id="pa_name" placeholder="e.g., AgriCart Office, Cabintan" style="width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px;" />
                                    </div>
                                    <div style="margin-bottom: 8px;">
                                        <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Map Link (Optional)</label>
                                        <input type="text" id="pa_mapLink" placeholder="https://maps.google.com/..." style="width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px;" />
                                    </div>
                                    <div style="margin-bottom: 8px;">
                                        <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Landmark</label>
                                        <input type="text" id="pa_landmark" placeholder="Notable nearby landmark" style="width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px;" />
                                    </div>
                                    <div style="margin-bottom: 8px;">
                                        <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Street (Optional)</label>
                                        <input type="text" id="pa_street" placeholder="Street name" style="width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px;" />
                                    </div>
                                    <div style="margin-bottom: 8px;">
                                        <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Sitio (Optional)</label>
                                        <input type="text" id="pa_sitio" placeholder="Sitio name" style="width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px;" />
                                    </div>
                                    <div style="margin-bottom: 8px;">
                                        <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Barangay</label>
                                        <input type="text" id="pa_barangay" placeholder="Barangay name" required style="width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px;" />
                                    </div>
                                    <div style="margin-bottom: 8px;">
                                        <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">City</label>
                                        <input type="text" id="pa_city" value="Ormoc" readonly style="width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; background-color:#f5f5f5;" />
                                    </div>
                                    <div style="margin-bottom: 8px;">
                                        <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Province</label>
                                        <input type="text" id="pa_province" value="Leyte" readonly style="width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; background-color:#f5f5f5;" />
                                    </div>
                                    <div style="grid-column:1 / span 2; margin-bottom: 8px;">
                                        <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Pick Up Instructions</label>
                                        <textarea id="pa_instructions" rows="4" placeholder="Specific instructions for customers..." style="width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px;"></textarea>
                                    </div>
                                    <input type="hidden" id="pa_currentId" value="" />
                                </div>
                                <div style="margin-top:12px; display:flex; gap:8px;">
                                    <button class="danger-btn" onclick="if(window.staffManager){staffManager.cancelPickupAreaForm();}else{alert('Staff manager not initialized. Please refresh the page.');}" style="padding: 10px 20px;">
                                        <i class="fas fa-times"></i> Cancel
                                    </button>
                                    <div style="flex:1"></div>
                                    <button class="confirm-btn" onclick="if(window.staffManager){staffManager.savePickupAreaRecord();}else{alert('Staff manager not initialized. Please refresh the page.');}" style="padding: 10px 20px;">
                                        <i class="fas fa-save"></i> Save
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Pickup Area Controls -->
                            <div style="display: flex; gap: 8px; margin-bottom: 20px; flex-wrap: wrap; align-items: center;">
                                <button class="primary-btn" onclick="if(window.staffManager){staffManager.openPickupAreaForm();}else{alert('Staff manager not initialized. Please refresh the page.');}" style="padding: 8px 16px; font-size: 14px;">
                                    <i class="fas fa-plus"></i> Add Pickup Area
                                </button>
                                <button class="secondary-btn" onclick="if(window.staffManager){staffManager.loadPickupAreaRecords();staffManager.loadPickupArea();}else{alert('Staff manager not initialized. Please refresh the page.');}" style="padding: 8px 16px; font-size: 14px;">
                                    <i class="fas fa-sync"></i> Refresh
                                </button>
                            </div>
                            
                            <!-- Pickup Areas List -->
                            <div id="pickupAreaList" style="min-height: 200px; display:grid; gap:12px; margin-bottom:16px;">
                                <!-- Records will render here -->
                            </div>
                        </div>
                    </div>
                </section>
                <!-- Staff Profile Section -->
                <section id="staff-profile" class="content-section">
                    <h2>Profile</h2>
                    <div class="profile-container">
                        <div class="profile-header">
                            <div class="profile-avatar-container" style="position: relative; display: inline-block;">
                                <div class="profile-avatar" id="profileAvatarDisplay" style="position: relative;">
                                    <img id="profileAvatarImg" src="" alt="Profile Picture" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%; display: none;">
                                    <i class="fas fa-user" id="profileAvatarIcon"></i>
                                </div>
                                <button type="button" id="changeProfilePictureBtn" class="change-picture-btn" onclick="staffManager.showChangeProfilePictureModal()" title="Change Profile Picture" style="display: none;">
                                    <i class="fas fa-camera"></i>
                                </button>
                            </div>
                            <div class="profile-info">
                                <h3 id="profileStaffName">Staff Member</h3>
                                <p class="profile-role" id="profileRoleDisplay">Staff Member</p>
                                <p class="profile-email" id="profileStaffEmail">staff@example.com</p>
                            </div>
                        </div>
                        
                        <div class="profile-details">
                            <div class="profile-section">
                                <div class="profile-section-header">
                                    <div class="profile-section-icon">
                                        <i class="fas fa-user"></i>
                                    </div>
                                    <h4>Personal Information</h4>
                                    <button type="button" id="editProfileBtn" class="edit-profile-btn" onclick="staffManager.toggleEditProfileMode()" style="display: none;">
                                        <i class="fas fa-edit"></i> Edit
                                    </button>
                                    <button type="button" id="saveProfileBtn" class="save-profile-btn" onclick="staffManager.saveProfileChanges()" style="display: none;">
                                        <i class="fas fa-save"></i> Save
                                    </button>
                                    <button type="button" id="cancelEditBtn" class="cancel-edit-btn" onclick="staffManager.cancelEditProfile()" style="display: none;">
                                        <i class="fas fa-times"></i> Cancel
                                    </button>
                                </div>
                                <div class="profile-content" id="profileContentContainer">
                                    <!-- Full Name Field (for Admin) -->
                                    <div class="profile-field" id="profileFullNameField" style="display: none;">
                                        <div class="profile-field-icon">
                                            <i class="fas fa-id-card"></i>
                                        </div>
                                        <div class="profile-field-info">
                                            <label>Full Name:</label>
                                            <span id="profileFullName">Staff Member</span>
                                            <input type="text" id="profileFullNameEdit" class="profile-edit-input" value="" style="display: none;">
                                        </div>
                                    </div>
                                    <!-- Name Fields (Individual - for Staff only) -->
                                    <div id="profileIndividualNameFields" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; margin-bottom: 16px;">
                                        <div class="profile-field">
                                            <div class="profile-field-icon">
                                                <i class="fas fa-user"></i>
                                            </div>
                                            <div class="profile-field-info">
                                                <label>First Name:</label>
                                                <span id="profileFirstName">-</span>
                                                <input type="text" id="profileFirstNameEdit" class="profile-edit-input" value="" style="display: none;">
                                            </div>
                                        </div>
                                        <div class="profile-field">
                                            <div class="profile-field-icon">
                                                <i class="fas fa-user"></i>
                                            </div>
                                            <div class="profile-field-info">
                                                <label>Middle Name:</label>
                                                <span id="profileMiddleName">-</span>
                                                <input type="text" id="profileMiddleNameEdit" class="profile-edit-input" value="" style="display: none;">
                                            </div>
                                        </div>
                                        <div class="profile-field">
                                            <div class="profile-field-icon">
                                                <i class="fas fa-user"></i>
                                            </div>
                                            <div class="profile-field-info">
                                                <label>Last Name:</label>
                                                <span id="profileLastName">-</span>
                                                <input type="text" id="profileLastNameEdit" class="profile-edit-input" value="" style="display: none;">
                                            </div>
                                        </div>
                                        <div class="profile-field">
                                            <div class="profile-field-icon">
                                                <i class="fas fa-user"></i>
                                            </div>
                                            <div class="profile-field-info">
                                                <label>Suffix:</label>
                                                <span id="profileSuffix">-</span>
                                                <input type="text" id="profileSuffixEdit" class="profile-edit-input" placeholder="Jr., Sr., III, etc." value="" style="display: none;">
                                            </div>
                                        </div>
                                    </div>
                                    <div class="profile-field" id="profileRoleField">
                                        <div class="profile-field-icon">
                                            <i class="fas fa-user-tag"></i>
                                        </div>
                                        <div class="profile-field-info">
                                            <label>Role:</label>
                                            <span id="profileRole">Staff Member</span>
                                            <input type="text" id="profileRoleEdit" class="profile-edit-input" value="" style="display: none;" readonly>
                                        </div>
                                    </div>
                                    <div class="profile-field" id="profileEmployeeIdField" style="display: none;">
                                        <div class="profile-field-icon">
                                            <i class="fas fa-id-badge"></i>
                                        </div>
                                        <div class="profile-field-info">
                                            <label>Employee ID:</label>
                                            <span id="profileEmployeeId">-</span>
                                        </div>
                                    </div>
                                    <div class="profile-field">
                                        <div class="profile-field-icon">
                                            <i class="fas fa-envelope"></i>
                                        </div>
                                        <div class="profile-field-info">
                                            <label>Email:</label>
                                            <span id="profileEmail">staff@example.com</span>
                                            <input type="email" id="profileEmailEdit" class="profile-edit-input" value="" style="display: none;">
                                        </div>
                                    </div>
                                    <div class="profile-field">
                                        <div class="profile-field-icon">
                                            <i class="fas fa-phone"></i>
                                        </div>
                                        <div class="profile-field-info">
                                            <label>Phone Number:</label>
                                            <span id="profilePhone">N/A</span>
                                            <input type="tel" id="profilePhoneEdit" class="profile-edit-input" value="" style="display: none;">
                                        </div>
                                    </div>
                                    <!-- Address Fields (Individual - for Staff only) -->
                                    <div id="profileAddressFields" style="margin-top: 24px; padding-top: 24px; border-top: 1px solid #e2e8f0; display: none;">
                                        <h4 style="margin: 0 0 16px 0; font-size: 16px; font-weight: 600; color: #333;">
                                            <i class="fas fa-map-marker-alt"></i> Home Address
                                        </h4>
                                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px;">
                                            <div class="profile-field">
                                                <div class="profile-field-icon">
                                                    <i class="fas fa-road"></i>
                                                </div>
                                                <div class="profile-field-info">
                                                    <label>Street:</label>
                                                    <span id="profileStreet">-</span>
                                                    <input type="text" id="profileStreetEdit" class="profile-edit-input" value="" style="display: none;">
                                                </div>
                                            </div>
                                            <div class="profile-field">
                                                <div class="profile-field-icon">
                                                    <i class="fas fa-map-pin"></i>
                                                </div>
                                                <div class="profile-field-info">
                                                    <label>Sitio:</label>
                                                    <span id="profileSitio">-</span>
                                                    <input type="text" id="profileSitioEdit" class="profile-edit-input" value="" style="display: none;">
                                                </div>
                                            </div>
                                            <div class="profile-field">
                                                <div class="profile-field-icon">
                                                    <i class="fas fa-map-marker-alt"></i>
                                                </div>
                                                <div class="profile-field-info">
                                                    <label>Barangay:</label>
                                                    <span id="profileBarangay">-</span>
                                                    <div id="profileBarangayEditContainer" style="display: none;"></div>
                                                </div>
                                            </div>
                                            <div class="profile-field">
                                                <div class="profile-field-icon">
                                                    <i class="fas fa-mail-bulk"></i>
                                                </div>
                                                <div class="profile-field-info">
                                                    <label>Postal Code:</label>
                                                    <span id="profilePostalCode">-</span>
                                                    <input type="text" id="profilePostalCodeEdit" class="profile-edit-input" value="6541" style="display: none;" readonly>
                                                </div>
                                            </div>
                                            <div class="profile-field">
                                                <div class="profile-field-icon">
                                                    <i class="fas fa-city"></i>
                                                </div>
                                                <div class="profile-field-info">
                                                    <label>City:</label>
                                                    <span id="profileCity">-</span>
                                                    <input type="text" id="profileCityEdit" class="profile-edit-input" value="Ormoc" style="display: none;" readonly>
                                                </div>
                                            </div>
                                            <div class="profile-field">
                                                <div class="profile-field-icon">
                                                    <i class="fas fa-map"></i>
                                                </div>
                                                <div class="profile-field-info">
                                                    <label>Province:</label>
                                                    <span id="profileProvince">-</span>
                                                    <input type="text" id="profileProvinceEdit" class="profile-edit-input" value="Leyte" style="display: none;" readonly>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <!-- Account Update Information (for Staff only) -->
                                    <div id="profileUpdateInfoFields" style="margin-top: 24px; padding-top: 24px; border-top: 1px solid #e2e8f0; display: none;">
                                        <h4 style="margin: 0 0 16px 0; font-size: 16px; font-weight: 600; color: #333;">
                                            <i class="fas fa-history"></i> Account Update Information
                                        </h4>
                                        <div style="display: flex; flex-direction: column; gap: 12px;">
                                            <div class="profile-field">
                                                <div class="profile-field-icon">
                                                    <i class="fas fa-clock"></i>
                                                </div>
                                                <div class="profile-field-info">
                                                    <label>Last Updated At:</label>
                                                    <span id="profileLastUpdatedAt">-</span>
                                                </div>
                                            </div>
                                            <div class="profile-field">
                                                <div class="profile-field-icon">
                                                    <i class="fas fa-user-edit"></i>
                                                </div>
                                                <div class="profile-field-info">
                                                    <label>Last Updated By:</label>
                                                    <span id="profileLastUpdatedBy">-</span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <!-- Valid ID fields removed from staff profile -->
                                </div>
                            </div>
                            
                        </div>
                    </div>
                </section>
                <!-- Staff Settings Section -->
                <section id="staff-settings" class="content-section">
                    <h2>Settings</h2>
                    <div class="settings-container">
                        <div class="settings-section">
                            <h3 data-translate="systemSettings">System Settings</h3>
                            <div class="settings-grid">
                                <div class="setting-item compact">
                                    <div class="setting-info">
                                        <h4 data-translate="darkMode">Dark Mode</h4>
                                        <p data-translate="darkModeDesc">Toggle dark mode on/off</p>
                                    </div>
                                    <div class="toggle-switch">
                                        <input type="checkbox" id="darkModeToggle" class="toggle-input" onchange="toggleDarkMode(this.checked)">
                                        <label for="darkModeToggle" class="toggle-label">
                                            <span class="toggle-slider"></span>
                                        </label>
                                    </div>
                                </div>
                                <div class="setting-item compact">
                                    <div class="setting-info">
                                        <h4 data-translate="language">Language</h4>
                                        <p data-translate="languageDesc">Select your preferred language</p>
                                    </div>
                                    <select id="languageSelect" class="setting-select compact" onchange="changeLanguage(this.value)">
                                        <option value="en">English</option>
                                        <option value="tl">Tagalog</option>
                                        <option value="ceb">Cebuano</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        <div class="settings-section">
                            <h3>Contact Support Settings</h3>
                            <p style="margin:6px 0 12px 0; color:#666;">Manage cooperative contact information displayed on customer app login screen</p>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                                <div class="form-field">
                                    <label for="supportEmail" style="font-weight: 600; margin-bottom: 8px; display: block; color: #333;">
                                        <i class="fas fa-envelope" style="color: #61a029; margin-right: 6px;"></i>
                                        Cooperative Gmail
                                    </label>
                                    <input type="email" id="supportEmail" placeholder="example@gmail.com" 
                                           style="width: 100%; padding: 12px; border: 1px solid #e0e0e0; border-radius: 8px; font-size: 14px;">
                                    <small style="color: #666; display: block; margin-top: 4px;">Email for customer inquiries</small>
                                </div>
                                <div class="form-field">
                                    <label for="supportPhone" style="font-weight: 600; margin-bottom: 8px; display: block; color: #333;">
                                        <i class="fas fa-phone" style="color: #61a029; margin-right: 6px;"></i>
                                        Phone Number (Philippine Format)
                                    </label>
                                    <input type="tel" id="supportPhone" placeholder="0917 123 4567 or +63 917 123 4567"
                                           style="width: 100%; padding: 12px; border: 1px solid #e0e0e0; border-radius: 8px; font-size: 14px;"
                                           oninput="formatPhoneNumber(this)">
                                    <small id="phoneHelp" style="color: #666; display: block; margin-top: 4px;">
                                        Enter 11-digit Philippine mobile number (e.g., 0917 123 4567)
                                    </small>
                                </div>
                            </div>
                            <div style="display: flex; gap: 12px; justify-content: flex-end;">
                                <button onclick="loadContactSupportSettings()" class="secondary-btn" style="padding: 10px 20px; border-radius: 8px; font-weight: 600;">
                                    <i class="fas fa-sync-alt"></i> Reload
                                </button>
                                <button onclick="saveContactSupportSettings()" class="primary-btn" style="padding: 10px 20px; border-radius: 8px; font-weight: 600; background: linear-gradient(135deg, #61a029, #4f8a22); color: white; border: none; cursor: pointer;">
                                    <i class="fas fa-save"></i> Save Changes
                                </button>
                            </div>
                        </div>
                        <div class="settings-section">
                            <h3>Featured Dashboard Media</h3>
                            <div class="setting-item compact">
                                <div class="setting-info">
                                    <h4>Upload Media</h4>
                                    <p>Upload featured images (max 8) and videos (max 2, 30s max) for customer dashboard carousel</p>
                                    <div style="margin-top: 10px; padding: 10px; background: #f0f7ff; border-left: 3px solid #61a029; border-radius: 4px; font-size: 0.85em; color: #555;">
                                        <strong>Allowed formats:</strong><br>
                                        <strong>Images:</strong> JPG, JPEG, PNG, GIF, WEBP, BMP, SVG<br>
                                        <strong>Videos:</strong> MP4, MOV, AVI, WEBM, MKV, FLV, WMV (max 30 seconds)
                                    </div>
                                </div>
                                <div>
                                    <input type="file" id="featuredMediaInput" multiple accept="image/*,video/*" style="display: none;" onchange="handleFeaturedMediaSelection(event)">
                                    <button onclick="document.getElementById('featuredMediaInput').click()" class="featured-media-btn featured-media-btn-primary">
                                        <i class="fas fa-upload"></i> Select Files
                                    </button>
                                </div>
                            </div>
                            <div id="featuredMediaRemainingCount" style="display: none; margin-top: 15px; padding: 12px; background: #e8f5e9; border-radius: 8px; border-left: 3px solid #61a029;">
                                <div style="font-size: 0.9em; color: #2e7d32; font-weight: 500;">
                                    <i class="fas fa-info-circle"></i> <span id="remainingCountText"></span>
                                </div>
                            </div>
                            <div id="featuredMediaPreviewArea" style="display: none; margin-top: 20px; padding-top: 20px; border-top: 1px solid #f0f0f0;">
                                <h4 style="margin-bottom: 15px; color: #333; font-size: 1em;">Preview Selected Files</h4>
                                <div id="featuredMediaPreviewList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px; margin-bottom: 20px;"></div>
                                <div style="display: flex; gap: 12px; justify-content: flex-end;">
                                    <button onclick="cancelFeaturedMediaPreview()" class="featured-media-btn featured-media-btn-secondary">
                                        <i class="fas fa-times"></i> Cancel
                                    </button>
                                    <button onclick="confirmFeaturedMediaUpload()" class="featured-media-btn featured-media-btn-primary">
                                        <i class="fas fa-check"></i> Upload All
                                    </button>
                                </div>
                            </div>
                            <div id="featuredMediaUploadProgress" style="display: none; margin-top: 20px; padding-top: 20px; border-top: 1px solid #f0f0f0;">
                                <div class="progress-bar" style="width: 100%; height: 8px; background: #e0e0e0; border-radius: 4px; overflow: hidden;">
                                    <div id="featuredMediaProgressFill" style="height: 100%; background: #61a029; width: 0%; transition: width 0.3s;"></div>
                                </div>
                                <p id="featuredMediaProgressText" style="margin-top: 5px; font-size: 0.85em; color: #666;"></p>
                            </div>
                            <div id="featuredMediaListContainer" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #f0f0f0;">
                                <h4 style="margin-bottom: 15px; color: #333; font-size: 1em;">Current Featured Media</h4>
                                <div id="featuredMediaList" class="featured-media-list" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px;"></div>
                            </div>
                        </div>
                        <div class="settings-section">
                            <h3>Data & Privacy</h3>
                            <div class="settings-grid">
                                <div class="setting-item compact">
                                    <div class="setting-info">
                                        <h4>Export Data</h4>
                                        <p>Download your account data</p>
                                    </div>
                                    <button class="compact-btn" onclick="exportUserData()">
                                        <i class="fas fa-download"></i>
                                    </button>
                                </div>
                                <div class="setting-item compact">
                                    <div class="setting-info">
                                        <h4>Clear Cache</h4>
                                        <p>Clear application cache and temporary files</p>
                                    </div>
                                    <button class="compact-btn" onclick="clearApplicationCache()">
                                        <i class="fas fa-trash"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
            </main>
        </div>
    </div>

    <!-- Modals -->
    <div id="modalOverlay" class="modal-overlay">
        <div id="modalContent" class="modal-content">
            <!-- Modal content will be dynamically populated -->
        </div>
    </div>

    <!-- Media Lightbox -->
    <div id="mediaLightbox" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10000; align-items: center; justify-content: center; flex-direction: column;">
        <button onclick="closeLightbox()" onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'" style="position: absolute; top: 20px; right: 20px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 50%; width: 40px; height: 40px; font-size: 24px; cursor: pointer; z-index: 10001; display: flex; align-items: center; justify-content: center; transition: background 0.2s;"></button>
        <div id="lightboxTitle" style="color: white; margin-bottom: 20px; font-size: 18px; max-width: 90vw; text-align: center; padding: 0 60px;"></div>
        <div id="lightboxContent" style="display: flex; align-items: center; justify-content: center;"></div>
    </div>

    <!-- Firebase Scripts -->
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-storage-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-functions-compat.js"></script>
    
    <!-- Chart.js for analytics -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<!-- jsPDF and AutoTable for PDF export -->
	<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js"></script>
    
    <!-- Supabase SDK (load before firebase-config to initialize client) -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <!-- Custom Scripts -->
    <script>
        // Initialize Supabase client after SDK loads
        // Use window variables to avoid duplicate declaration errors
        if (typeof supabase !== 'undefined') {
            if (!window.SUPABASE_URL) {
                window.SUPABASE_URL = 'https://afkwexvvuxwbpioqnelp.supabase.co';
            }
            if (!window.SUPABASE_ANON_KEY) {
                window.SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFma3dleHZ2dXh3YnBpb3FuZWxwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI5MzA3MjcsImV4cCI6MjA3ODUwNjcyN30.7r5j1xfWdJwiRZZm8AcOIaBp9VaXoD2QWE3WrGYZNyM';
            }
            if (!window.supabaseClient) {
                window.supabaseClient = supabase.createClient(window.SUPABASE_URL, window.SUPABASE_ANON_KEY);
                console.log(' Supabase client initialized globally');
            }
        }
    </script>
    <script src="firebase-config.js"></script>
    <script src="supabase-config.js"></script>
    <script src="customer-rejection-handler.js"></script>
    <script src="ormoc-barangays-complete.js"></script>
    <script src="ormoc-distances-manual.js"></script>
    <script src="coop-time-heartbeat.js"></script>
    <script src="admin.js"></script>
    <!-- EmailJS (for customer approval / rejection emails) -->
    <script src="https://cdn.jsdelivr.net/npm/@emailjs/browser@4/dist/email.min.js"></script>
    <script>
        /**
         * EmailJS Configuration
         * Public Key configured for customer approval/rejection emails
         */
        (function () {
            try {
                emailjs.init('8i_c5CCT1CzagEHBA');
                console.log(' EmailJS initialized for staff dashboard');
            } catch (e) {
                console.error(' Failed to initialize EmailJS:', e);
            }
        })();
    </script>

    <!-- Load staff.js with error handling (but we'll define StaffManager inline anyway) -->
    <script src="staff.js?v=20250127-1400" onerror="console.error('Failed to load staff.js');"></script>
    <script>
        // Always define StaffManager inline to ensure it's available immediately
        // If staff.js loads and defines it, this will be overwritten
        (function() {
            // Only define if not already defined
            if (typeof StaffManager === 'undefined') {
                console.log(' Creating StaffManager class inline');
                window.StaffManager = class StaffManager {
                    constructor() {
                        this.buildVersion = '2025-01-27-inline-fallback';
                        this._ordersCache = {};
                        console.log(' StaffManager instance created');
                    }

                    async initialize() {
                        console.log(' StaffManager initialize() called');
                        const loadingScreen = document.getElementById('loadingScreen');
                        if (loadingScreen) {
                            loadingScreen.classList.add('hidden');
                            document.body.classList.remove('loading');
                        }
                        return Promise.resolve();
                    }

                    showLoadingScreen(message) {
                        const loadingScreen = document.getElementById('loadingScreen');
                        if (loadingScreen) {
                            loadingScreen.classList.remove('hidden');
                            document.body.classList.add('loading');
                            const loadingText = loadingScreen.querySelector('.loading-text');
                            if (loadingText && message) {
                                loadingText.textContent = message;
                            }
                        }
                    }

                    switchSection(section) { console.log('switchSection called:', section); }
                    switchCustomerManagementTab(tab) { console.log('switchCustomerManagementTab called:', tab); }
                    switchAssignTab(tab) { console.log('switchAssignTab called:', tab); }
                    switchConfirmedSubTab(tab) { console.log('switchConfirmedSubTab called:', tab); }
                    switchToReceiveSubTab(tab) { console.log('switchToReceiveSubTab called:', tab); }
                    switchSuccessfulSubTab(tab) { console.log('switchSuccessfulSubTab called:', tab); }
                    switchFailedSubTab(tab) { console.log('switchFailedSubTab called:', tab); }
                    searchUsers(type, query) { console.log('searchUsers called:', type, query); }
                    searchVerifications(type, query) { console.log('searchVerifications called:', type, query); }
                    forceRefreshProducts() { console.log('forceRefreshProducts called'); }
                    showAddProductModal() { console.log('showAddProductModal called'); }
                    exportSalesReport() { console.log('exportSalesReport called'); }
                    reloadDeliverySettings() { console.log('reloadDeliverySettings called'); }
                    renderBarangaySelect(id, value, required) { return `<input type="text" id="${id}" ${required ? 'required' : ''}>`; }
                    loadPendingOrders() { console.log('loadPendingOrders called'); return Promise.resolve(); }
                    
                    // Critical methods for order card rendering
                    createOrderCard(id, order) {
                        console.log('createOrderCard called (stub):', id, order);
                        // Return a basic card structure - this will be patched by the chat button code
                        const card = document.createElement('div');
                        card.className = 'order-card';
                        card.id = `order-card-${id}`;
                        card.innerHTML = `<div id="order-details-${id}"><div class="order-actions"></div></div>`;
                        return card;
                    }
                    
                    createAssignedOrderCard(id, order) {
                        console.log('createAssignedOrderCard called (stub):', id, order);
                        // Return a basic card structure - this will be patched by the chat button code
                        const card = document.createElement('div');
                        card.className = 'order-card';
                        card.id = `order-card-${id}`;
                        card.innerHTML = `<div id="order-details-${id}"><div class="order-actions"></div></div>`;
                        return card;
                    }
                };
            }
            
            // Create window.staffManager immediately - no retry needed
            if (!window.staffManager && typeof StaffManager !== 'undefined') {
                window.staffManager = new StaffManager();
                console.log(' window.staffManager created immediately');
            } else if (window.staffManager) {
                console.log(' window.staffManager already exists');
            } else {
                console.error(' Failed to create StaffManager - StaffManager class is undefined');
                // Last resort: create a minimal stub to prevent errors
                window.staffManager = {
                    initialize: () => Promise.resolve(),
                    createOrderCard: (id, order) => {
                        const card = document.createElement('div');
                        card.className = 'order-card';
                        card.id = `order-card-${id}`;
                        card.innerHTML = `<div id="order-details-${id}"><div class="order-actions"></div></div>`;
                        return card;
                    },
                    createAssignedOrderCard: (id, order) => {
                        const card = document.createElement('div');
                        card.className = 'order-card';
                        card.id = `order-card-${id}`;
                        card.innerHTML = `<div id="order-details-${id}"><div class="order-actions"></div></div>`;
                        return card;
                    }
                };
                console.warn(' Created minimal staffManager stub to prevent errors');
            }
        })();
        
        // Global error handler to catch undefined URL errors
        window.addEventListener('error', function(e) {
            if (e.message && e.message.includes('Unexpected identifier') && e.message.includes('http')) {
                console.error(' Caught undefined URL error:', e.message, e.filename, e.lineno);
                // Prevent the error from propagating
                e.preventDefault();
                return true;
            }
            // Check for 404 errors with undefined in the URL
            if (e.target && e.target.tagName && (e.target.tagName === 'SCRIPT' || e.target.tagName === 'IMG' || e.target.tagName === 'LINK')) {
                const src = e.target.src || e.target.href;
                if (src && src.includes('undefined')) {
                    console.error(' Resource with undefined URL detected:', e.target.tagName, src);
                    e.preventDefault();
                    return true;
                }
            }
        }, true);
        
        // Check if user is admin and add admin-user class to body
        (function checkAdminRole() {
            try {
                const userRole = sessionStorage.getItem('userRole') || sessionStorage.getItem('adminRole') || '';
                const adminUid = sessionStorage.getItem('adminUid');
                const isAdmin = userRole.toLowerCase() === 'admin' || adminUid !== null;
                
                if (isAdmin) {
                    document.body.classList.add('admin-user');
                } else {
                    document.body.classList.remove('admin-user');
                }
            } catch (e) {
                console.warn('Error checking admin role:', e);
            }
        })();
        
        // Also check on DOMContentLoaded in case sessionStorage is set later
        document.addEventListener('DOMContentLoaded', function() {
            try {
                const userRole = sessionStorage.getItem('userRole') || sessionStorage.getItem('adminRole') || '';
                const adminUid = sessionStorage.getItem('adminUid');
                const isAdmin = userRole.toLowerCase() === 'admin' || adminUid !== null;
                
                if (isAdmin) {
                    document.body.classList.add('admin-user');
                } else {
                    document.body.classList.remove('admin-user');
                }
            } catch (e) {
                console.warn('Error checking admin role on DOMContentLoaded:', e);
            }
        });
    </script>
    <script>
      // Disable initialize all barangays functionality if present
      (function(){
        const neuter = function(){ console.warn('initializeBarangayData() disabled by configuration'); };
        if (!window.staffManager) {
          Object.defineProperty(window, 'staffManager', {
            configurable: true,
            enumerable: true,
            get(){ return this.__sm__; },
            set(v){ this.__sm__ = v; try { if (v && typeof v.initializeBarangayData === 'function') v.initializeBarangayData = neuter; } catch(_){} }
          });
        } else if (typeof window.staffManager.initializeBarangayData === 'function') {
          window.staffManager.initializeBarangayData = neuter;
        }
      })();
      // Complex caching system removed - using simple direct approach
      // Sanitize Firebase RTDB keys under systemData/deliveryFees to avoid invalid characters
      (function(){
        function sanitizeSegment(seg){
          let s = String(seg == null ? '' : seg);
          s = s.replace('Z.', 'Z');
          s = s.replace(/[.#$/\[\]]/g, '_');
          s = s.trim();
          return s === '' ? '_' : s;
        }
        function sanitizeDeliveryFeesKeyPath(key){
          try {
            if (typeof key !== 'string') return key;
            const marker = 'systemData/deliveryFees/';
            const idx = key.indexOf(marker);
            if (idx === -1) return key;
            const prefix = key.substring(0, idx + marker.length);
            const rest = key.substring(idx + marker.length);
            const sanitizedRest = sanitizeSegment(rest);
            return prefix + sanitizedRest;
          } catch (_) { return key; }
        }
        function wrapRef(ref, currentPath){
          if (!ref || typeof ref.update !== 'function') return ref;
          // Track current path for this ref
          ref.__path = currentPath || ref.__path || '';
          const originalChild = ref.child && ref.child.bind(ref);
          if (typeof originalChild === 'function') {
            ref.child = function(pathSegment){
              let seg = String(pathSegment == null ? '' : pathSegment);
              const base = this.__path || '';
              const isFeesBase = base.endsWith('systemData/deliveryFees') || base.includes('/systemData/deliveryFees');
              let safeSeg = isFeesBase ? sanitizeSegment(seg) : seg.trim();
              if (safeSeg === '') { safeSeg = '_'; }
              const childRef = originalChild(safeSeg);
              const nextPath = base ? (base + '/' + safeSeg) : safeSeg;
              return wrapRef(childRef, nextPath);
            };
          }
          const originalUpdate = ref.update.bind(ref);
          ref.update = function(updates){
            if (updates && typeof updates === 'object' && !Array.isArray(updates)) {
              const next = {};
              const basePath = this.__path || '';
              const isFeesBase = basePath.endsWith('systemData/deliveryFees') || basePath.includes('/systemData/deliveryFees');
              Object.keys(updates).forEach(function(k){
                let nk = k;
                if (isFeesBase) {
                  // Keys are barangay names at fees base
                  nk = sanitizeSegment(k);
                } else {
                  // Multi-path update keys containing full path
                  nk = sanitizeDeliveryFeesKeyPath(k);
                }
                next[nk] = updates[k];
              });
              return originalUpdate(next);
            }
            return originalUpdate(updates);
          };
          return ref;
        }
        try {
          if (window.firebase && typeof window.firebase.database === 'function') {
            const originalDb = window.firebase.database;
            function wrappedDatabase(){
              const db = originalDb.apply(this, arguments);
              const originalRef = db.ref.bind(db);
              db.ref = function(){
                let path = arguments && arguments[0] ? String(arguments[0]) : '';
                // Sanitize initial ref path if it targets deliveryFees and includes a barangay name
                try {
                  const m1 = 'systemData/deliveryFees/';
                  const m2 = '/systemData/deliveryFees/';
                  if (path.includes(m1)) {
                    const head = path.substring(0, path.indexOf(m1) + m1.length);
                    const tail = path.substring(path.indexOf(m1) + m1.length);
                    path = head + sanitizeSegment(tail);
                  } else if (path.includes(m2)) {
                    const head = path.substring(0, path.indexOf(m2) + m2.length);
                    const tail = path.substring(path.indexOf(m2) + m2.length);
                    path = head + sanitizeSegment(tail);
                  } else if (path === 'systemData/deliveryFees') {
                    // base path ok
                  }
                  // Normalize slashes and strip trailing slash
                  path = path.replace(/\\+/g, '/');
                  while (path.length > 0 && path.endsWith('/')) { path = path.slice(0, -1); }
                  if (path === '') { path = '_'; }
                } catch(_) {}
                const r = originalRef.call(this, path);
                return wrapRef(r, path);
              };
              return db;
            }
            try {
              Object.keys(originalDb).forEach(function(k){
                try { wrappedDatabase[k] = originalDb[k]; } catch(_){}
              });
            } catch(_) {}
            // Ensure ServerValue (including TIMESTAMP) is preserved
            try { wrappedDatabase.ServerValue = originalDb.ServerValue; } catch(_) {}
            window.firebase.database = wrappedDatabase;
          }
        } catch (e) { console.warn('Failed to patch Firebase database for key sanitization', e); }
      })();
      // Additionally wrap existing dbRefs to sanitize keys regardless of when refs were created
      (function(){
        function sanitize(seg){ let s = String(seg); s = s.replace('Z.', 'Z'); return s.replace(/[.#$/\[\]]/g, '_'); }
        function isFeesPath(p){ return typeof p === 'string' && (p.endsWith('systemData/deliveryFees') || p.includes('/systemData/deliveryFees')); }
        function sanitizeMultiPathKey(k){
          if (typeof k !== 'string') return k;
          const marker = '/systemData/deliveryFees/';
          const i = k.indexOf(marker);
          if (i === -1) return k;
          const head = k.substring(0, i + marker.length);
          const tail = k.substring(i + marker.length);
          return head + sanitize(tail);
        }
        function wrapRefDeep(ref, path){
          if (!ref) return ref;
          try { ref.__path = path || ref.__path || ''; } catch(_){}
          if (typeof ref.child === 'function') {
            const oChild = ref.child.bind(ref);
            ref.child = function(seg){
              const base = this.__path || '';
              const safeSeg = isFeesPath(base) ? sanitize(seg) : seg;
              const child = oChild(safeSeg);
              const nextPath = base ? (base + '/' + safeSeg) : String(safeSeg||'');
              return wrapRefDeep(child, nextPath);
            };
          }
          if (typeof ref.update === 'function') {
            const oUpdate = ref.update.bind(ref);
            ref.update = function(obj){
              if (obj && typeof obj === 'object' && !Array.isArray(obj)) {
                const base = this.__path || '';
                const next = {};
                Object.keys(obj).forEach(function(k){
                  let nk = k;
                  if (isFeesPath(base)) nk = sanitize(k); else nk = sanitizeMultiPathKey(k);
                  // strip trailing slash and skip empty keys
                  if (typeof nk === 'string') {
                    nk = nk.replace(/\\+/g, '/');
                    while (nk.endsWith('/')) nk = nk.slice(0, -1);
                  }
                  if (!nk) return;
                  next[nk] = obj[k];
                });
                return oUpdate(next);
              }
              return oUpdate(obj);
            };
          }
          if (typeof ref.set === 'function') {
            const oSet = ref.set.bind(ref);
            ref.set = function(v){
              // no key here; set is safe as long as path sanitized by child()
              return oSet(v);
            };
          }
          return ref;
        }
        try {
          if (window.dbRefs && typeof window.dbRefs === 'object') {
            Object.keys(window.dbRefs).forEach(function(key){
              try {
                const r = window.dbRefs[key];
                if (r && typeof r === 'object') {
                  // Try to infer initial path from toString if available
                  let p = '';
                  try { p = (r.toString && r.toString()) || ''; } catch(_){}
                  window.dbRefs[key] = wrapRefDeep(r, p);
                }
              } catch(_){}
            });
            // Also wrap commonly used specific refs
            try { window.dbRefs.systemData = wrapRefDeep(window.dbRefs.systemData, 'systemData'); } catch(_){}
          }
        } catch (e) { console.warn('Failed to wrap dbRefs for sanitization', e); }
      })();
      // Final safeguard: patch Reference prototype to sanitize keys for any refs created elsewhere
      (function(){
        try {
          if (window.firebase && typeof window.firebase.database === 'function') {
            var db = window.firebase.database();
            var ref = db.ref();
            var proto = ref && ref.constructor && ref.constructor.prototype;
            if (proto) {
              var origChild = proto.child;
              if (typeof origChild === 'function') {
                proto.child = function(pathSegment){
                  try {
                    var seg = String(pathSegment == null ? '' : pathSegment).trim();
                    // Always sanitize to avoid invalid paths; coerce empty to underscore
                    if (seg === '') seg = '_';
                    seg = seg.replace('Z.', 'Z').replace(/[.#$/\[\]]/g, '_');
                    return origChild.call(this, seg);
                  } catch (e) {
                    // Last resort: avoid empty
                    var safe = (pathSegment == null || String(pathSegment).trim() === '') ? '_' : String(pathSegment);
                    return origChild.call(this, safe);
                  }
                };
              }
              var origUpdate = proto.update;
              if (typeof origUpdate === 'function') {
                proto.update = function(values){
                  try {
                    if (values && typeof values === 'object' && !Array.isArray(values)) {
                      var baseUrl = (typeof this.toString === 'function') ? String(this.toString()) : '';
                      var isFees = baseUrl.indexOf('/systemData/deliveryFees') !== -1;
                      var next = {};
                      Object.keys(values).forEach(function(k){
                        var nk = k;
                        if (isFees) {
                          nk = String(k).replace('Z.', 'Z').replace(/[.#$/\[\]]/g, '_');
                        } else {
                          // multi-path update
                          var marker = '/systemData/deliveryFees/';
                          if (nk.indexOf(marker) !== -1) {
                            var head = nk.substring(0, nk.indexOf(marker) + marker.length);
                            var tail = nk.substring(nk.indexOf(marker) + marker.length);
                            tail = tail.replace('Z.', 'Z').replace(/[.#$/\[\]]/g, '_');
                            nk = head + tail;
                          }
                        }
                        next[nk] = values[k];
                      });
                      return origUpdate.call(this, next);
                    }
                  } catch(_) {}
                  return origUpdate.call(this, values);
                };
              }
            }
          }
        } catch (e) { console.warn('Reference prototype patch failed', e); }
      })();
      // Override saveDeliveryFees to sanitize keys at the source
      (function(){
        function showToast(msg, type){
          try {
            const n = document.createElement('div');
            n.className = 'notification ' + (type || 'success');
            n.innerHTML = '<i class="fas fa-check-circle"></i><span>' + String(msg || 'Saved') + '</span>';
            document.body.appendChild(n);
            setTimeout(()=>{ try { n.remove(); } catch(_){} }, 2500);
          } catch(_){}
        }
        function sanitizeKey(name){
          let s = String(name == null ? '' : name);
          s = s.replace('Z.', 'Z');
          s = s.replace(/[.#$/\[\]]/g, '_');
          s = s.trim();
          return s === '' ? '_' : s;
        }
        function installOverride(){
          if (!window.staffManager || typeof window.staffManager.saveDeliveryFees !== 'function') return false;
          const original = window.staffManager.saveDeliveryFees.bind(window.staffManager);
          window.staffManager.saveDeliveryFees = async function(){
            try {
              const tbody = document.getElementById('deliveryFeesTableBody');
              if (!tbody) return original();
              
              // Get Supabase client
              const supabase = window.getSupabaseClient ? window.getSupabaseClient() : (window.supabaseClient || null);
              if (!supabase) {
                console.error('Supabase client not available');
                return original();
              }
              
              // Get current data from Supabase
              const { data: currentData } = await supabase
                .from('delivery_fees')
                .select('*')
                .eq('id', 1)
                .single();
              
              const updateData = currentData ? { ...currentData } : { id: 1 };
              
              // Only get rows that have the data-barangay attribute (skip header rows and invalid rows)
              const rows = Array.from(tbody.querySelectorAll('tr[data-barangay]'));
              
              if (rows.length === 0) {
                console.warn('No valid delivery fee rows found');
                return original();
              }
              
              // Determine indices dynamically
              const ths = Array.from(document.querySelectorAll('#delivery-settings thead th'));
              const currentIdx = ths.findIndex(th => (th.textContent||'').toLowerCase().includes('current fee'));
              const newIdx = ths.findIndex(th => (th.textContent||'').toLowerCase().includes('new fee'));
              const nameIdx = ths.findIndex(th => (th.textContent||'').toLowerCase().includes('barangay'));
              
              rows.forEach(function(row){
                // Skip if this row doesn't have the required data-barangay attribute
                if (!row.hasAttribute('data-barangay')) {
                  console.warn('Skipping row without data-barangay attribute');
                  return;
                }
                
                // Get barangay name from data-barangay attribute (most reliable)
                let barangayName = row.getAttribute('data-barangay') || '';
                if (!barangayName) {
                  // Fallback to cell text if data attribute not available
                  const nameCell = (nameIdx >= 0 && row.cells) ? row.cells[nameIdx] : (row.cells && row.cells[1] ? row.cells[1] : null);
                  if (nameCell) {
                    // Get text from the first text node or strong element to avoid getting nested content
                    const strongEl = nameCell.querySelector('strong');
                    if (strongEl) {
                      barangayName = (strongEl.textContent || '').trim();
                    } else {
                      // Get only direct text content, not from nested elements
                      const textNodes = Array.from(nameCell.childNodes).filter(n => n.nodeType === 3);
                      barangayName = textNodes.map(n => n.textContent).join('').trim();
                    }
                  }
                  if (!barangayName) return;
                }
                
                // Validate barangay name - it should not look like multiple names concatenated
                // Check for suspicious patterns like numbers separated by underscores or spaces
                const numberMatches = barangayName.match(/\d+/g);
                const numberCount = numberMatches ? numberMatches.length : 0;
                const underscoreParts = barangayName.split('_').length;
                
                if (barangayName.length > 100 || 
                    barangayName.split(' ').length > 10 || 
                    /^\d+[\s_]+\d+/.test(barangayName) || // Multiple numbers at start
                    numberCount > 3 || // More than 3 number sequences (suggests concatenation)
                    (barangayName.includes('_') && underscoreParts > 8) || // Too many underscore-separated parts
                    /barangay.*\d+.*barangay/i.test(barangayName) || // Multiple "barangay" mentions
                    /poblacion.*\d+.*poblacion/i.test(barangayName)) { // Multiple "poblacion" mentions
                  console.error(' Suspicious barangay name detected:', barangayName);
                  console.error('Length:', barangayName.length, 'Words:', barangayName.split(' ').length, 'Numbers:', numberCount, 'Underscore parts:', underscoreParts);
                  console.error('Row HTML:', row.outerHTML.substring(0, 200));
                  return;
                }
                
                const currentCell = (currentIdx >= 0 && row.cells) ? row.cells[currentIdx] : null;
                const newCell = (newIdx >= 0 && row.cells) ? row.cells[newIdx] : null;
                
                // Convert barangay name to column name
                const columnName = barangayNameToColumnName(barangayName);
                if (!columnName) {
                  console.warn('Could not convert barangay name to column name:', barangayName);
                  return;
                }
                
                // Validate column name - it should not be too long or contain suspicious patterns
                if (columnName.length > 50 || columnName.split('_').length > 10) {
                  console.error('Invalid column name detected:', columnName, 'for barangay:', barangayName);
                  console.error('This suggests multiple barangay names were concatenated. Skipping this row.');
                  return;
                }
                
                console.log('Mapping barangay:', barangayName, '-> column:', columnName);
                
                // Only update rows where a new fee was explicitly provided (avoid overwriting others)
                let hasExplicitNew = false;
                let fee = undefined;
                if (newCell) {
                  const nf = newCell.querySelector('input');
                  if (nf && nf.value !== '') {
                    const val = parseFloat(String(nf.value || '').replace(/[^0-9.\-]/g, ''));
                    if (!isNaN(val)) { fee = val; hasExplicitNew = true; }
                  }
                }
                // Also allow explicit selection checkbox to apply a bulk-entered new fee value
                const sel = row.querySelector('input.barangay-checkbox');
                if (!hasExplicitNew && sel && sel.checked && newCell) {
                    const nf = newCell.querySelector('input');
                    if (nf && nf.value !== '') {
                        const val = parseFloat(String(nf.value || '').replace(/[^0-9.\-]/g, ''));
                        if (!isNaN(val)) { fee = val; hasExplicitNew = true; }
                    }
                }
                if (!hasExplicitNew) return; // skip rows without explicit new value
                
                // Additional validation: column name should not have suspicious patterns
                const columnUnderscoreParts = columnName.split('_').length;
                if (!columnName || 
                    columnName.length > 50 || 
                    columnUnderscoreParts > 10 ||
                    /barangay.*\d+.*barangay/i.test(columnName) ||
                    /poblacion.*\d+.*poblacion/i.test(columnName) ||
                    (columnName.match(/\d+/g) && columnName.match(/\d+/g).length > 2)) {
                  console.error(' Invalid column name detected:', columnName, 'for barangay:', barangayName);
                  console.error('Column name parts:', columnUnderscoreParts, 'Numbers:', columnName.match(/\d+/g)?.length);
                  return; // Skip this row
                }
                
                updateData[columnName] = fee;
              });
              
              // Update the updated_at timestamp
              updateData.updated_at = new Date().toISOString();
              
              // Filter out any invalid column names before sending to Supabase
              const validUpdateData = { id: updateData.id || 1 };
              
              // Get all valid barangay column names (they should match the pattern: lowercase with underscores, max 50 chars)
              Object.keys(updateData).forEach(key => {
                if (key === 'id' || key === 'updated_at') {
                  validUpdateData[key] = updateData[key];
                } else if (key.length <= 50 && /^[a-z0-9_]+$/.test(key) && key.split('_').length <= 10) {
                  // Valid column name pattern
                  validUpdateData[key] = updateData[key];
                } else {
                  console.warn('Filtering out invalid column name from updateData:', key);
                }
              });
              
              console.log('Final updateData keys:', Object.keys(validUpdateData));
              
              // Upsert the row
              const { error } = await supabase
                .from('delivery_fees')
                .upsert(validUpdateData, { onConflict: 'id' });
              
              if (error) {
                console.error('Error saving delivery fees:', error);
                return original();
              }
              
              // Immediately reflect into Current Fee column
              try {
                const ths2 = Array.from(document.querySelectorAll('#delivery-settings thead th'));
                const currentIdx2 = ths2.findIndex(th => (th.textContent||'').toLowerCase().includes('current fee'));
                const newIdx2 = ths2.findIndex(th => (th.textContent||'').toLowerCase().includes('new fee'));
                const nameIdx2 = ths2.findIndex(th => (th.textContent||'').toLowerCase().includes('barangay'));
                rows.forEach(function(row){
                  const currentCell = (currentIdx2 >= 0 && row.cells) ? row.cells[currentIdx2] : null;
                  const newCell = (newIdx2 >= 0 && row.cells) ? row.cells[newIdx2] : null;
                  const nameCell2 = (nameIdx2 >= 0 && row.cells) ? row.cells[nameIdx2] : null;
                  if (!currentCell || !newCell || !nameCell2) return;
                  const nf = newCell.querySelector('input');
                  if (nf && nf.value !== '') {
                    const span = currentCell.querySelector('span') || (function(){ const s=document.createElement('span'); s.className='current-fee-text'; currentCell.innerHTML=''; currentCell.appendChild(s); return s; })();
                    const feeValue = parseFloat(String(nf.value || '').replace(/[^0-9.\-]/g, '')) || 0;
                    span.textContent = feeValue > 0 ? `${feeValue}` : '0';
                  }
                });
              } catch(_) {}
              
              // Uncheck all checkboxes after successful save
              const allCheckboxes = document.querySelectorAll('.barangay-checkbox');
              allCheckboxes.forEach(checkbox => {
                checkbox.checked = false;
              });
              
              showToast('Fees saved successfully', 'success');
              return true;
            } catch (e) {
              console.warn('Sanitized saveDeliveryFees failed, falling back', e);
              try { showToast('Save failed, retrying...', 'error'); } catch(_){}
              return original();
            }
          };
          return true;
        }
        (function waitInstall(attempts){
          if (installOverride()) return;
          if (attempts <= 0) return;
          setTimeout(function(){ waitInstall(attempts - 1); }, 200);
        })(25);
      })();
    </script>
    <script>
      // Enhance order cards to show GCash receipt if available (from Supabase gcash_receipt bucket)
      (function(){
        const deferPatch = () => {
          if (!window.staffManager || typeof window.staffManager.createOrderCard !== 'function') {
            return setTimeout(deferPatch, 200);
          }
          const originalCreateOrderCard = window.staffManager.createOrderCard.bind(window.staffManager);
          window.staffManager.createOrderCard = function(id, order){
            const card = originalCreateOrderCard(id, order);
            try {
              const rawUrl = (order && order.gcashReceiptUrl) ? String(order.gcashReceiptUrl) : '';
              console.log('[GCash Receipt Patch] Raw URL from order:', rawUrl);
              // Use helper function to get correct Supabase URL
              let url = null;
              if (window.staffManager && typeof window.staffManager.getGcashReceiptUrl === 'function') {
                url = window.staffManager.getGcashReceiptUrl(rawUrl);
                console.log('[GCash Receipt Patch] Processed URL:', url);
              } else {
                // Fallback URL construction
                if (rawUrl && !rawUrl.startsWith('pending:')) {
                  if (rawUrl.startsWith('http://') || rawUrl.startsWith('https://')) {
                    url = rawUrl;
                  } else {
                    // Remove leading slashes and bucket name (handle multiple occurrences)
                    let cleanPath = rawUrl.replace(/^\/+/, '');
                    while (cleanPath.startsWith('gcash_receipt/')) {
                      cleanPath = cleanPath.substring('gcash_receipt/'.length).replace(/^\/+/, '');
                    }
                    url = `https://afkwexvvuxwbpioqnelp.supabase.co/storage/v1/object/public/gcash_receipt/${cleanPath}`;
                  }
                }
                console.log('[GCash Receipt Patch] Fallback URL:', url);
              }
              // Only add receipt section if URL exists and is NOT pending (original createOrderCard handles pending)
              // This ensures receipt is visible even if payment method check fails in main function
              if (url && String(order.paymentMethod || '').toLowerCase() === 'gcash') {
                const details = card && card.querySelector ? card.querySelector('#order-details-' + id) : null;
                const container = details || card;
                if (container) {
                  // Check if receipt already exists in the card (avoid duplicates)
                  const existingReceipt = container.querySelector('.gcash-receipt');
                  if (!existingReceipt) {
                    // Escape URL for use in onclick handler
                    const escapedUrl = url.replace(/'/g, "\\'").replace(/"/g, '&quot;');
                    const wrap = document.createElement('div');
                    wrap.style.marginTop = '12px';
                    wrap.style.width = '100%';
                    wrap.style.maxWidth = '100%';
                    wrap.style.overflow = 'hidden';
                    wrap.style.boxSizing = 'border-box';
                    wrap.style.display = 'block';
                    wrap.innerHTML = `
                      <div class="gcash-receipt" style="background:#f8f9fa;border:1px solid #e9ecef;border-radius:8px;padding:12px;overflow:hidden;width:100%;max-width:100%;box-sizing:border-box;display:block;">
                        <div style="display:flex;align-items:center;gap:8px;margin-bottom:10px;flex-shrink:0;">
                          <i class="fas fa-receipt" style="color:#4CAF50;"></i>
                          <strong style="color:#333;">GCash Receipt (Payment Proof)</strong>
                        </div>
                        <div style="margin-top:8px;width:100%;max-width:100%;overflow:hidden;box-sizing:border-box;display:block;">
                          <div style="width:100%;max-width:100%;overflow:hidden;border-radius:6px;box-sizing:border-box;position:relative;background:#fff;padding:8px;display:flex;align-items:center;justify-content:center;min-height:0;">
                            <img src="${url}" alt="GCash Receipt" 
                                 style="width:auto;max-width:100%;height:auto;max-height:200px;object-fit:contain;object-position:center;border:1px solid #e0e0e0;border-radius:4px;box-shadow:0 2px 4px rgba(0,0,0,0.1);cursor:pointer;transition:box-shadow 0.2s ease;display:block;margin:0;box-sizing:border-box;flex-shrink:1;" 
                                 onclick="event.preventDefault(); event.stopPropagation(); if(window.staffManager && typeof window.staffManager.showEnlargedImage === 'function') { window.staffManager.showEnlargedImage('${escapedUrl}', 'GCash Receipt'); }" 
                                 onerror="this.style.display='none';this.nextElementSibling.style.display='block';" 
                                 onmouseenter="this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)';"
                                 onmouseleave="this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)';"
                                 title="Click to view full size" 
                                 loading="lazy" />
                            <div style="display:none;padding:12px;background:#ffebee;border:1px solid #ffcdd2;border-radius:6px;color:#c62828;margin-top:8px;text-align:center;">
                              <i class="fas fa-exclamation-triangle"></i> Failed to load image. <a href="${url}" target="_blank" rel="noopener" style="color:#c62828;text-decoration:underline;">Click here to open receipt</a>
                            </div>
                          </div>
                        </div>
                      </div>`;
                    container.appendChild(wrap);
                  }
                }
              }
            } catch(e) { console.warn('GCash receipt render error', e); }
            return card;
          };
        };
        deferPatch();
      })();
    </script>
    <script>
      (function(){
        window.__chatLocks = window.__chatLocks || { activePanelLocked: false };
        // Skip the next full list refresh (used after clicking a snippet)
        window.__suppressNextConversationListRefresh = window.__suppressNextConversationListRefresh || false;
 
        // Disable chat lock to restore original behavior
        const isActiveLocked = () => false;
        const lockActivePanel = () => { window.__chatLocks.activePanelLocked = true; };
        const unlockActivePanel = () => { window.__chatLocks.activePanelLocked = false; };
      })();
    </script>
</body>
</html>
    <script>
        // Initialize badge on page load - check for unread messages
        (function() {
            const badge = document.getElementById('chatBadge');
            if (badge) {
                // Don't hide badge immediately - let it show unread count if there are unread messages
                // The badge will be updated by updateChatBadge() when Firebase is ready
            }
        })();
        
        // Initialize dropdown as hidden on page load
        document.addEventListener('DOMContentLoaded', function() {
            const dropdown = document.getElementById('profileDropdownMenu');
            if (dropdown) {
                // Remove debugging classes
                dropdown.classList.remove('force-visible', 'test-visible');
            }
            
            // Add click event listener to profile button
            const profileBtn = document.getElementById('staffProfileBtn');
            if (profileBtn) {
                profileBtn.addEventListener('click', function(event) {
                    event.preventDefault();
                    event.stopPropagation();
                    toggleDropdown(event);
                });
            } else {
                console.error('Profile button not found!');
            }
        });

        // Simple dropdown functions
        function toggleDropdown(event) {
            
            const dropdown = document.getElementById('profileDropdownMenu');
            
            if (!dropdown) {
                console.error('Dropdown not found!');
                return;
            }
            
            // Simple toggle
            if (dropdown.style.display === 'block') {
                dropdown.style.display = 'none';
            } else {
                // Position dropdown above the profile section with reduced gap
                const profileSection = document.getElementById('staffProfileBtn');
                if (profileSection) {
                    const profileRect = profileSection.getBoundingClientRect();
                    const dropdownHeight = 180; // Approximate dropdown height
                    const gap = 50; // Reduced gap to bring dropdown closer
                    dropdown.style.top = (profileRect.top - dropdownHeight - gap) + 'px'; // Dropdown closer to profile
                    dropdown.style.left = profileRect.left + 'px';
                    dropdown.style.setProperty('width', profileRect.width + 'px', 'important'); // Match profile section width
                } else {
                    dropdown.style.top = '100px';
                    dropdown.style.left = '50px';
                }
                
                dropdown.style.display = 'block';
                dropdown.style.position = 'fixed';
                dropdown.style.zIndex = '9999';
                dropdown.style.backgroundColor = 'white';
                dropdown.style.setProperty('border', '0.2px solid #ddd', 'important');
                dropdown.style.borderRadius = '8px';
                dropdown.style.padding = '0px';
                dropdown.style.boxShadow = '0 4px 8px rgba(0,0,0,0.1)';
                
                // Add border radius to dropdown header with !important to match main dropdown
                const dropdownHeader = dropdown.querySelector('.dropdown-header');
                if (dropdownHeader) {
                    dropdownHeader.style.setProperty('border-radius', '8px 8px 0 0', 'important'); // Top corners only, more curvy
                } else {
                }
                
                // Also apply the same border radius to the main dropdown to ensure consistency
                dropdown.style.setProperty('border-radius', '8px', 'important');
                
            }
        }

        // Test function to verify dropdown is working




        // Initialize dropdown on page load
        document.addEventListener('DOMContentLoaded', function() {
            const dropdown = document.getElementById('profileDropdownMenu');
            const button = document.getElementById('staffProfileBtn');
            
            if (dropdown && button) {
                // Ensure dropdown is always clickable
                setInterval(() => {
                    if (dropdown.classList.contains('show')) {
                        dropdown.style.pointerEvents = 'auto';
                        dropdown.style.cursor = 'pointer';
                        const dropdownItems = dropdown.querySelectorAll('.dropdown-item');
                        dropdownItems.forEach(item => {
                            item.style.pointerEvents = 'auto';
                            item.style.cursor = 'pointer';
                        });
                    }
                }, 100);
                
                // Ensure dropdown starts in hidden state
                resetDropdownState();
            }
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', function(event) {
            const dropdown = document.getElementById('profileDropdownMenu');
            const profileSection = document.getElementById('staffProfileBtn');
            
            if (dropdown && profileSection && !profileSection.contains(event.target) && !dropdown.contains(event.target)) {
                dropdown.classList.remove('show', 'force-visible', 'test-visible');
                dropdown.style.opacity = '0';
                dropdown.style.visibility = 'hidden';
                dropdown.style.transform = 'translateY(-10px)';
                dropdown.style.pointerEvents = 'none';
                profileSection.classList.remove('active');
            }
        });

        // Theme Management Functions
        function initializeTheme() {
            // Force light theme - dark theme disabled
            localStorage.setItem('theme', 'light');
            localStorage.setItem('darkMode', 'false');
            applyTheme('light');
            
            // Update toggle switch
            updateDarkModeToggle();
            
            // Dark theme disabled - always use light theme
            // Removed system theme listener to prevent dark theme activation
        }
        
        function updateDarkModeToggle() {
            const toggle = document.getElementById('darkModeToggle');
            if (toggle) {
                const isDark = document.body.classList.contains('dark-theme');
                toggle.checked = isDark;
            }
        }
        
        // Featured Media Management Functions
        let featuredMediaFiles = [];
        let selectedFilesForPreview = [];

        async function loadFeaturedMediaList() {
            try {
                const files = await FirebaseUtils.listFeaturedMedia();
                featuredMediaFiles = files.filter(f => f.name !== '.emptyFolderPlaceholder');
                renderFeaturedMediaList();
            } catch (error) {
                console.error('Error loading featured media:', error);
                alert('Failed to load featured media: ' + error.message);
            }
        }

        function renderFeaturedMediaList() {
            const container = document.getElementById('featuredMediaList');
            if (!container) return;

            container.innerHTML = '';

            const images = featuredMediaFiles.filter(f => {
                const name = f.name.toLowerCase();
                return name.endsWith('.jpg') || name.endsWith('.jpeg') || name.endsWith('.png') || 
                       name.endsWith('.gif') || name.endsWith('.webp') || name.endsWith('.bmp') || 
                       name.endsWith('.svg');
            });
            const videos = featuredMediaFiles.filter(f => {
                const name = f.name.toLowerCase();
                return name.endsWith('.mp4') || name.endsWith('.mov') || name.endsWith('.avi') || 
                       name.endsWith('.webm') || name.endsWith('.mkv') || name.endsWith('.flv') || 
                       name.endsWith('.wmv');
            });

            // Show images (max 8)
            images.slice(0, 8).forEach(file => {
                const card = createMediaCard(file, 'image', false);
                container.appendChild(card);
            });

            // Show videos (max 2)
            videos.slice(0, 2).forEach(file => {
                const card = createMediaCard(file, 'video', false);
                container.appendChild(card);
            });

            // Show counts
            const countInfo = document.createElement('div');
            countInfo.style.cssText = 'grid-column: 1 / -1; margin-top: 10px; padding: 10px; background: #f0f0f0; border-radius: 6px; font-size: 0.9em; color: #666;';
            countInfo.innerHTML = `Images: ${images.length}/8 | Videos: ${videos.length}/2`;
            container.appendChild(countInfo);
        }

        function createMediaCard(file, type, isPreview = false) {
            const card = document.createElement('div');
            card.style.cssText = 'position: relative; border: 1px solid #ddd; border-radius: 8px; overflow: hidden; background: #fff; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;';
            card.onmouseover = () => {
                card.style.transform = 'scale(1.02)';
                card.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
            };
            card.onmouseout = () => {
                card.style.transform = 'scale(1)';
                card.style.boxShadow = 'none';
            };
            
            let publicUrl;
            if (isPreview) {
                publicUrl = URL.createObjectURL(file);
            } else {
                const client = window.supabaseClient || (window.supabase && supabase.createClient(window.SUPABASE_URL, window.SUPABASE_ANON_KEY));
                publicUrl = client.storage.from('featured_display').getPublicUrl(file.name).publicUrl;
            }

            if (type === 'image') {
                card.innerHTML = `
                    <img src="${publicUrl}" style="width: 100%; height: 150px; object-fit: cover;" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'150\' height=\'150\'%3E%3Crect fill=\'%23ddd\' width=\'150\' height=\'150\'/%3E%3Ctext x=\'50%25\' y=\'50%25\' text-anchor=\'middle\' dy=\'.3em\' fill=\'%23999\' font-family=\'sans-serif\' font-size=\'14\'%3EImage%3C/text%3E%3C/svg%3E';" onclick="openLightbox('${publicUrl}', 'image', '${file.name}')">
                    <div style="padding: 8px; font-size: 0.8em; color: #666; word-break: break-all;">${file.name}</div>
                    ${!isPreview ? `<button onclick="event.stopPropagation(); deleteFeaturedMedia('${file.name}')" style="position: absolute; top: 5px; right: 5px; background: rgba(255,0,0,0.8); color: white; border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; font-size: 12px; z-index: 10;"></button>` : ''}
                `;
            } else {
                card.innerHTML = `
                    <div style="width: 100%; height: 150px; background: #000; display: flex; align-items: center; justify-content: center; color: white; font-size: 2em;" onclick="openLightbox('${publicUrl}', 'video', '${file.name}')">
                        <i class="fas fa-play-circle"></i>
                    </div>
                    <div style="padding: 8px; font-size: 0.8em; color: #666; word-break: break-all;">${file.name}</div>
                    ${!isPreview ? `<button onclick="event.stopPropagation(); deleteFeaturedMedia('${file.name}')" style="position: absolute; top: 5px; right: 5px; background: rgba(255,0,0,0.8); color: white; border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; font-size: 12px; z-index: 10;"></button>` : ''}
                `;
            }

            return card;
        }

        function handleFeaturedMediaSelection(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;

            const images = files.filter(f => {
                const name = f.name.toLowerCase();
                return name.endsWith('.jpg') || name.endsWith('.jpeg') || name.endsWith('.png') || 
                       name.endsWith('.gif') || name.endsWith('.webp') || name.endsWith('.bmp') || 
                       name.endsWith('.svg');
            });
            const videos = files.filter(f => {
                const name = f.name.toLowerCase();
                return name.endsWith('.mp4') || name.endsWith('.mov') || name.endsWith('.avi') || 
                       name.endsWith('.webm') || name.endsWith('.mkv') || name.endsWith('.flv') || 
                       name.endsWith('.wmv');
            });

            // Check limits
            const currentImages = featuredMediaFiles.filter(f => {
                const name = f.name.toLowerCase();
                return name.endsWith('.jpg') || name.endsWith('.jpeg') || name.endsWith('.png') || 
                       name.endsWith('.gif') || name.endsWith('.webp') || name.endsWith('.bmp') || 
                       name.endsWith('.svg');
            });
            const currentVideos = featuredMediaFiles.filter(f => {
                const name = f.name.toLowerCase();
                return name.endsWith('.mp4') || name.endsWith('.mov') || name.endsWith('.avi') || 
                       name.endsWith('.webm') || name.endsWith('.mkv') || name.endsWith('.flv') || 
                       name.endsWith('.wmv');
            });

            // Get currently selected files
            const selectedImages = selectedFilesForPreview.filter(f => {
                const name = f.name.toLowerCase();
                return name.match(/\.(jpg|jpeg|png|gif|webp|bmp|svg)$/);
            });
            const selectedVideos = selectedFilesForPreview.filter(f => {
                const name = f.name.toLowerCase();
                return name.match(/\.(mp4|mov|avi|webm|mkv|flv|wmv)$/);
            });

            // Calculate remaining slots (considering both current uploaded and selected)
            const totalSelectedImages = currentImages.length + selectedImages.length;
            const totalSelectedVideos = currentVideos.length + selectedVideos.length;
            const remainingImages = Math.max(0, 8 - totalSelectedImages);
            const remainingVideos = Math.max(0, 2 - totalSelectedVideos);

            // Filter new files to fit within remaining limits
            const validImages = images.slice(0, remainingImages);
            const validVideos = videos.slice(0, remainingVideos);

            // Show warning if files were filtered out
            if (images.length > remainingImages) {
                alert(`Maximum 8 images allowed. You currently have ${totalSelectedImages} images selected. Only ${remainingImages} more image(s) can be added.`);
            }
            if (videos.length > remainingVideos) {
                alert(`Maximum 2 videos allowed. You currently have ${totalSelectedVideos} videos selected. Only ${remainingVideos} more video(s) can be added.`);
            }

            // Check if there are any valid files to add
            if (validImages.length === 0 && validVideos.length === 0) {
                return;
            }

            // Validate video durations
            const videoPromises = validVideos.map(file => {
                return new Promise((resolve) => {
                    const video = document.createElement('video');
                    video.preload = 'metadata';
                    video.onloadedmetadata = () => {
                        window.URL.revokeObjectURL(video.src);
                        if (video.duration > 30) {
                            alert(`Video "${file.name}" exceeds 30 seconds. Maximum allowed duration is 30 seconds.`);
                            resolve(null);
                        } else {
                            resolve(file);
                        }
                    };
                    video.onerror = () => {
                        window.URL.revokeObjectURL(video.src);
                        resolve(file); // Assume valid if can't read metadata
                    };
                    video.src = URL.createObjectURL(file);
                });
            });

            Promise.all(videoPromises).then(validatedVideos => {
                const finalVideos = validatedVideos.filter(v => v !== null);
                // Add new files to existing selection (accumulate, don't replace)
                selectedFilesForPreview = [...selectedFilesForPreview, ...validImages, ...finalVideos];
                renderPreview();
                updateRemainingCount();
            });
        }

        function renderPreview() {
            const previewArea = document.getElementById('featuredMediaPreviewArea');
            const previewList = document.getElementById('featuredMediaPreviewList');
            
            if (!previewArea || !previewList) return;

            previewList.innerHTML = '';
            
            // Show all selected files in preview (no limit in preview display)
            selectedFilesForPreview.forEach((file, index) => {
                const isImage = file.name.toLowerCase().match(/\.(jpg|jpeg|png|gif|webp|bmp|svg)$/);
                const card = createMediaCard(file, isImage ? 'image' : 'video', true);
                
                // Add remove button for preview items
                const removeBtn = document.createElement('button');
                removeBtn.innerHTML = '';
                removeBtn.style.cssText = 'position: absolute; top: 5px; right: 5px; background: rgba(255,0,0,0.8); color: white; border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; font-size: 12px; z-index: 10;';
                removeBtn.onclick = (e) => {
                    e.stopPropagation();
                    selectedFilesForPreview.splice(index, 1);
                    renderPreview();
                    updateRemainingCount();
                };
                card.appendChild(removeBtn);
                
                previewList.appendChild(card);
            });

            previewArea.style.display = selectedFilesForPreview.length > 0 ? 'block' : 'none';
            updateRemainingCount();
        }

        function updateRemainingCount() {
            const remainingCountDiv = document.getElementById('featuredMediaRemainingCount');
            const remainingCountText = document.getElementById('remainingCountText');
            
            if (!remainingCountDiv || !remainingCountText) return;

            const currentImages = featuredMediaFiles.filter(f => {
                const name = f.name.toLowerCase();
                return name.endsWith('.jpg') || name.endsWith('.jpeg') || name.endsWith('.png') || 
                       name.endsWith('.gif') || name.endsWith('.webp') || name.endsWith('.bmp') || 
                       name.endsWith('.svg');
            });
            const currentVideos = featuredMediaFiles.filter(f => {
                const name = f.name.toLowerCase();
                return name.endsWith('.mp4') || name.endsWith('.mov') || name.endsWith('.avi') || 
                       name.endsWith('.webm') || name.endsWith('.mkv') || name.endsWith('.flv') || 
                       name.endsWith('.wmv');
            });

            const selectedImages = selectedFilesForPreview.filter(f => {
                const name = f.name.toLowerCase();
                return name.match(/\.(jpg|jpeg|png|gif|webp|bmp|svg)$/);
            });
            const selectedVideos = selectedFilesForPreview.filter(f => {
                const name = f.name.toLowerCase();
                return name.match(/\.(mp4|mov|avi|webm|mkv|flv|wmv)$/);
            });

            const totalImages = currentImages.length + selectedImages.length;
            const totalVideos = currentVideos.length + selectedVideos.length;

            if (selectedFilesForPreview.length > 0) {
                remainingCountText.innerHTML = `
                    <strong>Selected:</strong> Images - ${totalImages}/8, Videos - ${totalVideos}/2
                `;
                remainingCountDiv.style.display = 'block';
            } else {
                remainingCountDiv.style.display = 'none';
            }
        }

        async function confirmFeaturedMediaUpload() {
            if (selectedFilesForPreview.length === 0) return;

            const progressDiv = document.getElementById('featuredMediaUploadProgress');
            const progressFill = document.getElementById('featuredMediaProgressFill');
            const progressText = document.getElementById('featuredMediaProgressText');
            const previewArea = document.getElementById('featuredMediaPreviewArea');

            progressDiv.style.display = 'block';
            previewArea.style.display = 'none';
            progressFill.style.width = '0%';
            progressText.textContent = 'Uploading...';

            try {
                for (let i = 0; i < selectedFilesForPreview.length; i++) {
                    const file = selectedFilesForPreview[i];
                    progressText.textContent = `Uploading ${i + 1}/${selectedFilesForPreview.length}: ${file.name}`;
                    
                    await FirebaseUtils.uploadFeaturedMedia(file, (progress) => {
                        const overallProgress = ((i / selectedFilesForPreview.length) * 100) + (progress / selectedFilesForPreview.length);
                        progressFill.style.width = overallProgress + '%';
                    });

                    progressFill.style.width = ((i + 1) / selectedFilesForPreview.length) * 100 + '%';
                }

                progressText.textContent = 'Upload complete!';
                selectedFilesForPreview = [];
                document.getElementById('featuredMediaInput').value = '';
                document.getElementById('featuredMediaRemainingCount').style.display = 'none';
                
                setTimeout(() => {
                    progressDiv.style.display = 'none';
                    loadFeaturedMediaList();
                }, 1000);
            } catch (error) {
                console.error('Upload error:', error);
                alert('Upload failed: ' + error.message);
                progressDiv.style.display = 'none';
                previewArea.style.display = 'block';
            }
        }

        function cancelFeaturedMediaPreview() {
            selectedFilesForPreview = [];
            document.getElementById('featuredMediaInput').value = '';
            document.getElementById('featuredMediaPreviewArea').style.display = 'none';
            document.getElementById('featuredMediaRemainingCount').style.display = 'none';
        }

        async function deleteFeaturedMedia(fileName) {
            if (!confirm(`Delete ${fileName}?`)) return;

            try {
                await FirebaseUtils.deleteFeaturedMedia(fileName);
                await loadFeaturedMediaList();
            } catch (error) {
                console.error('Delete error:', error);
                alert('Failed to delete: ' + error.message);
            }
        }

        // Lightbox Functions
        function openLightbox(url, type, fileName) {
            const lightbox = document.getElementById('mediaLightbox');
            const lightboxContent = document.getElementById('lightboxContent');
            const lightboxTitle = document.getElementById('lightboxTitle');
            
            if (!lightbox || !lightboxContent || !lightboxTitle) return;

            lightboxTitle.textContent = fileName;
            lightboxContent.innerHTML = '';

            if (type === 'image') {
                const img = document.createElement('img');
                if (url) {
                    img.src = url;
                } else {
                    lightboxContent.innerHTML = '<div style="color: white; font-size: 18px;">Image URL is missing</div>';
                    return;
                }
                img.style.cssText = 'max-width: 90vw; max-height: 90vh; object-fit: contain; border-radius: 8px;';
                img.onerror = () => {
                    lightboxContent.innerHTML = '<div style="color: white; font-size: 18px;">Failed to load image</div>';
                };
                lightboxContent.appendChild(img);
            } else {
                const video = document.createElement('video');
                if (url) {
                    video.src = url;
                } else {
                    lightboxContent.innerHTML = '<div style="color: white; font-size: 18px;">Video URL is missing</div>';
                    return;
                }
                video.controls = true;
                video.style.cssText = 'max-width: 90vw; max-height: 90vh; border-radius: 8px;';
                video.onerror = () => {
                    lightboxContent.innerHTML = '<div style="color: white; font-size: 18px;">Failed to load video</div>';
                };
                lightboxContent.appendChild(video);
            }

            lightbox.style.display = 'flex';
            document.body.style.overflow = 'hidden';
            
            // Close on escape key
            const escapeHandler = (e) => {
                if (e.key === 'Escape') {
                    closeLightbox();
                    document.removeEventListener('keydown', escapeHandler);
                }
            };
            document.addEventListener('keydown', escapeHandler);
            
            // Close on background click
            lightbox.onclick = (e) => {
                if (e.target === lightbox) {
                    closeLightbox();
                }
            };
        }

        function closeLightbox() {
            const lightbox = document.getElementById('mediaLightbox');
            if (lightbox) {
                lightbox.style.display = 'none';
                document.body.style.overflow = '';
                // Clear content to stop video playback
                const content = document.getElementById('lightboxContent');
                if (content) content.innerHTML = '';
            }
        }

        // Load featured media list on page load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(loadFeaturedMediaList, 1000);
            });
        } else {
            setTimeout(loadFeaturedMediaList, 1000);
        }

        function toggleDarkMode(isDark) {
            // Set manual override
            localStorage.setItem('themeOverride', 'true');
            localStorage.setItem('darkMode', isDark.toString());
            
            if (isDark) {
                applyTheme('dark');
            } else {
                applyTheme('light');
            }
            
            // Update toggle state
            updateDarkModeToggle();
            
            // Show feedback
            showNotification(`Dark mode ${isDark ? 'enabled' : 'disabled'}`, 'success');
        }

        function applyTheme(theme) {
            const body = document.body;
            
            // Remove any existing theme classes first
            body.classList.remove('dark-theme', 'light-theme');
            
            // Check stored theme preference
            const storedTheme = localStorage.getItem('theme');
            
            // Apply theme based on selection
            if (theme === 'dark') { // Dark theme enabled
                body.classList.add('dark-theme');
                
                // Modern Analytics Dark Theme Palette
                const darkTheme = {
                    // Background Colors
                    background: '#0D0D0D',           // Pure black main background
                    surface: '#1E1E1E',              // Dark gray card background
                    surfaceElevated: '#1E1E1E',      // Elevated surfaces
                    surfaceHover: '#2A2A2A',          // Hover states
                    
                    // Text Colors
                    textPrimary: '#FFFFFF',          // White for all labels, titles, numbers
                    textSecondary: '#B3B3B3',         // Light gray for less important info
                    textMuted: '#B3B3B3',            // Light gray muted text
                    textAccent: '#8BC34A',           // Primary green for accents
                    
                    // Border Colors
                    border: '#333333',               // Subtle borders
                    borderLight: '#404040',          // Light borders
                    borderAccent: '#8BC34A',          // Green accent borders
                    
                    // Interactive Colors
                    primary: '#6FAA3C',             // Primary green buttons
                    primaryHover: '#8BC34A',         // Light green hover
                    primaryDisabled: '#3A3A3A',      // Disabled state
                    success: '#8BC34A',              // Success green
                    warning: '#F4A62B',             // Warning gold
                    error: '#ef4444',                // Error red
                    
                    // Form Elements
                    inputBg: '#1E1E1E',             // Input background
                    inputBorder: '#333333',          // Input border
                    inputFocus: '#8BC34A',          // Input focus green
                    
                    // Button Colors
                    buttonPrimary: '#6FAA3C',       // Default button background
                    buttonPrimaryHover: '#8BC34A', // Button hover
                    buttonPrimaryDisabled: '#3A3A3A', // Button disabled
                    buttonSecondary: '#333333',     // Secondary button
                    buttonDanger: '#dc2626',        // Danger button
                    buttonText: '#FFFFFF',          // Button text white
                    
                    // Graphics and Charts
                    chartPrimary: '#8BC34A',        // Primary green for charts
                    chartAccent: '#6FAA3C',         // Accent green
                    chartLight: '#A4D46F',          // Light green for effects
                    
                    // Sidebar Colors (keep green theme)
                    sidebarBg: '#243a27',           // Sidebar background
                    sidebarMenuDefault: '#F4A62B',  // Sidebar menu default
                    sidebarMenuHover: 'rgba(244, 166, 43, 0.12)', // Sidebar menu hover
                    sidebarMenuActive: '#FFFFFF',   // Sidebar menu active
                    sidebarMenuActiveBorder: '#F4A62B' // Sidebar menu active border
                };
                
                // Apply professional dark theme CSS variables
                body.style.setProperty('--bg', darkTheme.background, 'important');
                body.style.setProperty('--surface', darkTheme.surface, 'important');
                body.style.setProperty('--surface-2', darkTheme.surfaceElevated, 'important');
                body.style.setProperty('--text', darkTheme.textPrimary, 'important');
                body.style.setProperty('--muted', darkTheme.textMuted, 'important');
                body.style.backgroundColor = darkTheme.background;
                body.style.color = darkTheme.textPrimary;
                
                // Apply to all main containers to prevent white lines
                const mainContent = document.querySelector('.main-content');
                const contentWrapper = document.querySelector('.content-wrapper');
                const sidebar = document.querySelector('.sidebar');
                
                if (mainContent) {
                    mainContent.style.backgroundColor = darkTheme.background;
                    mainContent.style.color = darkTheme.textPrimary;
                }
                if (contentWrapper) {
                    contentWrapper.style.backgroundColor = darkTheme.background;
                    contentWrapper.style.color = darkTheme.textPrimary;
                }
                if (sidebar) {
                    sidebar.style.backgroundColor = darkTheme.sidebarBg; // Nature green sidebar
                    sidebar.style.color = darkTheme.textPrimary; // Primary text color
                }
                
                // Apply dark theme to all sections and cards
                const sections = document.querySelectorAll('.content-section, .settings-container, .profile-container');
                sections.forEach(section => {
                    section.style.backgroundColor = darkTheme.surface;
                    section.style.color = darkTheme.textPrimary;
                    section.style.borderColor = darkTheme.border;
                    section.style.borderBottom = 'none';
                    section.style.borderTop = 'none';
                    section.style.borderLeft = 'none';
                    section.style.borderRight = 'none';
                });
                
                // Apply dark theme to all cards and containers
                const cards = document.querySelectorAll('.card, .stat-card, .setting-item');
                cards.forEach(card => {
                    card.style.backgroundColor = darkTheme.surface;
                    card.style.color = darkTheme.textPrimary;
                    card.style.borderColor = darkTheme.border;
                    card.style.borderBottom = 'none';
                    card.style.borderTop = 'none';
                    card.style.borderLeft = 'none';
                    card.style.borderRight = 'none';
                });
                
                // Special handling for profile section in sidebar - maintain green theme
                const profileSection = document.querySelector('#staffProfileBtn.profile-section');
                if (profileSection) {
                    profileSection.style.backgroundColor = 'transparent'; // Blend with green sidebar
                    profileSection.style.color = '#ffffff'; // White text for readability
                    profileSection.style.borderColor = 'transparent'; // No borders
                    profileSection.style.borderBottom = 'none';
                    profileSection.style.borderTop = 'none';
                    profileSection.style.borderLeft = 'none';
                    profileSection.style.borderRight = 'none';
                    profileSection.style.border = 'none';
                }
                
                // Apply dark theme to all dropdowns and modals
                const dropdowns = document.querySelectorAll('.dropdown-menu, .modal-content');
                dropdowns.forEach(dropdown => {
                    dropdown.style.backgroundColor = '#2d2d2d';
                    dropdown.style.color = '#ffffff';
                    dropdown.style.borderColor = '#404040';
                    dropdown.style.borderBottom = 'none';
                    dropdown.style.borderTop = 'none';
                    dropdown.style.borderLeft = 'none';
                    dropdown.style.borderRight = 'none';
                });
                
                // Apply dark theme to all form elements
                const inputs = document.querySelectorAll('input, select, textarea');
                inputs.forEach(input => {
                    input.style.backgroundColor = '#333333';
                    input.style.color = '#ffffff';
                    input.style.borderColor = '#404040';
                });
                
                // Apply dark theme to all buttons
                const buttons = document.querySelectorAll('button, .btn, .compact-btn');
                buttons.forEach(button => {
                    if (!button.classList.contains('compact-btn')) {
                        button.style.backgroundColor = '#404040';
                        button.style.color = '#ffffff';
                        button.style.borderColor = '#404040';
                    }
                });
                
                // Apply dark theme to all tables
                const tables = document.querySelectorAll('table, .table');
                tables.forEach(table => {
                    table.style.backgroundColor = '#2d2d2d';
                    table.style.color = '#ffffff';
                });
                
                // Apply dark theme to all table cells
                const cells = document.querySelectorAll('td, th');
                cells.forEach(cell => {
                    cell.style.backgroundColor = '#2d2d2d';
                    cell.style.color = '#ffffff';
                    cell.style.borderColor = '#404040';
                    cell.style.borderBottom = 'none';
                    cell.style.borderTop = 'none';
                    cell.style.borderLeft = 'none';
                    cell.style.borderRight = 'none';
                });
                
                // Remove borders from dashboard title and headers
                const headers = document.querySelectorAll('h1, h2, h3, h4, h5, h6, .dashboard-title, .page-title, .section-title');
                headers.forEach(header => {
                    header.style.borderBottom = 'none';
                    header.style.borderTop = 'none';
                    header.style.borderLeft = 'none';
                    header.style.borderRight = 'none';
                    header.style.border = 'none';
                });
                
                // Remove borders from all divs and containers
                const allDivs = document.querySelectorAll('div');
                allDivs.forEach(div => {
                    if (div.classList.contains('content-section') || 
                        div.classList.contains('card') || 
                        div.classList.contains('stat-card') ||
                        div.classList.contains('dashboard-header') ||
                        div.classList.contains('page-header') ||
                        div.classList.contains('module') ||
                        div.classList.contains('delivery-fee') ||
                        div.classList.contains('pickup-area') ||
                        div.classList.contains('pickup-module') ||
                        div.classList.contains('delivery-module') ||
                        div.classList.contains('fee-module') ||
                        div.classList.contains('area-module')) {
                        div.style.borderBottom = 'none';
                        div.style.borderTop = 'none';
                        div.style.borderLeft = 'none';
                        div.style.borderRight = 'none';
                        div.style.border = 'none';
                    }
                });
                
                // Remove borders from all modules and sections
                const modules = document.querySelectorAll('.module, .delivery-fee, .pickup-area, .pickup-module, .delivery-module, .fee-module, .area-module, .dashboard-module, .content-module');
                modules.forEach(module => {
                    module.style.borderBottom = 'none';
                    module.style.borderTop = 'none';
                    module.style.borderLeft = 'none';
                    module.style.borderRight = 'none';
                    module.style.border = 'none';
                    module.style.backgroundColor = '#2d2d2d';
                    module.style.color = '#ffffff';
                });
                
                // Remove borders from all elements with common border classes
                const borderedElements = document.querySelectorAll('[class*="border"], [class*="line"], [class*="divider"]');
                borderedElements.forEach(element => {
                    element.style.borderBottom = 'none';
                    element.style.borderTop = 'none';
                    element.style.borderLeft = 'none';
                    element.style.borderRight = 'none';
                    element.style.border = 'none';
                });
                
                // Remove borders from all sections and containers
                const allSections = document.querySelectorAll('section, article, aside, header, footer, main, nav');
                allSections.forEach(section => {
                    section.style.borderBottom = 'none';
                    section.style.borderTop = 'none';
                    section.style.borderLeft = 'none';
                    section.style.borderRight = 'none';
                    section.style.border = 'none';
                });
                
                // Apply professional dark theme to ALL elements (EXCEPT SIDEBAR)
                const allElements = document.querySelectorAll('*');
                allElements.forEach(element => {
                    // Skip script, style, and meta elements
                    if (element.tagName === 'SCRIPT' || element.tagName === 'STYLE' || element.tagName === 'META' || element.tagName === 'LINK') {
                        return;
                    }
                    
                    // Skip sidebar and its children to keep it green
                    if (element.classList.contains('sidebar') || element.closest('.sidebar')) {
                        return;
                    }
                    
                    // Apply dark theme to all containers and modules
                    if (element.tagName === 'DIV' || element.tagName === 'SECTION' || element.tagName === 'ARTICLE' || 
                        element.tagName === 'ASIDE' || element.tagName === 'HEADER' || element.tagName === 'FOOTER' || 
                        element.tagName === 'MAIN' || element.tagName === 'NAV' || element.tagName === 'FORM') {
                        element.style.backgroundColor = darkTheme.surface;
                        element.style.color = darkTheme.textPrimary;
                        element.style.borderBottom = 'none';
                        element.style.borderTop = 'none';
                        element.style.borderLeft = 'none';
                        element.style.borderRight = 'none';
                        element.style.border = 'none';
                    }
                    
                    // Apply dark theme to all text elements
                    if (element.tagName === 'H1' || element.tagName === 'H2' || element.tagName === 'H3' || 
                        element.tagName === 'H4' || element.tagName === 'H5' || element.tagName === 'H6' || 
                        element.tagName === 'P' || element.tagName === 'SPAN' || element.tagName === 'LABEL') {
                        element.style.color = darkTheme.textPrimary;
                        element.style.borderBottom = 'none';
                        element.style.borderTop = 'none';
                        element.style.borderLeft = 'none';
                        element.style.borderRight = 'none';
                        element.style.border = 'none';
                    }
                    
                    // Apply dark theme to all form elements
                    if (element.tagName === 'INPUT' || element.tagName === 'SELECT' || element.tagName === 'TEXTAREA') {
                        element.style.backgroundColor = darkTheme.inputBg;
                        element.style.color = darkTheme.textPrimary;
                        element.style.borderColor = darkTheme.inputBorder;
                        element.style.borderBottom = 'none';
                        element.style.borderTop = 'none';
                        element.style.borderLeft = 'none';
                        element.style.borderRight = 'none';
                        element.style.border = 'none';
                    }
                    
                    // Apply nature-inspired dark theme to all buttons
                    if (element.tagName === 'BUTTON') {
                        element.style.backgroundColor = darkTheme.buttonPrimary;
                        element.style.color = darkTheme.buttonText;
                        element.style.borderColor = darkTheme.border;
                        element.style.borderBottom = 'none';
                        element.style.borderTop = 'none';
                        element.style.borderLeft = 'none';
                        element.style.borderRight = 'none';
                        element.style.border = 'none';
                        
                        // Add hover effect for buttons
                        element.addEventListener('mouseenter', function() {
                            if (!this.disabled) {
                                this.style.backgroundColor = darkTheme.buttonPrimaryHover;
                            }
                        });
                        element.addEventListener('mouseleave', function() {
                            if (!this.disabled) {
                                this.style.backgroundColor = darkTheme.buttonPrimary;
                            }
                        });
                    }
                    
                    // Apply dark theme to all table elements
                    if (element.tagName === 'TABLE' || element.tagName === 'TD' || element.tagName === 'TH' || 
                        element.tagName === 'TR' || element.tagName === 'THEAD' || element.tagName === 'TBODY' || 
                        element.tagName === 'TFOOT') {
                        element.style.backgroundColor = darkTheme.surface;
                        element.style.color = darkTheme.textPrimary;
                        element.style.borderBottom = 'none';
                        element.style.borderTop = 'none';
                        element.style.borderLeft = 'none';
                        element.style.borderRight = 'none';
                        element.style.border = 'none';
                    }
                    
                    // Apply dark theme to all list elements
                    if (element.tagName === 'UL' || element.tagName === 'OL' || element.tagName === 'LI') {
                        element.style.backgroundColor = darkTheme.surface;
                        element.style.color = darkTheme.textPrimary;
                        element.style.borderBottom = 'none';
                        element.style.borderTop = 'none';
                        element.style.borderLeft = 'none';
                        element.style.borderRight = 'none';
                        element.style.border = 'none';
                    }
                });
                
                // Force dark theme with maximum priority using professional palette
                document.documentElement.style.setProperty('--bg', darkTheme.background, 'important');
                document.documentElement.style.setProperty('--surface', darkTheme.surface, 'important');
                document.documentElement.style.setProperty('--surface-2', darkTheme.surfaceElevated, 'important');
                document.documentElement.style.setProperty('--text', darkTheme.textPrimary, 'important');
                document.documentElement.style.setProperty('--muted', darkTheme.textMuted, 'important');
                
                // Apply dark theme to specific problematic elements
                const problematicElements = document.querySelectorAll('.dashboard-header, .page-header, .content-header, .module-header, .section-header');
                problematicElements.forEach(element => {
                    element.style.backgroundColor = darkTheme.surface;
                    element.style.color = darkTheme.textPrimary;
                    element.style.borderBottom = 'none';
                    element.style.borderTop = 'none';
                    element.style.borderLeft = 'none';
                    element.style.borderRight = 'none';
                    element.style.border = 'none';
                });
                
                // Apply dark theme to all containers with common classes
                const containerClasses = ['.container', '.wrapper', '.content', '.main', '.section', '.panel', '.box', '.tile', '.item', '.block'];
                containerClasses.forEach(className => {
                    const elements = document.querySelectorAll(className);
                    elements.forEach(element => {
                        if (!element.closest('.sidebar')) {
                            element.style.backgroundColor = darkTheme.surface;
                            element.style.color = darkTheme.textPrimary;
                            element.style.borderBottom = 'none';
                            element.style.borderTop = 'none';
                            element.style.borderLeft = 'none';
                            element.style.borderRight = 'none';
                            element.style.border = 'none';
                        }
                    });
                });
                
                // Ensure sidebar maintains green theme
                const sidebarElements = document.querySelectorAll('.sidebar *');
                sidebarElements.forEach(element => {
                    // Keep green theme for sidebar elements
                    if (element.classList.contains('nav-item') || 
                        element.classList.contains('sidebar-link') || 
                        element.classList.contains('sidebar-menu') ||
                        element.classList.contains('profile-section')) {
                        element.style.backgroundColor = 'transparent';
                        element.style.color = '#ffffff';
                        element.style.borderBottom = 'none';
                        element.style.borderTop = 'none';
                        element.style.borderLeft = 'none';
                        element.style.borderRight = 'none';
                        element.style.border = 'none';
                    }
                });
            } else {
                body.classList.add('light-theme');
                
                // Remove all dark theme inline styles to allow light theme to show
                const allElements = document.querySelectorAll('*');
                allElements.forEach(element => {
                    // Skip script, style, and meta elements
                    if (element.tagName === 'SCRIPT' || element.tagName === 'STYLE' || element.tagName === 'META' || element.tagName === 'LINK') {
                        return;
                    }
                    
                    // Skip sidebar to keep it green
                    if (element.classList.contains('sidebar') || element.closest('.sidebar')) {
                        return;
                    }
                    
                    // Remove all dark theme inline styles
                    element.style.backgroundColor = '';
                    element.style.color = '';
                    element.style.borderColor = '';
                    element.style.borderBottom = '';
                    element.style.borderTop = '';
                    element.style.borderLeft = '';
                    element.style.borderRight = '';
                    element.style.border = '';
                });
                
                // Remove dark theme CSS variables with force
                document.documentElement.style.removeProperty('--bg');
                document.documentElement.style.removeProperty('--surface');
                document.documentElement.style.removeProperty('--surface-2');
                document.documentElement.style.removeProperty('--text');
                document.documentElement.style.removeProperty('--muted');
                body.style.removeProperty('--bg');
                body.style.removeProperty('--surface');
                body.style.removeProperty('--surface-2');
                body.style.removeProperty('--text');
                body.style.removeProperty('--muted');
                body.style.backgroundColor = '';
                body.style.color = '';
                
                // Force light theme by removing dark theme class
                body.classList.remove('dark-theme');
                document.documentElement.classList.remove('dark-theme');
            }
            
            // Save theme preference
            localStorage.setItem('theme', theme);
            
            // Force a reflow to ensure the change is applied
            body.offsetHeight;
            
            // Override any external theme handling by setting a flag
            window.manualThemeOverride = true;
            
            // Trigger a custom event for any components that need to react to theme changes
            window.dispatchEvent(new CustomEvent('themeChanged', { detail: { theme } }));
            
            // Ensure the theme persists by checking after a short delay
            setTimeout(() => {
                const currentTheme = localStorage.getItem('theme');
                if (currentTheme !== theme) {
                    applyTheme(theme);
                }
            }, 100);
        }
        function resetTheme() {
            // Clear theme preference and reset to light
            localStorage.removeItem('theme');
            applyTheme('light');
            
            // Update the select dropdown
            const themeSelect = document.querySelector('.setting-select[data-setting="theme"]');
            if (themeSelect) {
                themeSelect.value = 'light';
            }
        }

        function toggleTheme() {
            const currentTheme = localStorage.getItem('theme') || 'light';
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            applyTheme(newTheme);
        }

        function setTheme(theme) {
            
            // Set override flag to prevent external scripts from interfering
            window.manualThemeOverride = true;
            
            if (theme === 'auto') {
                // For auto theme, apply auto-theme class and let CSS handle it
                body.classList.add('auto-theme');
                body.classList.remove('dark-theme', 'light-theme');
                
                // Set up listener for system theme changes
                const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
                const handleSystemThemeChange = (e) => {
                    if (body.classList.contains('auto-theme')) {
                        // System theme changed, auto theme will update via CSS
                    }
                };
                
                mediaQuery.addEventListener('change', handleSystemThemeChange);
                
                localStorage.setItem('theme', 'auto');
            } else {
                applyTheme(theme);
            }
            
            // Force immediate visual update
            document.body.style.transition = 'none';
            setTimeout(() => {
                document.body.style.transition = '';
            }, 50);
            
            // Show feedback notification
            const themeName = theme === 'auto' ? 
                (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'Dark (Auto)' : 'Light (Auto)') :
                theme.charAt(0).toUpperCase() + theme.slice(1);
            showNotification(`Theme changed to ${themeName}`, 'success');
        }

        // Test function to manually toggle theme
        function testThemeToggle() {
            const currentTheme = localStorage.getItem('theme') || 'light';
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            setTheme(newTheme);
        }

        // Function to check current theme state
        function checkThemeState() {
            const body = document.body;
            const hasDarkClass = body.classList.contains('dark-theme');
            const hasLightClass = body.classList.contains('light-theme');
            const savedTheme = localStorage.getItem('theme');
            
            // Check computed styles
            const computedStyle = window.getComputedStyle(body);
            const bgColor = computedStyle.backgroundColor;
            const textColor = computedStyle.color;
            
            
            return {
                hasDarkClass,
                hasLightClass,
                savedTheme,
                bodyClasses: body.className,
                bgColor,
                textColor
            };
        }

        // Function to force dark theme with maximum priority
        function forceDarkTheme() {
            
            // Add dark class
            document.body.classList.add('dark-theme');
            
            // Set inline styles with maximum priority
            document.body.style.setProperty('background-color', '#1a1a1a', 'important');
            document.body.style.setProperty('color', '#ffffff', 'important');
            
            // Set CSS custom properties
            document.body.style.setProperty('--bg', '#1a1a1a', 'important');
            document.body.style.setProperty('--surface', '#2d2d2d', 'important');
            document.body.style.setProperty('--surface-2', '#333333', 'important');
            document.body.style.setProperty('--text', '#ffffff', 'important');
            document.body.style.setProperty('--muted', '#a0a0a0', 'important');
            
            // Apply to html element as well
            document.documentElement.style.setProperty('background-color', '#1a1a1a', 'important');
            document.documentElement.style.setProperty('color', '#ffffff', 'important');
        }

        // Function to test auto theme behavior
        function testAutoTheme() {
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            
            // Test setting auto theme
            localStorage.setItem('theme', 'auto');
            initializeTheme();
            
            return prefersDark;
        }
        // Function to apply dark theme to all elements (comprehensive)
        function applyDarkThemeToAll() {
            
            // Apply to body and html
            document.body.style.backgroundColor = '#1a1a1a';
            document.body.style.color = '#ffffff';
            document.documentElement.style.backgroundColor = '#1a1a1a';
            document.documentElement.style.color = '#ffffff';
            
            // Apply to all possible elements
            const allElements = document.querySelectorAll('*');
            allElements.forEach(element => {
                const tagName = element.tagName.toLowerCase();
                const className = element.className;
                
                // Skip if already styled or is a special element
                if (element.style.backgroundColor && element.style.backgroundColor !== '') {
                    return;
                }
                
                // Apply dark theme based on element type
                if (['div', 'section', 'article', 'aside', 'main', 'header', 'footer'].includes(tagName)) {
                    element.style.backgroundColor = '#2d2d2d';
                    element.style.color = '#ffffff';
                } else if (['input', 'select', 'textarea'].includes(tagName)) {
                    element.style.backgroundColor = '#333333';
                    element.style.color = '#ffffff';
                    element.style.borderColor = '#404040';
                } else if (tagName === 'button') {
                    element.style.backgroundColor = '#404040';
                    element.style.color = '#ffffff';
                    element.style.borderColor = '#404040';
                } else if (['table', 'tr', 'td', 'th'].includes(tagName)) {
                    element.style.backgroundColor = '#2d2d2d';
                    element.style.color = '#ffffff';
                    element.style.borderColor = '#404040';
                }
            });
        }

        // Chat System Functions
        let currentChatTab = 'conversations';
        let selectedConversation = null;
        
        // Helper function to normalize conversation IDs for comparison (handles type mismatches, whitespace, etc.)
        function normalizeConversationId(id) {
            if (!id) return '';
            return String(id).trim();
        }
        
        // Helper function to compare conversation IDs safely
        function conversationIdsMatch(id1, id2) {
            const normalized1 = normalizeConversationId(id1);
            const normalized2 = normalizeConversationId(id2);
            // CRITICAL: Use strict equality only - no includes() check
            // The includes() check was causing false matches (e.g. "12" matching "123")
            // This was causing the same customer to be counted multiple times in the badge
            return normalized1 === normalized2;
        }

        const FIREBASE_PUSH_CHARS = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';

        function isLikelyFirebasePushId(value) {
            if (typeof value !== 'string') {
                return false;
            }
            if (value.length !== 20) {
                return false;
            }
            if (value[0] !== '-') {
                return false;
            }
            // Firebase push IDs are typically 20 characters and only use the custom base64 alphabet
            for (let i = 0; i < value.length; i++) {
                if (!FIREBASE_PUSH_CHARS.includes(value[i])) {
                    return false;
                }
            }
            return true;
        }

        const MONTH_NAMES_REGEX = /(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)/i;
        const ISO_DATE_REGEX = /^\d{4}-\d{2}-\d{2}/;
        const SLASH_DATE_REGEX = /^\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}/;
        const DAY_MONTH_REGEX = /^\d{1,2}\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)/i;
        const TIME_ONLY_REGEX = /^\s*\d{1,2}(?::\d{2}){0,2}\s*(AM|PM)?\s*$/i;

        function hasDateIndicators(str) {
            if (!str || typeof str !== 'string') return false;
            const trimmed = str.trim();
            if (!trimmed) return false;
            if (ISO_DATE_REGEX.test(trimmed)) return true;
            if (SLASH_DATE_REGEX.test(trimmed)) return true;
            if (DAY_MONTH_REGEX.test(trimmed)) return true;
            if (MONTH_NAMES_REGEX.test(trimmed)) return true;
            if (trimmed.includes('T') || trimmed.includes('Z')) return true;
            if (/\d{4}/.test(trimmed)) return true;
            return false;
        }

        function parseTimestampString(str) {
            if (!str || typeof str !== 'string') return null;
            const trimmed = str.trim();
            if (!trimmed) return null;

            if (TIME_ONLY_REGEX.test(trimmed) && !hasDateIndicators(trimmed)) {
                return null;
            }

            const date = new Date(trimmed);
            if (!isNaN(date.getTime())) {
                return date.getTime();
            }
            return null;
        }

        function setTimestampMetadata(context, value, source) {
            if (!context || typeof context !== 'object') return;
            try {
                context.__timestampSource = source;
                context.__timestampValue = value;
            } catch (error) {
                // Non-critical: metadata is best-effort only
            }
        }

        function timestampFromFirebasePushId(pushId) {
            if (!isLikelyFirebasePushId(pushId)) {
                return null;
            }
            let timestamp = 0;
            for (let i = 0; i < 8 && i < pushId.length; i++) {
                const charIndex = FIREBASE_PUSH_CHARS.indexOf(pushId[i]);
                if (charIndex === -1) {
                    return null;
                }
                timestamp = (timestamp * 64) + charIndex;
            }
            return Number.isFinite(timestamp) && timestamp > 0 ? timestamp : null;
        }

        function getServerTimestampValue() {
            try {
                if (typeof firebase !== 'undefined' && firebase?.database?.ServerValue?.TIMESTAMP) {
                    return firebase.database.ServerValue.TIMESTAMP;
                }
            } catch (error) {
                console.warn('getServerTimestampValue: falling back to Date.now()', error);
            }
            return Date.now();
        }
        
        // CRITICAL: Centralized function to normalize timestamps to numbers
        // Handles various formats: numbers, strings, Firebase ServerValue objects, Date objects
        function normalizeTimestamp(timestamp, fallbackContext) {
            // Handle null/undefined
            if (timestamp === null || timestamp === undefined) {
                // Try fallback context first before using current time
                if (fallbackContext) {
                    const possibleId = fallbackContext.id || fallbackContext.messageId;
                    if (possibleId) {
                        const derived = normalizeTimestamp(possibleId);
                        if (derived && derived > 946684800000) { // After year 2000
                            setTimestampMetadata(fallbackContext, derived, 'derived_from_id');
                            return derived;
                        }
                    }
                }
                console.warn(' normalizeTimestamp: null/undefined timestamp, using current time');
                const fallbackNow = Date.now();
                setTimestampMetadata(fallbackContext, fallbackNow, 'fallback_now');
                return fallbackNow;
            }
            
            // If it's already a number, validate and return
            if (typeof timestamp === 'number') {
                if (!isFinite(timestamp)) {
                    console.warn(' normalizeTimestamp: Non-finite number:', timestamp);
                    if (fallbackContext) {
                        const possibleId = fallbackContext.id || fallbackContext.messageId;
                        if (possibleId) {
                            const derived = normalizeTimestamp(possibleId);
                            if (derived && derived > 946684800000) {
                                setTimestampMetadata(fallbackContext, derived, 'derived_from_id');
                                return derived;
                            }
                        }
                    }
                    const fallbackNow = Date.now();
                    setTimestampMetadata(fallbackContext, fallbackNow, 'fallback_now');
                    return fallbackNow;
                }
                // If timestamp is suspiciously small (less than year 2000 in ms), might be in seconds
                const year2000Ms = 946684800000;
                if (timestamp > 0 && timestamp < year2000Ms) {
                    // Might be in seconds, try converting
                    const asMs = timestamp * 1000;
                    if (asMs > year2000Ms && asMs < Date.now() + 86400000) { // Reasonable range
                        console.log(' normalizeTimestamp: Converted seconds to milliseconds:', timestamp, '->', asMs);
                        setTimestampMetadata(fallbackContext, asMs, 'number_seconds');
                        return asMs;
                    }
                }
                setTimestampMetadata(fallbackContext, timestamp, 'number');
                return timestamp;
            }
            
            // If it's a string, try multiple parsing strategies
            if (typeof timestamp === 'string') {
                const trimmedString = timestamp.trim();
                // First: direct numeric conversion
                const num = trimmedString ? parseFloat(trimmedString) : NaN;
                if (!isNaN(num) && isFinite(num) && num > 0) {
                    // Apply same seconds-to-milliseconds check
                    const year2000Ms = 946684800000;
                    if (num < year2000Ms) {
                        const asMs = num * 1000;
                        if (asMs > year2000Ms && asMs < Date.now() + 86400000) {
                            setTimestampMetadata(fallbackContext, asMs, 'string_seconds');
                            return asMs;
                        }
                    }
                    setTimestampMetadata(fallbackContext, num, 'string_numeric');
                    return num;
                }
                
                // Second: ISO/date string parsing (only when we detect an actual date component)
                if (hasDateIndicators(trimmedString)) {
                    const parsedDate = parseTimestampString(trimmedString);
                    if (parsedDate && parsedDate > 946684800000) {
                        setTimestampMetadata(fallbackContext, parsedDate, 'string_date');
                        return parsedDate;
                    }
                }
                
                // Third: extract numeric timestamp from string (e.g., "staff_1730987654321")
                const digitMatch = trimmedString.match(/\d{10,}/);
                if (digitMatch) {
                    const extracted = parseInt(digitMatch[0], 10);
                    if (!isNaN(extracted) && extracted > 0) {
                        // Check if needs conversion from seconds
                        const year2000Ms = 946684800000;
                        if (extracted < year2000Ms && extracted > 946684800) { // Between year 2000 in seconds and ms
                            const adjustedExtracted = extracted * 1000;
                            setTimestampMetadata(fallbackContext, adjustedExtracted, 'string_digits_seconds');
                            return adjustedExtracted;
                        }
                        setTimestampMetadata(fallbackContext, extracted, 'string_digits');
                        return extracted;
                    }
                }

                // Fourth: attempt to derive from Firebase push ID
                const derivedFromPushId = timestampFromFirebasePushId(trimmedString);
                if (derivedFromPushId && derivedFromPushId > 946684800000) {
                    setTimestampMetadata(fallbackContext, derivedFromPushId, 'push_id');
                    return derivedFromPushId;
                }
            }
            
            // If it's a Date object, convert to timestamp
            if (timestamp instanceof Date) {
                const time = timestamp.getTime();
                if (!isNaN(time)) {
                    setTimestampMetadata(fallbackContext, time, 'date_object');
                    return time;
                }
            }
            
            // If it's an object (Firebase ServerValue or similar), handle special cases
            if (typeof timestamp === 'object' && timestamp !== null) {
                // Firebase ServerValue.TIMESTAMP placeholder (should be resolved by Firebase, but handle if not)
                if (timestamp['.sv'] === 'timestamp' || timestamp._sv === 'timestamp') {
                    console.warn(' normalizeTimestamp: Unresolved ServerValue.TIMESTAMP, this should not happen');
                    // Don't use current time - try to get from context
                    if (fallbackContext) {
                        const possibleId = fallbackContext.id || fallbackContext.messageId;
                        if (possibleId) {
                            const derived = normalizeTimestamp(possibleId);
                            if (derived && derived > 946684800000) {
                                setTimestampMetadata(fallbackContext, derived, 'derived_from_id');
                                return derived;
                            }
                        }
                    }
                    const fallbackNow = Date.now();
                    setTimestampMetadata(fallbackContext, fallbackNow, 'fallback_now');
                    return fallbackNow;
                }
                
                // Try to find a numeric value in the object
                if (timestamp.value !== undefined) {
                    const value = normalizeTimestamp(timestamp.value, fallbackContext);
                    if (value && value > 946684800000) {
                        setTimestampMetadata(fallbackContext, value, 'object_value');
                        return value;
                    }
                }

                if (typeof timestamp.clientTimestamp === 'number' && timestamp.clientTimestamp > 0) {
                    const clientDerived = normalizeTimestamp(timestamp.clientTimestamp, fallbackContext);
                    if (clientDerived && clientDerived > 946684800000) {
                        setTimestampMetadata(fallbackContext, clientDerived, 'object_clientTimestamp');
                        return clientDerived;
                    }
                }
                
                // Firebase Firestore format: { seconds, nanoseconds }
                if (typeof timestamp.seconds === 'number') {
                    const ms = timestamp.seconds * 1000 + (timestamp.nanoseconds ? Math.floor(timestamp.nanoseconds / 1e6) : 0);
                    if (ms > 946684800000) {
                        setTimestampMetadata(fallbackContext, ms, 'object_firestore_seconds');
                        return ms;
                    }
                }
            }
            
            // If we have fallback context, try to derive from ID
            if (fallbackContext) {
                if (typeof fallbackContext.clientTimestamp === 'number' && fallbackContext.clientTimestamp > 0) {
                    const fromClientTs = normalizeTimestamp(fallbackContext.clientTimestamp);
                    if (fromClientTs && fromClientTs > 946684800000) {
                        setTimestampMetadata(fallbackContext, fromClientTs, 'context_clientTimestamp');
                        return fromClientTs;
                    }
                }
                const candidateStrings = [
                    fallbackContext.timestampFormatted,
                    fallbackContext.createdAtFormatted,
                    fallbackContext.sentAt,
                    fallbackContext.formattedTime,
                    fallbackContext.displayTime,
                    fallbackContext.time
                ];
                for (const candidate of candidateStrings) {
                    if (typeof candidate !== 'string') continue;
                    const trimmedCandidate = candidate.trim();
                    if (!trimmedCandidate) continue;
                    if (hasDateIndicators(trimmedCandidate)) {
                        const parsedCandidate = parseTimestampString(trimmedCandidate);
                        if (parsedCandidate && parsedCandidate > 946684800000) {
                            setTimestampMetadata(fallbackContext, parsedCandidate, 'context_string_date');
                            return parsedCandidate;
                        }
                    } else if (TIME_ONLY_REGEX.test(trimmedCandidate)) {
                        const baseFromId = fallbackContext.id ? timestampFromFirebasePushId(String(fallbackContext.id)) : null;
                        if (baseFromId && baseFromId > 946684800000) {
                            const baseDate = new Date(baseFromId);
                            if (!isNaN(baseDate.getTime())) {
                                const timeParts = trimmedCandidate.replace(/\s*(AM|PM)\s*$/i, '$1').split(':');
                                const ampmMatch = trimmedCandidate.match(/(AM|PM)$/i);
                                let hours = parseInt(timeParts[0], 10) || 0;
                                let minutes = timeParts.length >= 2 ? (parseInt(timeParts[1], 10) || 0) : 0;
                                let seconds = timeParts.length >= 3 ? (parseInt(timeParts[2], 10) || 0) : 0;
                                if (ampmMatch) {
                                    const ampm = ampmMatch[1].toUpperCase();
                                    if (ampm === 'PM' && hours < 12) {
                                        hours += 12;
                                    }
                                    if (ampm === 'AM' && hours === 12) {
                                        hours = 0;
                                    }
                                }
                                baseDate.setHours(hours, minutes, seconds, 0);
                                const combined = baseDate.getTime();
                                if (!isNaN(combined)) {
                                    setTimestampMetadata(fallbackContext, combined, 'context_string_time_combined');
                                    return combined;
                                }
                            }
                        }
                    }
                }
                const possibleId = fallbackContext.id || fallbackContext.messageId;
                if (possibleId && typeof possibleId !== 'object') {
                    let derived = null;
                    if (typeof possibleId === 'string') {
                        derived = timestampFromFirebasePushId(possibleId) || normalizeTimestamp(possibleId);
                    } else {
                        derived = normalizeTimestamp(possibleId);
                    }
                    if (derived && derived > 946684800000) {
                        setTimestampMetadata(fallbackContext, derived, 'derived_from_id');
                        console.log(' normalizeTimestamp: Derived timestamp from ID:', possibleId, '->', derived);
                        return derived;
                    }
                }
            }
            
            // Last resort: current time (with warning)
            console.warn(' normalizeTimestamp: Could not normalize, using current time. Input:', timestamp, 'Context:', fallbackContext);
            const finalFallback = Date.now();
            setTimestampMetadata(fallbackContext, finalFallback, 'fallback_now');
            return finalFallback;
        }
        
        // CRITICAL: Centralized function to sort messages chronologically (oldest first, newest last)
        // This ensures consistent ordering across the entire application
        function sortMessagesByTimestamp(messages) {
            if (!Array.isArray(messages) || messages.length === 0) {
                return messages;
            }
            
            // First, normalize all timestamps
            const messagesWithNormalizedTimestamps = messages.map(msg => {
                if (!msg) return msg;
                const normalized = normalizeTimestamp(msg.timestamp ?? msg.createdAt ?? msg.id ?? Date.now(), msg);
                return {
                    ...msg,
                    timestamp: normalized
                };
            });
            
            // Sort by timestamp (oldest first, newest last)
            const sorted = [...messagesWithNormalizedTimestamps].sort((a, b) => {
                const timestampA = a.timestamp || 0;
                const timestampB = b.timestamp || 0;
                
                // Primary sort: by timestamp
                if (timestampA !== timestampB) {
                    return timestampA - timestampB;
                }
                
                // Secondary sort: if timestamps are equal, order by sender (customer before staff)
                if (a.sender !== b.sender) {
                    return a.sender === 'customer' ? -1 : 1;
                }
                
                // Tertiary sort: if same sender and timestamp, order by id (for stability)
                const idA = String(a.id || '').localeCompare(String(b.id || ''));
                if (idA !== 0) {
                    return idA;
                }
                
                // Final sort: by text content (for complete stability)
                return String(a.text || '').localeCompare(String(b.text || ''));
            });
            
            return sorted;
        }
        
        let isChatboxOpen = false;
        // Initialize empty chatMessages object - no sample data
        let chatMessages = {};
        const ENABLE_FIREBASE_CHAT_FALLBACK = false;
        function isFirebaseChatAvailable() {
            return ENABLE_FIREBASE_CHAT_FALLBACK && isFirebaseChatAvailable();
        }
        const SUPABASE_CONVERSATION_TIMESTAMP_FIELDS = new Set([
            'lastMessageTime',
            'updatedAt',
            'archivedAt',
            'unarchivedAt',
            'deletedByStaffAt',
            'lastStaffMessageTime'
        ]);
        
        function getSupabaseClientSafe() {
            try {
                if (typeof window !== 'undefined') {
                    if (typeof window.getSupabaseClient === 'function') {
                        return window.getSupabaseClient();
                    }
                    if (window.supabaseClient) {
                        return window.supabaseClient;
                    }
                }
            } catch (error) {
                console.warn('Supabase client unavailable:', error);
            }
            return null;
        }
        
        function camelToSnakeCase(key) {
            return key.replace(/([a-z0-9])([A-Z])/g, '$1_$2').toLowerCase();
        }
        
        function toIsoTimestamp(value) {
            if (value === null || value === undefined) {
                return null;
            }
            if (typeof value === 'string' && value.includes('ServerValue')) {
                return new Date().toISOString();
            }
            if (value && typeof value === 'object' && value['.sv']) {
                return new Date().toISOString();
            }
            const date = new Date(typeof value === 'number' ? value : value);
            if (isNaN(date.getTime())) {
                return new Date().toISOString();
            }
            return date.toISOString();
        }
        
        function normalizeSupabasePayload(payload = {}, timestampFields = SUPABASE_CONVERSATION_TIMESTAMP_FIELDS, includeUpdatedAt = true) {
            const result = {};
            Object.entries(payload).forEach(([key, value]) => {
                if (value === undefined) return;
                let finalValue = value;
                if (timestampFields && timestampFields.has(key)) {
                    finalValue = value === null ? null : toIsoTimestamp(value);
                }
                result[camelToSnakeCase(key)] = finalValue;
            });
            if (includeUpdatedAt && !result.updated_at) {
                result.updated_at = new Date().toISOString();
            }
            return result;
        }
        
        function supabaseTimestampToMillis(value) {
            if (value === null || value === undefined) return null;
            if (typeof value === 'number') return value;
            const date = new Date(value);
            return isNaN(date.getTime()) ? null : date.getTime();
        }
        
        const SUPABASE_MESSAGE_TIMESTAMP_FIELDS = new Set([
            'timestamp',
            'createdAt',
            'clientTimestamp'
        ]);
        
        const supabaseConversationUuidCache = {};
        let supabaseMessageChannel = null;
        let supabaseMessageChannelConversationId = null;
        
        function mapSupabaseConversationRow(row) {
            if (!row) return null;
            const conversationId = row.customer_id || row.conversation_id;
            // Check if customer_name is a fallback format (starts with "Customer " or is just "Customer")
            let customerName = row.customer_name || 'Customer';
            const isFallbackName = customerName === 'Customer' || customerName.startsWith('Customer ');
            
            return {
                customerId: conversationId,
                customerName: customerName,
                _needsNameFetch: isFallbackName, // Flag to indicate we need to fetch the real name
                lastMessage: row.last_message || '',
                lastMessageTime: supabaseTimestampToMillis(row.last_message_time) 
                    || supabaseTimestampToMillis(row.updated_at) 
                    || Date.now(),
                lastMessageSender: row.last_message_sender || 'customer',
                unreadCount: typeof row.unread_count === 'number' ? row.unread_count : 0,
                updatedAt: supabaseTimestampToMillis(row.updated_at) || Date.now(),
                archived: row.archived === true,
                archivedAt: supabaseTimestampToMillis(row.archived_at),
                unarchivedAt: supabaseTimestampToMillis(row.unarchived_at),
                deletedByStaff: row.deleted_by_staff === true,
                deletedByStaffAt: supabaseTimestampToMillis(row.deleted_by_staff_at),
                chatType: row.chat_type || 'staff',
                riderId: row.rider_id || null,
                riderName: row.rider_name || null,
                hasUnreadStaffMessage: row.has_unread_staff_message === true,
                lastStaffMessage: row.last_staff_message || null,
                lastStaffMessageTime: supabaseTimestampToMillis(row.last_staff_message_time)
            };
        }
        
        async function supabaseFetchConversationRow(conversationId) {
            const supabase = getSupabaseClientSafe();
            if (!supabase || !conversationId) return null;
            try {
                const { data, error } = await supabase
                    .from('conversations')
                    .select('*')
                    .eq('customer_id', conversationId)
                    .maybeSingle();
                if (error && error.code !== 'PGRST116') {
                    console.warn('Supabase fetch conversation failed:', error);
                    return null;
                }
                if (data && data.conversation_id) {
                    supabaseConversationUuidCache[conversationId] = data.conversation_id;
                }
                return data || null;
            } catch (error) {
                console.warn('Supabase fetch conversation threw:', error);
                return null;
            }
        }
        
        function normalizeSupabaseMessagePayload(payload = {}) {
            return normalizeSupabasePayload(payload, SUPABASE_MESSAGE_TIMESTAMP_FIELDS, false);
        }
        
        function mapSupabaseChatMessage(row, fallbackConversationId = null) {
            if (!row) return null;
            const timestamp = supabaseTimestampToMillis(row.timestamp) 
                || supabaseTimestampToMillis(row.client_timestamp)
                || supabaseTimestampToMillis(row.created_at)
                || Date.now();
            const conversationId = fallbackConversationId || row.customer_id || row.conversation_key || row.conversation_id || null;
            const generatedId = (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function')
                ? crypto.randomUUID()
                : `msg_${Date.now()}`;
            return {
                id: row.message_id || row.id || row.firebase_id || row.external_id || generatedId,
                conversationId,
                customerId: row.customer_id || conversationId,
                sender: row.sender || 'customer',
                text: row.text || '',
                timestamp,
                createdAt: supabaseTimestampToMillis(row.created_at) || timestamp,
                clientTimestamp: supabaseTimestampToMillis(row.client_timestamp) || timestamp,
                staffId: row.staff_id || row.staff_uid || null,
                riderId: row.rider_id || null,
                isRead: row.is_read === true,
                imageUrl: row.image_url || null,
                videoUrl: row.video_url || null,
                messageType: row.message_type || 'text',
                status: row.status || 'sent',
                fromStaff: (row.sender || '').toLowerCase() === 'staff',
                staffName: row.staff_name || row.staff_display_name || null,
                staffDisplayName: row.staff_display_name || row.staff_name || null,
                staffUid: row.staff_uid || row.staff_id || null,
                messageDirection: row.message_direction || ((row.sender || '').toLowerCase() === 'staff' ? 'outgoing' : 'incoming'),
                customerDirection: row.customer_direction || ((row.sender || '').toLowerCase() === 'staff' ? 'incoming' : 'outgoing')
            };
        }
        
        async function getSupabaseConversationUuid(conversationId) {
            if (!conversationId) return null;
            if (supabaseConversationUuidCache[conversationId]) {
                return supabaseConversationUuidCache[conversationId];
            }
            const row = await supabaseFetchConversationRow(conversationId);
            if (row && row.conversation_id) {
                supabaseConversationUuidCache[conversationId] = row.conversation_id;
                return row.conversation_id;
            }
            return null;
        }
        
        async function supabaseInsertChatMessage(message) {
            const supabase = getSupabaseClientSafe();
            if (!supabase || !message || !message.conversationId) return null;
            try {
                let conversationUuid = await getSupabaseConversationUuid(message.conversationId);
                if (!conversationUuid) {
                    await supabaseUpsertConversation(message.conversationId, {
                        customerId: message.customerId || message.conversationId,
                        lastMessage: message.text,
                        lastMessageTime: message.timestamp || Date.now(),
                        lastMessageSender: message.sender || 'staff'
                    });
                    conversationUuid = await getSupabaseConversationUuid(message.conversationId);
                }
                
                if (!conversationUuid) {
                    console.warn('Supabase conversation UUID missing, cannot insert chat message');
                    return null;
                }
                
                const insertPayload = normalizeSupabaseMessagePayload({
                    messageId: message.id,
                    conversationId: conversationUuid,
                    customerId: message.customerId || message.conversationId,
                    sender: message.sender || 'staff',
                    text: message.text || '',
                    staffId: message.staffId || message.staffUid || null,
                    staffName: message.staffName || null,
                    staffDisplayName: message.staffDisplayName || null,
                    riderId: message.riderId || null,
                    riderName: message.riderName || null,
                    imageUrl: message.imageUrl || null,
                    videoUrl: message.videoUrl || null,
                    isRead: message.isRead === true,
                    timestamp: message.clientTimestamp || message.timestamp || Date.now(),
                    createdAt: message.createdAt || message.timestamp || Date.now()
                });
                
                const { data, error } = await supabase
                    .from('chat_messages')
                    .insert(insertPayload)
                    .select()
                    .maybeSingle();
                
                if (error) {
                    console.warn('Supabase insert chat message failed:', error);
                    return null;
                }
                return data;
            } catch (error) {
                console.warn('Supabase insert chat message threw:', error);
                return null;
            }
        }
        
        async function supabaseFetchMessages(conversationId, options = {}) {
            const supabase = getSupabaseClientSafe();
            if (!supabase || !conversationId) return null;
            try {
                const conversationUuid = await getSupabaseConversationUuid(conversationId);
                if (!conversationUuid) {
                    console.warn('Supabase conversation UUID missing for messages fetch:', conversationId);
                    return [];
                }
                
                let query = supabase
                    .from('chat_messages')
                    .select('*')
                    .eq('conversation_id', conversationUuid)
                    .order('timestamp', { ascending: true });
                
                if (options.limit) {
                    query = query.limit(options.limit);
                }
                
                const { data, error } = await query;
                if (error) {
                    console.warn('Supabase fetch messages failed:', error);
                    return null;
                }
                return (data || []).map(row => mapSupabaseChatMessage(row, conversationId));
            } catch (error) {
                console.warn('Supabase fetch messages threw:', error);
                return null;
            }
        }
        
        function unsubscribeFromSupabaseChatMessages() {
            try {
                if (supabaseMessageChannel && typeof supabaseMessageChannel.unsubscribe === 'function') {
                    supabaseMessageChannel.unsubscribe();
                }
            } catch (error) {
                console.warn('Error unsubscribing from Supabase chat channel:', error);
            } finally {
                supabaseMessageChannel = null;
                supabaseMessageChannelConversationId = null;
            }
        }
        
        async function subscribeToSupabaseChatMessages(conversationId) {
            const supabase = getSupabaseClientSafe();
            if (!supabase || !conversationId) return null;
            if (supabaseMessageChannelConversationId === conversationId && supabaseMessageChannel) {
                return supabaseMessageChannel;
            }
            
            unsubscribeFromSupabaseChatMessages();
            
            const conversationUuid = await getSupabaseConversationUuid(conversationId);
            if (!conversationUuid) {
                console.warn('Supabase conversation UUID missing, cannot subscribe to chat messages');
                return null;
            }
            
            const filter = `conversation_id=eq.${conversationUuid}`;
            const channelName = `staff-chat-${conversationUuid}`;
            
            const channel = supabase
                .channel(channelName)
                .on('postgres_changes', { 
                    event: 'INSERT', 
                    schema: 'public', 
                    table: 'chat_messages', 
                    filter 
                }, (payload) => {
                    console.log('[Supabase] INSERT event received:', payload);
                    if (!payload?.new) return;
                    const mapped = mapSupabaseChatMessage(payload.new, conversationId);
                    if (mapped) {
                        console.log('[Supabase] Adding message to conversation via real-time:', mapped);
                        addMessageToConversation(conversationId, mapped);
                    }
                })
                .on('postgres_changes', { 
                    event: 'UPDATE', 
                    schema: 'public', 
                    table: 'chat_messages', 
                    filter 
                }, (payload) => {
                    console.log('[Supabase] UPDATE event received:', payload);
                    if (!payload?.new) return;
                    const mapped = mapSupabaseChatMessage(payload.new, conversationId);
                    if (mapped) {
                        console.log('[Supabase] Updating message in conversation via real-time:', mapped);
                        updateMessageInConversation(conversationId, mapped);
                    }
                })
                .subscribe((status) => {
                    console.log('[Supabase] Chat message channel status:', status, 'conversation:', conversationId);
                    if (status === 'SUBSCRIBED') {
                        console.log('[Supabase]  Successfully subscribed to chat messages for conversation:', conversationId);
                    } else if (status === 'CHANNEL_ERROR') {
                        console.error('[Supabase]  Channel error - subscription failed for conversation:', conversationId);
                        // Retry subscription after a delay
                        setTimeout(() => {
                            console.log('[Supabase] Retrying subscription...');
                            subscribeToSupabaseChatMessages(conversationId);
                        }, 2000);
                    }
                });
            
            supabaseMessageChannel = channel;
            supabaseMessageChannelConversationId = conversationId;
            return channel;
        }
        
        async function resolveConversationCustomerName(conversationId, payload = {}) {
            if (!conversationId) {
                return 'Customer';
            }
            
            const tryNormalize = (value) => {
                if (typeof value !== 'string') return null;
                const trimmed = value.trim();
                return trimmed || null;
            };
            
            let resolved = null;
            
            // 1. Use any provided customer name in the payload
            if (payload) {
                resolved = tryNormalize(
                    payload.customerName ||
                    payload.customer_name ||
                    payload.customer?.fullName ||
                    payload.customer?.name
                );
            }
            
            // 2. Check the in-memory cache
            if (!resolved && window.customerNameCache && window.customerNameCache[conversationId]) {
                resolved = tryNormalize(window.customerNameCache[conversationId]);
            }
            
            // 3. Ask Supabase/Firebase helpers
            if (!resolved) {
                try {
                    const fetchedName = await getCustomerName(conversationId);
                    resolved = tryNormalize(fetchedName);
                } catch (error) {
                    console.warn('resolveConversationCustomerName: failed to fetch name:', error);
                }
            }
            
            // 4. Ensure we always pass a non-null value for not-null constraint
            return resolved || 'Customer';
        }
        
        async function supabaseInsertConversation(conversationId, payload = {}) {
            const supabase = getSupabaseClientSafe();
            if (!supabase || !conversationId) return false;
            
            // Ensure required fields for NOT NULL constraints
            const basePayload = { ...payload };
            
            // Always set customerId for the row key
            if (!basePayload.customerId && !basePayload.customer_id) {
                basePayload.customerId = conversationId;
            }
            
            // Ensure chatType is present  staff dashboard always uses staff chat
            if (!basePayload.chatType && !basePayload.chat_type) {
                basePayload.chatType = 'staff';
            }
            
            // Ensure customerName is not null (use resolver + safe fallback)
            if (!basePayload.customerName && !basePayload.customer_name) {
                basePayload.customerName = await resolveConversationCustomerName(conversationId, basePayload);
            }
            
            const insertPayload = normalizeSupabasePayload(basePayload);
            try {
                const { error } = await supabase.from('conversations').insert(insertPayload);
                if (error) {
                    console.warn('Supabase insert conversation failed:', error);
                    return false;
                }
                return true;
            } catch (error) {
                console.warn('Supabase insert conversation threw:', error);
                return false;
            }
        }
        
        async function supabaseUpdateConversation(conversationId, payload = {}) {
            const supabase = getSupabaseClientSafe();
            if (!supabase || !conversationId) return false;
            const updatePayload = normalizeSupabasePayload(payload);
            try {
                const { error } = await supabase
                    .from('conversations')
                    .update(updatePayload)
                    .eq('customer_id', conversationId);
                if (error) {
                    console.warn('Supabase update conversation failed:', error);
                    return false;
                }
                return true;
            } catch (error) {
                console.warn('Supabase update conversation threw:', error);
                return false;
            }
        }
        
        async function supabaseUpsertConversation(conversationId, payload = {}) {
            const existing = await supabaseFetchConversationRow(conversationId);
            if (existing) {
                return supabaseUpdateConversation(conversationId, payload);
            }
            
            const finalPayload = { ...payload };
            if (!finalPayload.customerName && !finalPayload.customer_name) {
                finalPayload.customerName = await resolveConversationCustomerName(conversationId, finalPayload);
            }
            
            return supabaseInsertConversation(conversationId, finalPayload);
        }
        
        async function supabaseFetchConversationsMap(options = {}) {
            const supabase = getSupabaseClientSafe();
            if (!supabase) return null;
            try {
                let query = supabase
                    .from('conversations')
                    .select('*')
                    .order('updated_at', { ascending: false });
                
                if (options.archived === true) {
                    query = query.eq('archived', true);
                } else if (options.archived === false) {
                    query = query.or('archived.is.null,archived.eq.false');
                }
                
                if (options.excludeDeleted !== false) {
                    query = query.or('deleted_by_staff.is.null,deleted_by_staff.eq.false');
                }
                
                if (options.chatType) {
                    query = query.eq('chat_type', options.chatType);
                }
                
                const { data, error } = await query;
                if (error) {
                    console.warn('Supabase conversation fetch failed:', error);
                    return null;
                }
                
                const mapped = {};
                const nameFetches = [];
                
                (data || []).forEach((row) => {
                    const mappedRow = mapSupabaseConversationRow(row);
                    if (mappedRow && mappedRow.customerId) {
                        mapped[mappedRow.customerId] = mappedRow;
                        
                        // If this conversation needs a name fetch, queue it
                        // But try CustomerHelpers first as it might bypass RLS
                        if (mappedRow._needsNameFetch) {
                            nameFetches.push(async () => {
                                try {
                                    let realName = null;
                                    
                                    // First try CustomerHelpers (might bypass RLS)
                                    if (window.CustomerHelpers && typeof window.CustomerHelpers.getCustomer === 'function') {
                                        try {
                                            const customerData = await window.CustomerHelpers.getCustomer(mappedRow.customerId);
                                            if (customerData) {
                                                realName = customerData.fullName || 
                                                          customerData.full_name ||
                                                          (customerData.firstName && customerData.lastName ? 
                                                           `${customerData.firstName} ${customerData.lastName}` : null) ||
                                                          (customerData.first_name && customerData.last_name ? 
                                                           `${customerData.first_name} ${customerData.last_name}` : null) ||
                                                          customerData.name;
                                            }
                                        } catch (helperError) {
                                            console.warn('CustomerHelpers.getCustomer failed:', helperError);
                                        }
                                    }
                                    
                                    // If CustomerHelpers didn't work, try getCustomerName (which tries Supabase)
                                    if (!realName || realName === 'Customer' || realName.startsWith('Customer ')) {
                                        realName = await getCustomerName(mappedRow.customerId);
                                    }
                                    
                                    if (realName && realName !== 'Customer' && !realName.startsWith('Customer ')) {
                                        // Update the mapped row
                                        mapped[mappedRow.customerId].customerName = realName;
                                        mapped[mappedRow.customerId]._needsNameFetch = false;
                                        
                                        // Update Supabase conversations table
                                        const supabase = getSupabaseClientSafe();
                                        if (supabase) {
                                            const { error } = await supabase
                                                .from('conversations')
                                                .update({ customer_name: realName })
                                                .eq('customer_id', mappedRow.customerId);
                                            
                                            if (error) {
                                                console.warn('Error updating customer_name:', error);
                                            }
                                        }
                                        
                                        // Update UI if this conversation is visible
                                        const conversationItem = document.querySelector(`.conversation-item[data-conversation-id="${mappedRow.customerId}"]`);
                                        if (conversationItem) {
                                            const nameElement = conversationItem.querySelector('.conversation-name');
                                            if (nameElement) {
                                                nameElement.textContent = realName;
                                            }
                                        }
                                    }
                                } catch (error) {
                                    console.warn('Error fetching customer name for conversation:', mappedRow.customerId, error);
                                }
                            });
                        }
                    }
                });
                
                // Fetch all names in parallel (but don't wait - return immediately)
                if (nameFetches.length > 0) {
                    Promise.all(nameFetches.map(fetch => fetch())).then(() => {
                        console.log(` Fetched ${nameFetches.length} customer names and updated conversations`);
                    }).catch(err => {
                        console.warn('Error fetching customer names:', err);
                    });
                }
                
                return mapped;
            } catch (error) {
                console.warn('Supabase conversation fetch threw:', error);
                return null;
            }
        }
        
        async function subscribeToSupabaseConversationChanges() {
            try {
                const supabase = getSupabaseClientSafe();
                if (!supabase) return null;
                if (window.__supabaseConvoChannel) {
                    return window.__supabaseConvoChannel;
                }
                const channel = supabase
                    .channel('staff-dashboard-conversations')
                    .on('postgres_changes', { event: '*', schema: 'public', table: 'conversations' }, () => {
                        if (currentConversationTab === 'archived') {
                            loadArchivedConversations();
                        } else {
                            loadActiveConversations();
                        }
                        if (typeof updateBadgeCount === 'function') {
                            updateBadgeCount(true);
                        }
                    })
                    .subscribe((status) => {
                        console.log('[Supabase] Conversation channel status:', status);
                    });
                window.__supabaseConvoChannel = channel;
                return channel;
            } catch (error) {
                console.warn('Supabase realtime subscription failed:', error);
                return null;
            }
        }
        
        function unsubscribeFromSupabaseConversationChanges() {
            try {
                if (window.__supabaseConvoChannel && typeof window.__supabaseConvoChannel.unsubscribe === 'function') {
                    window.__supabaseConvoChannel.unsubscribe();
                }
            } catch (error) {
                console.warn('Error unsubscribing from Supabase channel:', error);
            } finally {
                window.__supabaseConvoChannel = null;
            }
        }
        
        // Global subscription for ALL chat messages - ensures we catch messages even if conversation-specific subscription fails
        async function subscribeToAllSupabaseChatMessages() {
            try {
                const supabase = getSupabaseClientSafe();
                if (!supabase) return null;
                if (window.__supabaseGlobalChatChannel) {
                    return window.__supabaseGlobalChatChannel;
                }
                
                const channel = supabase
                    .channel('staff-dashboard-all-chat-messages')
                    .on('postgres_changes', { 
                        event: 'INSERT', 
                        schema: 'public', 
                        table: 'chat_messages' 
                    }, async (payload) => {
                        console.log('[Supabase] Global INSERT event received:', payload);
                        if (!payload?.new) return;
                        
                        // Get conversation ID from the message
                        let customerId = payload.new.customer_id;
                        const conversationUuid = payload.new.conversation_id;
                        
                        // If customer_id is not available, fetch it from conversations table using conversation_id
                        if (!customerId && conversationUuid) {
                            // Try cache first
                            for (const [key, uuid] of Object.entries(supabaseConversationUuidCache)) {
                                if (uuid === conversationUuid) {
                                    customerId = key;
                                    break;
                                }
                            }
                            
                            // If not in cache, fetch from Supabase
                            if (!customerId) {
                                try {
                                    const supabase = getSupabaseClientSafe();
                                    if (supabase) {
                                        const { data: convData, error: convError } = await supabase
                                            .from('conversations')
                                            .select('customer_id')
                                            .eq('conversation_id', conversationUuid)
                                            .maybeSingle();
                                        
                                        if (!convError && convData && convData.customer_id) {
                                            customerId = convData.customer_id;
                                            // Cache it for future use
                                            supabaseConversationUuidCache[customerId] = conversationUuid;
                                            console.log('[Supabase] Fetched customer_id from conversations table:', customerId);
                                        }
                                    }
                                } catch (error) {
                                    console.warn('[Supabase] Error fetching conversation ID:', error);
                                }
                            }
                        }
                        
                        if (customerId) {
                            const mapped = mapSupabaseChatMessage(payload.new, customerId);
                            if (mapped) {
                                console.log('[Supabase] Global subscription: Adding message to conversation:', customerId, 'Sender:', mapped.sender);
                                addMessageToConversation(customerId, mapped);
                            } else {
                                console.warn('[Supabase] Failed to map message:', payload.new);
                            }
                        } else {
                            console.warn('[Supabase] Could not determine conversation ID for message:', payload.new);
                        }
                    })
                    .on('postgres_changes', { 
                        event: 'UPDATE', 
                        schema: 'public', 
                        table: 'chat_messages' 
                    }, async (payload) => {
                        console.log('[Supabase] Global UPDATE event received:', payload);
                        if (!payload?.new) return;
                        
                        let customerId = payload.new.customer_id;
                        const conversationUuid = payload.new.conversation_id;
                        
                        // If customer_id is not available, fetch it from conversations table using conversation_id
                        if (!customerId && conversationUuid) {
                            // Try cache first
                            for (const [key, uuid] of Object.entries(supabaseConversationUuidCache)) {
                                if (uuid === conversationUuid) {
                                    customerId = key;
                                    break;
                                }
                            }
                            
                            // If not in cache, fetch from Supabase
                            if (!customerId) {
                                try {
                                    const supabase = getSupabaseClientSafe();
                                    if (supabase) {
                                        const { data: convData, error: convError } = await supabase
                                            .from('conversations')
                                            .select('customer_id')
                                            .eq('conversation_id', conversationUuid)
                                            .maybeSingle();
                                        
                                        if (!convError && convData && convData.customer_id) {
                                            customerId = convData.customer_id;
                                            // Cache it for future use
                                            supabaseConversationUuidCache[customerId] = conversationUuid;
                                            console.log('[Supabase] Fetched customer_id from conversations table (UPDATE):', customerId);
                                        }
                                    }
                                } catch (error) {
                                    console.warn('[Supabase] Error fetching conversation ID (UPDATE):', error);
                                }
                            }
                        }
                        
                        if (customerId) {
                            const mapped = mapSupabaseChatMessage(payload.new, customerId);
                            if (mapped) {
                                console.log('[Supabase] Global subscription: Updating message in conversation:', customerId, 'Sender:', mapped.sender);
                                updateMessageInConversation(customerId, mapped);
                            } else {
                                console.warn('[Supabase] Failed to map message (UPDATE):', payload.new);
                            }
                        } else {
                            console.warn('[Supabase] Could not determine conversation ID for message (UPDATE):', payload.new);
                        }
                    })
                    .subscribe((status) => {
                        console.log('[Supabase] Global chat messages channel status:', status);
                        if (status === 'SUBSCRIBED') {
                            console.log('[Supabase]  Successfully subscribed to ALL chat messages globally');
                        } else if (status === 'CHANNEL_ERROR') {
                            console.error('[Supabase]  Global chat channel error - retrying...');
                            setTimeout(() => {
                                window.__supabaseGlobalChatChannel = null;
                                subscribeToAllSupabaseChatMessages();
                            }, 3000);
                        }
                    });
                
                window.__supabaseGlobalChatChannel = channel;
                return channel;
            } catch (error) {
                console.warn('Supabase global chat messages subscription failed:', error);
                return null;
            }
        }
        
        function unsubscribeFromAllSupabaseChatMessages() {
            try {
                if (window.__supabaseGlobalChatChannel && typeof window.__supabaseGlobalChatChannel.unsubscribe === 'function') {
                    window.__supabaseGlobalChatChannel.unsubscribe();
                }
            } catch (error) {
                console.warn('Error unsubscribing from global Supabase chat channel:', error);
            } finally {
                window.__supabaseGlobalChatChannel = null;
            }
        }
        // Flag to prevent value listener from overwriting messages during optimistic rendering
        let isRenderingOptimisticMessage = false;
        let optimisticRenderTime = 0;
        
        // Enable timestamp debugging by setting this to true in console:
        // window.DEBUG_TIMESTAMPS = true;
        // This will log all timestamp conversions to help diagnose display issues
        if (typeof window.DEBUG_TIMESTAMPS === 'undefined') {
            window.DEBUG_TIMESTAMPS = false;
        }

        function toggleChatBox() {
            console.log('Toggle chatbox clicked');
            const overlay = document.getElementById('chatboxOverlay');
            console.log('Overlay found:', overlay);
            const isOpen = overlay ? overlay.classList.contains('active') : false;
            console.log('Is open:', isOpen);
            
            if (isOpen) {
                closeChatBox();
            } else {
                openChatBox();
            }
        }
        window.toggleChatBox = toggleChatBox;
        // skipInit: if true, don't reset UI (used when opening directly to a customer)
        function openChatBox(skipInit = false) {
            console.log('Opening chatbox... skipInit:', skipInit);
            isChatboxOpen = true;
            const overlay = document.getElementById('chatboxOverlay');
            console.log('Overlay element:', overlay);
            if (overlay) {
                overlay.classList.add('active');
                document.body.style.overflow = 'hidden';
                console.log('Chatbox opened successfully');
                
                // CRITICAL: If there's a selected conversation when opening chatbox, mark it as read immediately
                // This handles the case where user opens chatbox with an already-selected conversation
                if (selectedConversation) {
                    console.log(' Chatbox opened with conversation already selected:', selectedConversation);
                    console.log('Marking this conversation as read immediately...');
                    // Use setTimeout to ensure this runs after the chatbox is fully open
                    setTimeout(() => {
                        if (selectedConversation && typeof markConversationAsRead === 'function') {
                            markConversationAsRead(selectedConversation).then(() => {
                                console.log(' Selected conversation marked as read on chatbox open');
                                updateBadgeCount(true);
                            });
                        }
                    }, 100);
                }
                
                // CRITICAL: Initialize chat input handlers when chat box is opened
                // This ensures event handlers are attached to the input field
                if (typeof initializeChat === 'function') {
                    initializeChat();
                    console.log('Initialized chat input handlers');
                } else {
                    console.warn('initializeChat function not found');
                }
                
                try {
                    // Default to Active tab
                    // CRITICAL: If skipInit is true, don't reset UI
                    // Otherwise, always initialize with "Select a conversation"
                    if (typeof switchConversationTab === 'function') {
                        if (skipInit) {
                            console.log(' Skipping switchConversationTab - opening directly to customer');
                            // Just update the tab to active without resetting UI
                            currentConversationTab = 'active';
                        } else {
                            // Normal chatbox open - show "Select a conversation"
                            switchConversationTab('active');
                        }
                    }
                    
                    // Check if conversations are already loaded
                    const list = document.getElementById('conversationsList');
                    const hasConversations = list && list.querySelectorAll('.conversation-item').length > 0;
                    
                    if (!hasConversations) {
                        // Load conversations silently without showing loading message
                        // Just keep the list empty and load in background
                        if (typeof loadActiveConversations === 'function') {
                            console.log('Kickoff: calling loadActiveConversations() silently');
                            try { 
                                loadActiveConversations(); 
                            } catch(e) { 
                                console.warn('loadActiveConversations threw', e); 
                            }
                        }
                    } else {
                        console.log('Conversations already loaded, skipping reload');
                    }
                    // Start realtime listener if not already active
                    const supabaseChannel = subscribeToSupabaseConversationChanges();
                    // Start global chat messages subscription for real-time updates
                    subscribeToAllSupabaseChatMessages();
                    if (!supabaseChannel) {
                        if (isFirebaseChatAvailable()) {
                            if (!window.__conversationsListener) {
                                const ref = firebase.database().ref('conversations');
                                window.__conversationsListener = ref;
                                ref.on('value', async (snapshot) => {
                                    const data = snapshot.val() || {};
                                    const active = {};
                                    Object.keys(data).forEach(id => {
                                        const c = data[id] || {};
                                        if (c.archived !== true) active[id] = c;
                                    });
                                    try {
                                        if (typeof updateConversationList === 'function') {
                                            await updateConversationList(active);
                                        }
                                        if (typeof updateBadgeCount === 'function') {
                                            updateBadgeCount();
                                        }
                                    } catch(e) { console.warn('Realtime updateConversationList error', e); }
                                });
                            }
                        } else {
                            // Retry attaching realtime listener until Firebase is ready
                            (function ensureRealtime(attempt){
                                const maxAttempts = 10;
                                if (isFirebaseChatAvailable()) {
                                    if (!window.__conversationsListener) {
                                        const ref = firebase.database().ref('conversations');
                                        window.__conversationsListener = ref;
                                        ref.on('value', async (snapshot) => {
                                            const data = snapshot.val() || {};
                                            const active = {};
                                            Object.keys(data).forEach(id => { const c = data[id] || {}; if (c.archived !== true) active[id] = c; });
                                            try {
                                                if (typeof updateConversationList === 'function') { await updateConversationList(active); }
                                                if (typeof updateBadgeCount === 'function') { updateBadgeCount(); }
                                            } catch(e) { console.warn('Realtime updateConversationList error', e); }
                                        });
                                    }
                                    return;
                                }
                                if (attempt >= maxAttempts) { console.warn('Realtime listener attach failed: firebase not ready'); return; }
                                setTimeout(() => ensureRealtime(attempt + 1), 500);
                            })(0);
                        }
                    }

                    // Removed redundant secondary retry - already handled above

                    // Final watchdog: if still showing Loading after 2.5s, derive list from messages and render
                    setTimeout(async () => {
                        try {
                            const listEl = document.getElementById('conversationsList');
                            const stillLoading = !!listEl && /Loading conversations/i.test(listEl.textContent || '');
                            if (!stillLoading) return;
                            if (!(isFirebaseChatAvailable())) return;
                            console.warn('Watchdog: conversations still loading, deriving from messages trees');
                            const db = firebase.database();
                            const [cmSnap, custSnap] = await Promise.all([
                                db.ref('chatMessages').once('value').catch(() => null),
                                db.ref('customerMessages').once('value').catch(() => null)
                            ]);
                            const cm = (cmSnap && cmSnap.val()) || {};
                            const cust = (custSnap && custSnap.val()) || {};
                            const derived = {};
                            const addMsg = (m) => {
                                if (!m || !m.conversationId) return;
                                const cid = String(m.conversationId);
                                const prev = derived[cid] || { lastMessageTime: 0, lastMessage: '', archived: false };
                                const ts = m.timestamp || 0;
                                if (ts >= (prev.lastMessageTime||0)) {
                                    prev.lastMessageTime = ts;
                                    prev.lastMessage = m.text || '';
                                }
                                derived[cid] = prev;
                            };
                            Object.values(cm).forEach(addMsg);
                            Object.keys(cust).forEach(cid => {
                                const msgs = cust[cid] || {};
                                Object.values(msgs).forEach(addMsg);
                            });
                            if (Object.keys(derived).length > 0) {
                                console.log('Watchdog: rendering derived conversations from messages:', Object.keys(derived));
                                try { await updateConversationList(derived); } catch(e) { console.warn('Watchdog updateConversationList error', e); }
                            } else if (listEl) {
                                listEl.innerHTML = '<div class="no-conversations">No active conversations</div>';
                            }
                        } catch (e) { console.warn('Watchdog derive failed', e); }
                    }, 2500);

                    // Realtime list builder from chatMessages and customerMessages (fallback source)
                    try {
                        if (!window.__chatMessagesListListener) {
                            let isBuilding = false;
                            let buildTimeout = null;
                            
                            const buildFromMessages = async () => {
                                // Prevent infinite loops and concurrent builds
                                if (isBuilding) {
                                    console.log('buildFromMessages already in progress, skipping...');
                                    return;
                                }
                                
                                isBuilding = true;
                                try {
                                    if (!(isFirebaseChatAvailable())) {
                                        isBuilding = false;
                                        return;
                                    }
                                    
                                    const db = firebase.database();
                                    const [cmSnap, custSnap] = await Promise.all([
                                        db.ref('chatMessages').once('value').catch(() => null),
                                        db.ref('customerMessages').once('value').catch(() => null)
                                    ]);
                                    const cm = (cmSnap && cmSnap.val()) || {};
                                    const cust = (custSnap && custSnap.val()) || {};
                                    const derived = {};
                                    
                                    const addMsg = (m, conversationId) => {
                                        if (!m) return;
                                        const cid = String(conversationId || m.conversationId);
                                        if (!cid) return;
                                        
                                        // CRITICAL: Filter out rider-customer conversations
                                        const isRiderConversation = (m.chatType === 'rider') || cid.includes('_rider_');
                                        if (isRiderConversation) {
                                            return; // Skip this message
                                        }
                                        
                                        const prev = derived[cid] || { 
                                            lastMessageTime: 0, 
                                            lastMessage: '', 
                                            lastMessageSender: '',
                                            archived: false,
                                            customerId: cid,
                                            customerName: m.customerName || null
                                        };
                                        const ts = m.timestamp || 0;
                                        if (ts >= (prev.lastMessageTime||0)) {
                                            prev.lastMessageTime = ts;
                                            prev.lastMessage = m.text || '';
                                            prev.lastMessageSender = m.sender || '';
                                            if (m.customerName && !prev.customerName) {
                                                prev.customerName = m.customerName;
                                            }
                                        }
                                        derived[cid] = prev;
                                    };
                                    
                                    // Process chatMessages
                                    Object.values(cm).forEach(m => addMsg(m));
                                    
                                    // Process customerMessages/{conversationId}
                                    Object.keys(cust).forEach(cid => {
                                        // CRITICAL: Skip if conversation ID indicates it's a rider conversation
                                        if (cid.includes('_rider_')) {
                                            return; // Skip this conversation
                                        }
                                        const msgs = cust[cid] || {}; 
                                        Object.values(msgs).forEach(m => addMsg(m, cid)); 
                                    });
                                    
                                    if (Object.keys(derived).length > 0) {
                                        // Only update conversation metadata if conversations don't exist
                                        // This prevents triggering the listeners unnecessarily
                                        const conversationUpdates = {};
                                        const conversationsRef = db.ref('conversations');
                                        const existingConversations = await conversationsRef.once('value').catch(() => ({ val: () => null }));
                                        const existing = existingConversations.val() || {};
                                        
                                        for (const [cid, conv] of Object.entries(derived)) {
                                            // CRITICAL: Skip rider-customer conversations
                                            if (cid.includes('_rider_')) {
                                                console.log(`Skipping ${cid} - it's a rider conversation`);
                                                continue;
                                            }
                                            
                                            // Check if conversation already exists or is tombstoned
                                            const convRef = db.ref(`conversations/${cid}`);
                                            const convSnap = await convRef.once('value');
                                            const tombstoneSnap = await db.ref(`deletedConversations/${cid}`).once('value').catch(()=>null);
                                            const isTombstoned = tombstoneSnap && tombstoneSnap.exists();
                                            
                                            if (isTombstoned) {
                                                console.log(`Skipping ${cid} - tombstoned (hard-deleted previously)`);
                                                continue;
                                            } else if (convSnap.exists()) {
                                                const convData = convSnap.val();
                                                
                                                // CRITICAL: Skip rider conversations
                                                const chatType = convData.chatType || 'staff';
                                                if (chatType === 'rider') {
                                                    console.log(`Skipping ${cid} - it's a rider conversation (chatType: ${chatType})`);
                                                    continue;
                                                }
                                                
                                                // If marked as deleted by staff, skip it from staff view
                                                if (convData.deletedByStaff === true) {
                                                    console.log(`Skipping ${cid} - marked as deleted by staff`);
                                                    continue;
                                                }
                                                // Update existing conversation (preserve deletedByStaff flag if it exists)
                                                conversationUpdates[`conversations/${cid}`] = {
                                                    ...convData, // Preserve existing data
                                                    customerId: conv.customerId || cid,
                                                    customerName: conv.customerName || convData.customerName || null,
                                                    lastMessage: conv.lastMessage,
                                                    lastMessageTime: conv.lastMessageTime,
                                                    lastMessageSender: conv.lastMessageSender,
                                                    updatedAt: Date.now()
                                                };
                                            } else {
                                                // Create new conversation metadata (not deleted)
                                                conversationUpdates[`conversations/${cid}`] = {
                                                    customerId: conv.customerId || cid,
                                                    customerName: conv.customerName || null,
                                                    lastMessage: conv.lastMessage,
                                                    lastMessageTime: conv.lastMessageTime,
                                                    lastMessageSender: conv.lastMessageSender,
                                                    unreadCount: 0,
                                                    updatedAt: Date.now(),
                                                    archived: false
                                                };
                                            }
                                        }
                                        
                                        if (Object.keys(conversationUpdates).length > 0) {
                                            await db.ref().update(conversationUpdates).catch(err => {
                                                console.warn('Error updating conversation metadata:', err);
                                            });
                                        }
                                        
                                        // Only update list if we're on the active tab and chatbox is open
                                        if (isChatboxOpen && currentConversationTab === 'active' && typeof updateConversationList === 'function') {
                                            await updateConversationList(derived);
                                        }
                                    }
                                } catch (e) { 
                                    console.warn('Realtime list build from messages failed', e); 
                                } finally {
                                    isBuilding = false;
                                }
                            };
                            
                            // Debounced handler to prevent rapid-fire calls
                            const handler = () => {
                                if (buildTimeout) {
                                    clearTimeout(buildTimeout);
                                }
                                buildTimeout = setTimeout(() => {
                                    buildFromMessages();
                                }, 1000); // Debounce by 1 second
                            };
                            
                            // initial build (only once)
                            buildFromMessages();
                            
                            // attach listeners
                            const db = firebase.database();
                            const cmRef = db.ref('chatMessages');
                            const custRef = db.ref('customerMessages');
                            cmRef.on('child_added', handler);
                            cmRef.on('child_changed', handler);
                            custRef.on('child_added', handler);
                            custRef.on('child_changed', handler);
                            window.__chatMessagesListListener = { cmRef, custRef, handler };
                        }
                    } catch(_) {}
                } catch(e) { console.warn('Chat load init error:', e); }
            } else {
                console.error('Chatbox overlay not found!');
            }
        }
        window.openChatBox = openChatBox;

        function closeChatBox() {
            console.log('Closing chatbox...');
            isChatboxOpen = false;
            const overlay = document.getElementById('chatboxOverlay');
            if (overlay) {
                overlay.classList.remove('active');
                document.body.style.overflow = '';
                console.log('Chatbox closed successfully');
            }
            
            // Clear message polling interval when chatbox is closed
            if (window.__messageRefreshInterval) {
                clearInterval(window.__messageRefreshInterval);
                window.__messageRefreshInterval = null;
                console.log('Cleared message polling interval');
            }
            
            // Detach realtime listener when closing to avoid duplicates
            try {
                if (window.__conversationsListener) {
                    window.__conversationsListener.off();
                    window.__conversationsListener = null;
                }
                unsubscribeFromSupabaseConversationChanges();
                unsubscribeFromSupabaseChatMessages();
                if (window.__chatMessagesListListener) {
                    try {
                        const { cmRef, custRef, handler } = window.__chatMessagesListListener;
                        if (cmRef && handler) { cmRef.off('child_added', handler); cmRef.off('child_changed', handler); }
                        if (custRef && handler) { custRef.off('child_added', handler); custRef.off('child_changed', handler); }
                    } catch(_) {}
                    window.__chatMessagesListListener = null;
                }
            } catch(_) {}
            
            // CRITICAL: Update badge when closing chatbox to ensure it shows unread messages
            // This ensures that if new messages arrive after closing, the badge will appear correctly
            setTimeout(() => {
                console.log(' Updating badge after closing chatbox...');
                updateBadgeCount(true);
            }, 100);
        }
        window.closeChatBox = closeChatBox;

        function switchChatTab(tab) {
            // This function is no longer needed with the new two-panel layout
            // Keeping it for backward compatibility but it doesn't do anything
            currentChatTab = tab;
        }

        // Search conversations functionality
        function searchConversations() {
            const searchInput = document.getElementById('conversationSearch');
            const searchTerm = searchInput.value.toLowerCase();
            const conversationItems = document.querySelectorAll('.conversation-item');
            
            conversationItems.forEach(item => {
                const customerName = item.querySelector('.conversation-name').textContent.toLowerCase();
                const preview = item.querySelector('.conversation-preview').textContent.toLowerCase();
                
                if (customerName.includes(searchTerm) || preview.includes(searchTerm)) {
                    item.style.display = 'flex';
                } else {
                    item.style.display = 'none';
                }
            });
        }

        // Initialize search functionality
        document.addEventListener('DOMContentLoaded', function() {
            const searchInput = document.getElementById('conversationSearch');
            if (searchInput) {
                searchInput.addEventListener('input', searchConversations);
            }
        });

        async function selectConversation(conversationId) {
            console.log(' Selecting conversation:', conversationId, 'Current tab:', currentConversationTab);
            
            // VERIFY that we're on the correct tab
            if (currentConversationTab !== 'active') {
                console.error(' Attempted to select active conversation while on archived tab');
                return;
            }
            
            // VERIFY that this conversation is NOT archived
            if (isFirebaseChatAvailable()) {
                const conversationRef = firebase.database().ref(`conversations/${conversationId}`);
                const snapshot = await conversationRef.once('value');
                const conversation = snapshot.val();
                
                if (conversation && conversation.archived === true) {
                    console.error(' Attempted to select archived conversation as active:', conversationId);
                    alert('This conversation is archived. Please switch to the Archived section.');
                    return;
                }
                
                console.log(' Verified active conversation:', conversationId);
            }
            
            // Check if this conversation is already selected
            const normalizedConversationId = normalizeConversationId(conversationId);
            const isAlreadySelected = selectedConversation === normalizedConversationId;
            
            // Check if chat container is already open/visible
            const messagesContainer = document.getElementById('chatMessages');
            const isChatContainerOpen = messagesContainer && messagesContainer.classList.contains('active');
            
            // CRITICAL FIX: Mark previous conversation as read when switching conversations while chatbox is open
            // This ensures badge counts unique customers correctly (prevents same customer from being counted multiple times)
            if (!isAlreadySelected && isChatContainerOpen && selectedConversation) {
                console.log(' Switching conversations while chatbox is open - marking previous conversation as read:', selectedConversation);
                // Mark the previous conversation as read before switching to new one
                await markConversationAsRead(selectedConversation);
                console.log(' Previous conversation marked as read, badge should update accordingly');
            }
            
            // CRITICAL: Normalize conversation ID to ensure consistency
            // Clear previous polling interval if switching conversations
            if (!isAlreadySelected && window.__messageRefreshInterval) {
                clearInterval(window.__messageRefreshInterval);
                window.__messageRefreshInterval = null;
                console.log('Cleared previous message polling interval for conversation switch');
            }
            
            selectedConversation = normalizedConversationId;
            console.log('Selected conversation:', conversationId, 'normalized:', selectedConversation, 'already selected:', isAlreadySelected, 'chat container open:', isChatContainerOpen);
            
            // CRITICAL: Only process unread styling and marking as read if this is a different conversation
            // If the same conversation is clicked again AND chat container is already open,
            // keep the bold state until input is focused
            const isSameConversationAlreadyOpen = isAlreadySelected && isChatContainerOpen;
            
            // Update active conversation
            document.querySelectorAll('.conversation-item').forEach(item => {
                item.classList.remove('active');
            });
            const selectedItem = document.querySelector(`.conversation-item[data-conversation-id="${conversationId}"]`);
            if (selectedItem) {
                selectedItem.classList.add('active');
            }
            
            // CRITICAL FIX: Check if conversation is already marked as read
            // If it is, immediately remove any unread styling that might have been re-applied
            const normalizedConvoId = normalizeConversationId(conversationId);
            if (!window.readConversations) {
                window.readConversations = new Set();
            }
            
            const isAlreadyRead = window.readConversations.has(normalizedConvoId) || 
                                  window.readConversations.has(conversationId);
            
            if (selectedItem && isAlreadyRead && !isSameConversationAlreadyOpen) {
                // This conversation was already read before - ensure styling stays removed
                selectedItem.classList.remove('unread');
                const nameElement = selectedItem.querySelector('.conversation-name');
                const previewElement = selectedItem.querySelector('.conversation-preview');
                if (nameElement) {
                    nameElement.classList.remove('unread');
                }
                if (previewElement) {
                    previewElement.classList.remove('unread');
                }
                console.log(' Conversation already read - ensuring styling stays removed:', normalizedConvoId);
            } else if (selectedItem && !isSameConversationAlreadyOpen && !isAlreadyRead) {
                // This is a NEW unread conversation being clicked - mark as read now
                window.readConversations.add(normalizedConvoId);
                window.readConversations.add(conversationId);
                console.log(' Added conversation to readConversations immediately:', normalizedConvoId);
                
                // CRITICAL: Also update local message state immediately to mark all customer messages as read
                // This prevents badge/styling from being re-applied by listeners
                Object.keys(chatMessages).forEach(key => {
                    if (conversationIdsMatch(key, normalizedConvoId)) {
                        const messages = chatMessages[key] || [];
                        messages.forEach(msg => {
                            if (msg.sender === 'customer' && msg.isRead !== true) {
                                msg.isRead = true;
                            }
                        });
                        console.log(' Updated local messages to isRead:true for:', key);
                    }
                });
                
                // Remove unread styling immediately for instant visual feedback
                selectedItem.classList.remove('unread');
                const nameElement = selectedItem.querySelector('.conversation-name');
                const previewElement = selectedItem.querySelector('.conversation-preview');
                if (nameElement) {
                    nameElement.classList.remove('unread');
                }
                if (previewElement) {
                    previewElement.classList.remove('unread');
                }
                console.log(' Removed unread styling immediately - UI is responsive');
                
                // Update badge immediately to reflect the read state
                updateBadgeCount(true);
                
                // Mark as read in Firebase in the background (don't wait)
                markConversationAsRead(conversationId).then(() => {
                    console.log(' Background: Conversation marked as read in Firebase');
                }).catch((error) => {
                    console.error('Error marking conversation as read:', error);
                });
            } else if (isSameConversationAlreadyOpen) {
                console.log('Same conversation clicked while chat container is open - keeping unread styling until input focus');
            }
            
            // Update customer name in right panel header
            const selectedForName = selectedItem || document.querySelector(`.conversation-item[data-conversation-id="${conversationId}"]`);
            if (selectedForName) {
                const customerName = selectedForName.querySelector('.conversation-name')?.textContent || 'Customer';
                const customerNameElement = document.getElementById('customerName');
                if (customerNameElement) {
                    customerNameElement.textContent = customerName;
                }
            } else {
                // Fallback: Try to get customer name from Firebase if conversation item not found
                if (ENABLE_FIREBASE_CHAT_FALLBACK && isFirebaseChatAvailable()) {
                    try {
                        const conversationRef = firebase.database().ref(`conversations/${conversationId}`);
                        const snapshot = await conversationRef.once('value');
                        const conversation = snapshot.val();
                        if (conversation && conversation.customerName) {
                            const customerNameElement = document.getElementById('customerName');
                            if (customerNameElement) {
                                customerNameElement.textContent = conversation.customerName;
                            }
                        }
                    } catch (error) {
                        console.log('Could not fetch customer name from Firebase:', error);
                    }
                }
            }
            
            // Show chat messages and input
            document.getElementById('chatMessages').classList.add('active');
            document.getElementById('chatInputArea').classList.add('active');
            
            // CRITICAL: Ensure chat input handlers are attached when conversation is selected
            // This ensures the input field focus/click handlers work to remove bold state
            if (typeof initializeChat === 'function') {
                initializeChat();
            }
            
            // Show conversation action buttons
            document.getElementById('conversationActions').style.display = 'flex';
            
            // Show archive button for active conversations
            document.getElementById('archiveBtn').style.display = 'inline-flex';
            document.getElementById('unarchiveBtn').style.display = 'none';
            
            // Always load messages from Supabase when selecting a conversation to ensure we have the latest
            // This ensures messages persist even after switching conversations or refreshing the page
            if (!isSameConversationAlreadyOpen) {
                // Clear the UI to show loading state
                const messagesContainerForClear = document.getElementById('chatMessages');
                if (messagesContainerForClear) {
                    messagesContainerForClear.innerHTML = '';
                }
                
                // Always load from Supabase to get the latest messages
                // This ensures all messages (including staff/admin replies) are loaded
                loadMessagesFromFirebase(conversationId);
            } else {
                console.log('Same conversation already open - skipping message reload to preserve current state');
            }
            
            // Debug Firebase data
            debugFirebaseData(conversationId);
        }

        function loadChatMessages(conversationId) {
            // Always load messages from Firebase to ensure persistence
            loadMessagesFromFirebase(conversationId);
        }

        // Render messages in the chat container
        // SIMPLIFIED VERSION based on working backup
        // Helper function to format date header labels
        function getDateHeaderLabel(messageTimestamp) {
            const messageDate = new Date(messageTimestamp);
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            
            // Reset time to midnight for accurate date comparison
            const messageDateMidnight = new Date(messageDate.getFullYear(), messageDate.getMonth(), messageDate.getDate());
            const todayMidnight = new Date(today.getFullYear(), today.getMonth(), today.getDate());
            const yesterdayMidnight = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate());
            
            // Check if it's today
            if (messageDateMidnight.getTime() === todayMidnight.getTime()) {
                return 'Today';
            }
            
            // Check if it's yesterday
            if (messageDateMidnight.getTime() === yesterdayMidnight.getTime()) {
                return 'Yesterday';
            }
            
            // Check if it's in the current week (within last 7 days)
            const diffTime = todayMidnight - messageDateMidnight;
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
            
            if (diffDays < 7 && diffDays > 0) {
                // Show day name (Monday, Tuesday, etc.)
                const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                return dayNames[messageDate.getDay()];
            }
            
            // Older than current week - show full date format: Month Day, Year
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 
                               'July', 'August', 'September', 'October', 'November', 'December'];
            return `${monthNames[messageDate.getMonth()]} ${messageDate.getDate()}, ${messageDate.getFullYear()}`;
        }
        
        // Helper function to get date string for grouping (YYYY-MM-DD format)
        function getDateString(timestamp) {
            const date = new Date(timestamp);
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        // Image/Video Lightbox Functions
        let currentLightboxMediaUrl = '';
        let currentLightboxMediaType = 'image'; // 'image' or 'video'
        
        window.openImageLightbox = function(imageUrl) {
            if (!imageUrl) {
                console.error('openImageLightbox called with undefined imageUrl');
                return;
            }
            currentLightboxMediaUrl = imageUrl;
            currentLightboxMediaType = 'image';
            const overlay = document.getElementById('imageLightboxOverlay');
            const img = document.getElementById('lightboxImage');
            const video = document.getElementById('lightboxVideo');
            const videoSource = document.getElementById('lightboxVideoSource');
            if (overlay) {
                // Hide video, show image
                if (video) {
                    video.style.display = 'none';
                    video.pause();
                }
                if (img) {
                    img.src = imageUrl;
                    img.style.display = 'block';
                }
                overlay.classList.add('active');
                document.body.style.overflow = 'hidden'; // Prevent background scrolling
            }
        };
        
        window.openVideoLightbox = function(videoUrl) {
            if (!videoUrl) {
                console.error('openVideoLightbox called with undefined videoUrl');
                return;
            }
            currentLightboxMediaUrl = videoUrl;
            currentLightboxMediaType = 'video';
            const overlay = document.getElementById('imageLightboxOverlay');
            const img = document.getElementById('lightboxImage');
            const video = document.getElementById('lightboxVideo');
            const videoSource = document.getElementById('lightboxVideoSource');
            const videoSourceWebm = document.getElementById('lightboxVideoSourceWebm');
            const videoSourceQuicktime = document.getElementById('lightboxVideoSourceQuicktime');
            if (overlay) {
                // Hide image, show video
                if (img) {
                    img.style.display = 'none';
                }
                if (video) {
                    if (videoSource) videoSource.src = videoUrl;
                    if (videoSourceWebm) videoSourceWebm.src = videoUrl;
                    if (videoSourceQuicktime) videoSourceQuicktime.src = videoUrl;
                    video.load();
                    video.style.display = 'block';
                }
                overlay.classList.add('active');
                document.body.style.overflow = 'hidden'; // Prevent background scrolling
            }
        };
        
        window.closeImageLightbox = function(event) {
            if (event) {
                event.stopPropagation();
            }
            const overlay = document.getElementById('imageLightboxOverlay');
            const video = document.getElementById('lightboxVideo');
            if (overlay) {
                overlay.classList.remove('active');
                document.body.style.overflow = ''; // Restore scrolling
                // Pause video if playing
                if (video) {
                    video.pause();
                    video.currentTime = 0;
                }
            }
        };
        
        window.openMediaInNewTab = function() {
            if (currentLightboxMediaUrl) {
                window.open(currentLightboxMediaUrl, '_blank');
            } else {
                console.error(' openMediaInNewTab called but currentLightboxMediaUrl is undefined');
            }
        };
        
        window.downloadMedia = function(mediaUrl, type) {
            try {
                // Handle both single-argument (from lightbox) and two-argument (direct call) forms
                if (!mediaUrl && currentLightboxMediaUrl) {
                    mediaUrl = currentLightboxMediaUrl;
                    type = currentLightboxMediaType;
                }
                
                if (!mediaUrl) {
                    console.error(' downloadMedia called with undefined URL');
                    return;
                }
                
                const link = document.createElement('a');
                link.href = mediaUrl;
                const fileName = mediaUrl.split('/').pop() || (type === 'video' ? 'video.mp4' : 'image.jpg');
                link.download = fileName;
                link.target = '_blank';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                console.log(' Downloading:', fileName);
            } catch (error) {
                console.error(' Download error:', error);
                // Fallback: open in new tab only if URL is valid
                if (mediaUrl) {
                    window.open(mediaUrl, '_blank');
                }
            }
        };
        
        function openImageLightbox(imageUrl) {
            window.openImageLightbox(imageUrl);
        }
        
        function openVideoLightbox(videoUrl) {
            window.openVideoLightbox(videoUrl);
        }
        
        function closeImageLightbox(event) {
            window.closeImageLightbox(event);
        }
        
        function openMediaInNewTab() {
            window.openMediaInNewTab();
        }
        
        function downloadMedia() {
            window.downloadMedia();
        }
        
        // Close lightbox on ESC key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const overlay = document.getElementById('imageLightboxOverlay');
                if (overlay && overlay.classList.contains('active')) {
                    closeImageLightbox();
                }
            }
        });
        
        async function renderMessages(messages, messagesContainer) {
            if (!messagesContainer) {
                console.error(' renderMessages: messagesContainer is null!');
                return;
            }
            
            // CRITICAL: Ensure container is visible before rendering
            messagesContainer.classList.add('active');
            const containerStyle = window.getComputedStyle(messagesContainer);
            console.log(' Container visibility check:', {
                hasActiveClass: messagesContainer.classList.contains('active'),
                display: containerStyle.display,
                visibility: containerStyle.visibility,
                opacity: containerStyle.opacity,
                height: containerStyle.height,
                width: containerStyle.width
            });
            
            console.log('renderMessages called with:', messages.length, 'messages');
            
            if (messages.length === 0) {
                messagesContainer.innerHTML = `
                    <div class="chat-empty">
                        <i class="fas fa-comment-dots"></i>
                        <h4>No messages yet</h4>
                        <p>Start a conversation with this customer</p>
                    </div>
                `;
                return;
            }
            
            // CRITICAL: Use centralized sorting function to ensure consistent ordering
            // This normalizes timestamps and sorts messages chronologically (oldest first, newest last)
            let sortedMessages = sortMessagesByTimestamp(messages);

            // STAFF-LOCAL purge: hide history older than staffDeletedBefore for this conversation
            try {
                if (isFirebaseChatAvailable() && typeof selectedConversation !== 'undefined' && selectedConversation) {
                    const staffUid = sessionStorage.getItem('staffUid');
                    if (staffUid) {
                        const purgeSnap = await firebase.database().ref(`staffDeletedBefore/${staffUid}/${selectedConversation}`).once('value');
                        if (purgeSnap && purgeSnap.exists()) {
                            const purgeBefore = Number(purgeSnap.val());
                            if (purgeBefore && isFinite(purgeBefore)) {
                                sortedMessages = sortedMessages.filter(m => {
                                    const ts = normalizeTimestamp(m?.timestamp ?? m?.createdAt ?? m?.id ?? Date.now(), m);
                                    return !ts || ts >= purgeBefore;
                                });
                                console.log(' Staff-local purge applied. Remaining messages:', sortedMessages.length);
                            }
                        }
                    }
                }
            } catch (e) {
                console.warn('Purge filter skipped due to error:', e);
            }
            
            // Log sorting verification
            if (sortedMessages.length > 0) {
                const firstMsg = sortedMessages[0];
                const lastMsg = sortedMessages[sortedMessages.length - 1];
                const isSorted = sortedMessages.every((m, i) => i === 0 || (m.timestamp || 0) >= (sortedMessages[i - 1].timestamp || 0));
                console.log(' renderMessages sorting check:', {
                    totalMessages: sortedMessages.length,
                    firstTimestamp: firstMsg.timestamp,
                    lastTimestamp: lastMsg.timestamp,
                    isSorted: isSorted
                });
                
                if (!isSorted) {
                    console.error(' Messages are NOT sorted correctly!');
                    // Log first few and last few messages to debug
                    console.log(' First 3 messages:', sortedMessages.slice(0, 3).map(m => ({
                        text: m.text?.substring(0, 20),
                        timestamp: m.timestamp,
                        sender: m.sender
                    })));
                    console.log(' Last 3 messages:', sortedMessages.slice(-3).map(m => ({
                        text: m.text?.substring(0, 20),
                        timestamp: m.timestamp,
                        sender: m.sender
                    })));
                }
            }
            
            // Build HTML (simple approach like backup)
            let html = '';
            let staffMessageCount = 0;
            let customerMessageCount = 0;
            let lastDateString = null; // Track the last date to insert headers
            const mediaElements = []; // Store image/video elements to attach event listeners after HTML insertion
            let lastSenderId = null; // Track last sender to group messages
            let previousMessage = null; // Track previous message for grouping
            
            // Helper function to get staff name and role from message
            function getStaffInfoFromMessage(message) {
                let staffName = message.staffName || message.staffDisplayName || null;
                let staffRole = 'Staff';
                
                // Extract role from staffDisplayName if it contains role info
                if (message.staffDisplayName) {
                    const roleMatch = message.staffDisplayName.match(/\(Role:\s*([^)]+)\)/i);
                    if (roleMatch) {
                        staffRole = roleMatch[1].trim();
                    }
                    // Extract name if displayName has format "Name - (Role: Role)"
                    const nameMatch = message.staffDisplayName.match(/^([^-]+?)\s*-\s*\(Role:/i);
                    if (nameMatch) {
                        staffName = nameMatch[1].trim();
                    }
                }
                
                // If no name found, try to get from session storage (for current user)
                if (!staffName && message.sender === 'staff') {
                    const currentStaffUid = sessionStorage.getItem('staffUid') || sessionStorage.getItem('adminUid');
                    if (currentStaffUid && (message.staffId === currentStaffUid || message.staffUid === currentStaffUid)) {
                        staffName = sessionStorage.getItem('staffName') || sessionStorage.getItem('adminName') || 'Staff Member';
                        const userRole = sessionStorage.getItem('userRole') || sessionStorage.getItem('adminRole') || 'staff';
                        staffRole = userRole === 'admin' ? 'Admin' : 'Staff';
                    }
                }
                
                // Default fallback
                if (!staffName) {
                    staffName = 'Staff Member';
                }
                
                return { staffName, staffRole };
            }
            
            for (const message of sortedMessages) {
                // Skip messages without text, image, or video
                if ((!message.text || message.text.trim() === '') && !message.imageUrl && !message.videoUrl) {
                    console.log(' Skipping message without content:', message);
                    continue;
                }
                
                // Get normalized timestamp for the message
                const messageTimestamp = normalizeTimestamp(message.timestamp ?? message.createdAt ?? message.id ?? Date.now(), message);
                const currentDateString = getDateString(messageTimestamp);
                
                // Insert date header if this is a new date
                if (currentDateString !== lastDateString) {
                    const dateLabel = getDateHeaderLabel(messageTimestamp);
                    html += `
                        <div class="date-header">
                            <span class="date-header-line"></span>
                            <span class="date-header-text">${dateLabel}</span>
                            <span class="date-header-line"></span>
                        </div>
                    `;
                    lastDateString = currentDateString;
                }
                
                // Count messages by sender
                if (message.sender === 'staff') {
                    staffMessageCount++;
                } else if (message.sender === 'customer') {
                    customerMessageCount++;
                }
                
                let customerName = '';
                if (message.sender === 'customer') {
                    try {
                        customerName = await getCustomerName(message.customerId || message.senderId);
                    } catch (error) {
                        console.log('Could not fetch customer name:', error);
                        customerName = message.customerName || 'Customer';
                    }
                }
                
                const isStaffMessage = message.sender === 'staff';
                
                // Get staff info for staff messages
                let staffInfo = null;
                let currentSenderId = null;
                let isCurrentUserMessage = false;
                
                if (isStaffMessage) {
                    staffInfo = getStaffInfoFromMessage(message);
                    currentSenderId = message.staffId || message.staffUid || 'staff';
                    // Ensure staffInfo is never null for staff messages
                    if (!staffInfo) {
                        staffInfo = { staffName: 'Staff Member', staffRole: 'Staff' };
                    }
                    
                    // Check if this message is from the current user
                    const currentUserUid = sessionStorage.getItem('staffUid') || sessionStorage.getItem('adminUid');
                    isCurrentUserMessage = currentUserUid && (currentSenderId === currentUserUid);
                }
                
                // Determine message position:
                // - Customer messages: always on left
                // - Current user's staff messages: on right
                // - Other staff/admin messages: on left (as replies)
                const messageClass = isStaffMessage 
                    ? (isCurrentUserMessage ? 'message-right' : 'message-left')
                    : 'message-left';
                
                // Always show sender name/role for staff/admin messages to ensure clear identification
                // This ensures every message clearly shows who sent it
                const shouldShowSender = isStaffMessage;
                
                // CRITICAL: Ensure timestamp is normalized before formatting
                // Even though sortMessagesByTimestamp normalizes, we normalize again here for safety
                const originalTimestamp = message.timestamp ?? message.createdAt ?? null;
                const normalizedTimestamp = normalizeTimestamp(originalTimestamp ?? message.id ?? Date.now(), message);
                const displayTimestamp = getMessageDisplayTime(message, normalizedTimestamp);
                
                // Debug: Log timestamp information for troubleshooting
                // Enable by setting: window.DEBUG_TIMESTAMPS = true; in console
                if (window.DEBUG_TIMESTAMPS) {
                    console.log(' Message timestamp debug:', {
                        id: message.id,
                        sender: message.sender,
                        text: message.text?.substring(0, 30),
                        originalTimestamp: originalTimestamp,
                        createdAt: message.createdAt,
                        messageId: message.id,
                        normalizedTimestamp: normalizedTimestamp,
                        formatted: formatTime(normalizedTimestamp),
                        date: new Date(normalizedTimestamp).toISOString(),
                        fullMessage: message
                    });
                }
                
                // Always log warnings for suspicious timestamps (missing or very recent)
                if (!originalTimestamp || (normalizedTimestamp > Date.now() - 60000 && normalizedTimestamp < Date.now() + 60000)) {
                    console.warn(' Suspicious timestamp detected:', {
                        id: message.id,
                        sender: message.sender,
                        text: message.text?.substring(0, 30),
                        originalTimestamp: originalTimestamp,
                        normalizedTimestamp: normalizedTimestamp,
                        formatted: formatTime(normalizedTimestamp),
                        currentTime: Date.now(),
                        diff: Date.now() - normalizedTimestamp
                    });
                }
                
                // Build media HTML if present
                let mediaHtml = '';
                // Debug: Log imageUrl and videoUrl
                if (message.imageUrl || message.videoUrl) {
                    console.log(' Message has media:', {
                        id: message.id,
                        sender: message.sender,
                        imageUrl: message.imageUrl,
                        videoUrl: message.videoUrl,
                        imageUrlType: typeof message.imageUrl,
                        videoUrlType: typeof message.videoUrl
                    });
                }
                
                if (message.imageUrl) {
                    // Get the raw URL and ensure it's a string
                    let rawUrl = String(message.imageUrl).trim();
                    
                    // If URL doesn't start with http, it might be a path - construct full URL
                    if (!rawUrl.startsWith('http://') && !rawUrl.startsWith('https://')) {
                        // It's a file path, construct Supabase URL
                        let cleanPath = rawUrl.replace(/^\/+/, '');
                        // Remove bucket name if present (handle multiple occurrences)
                        while (cleanPath.startsWith('customerconvo_uploads/')) {
                            cleanPath = cleanPath.substring('customerconvo_uploads/'.length).replace(/^\/+/, '');
                        }
                        rawUrl = `https://afkwexvvuxwbpioqnelp.supabase.co/storage/v1/object/public/customerconvo_uploads/${cleanPath}`;
                    } else {
                        // It's already a full URL - check for duplicate bucket names and fix
                        // Fix duplicate bucket names in the path
                        rawUrl = rawUrl.replace(/\/customerconvo_uploads\/customerconvo_uploads\//g, '/customerconvo_uploads/');
                        // Also handle if bucket appears multiple times in different positions
                        const bucketPattern = /\/customerconvo_uploads\//g;
                        const matches = rawUrl.match(bucketPattern);
                        if (matches && matches.length > 1) {
                            // Remove all but the last occurrence
                            const parts = rawUrl.split('/customerconvo_uploads/');
                            if (parts.length > 2) {
                                // Reconstruct with only one bucket name
                                const baseUrl = parts[0] + '/customerconvo_uploads/';
                                const filePath = parts.slice(1).join('/'); // Join all path parts after first bucket
                                rawUrl = baseUrl + filePath;
                            }
                        }
                    }
                    
                    // Ensure URL is properly encoded
                    try {
                        const urlObj = new URL(rawUrl);
                        // Reconstruct with proper encoding
                        rawUrl = urlObj.href;
                    } catch (e) {
                        console.warn('Invalid URL format, using as-is:', rawUrl);
                    }
                    
                    // Escape for HTML attributes (use HTML entity encoding)
                    const imageUrl = rawUrl.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                    // Escape for JavaScript strings (double escape for onclick)
                    const imageUrlForJs = rawUrl.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/"/g, '\\"');
                    
                    console.log(' Rendering image with URL:', rawUrl);
                    console.log(' Original URL from message:', message.imageUrl);
                    
                    // Create a unique ID for this image to handle errors properly
                    const imageId = 'img_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    
                    // Store for event listener attachment after HTML insertion
                    mediaElements.push({
                        type: 'image',
                        id: imageId,
                        url: rawUrl,
                        urlForJs: imageUrlForJs
                    });
                    
                    mediaHtml = `
                        <div class="message-media" style="margin-bottom: 8px; max-width: 250px; max-height: 250px; border-radius: 12px; overflow: hidden; border: 1px solid ${isStaffMessage ? '#e2e8f0' : '#d1d5db'}; position: relative; background: #f5f5f5; cursor: pointer;" onclick="openImageLightbox('${imageUrlForJs}')">
                            <img id="${imageId}"
                                 src="${imageUrl}" 
                                 alt="Image" 
                                 style="width: 100%; height: 100%; object-fit: cover; display: block; cursor: pointer;" 
                                 crossorigin="anonymous"
                                 loading="lazy"
                                 title="Click to view full size" />
                            <div class="media-action-buttons">
                                <button class="media-action-btn" onclick="event.stopPropagation(); event.preventDefault(); downloadMedia('${rawUrl.replace(/'/g, "\\'")}', 'image');" title="Download image">
                                    <i class="fas fa-download"></i>
                                </button>
                                <button class="media-action-btn" onclick="event.stopPropagation(); event.preventDefault(); window.open('${rawUrl.replace(/'/g, "\\'")}', '_blank');" title="Open in new tab">
                                    <i class="fas fa-external-link-alt"></i>
                                </button>
                            </div>
                        </div>
                    `;
                }
                if (message.videoUrl) {
                    // Get the raw URL and ensure it's a string
                    let rawVideoUrl = String(message.videoUrl).trim();
                    
                    // If URL doesn't start with http, it might be a path - construct full URL
                    if (!rawVideoUrl.startsWith('http://') && !rawVideoUrl.startsWith('https://')) {
                        // It's a file path, construct Supabase URL
                        let cleanPath = rawVideoUrl.replace(/^\/+/, '');
                        // Remove bucket name if present (handle multiple occurrences)
                        while (cleanPath.startsWith('customerconvo_uploads/')) {
                            cleanPath = cleanPath.substring('customerconvo_uploads/'.length).replace(/^\/+/, '');
                        }
                        rawVideoUrl = `https://afkwexvvuxwbpioqnelp.supabase.co/storage/v1/object/public/customerconvo_uploads/${cleanPath}`;
                    } else {
                        // It's already a full URL - check for duplicate bucket names and fix
                        // Fix duplicate bucket names in the path
                        rawVideoUrl = rawVideoUrl.replace(/\/customerconvo_uploads\/customerconvo_uploads\//g, '/customerconvo_uploads/');
                        // Also handle if bucket appears multiple times in different positions
                        const bucketPattern = /\/customerconvo_uploads\//g;
                        const matches = rawVideoUrl.match(bucketPattern);
                        if (matches && matches.length > 1) {
                            // Remove all but the last occurrence
                            const parts = rawVideoUrl.split('/customerconvo_uploads/');
                            if (parts.length > 2) {
                                // Reconstruct with only one bucket name
                                const baseUrl = parts[0] + '/customerconvo_uploads/';
                                const filePath = parts.slice(1).join('/'); // Join all path parts after first bucket
                                rawVideoUrl = baseUrl + filePath;
                            }
                        }
                    }
                    
                    // Ensure URL is properly encoded
                    try {
                        const urlObj = new URL(rawVideoUrl);
                        rawVideoUrl = urlObj.href;
                    } catch (e) {
                        console.warn('Invalid video URL format, using as-is:', rawVideoUrl);
                    }
                    
                    // Escape for HTML attributes
                    const videoUrl = rawVideoUrl.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                    // Escape for JavaScript strings
                    const videoUrlForJs = rawVideoUrl.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/"/g, '\\"');
                    
                    console.log(' Rendering video with URL:', rawVideoUrl);
                    console.log(' Original video URL from message:', message.videoUrl);
                    
                    // Create a unique ID for this video to handle errors properly
                    const videoId = 'vid_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    
                    // Store for event listener attachment after HTML insertion
                    mediaElements.push({
                        type: 'video',
                        id: videoId,
                        url: rawVideoUrl,
                        urlForJs: videoUrlForJs
                    });
                    
                    mediaHtml = `
                        <div class="message-media" style="margin-bottom: 8px; max-width: 250px; max-height: 250px; border-radius: 12px; overflow: hidden; border: 1px solid ${isStaffMessage ? '#e2e8f0' : '#d1d5db'}; background: #000; position: relative;">
                            <video id="${videoId}"
                                   controls 
                                   crossorigin="anonymous"
                                   style="width: 100%; height: 100%; object-fit: contain;"
                                   onclick="event.stopPropagation();"
                                   onloadedmetadata="this.style.cursor='default';">
                                <source src="${videoUrl}" type="video/mp4">
                                <source src="${videoUrl}" type="video/webm">
                                <source src="${videoUrl}" type="video/quicktime">
                            </video>
                            <div style="position: absolute; top: 8px; right: 8px; z-index: 10;">
                                <button class="media-action-btn" onclick="event.stopPropagation(); event.preventDefault(); openVideoLightbox('${videoUrlForJs}');" title="View in lightbox" style="background: rgba(0,0,0,0.7); color: white; border: none; border-radius: 4px; padding: 6px 8px; cursor: pointer; font-size: 12px;">
                                    <i class="fas fa-expand"></i>
                                </button>
                            </div>
                            <div class="media-action-buttons">
                                <button class="media-action-btn" onclick="event.stopPropagation(); event.preventDefault(); downloadMedia('${rawVideoUrl.replace(/'/g, "\\'")}', 'video');" title="Download video">
                                    <i class="fas fa-download"></i>
                                </button>
                                <button class="media-action-btn" onclick="event.stopPropagation(); event.preventDefault(); window.open('${rawVideoUrl.replace(/'/g, "\\'")}', '_blank');" title="Open in new tab">
                                    <i class="fas fa-external-link-alt"></i>
                                </button>
                            </div>
                        </div>
                    `;
                }
                
                // Build sender name/role display
                let senderDisplay = '';
                if (message.sender === 'customer' && customerName) {
                    senderDisplay = `<div class="message-sender">${customerName}</div>`;
                } else if (isStaffMessage && shouldShowSender) {
                    // Always show identifier for staff/admin messages
                    // Use staffInfo if available, otherwise use fallback
                    const displayName = staffInfo?.staffName || 'Staff Member';
                    const displayRole = staffInfo?.staffRole || 'Staff';
                    senderDisplay = `<div class="message-sender">${displayName}<span class="message-sender-role">${displayRole}</span></div>`;
                }
                
                // Determine avatar position based on message alignment
                // Left messages (customer or other staff): avatar on left
                // Right messages (current user): avatar on right
                const avatarHtml = '<div class="message-avatar"><i class="fas fa-user-tie"></i></div>';
                const customerAvatarHtml = '<div class="message-avatar"><i class="fas fa-user"></i></div>';
                
                let avatarBefore = '';
                let avatarAfter = '';
                
                if (message.sender === 'customer') {
                    avatarBefore = customerAvatarHtml;
                } else if (isStaffMessage) {
                    if (isCurrentUserMessage) {
                        // Current user's message: avatar on right
                        avatarAfter = avatarHtml;
                    } else {
                        // Other staff/admin message: avatar on left (as reply)
                        avatarBefore = avatarHtml;
                    }
                }
                
                html += `
                    <div class="message ${messageClass}">
                        ${avatarBefore}
                        <div class="message-content">
                            ${senderDisplay}
                            ${mediaHtml}
                            ${message.text ? `<p class="message-text">${message.text}</p>` : ''}
                            <div class="message-time">${displayTimestamp}</div>
                        </div>
                        ${avatarAfter}
                    </div>
                `;
                
                // Update lastSenderId for grouping
                if (isStaffMessage) {
                    lastSenderId = currentSenderId;
                } else {
                    lastSenderId = null; // Reset when customer message appears
                }
                
                // Update previousMessage for next iteration
                previousMessage = message;
            }
            
            // CRITICAL: Ensure container is visible before setting innerHTML
            messagesContainer.classList.add('active');
            
            // Preserve scroll position before re-rendering to prevent bouncing
            const wasAtBottom = Math.abs(messagesContainer.scrollHeight - messagesContainer.scrollTop - messagesContainer.clientHeight) < 10;
            const previousScrollTop = messagesContainer.scrollTop;
            const previousScrollHeight = messagesContainer.scrollHeight;
            
            messagesContainer.innerHTML = html;
            console.log(' Rendered', messages.length, 'messages to UI - Staff:', staffMessageCount, 'Customer:', customerMessageCount);
            console.log(' HTML length:', html.length, 'characters');
            
            // Attach event listeners to media elements after HTML is inserted
            mediaElements.forEach(media => {
                const element = document.getElementById(media.id);
                if (element) {
                    if (media.type === 'image') {
                        // Make sure the image is clickable
                        element.style.pointerEvents = 'auto';
                        element.style.cursor = 'pointer';
                        element.onclick = function(e) {
                            // Don't open lightbox if clicking on action buttons
                            if (e.target.closest('.media-action-buttons')) {
                                return;
                            }
                            e.stopPropagation();
                            openImageLightbox(media.url);
                        };
                        element.onload = function() {
                            console.log(' Image loaded successfully:', this.src);
                        };
                        element.onerror = function() {
                            this.onerror = null;
                            console.error('Image load error:', this.src);
                            const parent = this.parentElement;
                            const btn = document.createElement('button');
                            btn.textContent = 'Open in new tab';
                            btn.style.cssText = 'margin-top:8px;padding:4px 8px;background:#9ad061;color:white;border:none;border-radius:4px;cursor:pointer';
                            btn.onclick = function() {
                                window.open(media.url, '_blank');
                            };
                            parent.innerHTML = '<div style="padding:20px;text-align:center;color:#999"><i class="fas fa-image" style="font-size:32px;margin-bottom:8px"></i><br>Image not available<br><small style="word-break:break-all;font-size:10px">' + this.src.substring(0,80) + '...</small></div>';
                            parent.appendChild(btn);
                        };
                    } else if (media.type === 'video') {
                        element.onloadstart = function() {
                            console.log('Video loading:', this.src);
                        };
                        element.onerror = function() {
                            this.onerror = null;
                            console.error('Video load error:', this.src);
                            const parent = this.parentElement;
                            const btn = document.createElement('button');
                            btn.textContent = 'Open in new tab';
                            btn.style.cssText = 'margin-top:8px;padding:4px 8px;background:#9ad061;color:white;border:none;border-radius:4px;cursor:pointer';
                            btn.onclick = function() {
                                window.open(media.url, '_blank');
                            };
                            parent.innerHTML = '<div style="padding:20px;text-align:center;color:#fff"><i class="fas fa-video" style="font-size:32px;margin-bottom:8px"></i><br>Video not available<br><small style="word-break:break-all;font-size:10px">' + this.src.substring(0,80) + '...</small></div>';
                            parent.appendChild(btn);
                        };
                    }
                }
            });
            
            // Verify container is visible after setting innerHTML and restore scroll smoothly
            setTimeout(() => {
                const containerStyle = window.getComputedStyle(messagesContainer);
                const hasActiveClass = messagesContainer.classList.contains('active');
                const renderedMessages = messagesContainer.querySelectorAll('.message');
                const staffMessages = messagesContainer.querySelectorAll('.message.message-right');
                
                console.log(' Container visibility after render:', {
                    hasActiveClass: hasActiveClass,
                    display: containerStyle.display,
                    visibility: containerStyle.visibility,
                    opacity: containerStyle.opacity,
                    height: containerStyle.height,
                    width: containerStyle.width,
                    scrollHeight: messagesContainer.scrollHeight,
                    clientHeight: messagesContainer.clientHeight,
                    renderedMessages: renderedMessages.length,
                    staffMessages: staffMessages.length
                });
                
                // If container is not visible, force it to be visible
                if (containerStyle.display === 'none' || !hasActiveClass) {
                    console.error(' Container is not visible! Forcing visibility...');
                    messagesContainer.classList.add('active');
                    messagesContainer.style.display = 'flex';
                    messagesContainer.style.visibility = 'visible';
                    messagesContainer.style.opacity = '1';
                    messagesContainer.style.height = 'auto';
                }
                
                // CRITICAL: Smooth scroll restoration to prevent bouncing
                const scrollToBottom = () => {
                    const currentScrollHeight = messagesContainer.scrollHeight;
                    
                    if (wasAtBottom) {
                        // If we were at bottom, smoothly scroll to new bottom
                        messagesContainer.scrollTop = currentScrollHeight;
                        console.log(' Scrolled to bottom - scrollTop:', messagesContainer.scrollTop, 'scrollHeight:', currentScrollHeight);
                    } else {
                        // Otherwise, try to preserve relative scroll position
                        const heightDiff = currentScrollHeight - previousScrollHeight;
                        const newScrollTop = Math.max(0, previousScrollTop + heightDiff);
                        messagesContainer.scrollTop = newScrollTop;
                        console.log(' Preserved scroll position - previous:', previousScrollTop, 'new:', newScrollTop, 'heightDiff:', heightDiff);
                    }
                    
                    // Verify we're at the bottom (if we intended to be)
                    if (wasAtBottom) {
                        const isAtBottom = Math.abs(messagesContainer.scrollHeight - messagesContainer.scrollTop - messagesContainer.clientHeight) < 5;
                        if (!isAtBottom) {
                            console.warn(' Not at bottom, retrying scroll...');
                            setTimeout(() => {
                                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                            }, 50);
                        }
                    }
                };
                
                // Scroll immediately
                scrollToBottom();
                
                // Also scroll after a short delay to ensure DOM is fully rendered (only if we were at bottom)
                if (wasAtBottom) {
                    setTimeout(scrollToBottom, 50);
                    setTimeout(scrollToBottom, 100);
                }
            }, 10);
        }
        // Load messages from Firebase for a specific conversation
        async function loadMessagesFromFirebase(conversationId) {
            try {
                // CRITICAL: Normalize conversation ID to ensure consistency
                const normalizedConversationId = normalizeConversationId(conversationId);
                console.log(' loadMessagesFromFirebase called with:', conversationId, 'normalized:', normalizedConversationId);
                
                // Show loading state immediately
                const messagesContainer = document.getElementById('chatMessages');
                if (messagesContainer) {
                    messagesContainer.innerHTML = `
                        <div class="chat-loading">
                            <i class="fas fa-spinner fa-spin"></i>
                            <h4>Loading messages...</h4>
                            <p>Please wait while we fetch the conversation</p>
                        </div>
                    `;
                }
                
                const supabaseMessages = await supabaseFetchMessages(normalizedConversationId);
                if (Array.isArray(supabaseMessages)) {
                    console.log('Loaded messages from Supabase for conversation:', normalizedConversationId, supabaseMessages.length);
                    
                    // Merge with existing local messages to preserve any that were added via real-time
                    const existingMessages = chatMessages[normalizedConversationId] || [];
                    const existingMessageIds = new Set(existingMessages.map(m => m.id || `${m.timestamp}_${m.sender}_${m.text}`));
                    
                    // Add any existing messages that aren't in Supabase (in case of timing issues)
                    const allMessages = [...supabaseMessages];
                    for (const existingMsg of existingMessages) {
                        const existingMsgId = existingMsg.id || `${existingMsg.timestamp}_${existingMsg.sender}_${existingMsg.text}`;
                        const existsInSupabase = supabaseMessages.some(m => {
                            const msgId = m.id || `${m.timestamp}_${m.sender}_${m.text}`;
                            return msgId === existingMsgId;
                        });
                        if (!existsInSupabase) {
                            console.log('[Load] Preserving local message not yet in Supabase:', existingMsgId);
                            allMessages.push(existingMsg);
                        }
                    }
                    
                    // Store all messages (merged) in chatMessages object
                    chatMessages[normalizedConversationId] = sortMessagesByTimestamp(allMessages);
                    console.log('Total messages after merge:', chatMessages[normalizedConversationId].length, '(Supabase:', supabaseMessages.length, 'Local:', existingMessages.length, ')');
                    
                    if (messagesContainer) {
                        await renderMessages(chatMessages[normalizedConversationId], messagesContainer);
                    }
                    await subscribeToSupabaseChatMessages(normalizedConversationId);
                    
                    // Set up polling fallback to refresh messages every 3 seconds for the selected conversation
                    // This ensures messages appear even if real-time subscription fails
                    if (window.__messageRefreshInterval) {
                        clearInterval(window.__messageRefreshInterval);
                    }
                    window.__messageRefreshInterval = setInterval(async () => {
                        if (selectedConversation === normalizedConversationId && isChatboxOpen) {
                            try {
                                const latestMessages = await supabaseFetchMessages(normalizedConversationId);
                                if (Array.isArray(latestMessages)) {
                                    const currentMessages = chatMessages[normalizedConversationId] || [];
                                    const currentMessageIds = new Set(currentMessages.map(m => m.id || `${m.timestamp}_${m.sender}_${m.text}`));
                                    const latestMessageIds = new Set(latestMessages.map(m => m.id || `${m.timestamp}_${m.sender}_${m.text}`));
                                    
                                    // Check if there are any new messages by comparing IDs
                                    let hasNewMessages = false;
                                    for (const msg of latestMessages) {
                                        const msgId = msg.id || `${msg.timestamp}_${msg.sender}_${msg.text}`;
                                        if (!currentMessageIds.has(msgId)) {
                                            hasNewMessages = true;
                                            console.log('[Polling] Found new message:', msgId, 'Sender:', msg.sender);
                                            break;
                                        }
                                    }
                                    
                                    // Update if there are new messages
                                    if (hasNewMessages) {
                                        console.log('[Polling] Updating messages - found new messages. Current:', currentMessages.length, 'Latest:', latestMessages.length);
                                        chatMessages[normalizedConversationId] = sortMessagesByTimestamp(latestMessages);
                                        const container = document.getElementById('chatMessages');
                                        if (container) {
                                            await renderMessages(chatMessages[normalizedConversationId], container);
                                            container.scrollTop = container.scrollHeight;
                                        }
                                    }
                                }
                            } catch (error) {
                                console.warn('[Polling] Error refreshing messages:', error);
                            }
                        }
                    }, 3000); // Poll every 3 seconds
                    
                    return;
                }
                
                if (ENABLE_FIREBASE_CHAT_FALLBACK && isFirebaseChatAvailable()) {
                    console.log('Loading messages from Firebase for conversation:', normalizedConversationId);
                    
                    // Fetch from both chatMessages and customerMessages paths
                    // Load ALL messages and filter client-side (more reliable than orderByChild which requires index)
                    // This approach works even if Firebase index is missing
                    const messagesRef = firebase.database().ref('chatMessages');
                    // CRITICAL: Use normalized conversation ID for consistency
                    const custRef = firebase.database().ref(`customerMessages/${normalizedConversationId}`);
                    
                    console.log('Loading messages for conversationId:', normalizedConversationId, '(will filter client-side)');
                    
                    // IMPORTANT: Create listener only once and keep it persistent
                    // Store the reference globally if not already stored
                    if (!window.firebaseListeners) {
                        window.firebaseListeners = {};
                    }
                    
                    // Only create listener if it doesn't exist
                    // CRITICAL: Use normalized conversation ID as key
                    if (window.firebaseListeners[normalizedConversationId]) {
                        console.log(' Listener already exists for conversation:', normalizedConversationId, '- refreshing data');
                        // Preserve existing local messages before refreshing
                        const existingLocalMessages = chatMessages[conversationId] || [];
                        const now = Date.now();
                        const RECENT_THRESHOLD = 30000; // 30 seconds
                        
                        // Just trigger a manual update to refresh the UI
                        Promise.all([
                            messagesRef.once('value'),
                            custRef.once('value').catch(() => ({ val: () => null, exists: () => false }))
                        ]).then(([snapshot, custSnap]) => {
                            const messages = [];
                            if (snapshot && snapshot.exists()) {
                                snapshot.forEach(function(childSnapshot) {
                                    const message = childSnapshot.val();
                                    // Always filter by conversationId client-side as fallback
                                    // Use normalized comparison for consistency
                                    const msgConvId = normalizeConversationId(message?.conversationId);
                                    const msgCustId = normalizeConversationId(message?.customerId);
                                    const targetConvId = normalizeConversationId(conversationId);
                                    
                                    const matchesConversationId = conversationIdsMatch(msgConvId, targetConvId);
                                    const matchesCustomerId = conversationIdsMatch(msgCustId, targetConvId);
                                    
                                    const isStaffToCustomer = message?.sender === 'staff' && (
                                        conversationIdsMatch(msgCustId, targetConvId) || 
                                        conversationIdsMatch(msgConvId, targetConvId)
                                    );
                                    
                                    if (message && (matchesConversationId || matchesCustomerId || isStaffToCustomer)) {
                                        // Ensure message has an ID - use key if id is missing
                                        if (!message.id && childSnapshot.key) {
                                            message.id = childSnapshot.key;
                                        }
                                        // CRITICAL: Log RAW Firebase data before any processing
                                        console.log(' RAW Firebase message data:', {
                                            key: childSnapshot.key,
                                            rawData: JSON.stringify(message),
                                            timestampRaw: message.timestamp,
                                            timestampType: typeof message.timestamp,
                                            createdAtRaw: message.createdAt,
                                            createdAtType: typeof message.createdAt,
                                            idRaw: message.id,
                                            idType: typeof message.id
                                        });
                                        
                                        // CRITICAL: Normalize timestamp to ensure it's always a number
                                        const originalTs = message.timestamp;
                                        // Try timestamp first, then createdAt, then id, but avoid Date.now() unless absolutely necessary
                                        const tsToNormalize = message.timestamp ?? message.createdAt ?? message.id ?? null;
                                        if (tsToNormalize !== null) {
                                            message.timestamp = normalizeTimestamp(tsToNormalize, message);
                                        } else {
                                            console.error(' CRITICAL: Message has no timestamp, createdAt, or id!', message);
                                            message.timestamp = Date.now(); // Last resort
                                        }
                                        console.log(' Refreshed message from chatMessages:', message.id, message.sender, message.text?.substring(0, 30), 'conversationId:', message.conversationId, 'customerId:', message.customerId, 'originalTimestamp:', originalTs, 'normalizedTimestamp:', message.timestamp, 'formatted:', formatTime(message.timestamp));
                                        messages.push(message);
                                    } else if (message) {
                                        console.log(' Refreshed message filtered out:', message.id, 'sender:', message.sender, 'conversationId:', message.conversationId, 'customerId:', message.customerId, 'target:', conversationId);
                                    }
                                });
                            }
                            
                            const custMessages = [];
                            if (custSnap && custSnap.exists() && custSnap.val()) {
                                custSnap.forEach(function(childSnapshot){
                                    const msg = childSnapshot.val();
                                    if (msg) {
                                        // Ensure message has an ID - use key if id is missing
                                        if (!msg.id && childSnapshot.key) {
                                            msg.id = childSnapshot.key;
                                        }
                                        // CRITICAL: Normalize timestamp to ensure it's always a number
                                        const originalTs = msg.timestamp;
                                        msg.timestamp = normalizeTimestamp(msg.timestamp ?? msg.createdAt ?? msg.id ?? msg.messageId ?? Date.now(), msg);
                                        console.log('Refreshed message from customerMessages:', msg.id, msg.sender, msg.text?.substring(0, 30), 'originalTimestamp:', originalTs, 'normalizedTimestamp:', msg.timestamp, 'formatted:', formatTime(msg.timestamp));
                                        custMessages.push(msg);
                                    }
                                });
                            }
                            
                            console.log('Refresh: Found', messages.length, 'from chatMessages and', custMessages.length, 'from customerMessages');
                            
                            // Build set of Firebase message IDs
                            const firebaseIds = new Set();
                            [...messages, ...custMessages].forEach(m => {
                                if (m && m.id) firebaseIds.add(m.id);
                            });
                            
                            // Merge and deduplicate messages, preserving ALL local messages that aren't in Firebase
                            const byId = new Map();
                            
                            // First add ALL Firebase messages (source of truth)
                            [...messages, ...custMessages].forEach(m => { 
                                if (m && (m.id || m.timestamp)) {
                                    const key = m.id || `t_${m.timestamp}_${m.sender}`;
                                    // Keep the most complete message if duplicate
                                    const existing = byId.get(key);
                                    if (!existing || (m.customerName && !existing.customerName)) {
                                        byId.set(key, m);
                                    }
                                }
                            });
                            
                            // Then preserve ALL local messages that aren't in Firebase (not just recent ones)
                            existingLocalMessages.forEach(m => {
                                if (m && (m.id || m.timestamp)) {
                                    const key = m.id || `t_${m.timestamp}_${m.sender}`;
                                    const existsInFirebase = m.id && firebaseIds.has(m.id);
                                    
                                    // Always preserve local messages that aren't in Firebase yet
                                    // This ensures we don't lose messages during the refresh
                                    if (!existsInFirebase && !byId.has(key)) {
                                        console.log('Refresh: Preserving local message not in Firebase:', m.id || m.text?.substring(0, 30));
                                        byId.set(key, m);
                                    } else if (existsInFirebase && byId.has(key)) {
                                        // Message exists in both - prefer Firebase version but preserve local isRead state
                                        const firebaseMsg = byId.get(key);
                                        // CRITICAL: Preserve isRead state from local message if it was marked as read
                                        // This prevents messages from being marked as unread when refreshing from Firebase
                                        if (m.sender === 'customer' && m.isRead === true) {
                                            firebaseMsg.isRead = true;
                                            console.log('Refresh: Preserved isRead=true from local state for message:', firebaseMsg.id || firebaseMsg.text?.substring(0, 30));
                                        }
                                        // Keep local version if it has more data (like customerName)
                                        if (m.customerName && !firebaseMsg.customerName) {
                                            byId.set(key, m);
                                        } else {
                                            // Use Firebase version but with preserved isRead state
                                            byId.set(key, firebaseMsg);
                                        }
                                    }
                                }
                            });
                            
                            // CRITICAL: Use centralized sorting function to ensure consistent ordering
                            const merged = sortMessagesByTimestamp(Array.from(byId.values()));
                            
                            // CRITICAL: If conversation is in readConversations, mark ALL customer messages as read
                            // This ensures badge doesn't appear when loading messages for already-read conversations
                            const normalizedConvoId = normalizeConversationId(conversationId);
                            const isReadConversation = window.readConversations && window.readConversations.has(normalizedConvoId);
                            if (isReadConversation) {
                                merged.forEach(message => {
                                    if (message.sender === 'customer') {
                                        message.isRead = true;
                                    }
                                });
                                console.log('Refresh: Marked all customer messages as read for conversation in readConversations:', normalizedConvoId);
                            }
                            
                            chatMessages[conversationId] = merged;
                            console.log('Refresh: Loaded', merged.length, 'total messages (preserved', existingLocalMessages.length, 'local)');
                            
                            // Always render if this conversation is selected
                            if (selectedConversation === conversationId && messagesContainer) {
                                console.log('Rendering', merged.length, 'refreshed messages');
                                renderMessages(merged, messagesContainer);
                            }
                            
                            // Update conversation preview with the latest message
                            // CRITICAL: Skip badge update if conversation is read
                            if (merged.length > 0) {
                                const lastMessage = merged[merged.length - 1];
                                if (lastMessage && lastMessage.text) {
                                    updateConversationPreview(conversationId, lastMessage.text, lastMessage.sender, lastMessage.timestamp);
                                    // Only update conversation list if conversation is NOT read (prevents badge from appearing)
                                    if (!isReadConversation) {
                                        updateConversationListFromMessage(conversationId, lastMessage);
                                    } else {
                                        console.log('Skipping updateConversationListFromMessage for read conversation:', normalizedConvoId);
                                    }
                                }
                            }
                        }).catch((err) => {
                            console.error('Error refreshing messages:', err);
                            // Don't clear messages on error - keep existing ones
                            if (selectedConversation === conversationId && messagesContainer && existingLocalMessages.length > 0) {
                                renderMessages(existingLocalMessages, messagesContainer);
                            } else if (selectedConversation === conversationId && messagesContainer) {
                                chatMessages[conversationId] = [];
                                renderMessages([], messagesContainer);
                            }
                        });
                        return;
                    }
                    
                    // Initial load: Fetch from both chatMessages and customerMessages
                    Promise.all([
                        messagesRef.once('value'),
                        custRef.once('value').catch(() => ({ val: () => null }))
                    ]).then(([snapshot, custSnap]) => {
                        const messages = [];
                        if (snapshot && snapshot.exists()) {
                            snapshot.forEach(function(childSnapshot) {
                                const message = childSnapshot.val();
                                // Always filter by conversationId client-side (works even if query fails)
                                // Also check customerId as fallback - this is critical for customer messages
                                // Customer messages have conversationId = customerId, so both should match
                                // Use normalized comparison for consistency
                                const msgConvId = normalizeConversationId(message?.conversationId);
                                const msgCustId = normalizeConversationId(message?.customerId);
                                const targetConvId = normalizeConversationId(conversationId);
                                
                                const matchesConversationId = conversationIdsMatch(msgConvId, targetConvId);
                                const matchesCustomerId = conversationIdsMatch(msgCustId, targetConvId);
                                
                                // CRITICAL: Exclude messages from rider-customer conversations
                                // Check if message is from a rider conversation (conversationId contains '_rider_' or chatType is 'rider')
                                const isRiderConversation = (message?.conversationId && message.conversationId.toString().includes('_rider_')) ||
                                                           (message?.chatType === 'rider');
                                
                                if (isRiderConversation) {
                                    console.log(' Message filtered out - it\'s from a rider conversation:', message.id, 'conversationId:', message.conversationId, 'chatType:', message.chatType);
                                    return; // Skip this message
                                }
                                
                                // Also check if message is from staff to this customer (staff messages should have customerId matching conversationId)
                                const isStaffToCustomer = message?.sender === 'staff' && (
                                    conversationIdsMatch(msgCustId, targetConvId) || 
                                    conversationIdsMatch(msgConvId, targetConvId)
                                );
                                
                                if (message && (matchesConversationId || matchesCustomerId || isStaffToCustomer)) {
                                    // Ensure message has an ID - use key if id is missing
                                    if (!message.id && childSnapshot.key) {
                                        message.id = childSnapshot.key;
                                    }
                                    // CRITICAL: Preserve imageUrl and videoUrl fields from Firebase
                                    if (message.imageUrl) {
                                        message.imageUrl = message.imageUrl;
                                    }
                                    if (message.videoUrl) {
                                        message.videoUrl = message.videoUrl;
                                    }
                                    // CRITICAL: Normalize timestamp to ensure it's always a number
                                    const originalTs = message.timestamp;
                                    message.timestamp = normalizeTimestamp(message.timestamp ?? message.createdAt ?? message.id ?? message.messageId ?? Date.now(), message);
                                    console.log(' Loaded message from chatMessages:', message.id, message.sender, message.text?.substring(0, 30), 'conversationId:', message.conversationId, 'customerId:', message.customerId, 'imageUrl:', message.imageUrl ? 'YES' : 'NO', 'videoUrl:', message.videoUrl ? 'YES' : 'NO', 'originalTimestamp:', originalTs, 'normalizedTimestamp:', message.timestamp, 'formatted:', formatTime(message.timestamp), 'target:', conversationId);
                                    messages.push(message);
                                } else if (message) {
                                    console.log(' Message filtered out:', message.id, 'sender:', message.sender, 'conversationId:', message.conversationId, 'customerId:', message.customerId, 'target:', conversationId, 'msgConvId:', msgConvId, 'msgCustId:', msgCustId);
                                }
                            });
                        }
                        
                        const custMessages = [];
                        if (custSnap && custSnap.exists() && custSnap.val()) {
                            custSnap.forEach(function(childSnapshot){
                                const msg = childSnapshot.val();
                                if (msg) {
                                    // Ensure message has an ID - use key if id is missing
                                    if (!msg.id && childSnapshot.key) {
                                        msg.id = childSnapshot.key;
                                    }
                                    // CRITICAL: Preserve imageUrl and videoUrl fields from Firebase
                                    if (msg.imageUrl) {
                                        msg.imageUrl = msg.imageUrl;
                                    }
                                    if (msg.videoUrl) {
                                        msg.videoUrl = msg.videoUrl;
                                    }
                                    // CRITICAL: Normalize timestamp to ensure it's always a number
                                    msg.timestamp = normalizeTimestamp(msg.timestamp ?? msg.createdAt ?? msg.id ?? msg.messageId ?? Date.now(), msg);
                                    console.log('Loaded message from customerMessages:', msg.id, msg.sender, msg.text?.substring(0, 30), 'imageUrl:', msg.imageUrl ? 'YES' : 'NO', 'videoUrl:', msg.videoUrl ? 'YES' : 'NO', 'timestamp:', msg.timestamp);
                                    custMessages.push(msg);
                                }
                            });
                        }
                        
                        console.log('Initial load: Found', messages.length, 'from chatMessages and', custMessages.length, 'from customerMessages');
                        
                        // Merge and deduplicate messages
                        const byId = new Map();
                        
                        // CRITICAL: First, check local state to preserve isRead status
                        // This ensures messages marked as read don't get marked as unread when loading from Firebase
                        const existingLocalMessages = chatMessages[conversationId] || [];
                        const localReadState = new Map();
                        existingLocalMessages.forEach(localMsg => {
                            if (localMsg && (localMsg.id || localMsg.timestamp)) {
                                const key = localMsg.id || `t_${localMsg.timestamp}_${localMsg.sender}`;
                                // Preserve isRead state from local messages
                                if (localMsg.isRead === true && localMsg.sender === 'customer') {
                                    localReadState.set(key, true);
                                }
                            }
                        });
                        
                        [...messages, ...custMessages].forEach(m => { 
                            if (m && (m.id || m.timestamp)) {
                                const key = m.id || `t_${m.timestamp}_${m.sender}`;
                                // Keep the most complete message if duplicate
                                const existing = byId.get(key);
                                // CRITICAL: Preserve imageUrl and videoUrl - prefer the one with media if available
                                const hasMedia = (m.imageUrl || m.videoUrl);
                                const existingHasMedia = (existing && (existing.imageUrl || existing.videoUrl));
                                
                                if (!existing || (m.customerName && !existing.customerName) || (hasMedia && !existingHasMedia)) {
                                    // CRITICAL: Preserve isRead state from local messages
                                    // This prevents messages from being marked as unread when loading from Firebase
                                    // BUT: Don't mark new messages as read - only preserve existing read state
                                    if (m.sender === 'customer') {
                                        if (localReadState.has(key) && localReadState.get(key) === true) {
                                            // Message was already marked as read in local state - preserve that
                                            m.isRead = true;
                                            console.log('Preserved isRead=true from local state for message:', m.id || m.text?.substring(0, 30));
                                        } else if (m.isRead !== true) {
                                            // Message not explicitly read - mark as unread
                                            m.isRead = false;
                                        }
                                    }
                                    
                                    // CRITICAL: Ensure imageUrl and videoUrl are preserved as strings
                                    if (m.imageUrl) {
                                        m.imageUrl = String(m.imageUrl);
                                    }
                                    if (m.videoUrl) {
                                        m.videoUrl = String(m.videoUrl);
                                    }
                                    
                                    byId.set(key, m);
                                } else if (existing) {
                                    // If existing message is kept, ensure it has media fields if m has them
                                    if (m.imageUrl && !existing.imageUrl) {
                                        existing.imageUrl = String(m.imageUrl);
                                    }
                                    if (m.videoUrl && !existing.videoUrl) {
                                        existing.videoUrl = String(m.videoUrl);
                                    }
                                }
                            }
                        });
                        
                        // CRITICAL: Use centralized sorting function to ensure consistent ordering
                        const merged = sortMessagesByTimestamp(Array.from(byId.values()));
                        
                        // CRITICAL: If conversation is in readConversations, mark ALL customer messages as read
                        // This ensures badge doesn't appear when loading messages for already-read conversations
                        const normalizedConvoId = normalizeConversationId(conversationId);
                        const isReadConversation = window.readConversations && window.readConversations.has(normalizedConvoId);
                        if (isReadConversation) {
                            merged.forEach(message => {
                                if (message.sender === 'customer') {
                                    message.isRead = true;
                                }
                            });
                            console.log('Initial load: Marked all customer messages as read for conversation in readConversations:', normalizedConvoId);
                        }
                        
                        chatMessages[conversationId] = merged;
                        console.log('Initial load: Loaded', merged.length, 'total messages for conversation:', conversationId);
                        console.log('Initial load: Messages breakdown -', messages.length, 'from chatMessages,', custMessages.length, 'from customerMessages');
                        
                        // CRITICAL: Only update badge count if conversation is NOT in readConversations
                        // If conversation is in readConversations, badge was already updated when marking as read
                        // This prevents badge from appearing when loading messages for already-read conversations
                        if (!isReadConversation) {
                            // Update badge count AFTER merging and preserving isRead state
                            // Small delay to ensure merge is complete and isRead state is preserved
                            setTimeout(() => {
                                updateBadgeCount();
                            }, 100);
                        } else {
                            console.log('Skipping badge update for conversation in readConversations:', normalizedConvoId);
                        }
                        
                        // Use type-safe comparison to handle string/number mismatches
                        const isSelectedConversation = conversationIdsMatch(selectedConversation, conversationId);
                        
                        console.log('Initial load: Selected conversation:', selectedConversation, 'Current conversation:', conversationId);
                        console.log('Initial load: Type-safe comparison:', {
                            normalizedSelected: normalizeConversationId(selectedConversation),
                            normalizedLoad: normalizeConversationId(conversationId),
                            isSelectedConversation: isSelectedConversation,
                            messagesContainer: !!messagesContainer
                        });
                        
                        // Always render if this conversation is selected
                        if (isSelectedConversation && messagesContainer) {
                            console.log(' Rendering', merged.length, 'messages for selected conversation');
                            renderMessages(merged, messagesContainer);
                        } else {
                            console.log(' Not rendering - selectedConversation:', selectedConversation, 'conversationId:', conversationId, 'messagesContainer:', !!messagesContainer);
                        }
                        
                        // Ensure conversation metadata exists and update preview
                        if (merged.length > 0) {
                            const lastMessage = merged[merged.length - 1];
                            ensureConversationExists(conversationId, lastMessage);
                            // Update conversation preview with the latest message
                            if (lastMessage && lastMessage.text) {
                                updateConversationPreview(conversationId, lastMessage.text, lastMessage.sender, lastMessage.timestamp);
                                // Also update conversation list from message
                                updateConversationListFromMessage(conversationId, lastMessage);
                            }
                        } else {
                            ensureConversationExists(conversationId, { sender: 'customer', text: '', timestamp: Date.now() });
                        }
                    }).catch((err) => {
                        console.error('Error loading initial messages:', err);
                        // CRITICAL: Use normalized conversation ID
                        chatMessages[normalizedConversationId] = [];
                        const isSelected = conversationIdsMatch(selectedConversation, normalizedConversationId);
                        if (isSelected && messagesContainer) {
                            renderMessages([], messagesContainer);
                        }
                    });
                    // CRITICAL: Use normalized conversation ID as key
                    window.firebaseListeners[normalizedConversationId] = messagesRef;
                    // Initialize listeners object if it doesn't exist
                    if (!window.chatMessageListeners) {
                        window.chatMessageListeners = {};
                    }
                    
                    // Set up real-time listener that merges from both paths
                    // CRITICAL: Use normalized conversation ID as key
                    window.chatMessageListeners[normalizedConversationId] = async function(snapshot) {
                        // CRITICAL: Use normalized conversation ID throughout this listener
                        const listenerConversationId = normalizedConversationId;
                        // Don't skip rendering - we need to update the UI when Firebase confirms the message
                        // The optimistic message will be replaced with the real Firebase message
                        const timeSinceOptimistic = Date.now() - optimisticRenderTime;
                        const shouldSkipOptimisticCheck = isRenderingOptimisticMessage && timeSinceOptimistic < 1000; // Reduced to 1 second
                        
                        if (shouldSkipOptimisticCheck) {
                            console.log(' Brief delay for optimistic render (time since:', timeSinceOptimistic, 'ms)');
                            // Don't return - continue processing but with a small delay
                        }
                        
                        const messages = [];
                        console.log('Real-time update for conversation:', listenerConversationId, 'snapshot exists:', snapshot.exists());
                        
                        if (snapshot && snapshot.exists()) {
                            snapshot.forEach(function(childSnapshot) {
                                const message = childSnapshot.val();
                                
                                // CRITICAL: Exclude messages from rider-customer conversations
                                const msgConvId = normalizeConversationId(message?.conversationId);
                                const isRiderConversation = (message?.chatType === 'rider') || 
                                                           (msgConvId && msgConvId.includes('_rider_'));
                                if (isRiderConversation) {
                                    console.log(' Real-time message filtered out - rider conversation:', message.id, 'conversationId:', msgConvId, 'chatType:', message.chatType);
                                    return; // Skip this message
                                }
                                
                                // Use normalized comparison for consistency
                                const msgCustId = normalizeConversationId(message?.customerId);
                                // CRITICAL: Use normalized conversation ID for comparison
                                const targetConvId = normalizeConversationId(listenerConversationId);
                                
                                const matchesConversationId = conversationIdsMatch(msgConvId, targetConvId);
                                const matchesCustomerId = conversationIdsMatch(msgCustId, targetConvId);
                                
                                // Also check if message is from staff to this customer
                                const isStaffToCustomer = message?.sender === 'staff' && (
                                    conversationIdsMatch(msgCustId, targetConvId) || 
                                    conversationIdsMatch(msgConvId, targetConvId)
                                );
                                
                                if (message && (matchesConversationId || matchesCustomerId || isStaffToCustomer)) {
                                    // Ensure message has an ID - use key if id is missing
                                    if (!message.id && childSnapshot.key) {
                                        message.id = childSnapshot.key;
                                    }
                                    // CRITICAL: Normalize timestamp to ensure it's always a number
                                    const originalTs = message.timestamp;
                                    message.timestamp = normalizeTimestamp(message.timestamp ?? message.createdAt ?? message.id ?? message.messageId ?? Date.now(), message);
                                    console.log(' Found message in real-time:', message.id, 'sender:', message.sender, 'text:', message.text?.substring(0, 50), 'conversationId:', message.conversationId, 'customerId:', message.customerId, 'originalTimestamp:', originalTs, 'normalizedTimestamp:', message.timestamp, 'formatted:', formatTime(message.timestamp));
                                    messages.push(message);
                                } else if (message) {
                                    console.log(' Real-time message filtered out:', message.id, 'sender:', message.sender, 'conversationId:', message.conversationId, 'customerId:', message.customerId, 'target:', conversationId);
                                }
                            });
                        }
                        
                        // Also fetch from customerMessages and merge
                        try {
                            const custSnap = await custRef.once('value');
                            if (custSnap && custSnap.exists() && custSnap.val()) {
                                custSnap.forEach(function(childSnapshot){
                                    const msg = childSnapshot.val();
                                    if (msg) {
                                        // CRITICAL: Exclude messages from rider-customer conversations
                                        const msgConvId = normalizeConversationId(msg?.conversationId);
                                        const isRiderConversation = (msg?.chatType === 'rider') || 
                                                                   (msgConvId && msgConvId.includes('_rider_')) ||
                                                                   (listenerConversationId && listenerConversationId.includes('_rider_'));
                                        if (isRiderConversation) {
                                            console.log(' customerMessages real-time update filtered out - rider conversation:', msg.id, 'conversationId:', msgConvId || listenerConversationId, 'chatType:', msg.chatType);
                                            return; // Skip this message
                                        }
                                        
                                        // Ensure message has an ID - use key if id is missing
                                        if (!msg.id && childSnapshot.key) {
                                            msg.id = childSnapshot.key;
                                        }
                                        // CRITICAL: Normalize timestamp to ensure it's always a number
                                        const originalTs = msg.timestamp;
                                        msg.timestamp = normalizeTimestamp(msg.timestamp ?? msg.createdAt ?? msg.id ?? msg.messageId ?? Date.now(), msg);
                                        console.log('Found message in customerMessages:', msg.id, 'sender:', msg.sender, 'text:', msg.text?.substring(0, 50), 'originalTimestamp:', originalTs, 'normalizedTimestamp:', msg.timestamp, 'formatted:', formatTime(msg.timestamp));
                                        messages.push(msg);
                                    }
                                });
                            }
                        } catch (err) {
                            console.warn('Error fetching customerMessages in real-time:', err);
                        }
                        
                        // Merge with existing local messages to preserve optimistic updates
                        // CRITICAL: Use normalized conversation ID
                        const existingLocalMessages = chatMessages[listenerConversationId] || [];
                        const now = Date.now();
                        const RECENT_MESSAGE_THRESHOLD = 30000; // 30 seconds - consider messages newer than this as "recent"
                        
                        console.log('Real-time: Found', messages.length, 'messages from Firebase,', existingLocalMessages.length, 'existing local messages');
                        
                        // Build a map of Firebase message IDs for quick lookup
                        const firebaseMessageIds = new Set();
                        messages.forEach(m => {
                            if (m && m.id) {
                                firebaseMessageIds.add(m.id);
                            }
                        });
                        
                        // Merge and deduplicate - combine Firebase messages with local messages
                        const byId = new Map();
                        
                        // First, add all Firebase messages (source of truth)
                        messages.forEach(m => { 
                            if (m && (m.id || m.timestamp)) {
                                const key = m.id || `t_${m.timestamp}_${m.sender}`;
                                byId.set(key, m);
                            }
                        });
                        
                        // Then, add local messages that aren't in Firebase yet (preserve ALL local messages not in Firebase)
                        existingLocalMessages.forEach(m => { 
                            if (m && (m.id || m.timestamp)) {
                                const key = m.id || `t_${m.timestamp}_${m.sender}`;
                                const existsInFirebase = m.id && firebaseMessageIds.has(m.id);
                                const isOptimistic = m.isOptimistic === true;
                                
                                // Check if there's a Firebase message with matching text and timestamp (for optimistic messages)
                                // Use more lenient matching for staff messages - check text and sender, allow up to 10 seconds difference
                                const matchingFirebaseMsg = messages.find(fm => 
                                    fm.sender === m.sender &&
                                    fm.text === m.text &&
                                    Math.abs((fm.timestamp || 0) - (m.timestamp || 0)) < 10000 // Within 10 seconds for better matching
                                );
                                
                                // Preserve local message if:
                                // 1. It's an optimistic message (not yet confirmed by Firebase)
                                // 2. It's not in Firebase yet (preserve ALL local messages not in Firebase)
                                // 3. Or if it exists but our local version has more complete data
                                if (matchingFirebaseMsg) {
                                    // Found matching Firebase message - use Firebase version
                                    console.log('Found matching Firebase message for local/optimistic message, using Firebase version with ID:', matchingFirebaseMsg.id);
                                    // Update the optimistic message in the local array if it exists
                                    if (isOptimistic) {
                                        // CRITICAL: Use normalized conversation ID
                                        const optimisticIndex = chatMessages[listenerConversationId].findIndex(msg => 
                                            (msg.id === m.id || msg.isOptimistic || (msg.id && msg.id.startsWith('temp_'))) &&
                                            msg.text === m.text &&
                                            msg.sender === m.sender &&
                                            Math.abs((msg.timestamp || 0) - (m.timestamp || 0)) < 10000
                                        );
                                        if (optimisticIndex !== -1) {
                                            // Update optimistic message with Firebase ID
                                            // CRITICAL: Use normalized conversation ID
                                            chatMessages[listenerConversationId][optimisticIndex] = {
                                                ...matchingFirebaseMsg,
                                                isOptimistic: false
                                            };
                                            console.log(' Updated optimistic message in local array with Firebase ID:', matchingFirebaseMsg.id);
                                            
                                            // Re-render immediately after updating optimistic message
                                            // CRITICAL: Use normalized comparison
                                            const isSelected = conversationIdsMatch(selectedConversation, listenerConversationId);
                                            if (isSelected && !isMarkingAsRead) {
                                                const msgContainer = document.getElementById('chatMessages');
                                                if (msgContainer) {
                                                    console.log(' Re-rendering after optimistic message update');
                                                    // CRITICAL: Use normalized conversation ID
                                                    renderMessages(chatMessages[listenerConversationId], msgContainer).then(() => {
                                                        setTimeout(() => {
                                                            if (msgContainer) {
                                                                msgContainer.scrollTop = msgContainer.scrollHeight;
                                                            }
                                                        }, 100);
                                                    });
                                                }
                                            }
                                        }
                                    }
                                    // Use Firebase version in merged result
                                    byId.set(matchingFirebaseMsg.id || key, matchingFirebaseMsg);
                                } else if (isOptimistic) {
                                    // Optimistic message not yet confirmed by Firebase - ALWAYS preserve it
                                    console.log(' Preserving optimistic message:', m.id || m.text?.substring(0, 30), 'sender:', m.sender, 'timestamp:', m.timestamp);
                                    byId.set(key, m);
                                } else if (!existsInFirebase && !byId.has(key)) {
                                    // Local message not in Firebase yet - ALWAYS preserve it (not just recent ones)
                                    // This ensures we don't lose messages during real-time updates
                                    console.log('Preserving local message not in Firebase:', m.id || m.text?.substring(0, 30), 'sender:', m.sender);
                                    byId.set(key, m);
                                } else if (existsInFirebase && byId.has(key)) {
                                    // Message exists in both - prefer Firebase version but preserve local isRead state
                                    const firebaseMsg = byId.get(key);
                                    // CRITICAL: Preserve isRead state from local message if it was marked as read
                                    // This prevents messages from being marked as unread when real-time updates come from Firebase
                                    if (m.sender === 'customer' && m.isRead === true) {
                                        firebaseMsg.isRead = true;
                                        console.log('Real-time: Preserved isRead=true from local state for message:', firebaseMsg.id || firebaseMsg.text?.substring(0, 30));
                                    }
                                    // Keep local version if it has more data (like customerName)
                                    if (m.customerName && !firebaseMsg.customerName) {
                                        byId.set(key, m);
                                    } else {
                                        // Use Firebase version but with preserved isRead state
                                        byId.set(key, firebaseMsg);
                                    }
                                }
                            }
                        });
                        
                        // CRITICAL: Use centralized sorting function to ensure consistent ordering
                        const merged = sortMessagesByTimestamp(Array.from(byId.values()));
                        
                        // Store messages locally (merged version preserves local optimistic updates)
                        // CRITICAL: Before overwriting, check if there are optimistic messages in the current array
                        // that aren't in the merged array - if so, preserve them
                        // CRITICAL: Use normalized conversation ID
                        const currentArray = chatMessages[listenerConversationId] || [];
                        const currentOptimistic = currentArray.filter(m => m.isOptimistic);
                        const mergedOptimistic = merged.filter(m => m.isOptimistic);
                        
                        console.log('Real-time merge: Current array has', currentArray.length, 'messages (', currentOptimistic.length, 'optimistic)');
                        console.log('Real-time merge: Merged array has', merged.length, 'messages (', mergedOptimistic.length, 'optimistic)');
                        
                        // ALWAYS preserve ALL optimistic messages from current array that aren't in merged
                        // This is critical to prevent losing messages that are being sent
                        currentOptimistic.forEach(optMsg => {
                            // Check if this optimistic message exists in merged by matching text, sender, and timestamp
                            const existsInMerged = merged.some(m => 
                                (m.isOptimistic && m.text === optMsg.text && m.sender === optMsg.sender && Math.abs((m.timestamp || 0) - (optMsg.timestamp || 0)) < 2000) ||
                                (m.id === optMsg.id && optMsg.id && optMsg.id.startsWith('temp_')) ||
                                (m.text === optMsg.text && m.sender === optMsg.sender && Math.abs((m.timestamp || 0) - (optMsg.timestamp || 0)) < 2000 && m.sender === 'staff')
                            );
                            if (!existsInMerged) {
                                console.log(' CRITICAL: Adding missing optimistic message to merged array:', optMsg.text?.substring(0, 30), 'sender:', optMsg.sender, 'timestamp:', optMsg.timestamp);
                                merged.push(optMsg);
                            } else {
                                console.log(' Optimistic message already in merged:', optMsg.text?.substring(0, 30));
                            }
                        });
                        
                        // Also preserve any recent staff messages from current array that might not be in merged yet
                        // This handles the case where a message was just sent but Firebase hasn't confirmed it yet
                        const recentThreshold = Date.now() - 5000; // Last 5 seconds
                        currentArray.forEach(msg => {
                            if (msg.sender === 'staff' && msg.timestamp && msg.timestamp > recentThreshold) {
                                const existsInMerged = merged.some(m => 
                                    (m.id === msg.id && msg.id) ||
                                    (m.text === msg.text && m.sender === msg.sender && Math.abs((m.timestamp || 0) - (msg.timestamp || 0)) < 2000)
                                );
                                if (!existsInMerged) {
                                    console.log(' CRITICAL: Adding missing recent staff message to merged array:', msg.text?.substring(0, 30));
                                    merged.push(msg);
                                }
                            }
                        });
                        
                        // CRITICAL: Re-sort after adding optimistic/recent messages using centralized function
                        // This ensures consistent ordering with the rest of the application
                        const finalMerged = sortMessagesByTimestamp(merged);
                        // Update merged array reference
                        merged.length = 0;
                        merged.push(...finalMerged);
                        
                        // Verify sorting is correct
                        const isSorted = merged.every((m, i) => i === 0 || (m.timestamp || 0) >= (merged[i - 1].timestamp || 0));
                        if (!isSorted) {
                            console.error(' Real-time listener: Merged array is NOT sorted correctly!');
                            console.log(' First 3 messages:', merged.slice(0, 3).map(m => ({
                                text: m.text?.substring(0, 20),
                                timestamp: m.timestamp,
                                sender: m.sender
                            })));
                            console.log(' Last 3 messages:', merged.slice(-3).map(m => ({
                                text: m.text?.substring(0, 20),
                                timestamp: m.timestamp,
                                sender: m.sender
                            })));
                        } else {
                            console.log(' Real-time listener: Merged array is sorted correctly');
                            if (merged.length > 0) {
                                console.log(' First message timestamp:', merged[0].timestamp);
                                console.log(' Last message timestamp:', merged[merged.length - 1].timestamp);
                            }
                        }
                        
                        // CRITICAL: Use normalized conversation ID as key
                        chatMessages[listenerConversationId] = merged;
                        console.log('Real-time: Stored', merged.length, 'messages for conversation:', listenerConversationId, '(preserved', existingLocalMessages.length, 'local messages)');
                        console.log('Optimistic messages in merged:', merged.filter(m => m.isOptimistic).length);
                        console.log('Staff messages in merged:', merged.filter(m => m.sender === 'staff').length);
                        
                        // Always render if this conversation is currently selected and we're not in a bulk read mark
                        // CRITICAL: Always render to ensure messages appear after Firebase save
                        // Use type-safe comparison to handle string/number mismatches
                        const isSelectedConversation = conversationIdsMatch(selectedConversation, conversationId);
                        
                        console.log(' Real-time listener render check:', {
                            selectedConversation: selectedConversation,
                            conversationId: conversationId,
                            normalizedSelected: normalizeConversationId(selectedConversation),
                            normalizedListener: normalizeConversationId(conversationId),
                            isSelectedConversation: isSelectedConversation,
                            isMarkingAsRead: isMarkingAsRead,
                            mergedLength: merged.length,
                            staffMessages: merged.filter(m => m.sender === 'staff').length
                        });
                        
                        if (isSelectedConversation && !isMarkingAsRead) {
                            const msgContainer = document.getElementById('chatMessages');
                            if (msgContainer) {
                                // Check if there are optimistic messages that need to be preserved
                                const hasOptimisticInMerged = merged.some(m => m.isOptimistic);
                                const hasOptimisticInCurrent = (chatMessages[conversationId] || []).some(m => m.isOptimistic);
                                const hasOptimistic = hasOptimisticInMerged || hasOptimisticInCurrent;
                                
                                // If we have optimistic messages and it's been less than 2 seconds, use a small delay
                                // Otherwise, render immediately to ensure messages appear
                                const timeSinceOptimistic = Date.now() - optimisticRenderTime;
                                if (hasOptimistic && timeSinceOptimistic < 2000) {
                                    console.log(' Has optimistic messages, using brief delay before render');
                                    setTimeout(() => {
                                        // Use type-safe comparison
                                        const stillSelected = conversationIdsMatch(selectedConversation, listenerConversationId);
                                        
                                        if (stillSelected) {
                                            // Merge current optimistic messages with Firebase messages
                                            // CRITICAL: Use normalized conversation ID
                                            const currentOptimistic = (chatMessages[listenerConversationId] || []).filter(m => m.isOptimistic);
                                            const finalMerged = [...merged];
                                            
                                            // Add optimistic messages that aren't in merged yet
                                            currentOptimistic.forEach(optMsg => {
                                                const exists = finalMerged.some(m => 
                                                    (m.id === optMsg.id && optMsg.id) ||
                                                    (m.text === optMsg.text && m.sender === optMsg.sender && 
                                                     Math.abs((m.timestamp || 0) - (optMsg.timestamp || 0)) < 2000)
                                                );
                                                if (!exists) {
                                                    finalMerged.push(optMsg);
                                                }
                                            });
                                            
                                            // Sort final merged array
                                            finalMerged.sort((a, b) => {
                                                if ((a.timestamp||0) !== (b.timestamp||0)) return (a.timestamp||0) - (b.timestamp||0);
                                                if ((a.sender||'') !== (b.sender||'')) return (a.sender||'') === 'customer' ? -1 : 1;
                                                return (a.id || '').localeCompare(b.id || '');
                                            });
                                            
                                            console.log(' Rendering', finalMerged.length, 'messages (including optimistic) from real-time listener');
                                            console.log(' Staff messages in render array:', finalMerged.filter(m => m.sender === 'staff').length);
                                            renderMessages(finalMerged, msgContainer).then(() => {
                                                setTimeout(() => {
                                                    if (msgContainer) {
                                                        msgContainer.scrollTop = msgContainer.scrollHeight;
                                                    }
                                                }, 100);
                                            });
                                        }
                                    }, 300); // Reduced delay
                                } else {
                                    // No optimistic messages or enough time has passed - render immediately
                                    console.log(' Rendering', merged.length, 'messages from real-time listener (value listener)');
                                    console.log('Selected conversation:', selectedConversation, 'Current conversation:', listenerConversationId);
                                    console.log(' Staff messages in render array:', merged.filter(m => m.sender === 'staff').length);
                                    console.log(' Real-time listener - checking if should render:', {
                                        selectedConversation: selectedConversation,
                                        listenerConversationId: listenerConversationId,
                                        isSelected: isSelectedConversation,
                                        mergedLength: merged.length,
                                        staffMessages: merged.filter(m => m.sender === 'staff').length
                                    });
                                    renderMessages(merged, msgContainer).then(() => {
                                        console.log(' Completed rendering', merged.length, 'messages');
                                        // Scroll to bottom after render
                                        setTimeout(() => {
                                            if (msgContainer) {
                                                msgContainer.scrollTop = msgContainer.scrollHeight;
                                                console.log(' Scrolled to bottom, scrollTop:', msgContainer.scrollTop, 'scrollHeight:', msgContainer.scrollHeight);
                                            }
                                        }, 100);
                                    }).catch((error) => {
                                        console.error(' Error rendering messages:', error);
                                    });
                                }
                            } else {
                                console.warn(' Messages container not found for rendering. selectedConversation:', selectedConversation);
                            }
                        } else {
                            console.log(' Not rendering - selectedConversation:', selectedConversation, 'conversationId:', conversationId, 'isMarkingAsRead:', isMarkingAsRead);
                        }
                        
                        // Ensure conversation metadata exists for new customer messages
                        if (merged.length > 0) {
                            const lastMessage = merged[merged.length - 1];
                            if (lastMessage.sender === 'customer') {
                                ensureConversationExists(conversationId, lastMessage);
                            }
                        }
                    };
                    // Add persistent listener for real-time updates (chatMessages)
                    // CRITICAL: Use normalized conversation ID
                    console.log(' Creating persistent listener for conversation:', normalizedConversationId);
                    messagesRef.on('value', window.chatMessageListeners[normalizedConversationId], (error) => {
                        if (error) {
                            console.error(' Error in Firebase listener:', error);
                        }
                    });

                    // Also listen to customerMessages/{conversationId} as a compatibility source
                    if (!window.chatCustomerMessageListeners) {
                        window.chatCustomerMessageListeners = {};
                    }
                    window.chatCustomerMessageListeners[conversationId] = async function(snapshot){
                        const custMessages = [];
                        snapshot.forEach(function(childSnapshot){
                            const msg = childSnapshot.val();
                            if (msg) {
                                // CRITICAL: Exclude messages from rider-customer conversations
                                const msgConvId = normalizeConversationId(msg?.conversationId);
                                const isRiderConversation = (msg?.chatType === 'rider') || 
                                                           (msgConvId && msgConvId.includes('_rider_')) ||
                                                           (conversationId && conversationId.includes('_rider_'));
                                if (isRiderConversation) {
                                    console.log(' customerMessages listener filtered out - rider conversation:', msg.id, 'conversationId:', msgConvId || conversationId, 'chatType:', msg.chatType);
                                    return; // Skip this message
                                }
                                
                                // Ensure message has an ID - use key if id is missing
                                if (!msg.id && childSnapshot.key) {
                                    msg.id = childSnapshot.key;
                                }
                                custMessages.push(msg);
                            }
                        });
                        
                        // Check for new messages that aren't already in our local array
                        const existing = chatMessages[conversationId] || [];
                        const existingIds = new Set(existing.map(m => m.id || `t_${m.timestamp}_${m.sender}`));
                        const newMessages = custMessages.filter(m => {
                            const key = m.id || `t_${m.timestamp}_${m.sender}`;
                            return !existingIds.has(key);
                        });
                        
                        // If we have new messages, add them individually so they get rendered properly
                        if (newMessages.length > 0) {
                            console.log('Found', newMessages.length, 'new messages in customerMessages path');
                            for (const newMsg of newMessages) {
                                // CRITICAL: Use normalized conversation ID
                                await addMessageToConversation(listenerConversationId, newMsg);
                            }
                        } else {
                            // No new messages, just merge to ensure consistency
                            // But preserve ALL local staff messages that might not be in customerMessages
                            const byId = new Map();
                            
                            // First add all customerMessages (they're the source for this path)
                            custMessages.forEach(m => { 
                                if (m && (m.id || m.timestamp)) {
                                    const key = m.id || `t_${m.timestamp}_${m.sender}`;
                                    // Keep the most complete message if duplicate
                                    const existing = byId.get(key);
                                    if (!existing || (m.customerName && !existing.customerName)) {
                                        byId.set(key, m);
                                    }
                                }
                            });
                            
                            // Then add existing local messages, preserving ALL staff messages (customerMessages doesn't contain staff messages, so always preserve them)
                            // and preserving ALL customer messages that might not be in customerMessages yet
                            existing.forEach(m => { 
                                if (m && (m.id || m.timestamp)) {
                                    const key = m.id || `t_${m.timestamp}_${m.sender}`;
                                    const isStaff = m.sender === 'staff';
                                    
                                    // Always preserve staff messages (they're not in customerMessages, so always preserve them)
                                    // Also preserve ALL customer messages that might not be in customerMessages yet
                                    if (isStaff) {
                                        if (!byId.has(key)) {
                                            byId.set(key, m);
                                        }
                                    } else if (!byId.has(key)) {
                                        // Customer message not in customerMessages yet - preserve it (not just recent ones)
                                        byId.set(key, m);
                                    } else if (byId.has(key)) {
                                        // Message exists in both - prefer customerMessages version but keep local if it has more data
                                        const existingMsg = byId.get(key);
                                        if (m.customerName && !existingMsg.customerName) {
                                            byId.set(key, m);
                                        }
                                    }
                                }
                            });
                            
                            const merged = Array.from(byId.values()).sort((a, b) => {
                                if ((a.timestamp||0) !== (b.timestamp||0)) return (a.timestamp||0) - (b.timestamp||0);
                                if ((a.sender||'') !== (b.sender||'')) return (a.sender||'') === 'customer' ? -1 : 1;
                                return (a.id || '').localeCompare(b.id || '');
                            });
                            
                            chatMessages[conversationId] = merged;
                            
                            // Render if this conversation is selected
                            if (selectedConversation === conversationId && !isMarkingAsRead) {
                                const msgContainer = document.getElementById('chatMessages');
                                if (msgContainer) {
                                    renderMessages(merged, msgContainer);
                                }
                            }
                        }
                    };
                    console.log(' Creating compatibility listener for customerMessages:', conversationId);
                    custRef.on('value', window.chatCustomerMessageListeners[conversationId]);
                    
                    // Monitor connection state (only once globally)
                    if (!window.firebaseConnectionMonitor) {
                        const connectedRef = firebase.database().ref('.info/connected');
                        connectedRef.on('value', (snapshot) => {
                            const isConnected = snapshot.val();
                            if (isConnected) {
                                console.log(' Firebase connected');
                            } else {
                                console.warn(' Firebase disconnected - will reconnect automatically');
                            }
                        });
                        window.firebaseConnectionMonitor = connectedRef;
                    }
                    
                    // Set up a heartbeat to keep connection alive
                    if (!window.firebaseHeartbeat) {
                        window.firebaseHeartbeat = setInterval(() => {
                            // Make a small read to keep connection alive
                            firebase.database().ref('.info/connected').once('value').then(() => {
                                console.log(' Firebase heartbeat - connection alive');
                            }).catch((error) => {
                                console.error(' Firebase heartbeat failed:', error);
                            });
                        }, 30000); // Every 30 seconds
                    }
                    
                    // Track active listeners for debugging
                    if (!window.activeListeners) {
                        window.activeListeners = new Set();
                    }
                    window.activeListeners.add(conversationId);
                    console.log(' Added real-time listener for conversation:', conversationId);
                    console.log(' Active listeners:', Array.from(window.activeListeners));
                    
                } else {
                    // Firebase fallback disabled - using Supabase instead
                    // Load messages from Supabase
                    console.log(' Loading messages from Supabase (Firebase fallback disabled)');
                    try {
                        const supabase = getSupabaseClientSafe();
                        if (supabase) {
                            // Load messages from Supabase conversations table
                            const { data: messages, error } = await supabase
                                .from('conversations')
                                .select('*')
                                .eq('conversation_id', conversationId)
                                .order('created_at', { ascending: true });
                            
                            if (!error && messages && messages.length > 0) {
                                // Convert Supabase messages to chat format
                                const formattedMessages = messages.map(msg => ({
                                    id: msg.id,
                                    conversationId: msg.conversation_id,
                                    sender: msg.sender_type || 'customer',
                                    text: msg.message_text || '',
                                    timestamp: new Date(msg.created_at).getTime(),
                                    isRead: msg.is_read || false,
                                    createdAt: new Date(msg.created_at).getTime()
                                }));
                                
                                chatMessages[conversationId] = formattedMessages;
                                
                                if (messagesContainer) {
                                    renderMessages(formattedMessages, messagesContainer);
                                }
                            } else {
                                // No messages found - show empty state
                                if (messagesContainer) {
                                    messagesContainer.innerHTML = `
                                        <div class="chat-empty">
                                            <i class="fas fa-comments"></i>
                                            <p>No messages yet. Start the conversation!</p>
                                        </div>
                                    `;
                                }
                            }
                        } else {
                            console.warn('Supabase not available - showing empty state');
                            if (messagesContainer) {
                                messagesContainer.innerHTML = `
                                    <div class="chat-empty">
                                        <i class="fas fa-comments"></i>
                                        <p>Loading messages...</p>
                                    </div>
                                `;
                            }
                        }
                    } catch (error) {
                        console.error('Error loading messages from Supabase:', error);
                        if (messagesContainer) {
                            messagesContainer.innerHTML = `
                                <div class="chat-error">
                                    <i class="fas fa-exclamation-triangle"></i>
                                    <h4>Error loading messages</h4>
                                    <p>Please try again later</p>
                                </div>
                            `;
                        }
                    }
                }
            } catch (error) {
                console.error('Error loading messages from Firebase:', error);
                // Show error state
                const messagesContainer = document.getElementById('chatMessages');
                if (messagesContainer) {
                    messagesContainer.innerHTML = `
                        <div class="chat-error">
                            <i class="fas fa-exclamation-triangle"></i>
                            <h4>Error loading messages</h4>
                            <p>Please try again later</p>
                        </div>
                    `;
                }
            }
        }
        // Handle media file selection and upload to Supabase
        // Store selected media files for preview
        let selectedMediaFiles = [];

        async function handleMediaSelection(event) {
            const files = Array.from(event.target.files);
            if (!files || files.length === 0) return;
            
            // Add files to preview
            for (const file of files) {
                if (file.type.startsWith('image/') || file.type.startsWith('video/')) {
                    selectedMediaFiles.push(file);
                    addMediaPreview(file);
                }
            }
            
            // Reset input to allow selecting same files again
            event.target.value = '';
            
            // Show preview container
            const previewContainer = document.getElementById('mediaPreviewContainer');
            if (previewContainer && selectedMediaFiles.length > 0) {
                previewContainer.classList.add('active');
            }
        }

        function addMediaPreview(file) {
            const previewGrid = document.getElementById('mediaPreviewGrid');
            if (!previewGrid) return;
            
            const previewItem = document.createElement('div');
            previewItem.className = 'media-preview-item';
            previewItem.dataset.fileIndex = selectedMediaFiles.length - 1;
            
            const isVideo = file.type.startsWith('video/');
            const objectUrl = URL.createObjectURL(file);
            
            if (isVideo) {
                const video = document.createElement('video');
                video.src = objectUrl;
                video.muted = true;
                video.playsInline = true;
                previewItem.appendChild(video);
                
                const videoIcon = document.createElement('div');
                videoIcon.className = 'video-icon';
                videoIcon.innerHTML = '<i class="fas fa-play-circle"></i>';
                previewItem.appendChild(videoIcon);
            } else {
                const img = document.createElement('img');
                img.src = objectUrl;
                previewItem.appendChild(img);
            }
            
            // Remove button
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-btn';
            removeBtn.innerHTML = '<i class="fas fa-times"></i>';
            removeBtn.onclick = (e) => {
                e.stopPropagation();
                removeMediaPreview(previewItem.dataset.fileIndex);
            };
            previewItem.appendChild(removeBtn);
            
            // Click to view in lightbox
            previewItem.onclick = () => {
                if (isVideo) {
                    openVideoLightbox(objectUrl);
                } else {
                    openImageLightbox(objectUrl);
                }
            };
            
            previewGrid.appendChild(previewItem);
        }

        function removeMediaPreview(index) {
            const previewGrid = document.getElementById('mediaPreviewGrid');
            if (!previewGrid) return;
            
            // Remove from array
            selectedMediaFiles.splice(index, 1);
            
            // Remove preview item
            const previewItem = previewGrid.querySelector(`[data-file-index="${index}"]`);
            if (previewItem) {
                // Revoke object URL to free memory
                const mediaElement = previewItem.querySelector('img, video');
                if (mediaElement && mediaElement.src) {
                    URL.revokeObjectURL(mediaElement.src);
                }
                previewItem.remove();
            }
            
            // Update indices
            const items = previewGrid.querySelectorAll('.media-preview-item');
            items.forEach((item, i) => {
                item.dataset.fileIndex = i;
                const removeBtn = item.querySelector('.remove-btn');
                if (removeBtn) {
                    removeBtn.onclick = (e) => {
                        e.stopPropagation();
                        removeMediaPreview(i);
                    };
                }
            });
            
            // Hide preview container if empty
            const previewContainer = document.getElementById('mediaPreviewContainer');
            if (selectedMediaFiles.length === 0 && previewContainer) {
                previewContainer.classList.remove('active');
            }
        }

        function clearMediaPreview() {
            const previewGrid = document.getElementById('mediaPreviewGrid');
            if (previewGrid) {
                // Revoke all object URLs
                previewGrid.querySelectorAll('img, video').forEach(el => {
                    if (el.src && el.src.startsWith('blob:')) {
                        URL.revokeObjectURL(el.src);
                    }
                });
                previewGrid.innerHTML = '';
            }
            selectedMediaFiles = [];
            const previewContainer = document.getElementById('mediaPreviewContainer');
            if (previewContainer) {
                previewContainer.classList.remove('active');
            }
        }
        
        async function sendMessage() {
            const input = document.getElementById('mainChatMessageInput');
            const message = input.value.trim();
            
            if (!message || !selectedConversation) {
                console.log('Send message failed: message =', message, 'selectedConversation =', selectedConversation);
                return;
            }
            
            console.log('Sending staff message:', message, 'to conversation:', selectedConversation);
            
            // Add message to local data with consistent timestamp
            const messageTimestamp = Date.now();
            const messageId = `staff_${messageTimestamp}`;
            const newMessage = {
                id: messageId,
                sender: 'staff',
                text: message,
                time: formatTime(messageTimestamp), // Use formatTime for consistency
                timestamp: messageTimestamp
            };
            
            if (!chatMessages[selectedConversation]) {
                chatMessages[selectedConversation] = [];
            }
            // Check if message already exists to prevent duplicates
            const existingMessage = chatMessages[selectedConversation].find(msg => 
                msg.timestamp === newMessage.timestamp && 
                msg.text === newMessage.text && 
                msg.sender === newMessage.sender
            );
            
            if (!existingMessage) {
                chatMessages[selectedConversation].push(newMessage);
                // Sort messages to maintain chronological order
                chatMessages[selectedConversation].sort((a, b) => a.timestamp - b.timestamp);
                console.log('Added message to local array. Total messages:', chatMessages[selectedConversation].length);
            } else {
                console.log('Message already exists, skipping duplicate');
            }
            
            // Immediately render the message to the UI before Firebase save
            const messagesContainer = document.getElementById('chatMessages');
            if (messagesContainer) {
                console.log('About to render messages:', chatMessages[selectedConversation]);
                await renderMessages(chatMessages[selectedConversation], messagesContainer);
                console.log('Immediately rendered message to UI');
            } else {
                console.error('chatMessages container not found!');
            }
            
            // Save message to Firebase
            console.log('Calling sendMessageToFirebase with:', selectedConversation, message);
            sendMessageToFirebase(selectedConversation, message).then(async () => {
                console.log('Firebase save completed - real-time listener will update UI automatically');
                // If conversation is archived, auto-move it to active on staff reply
                try {
                    if (isFirebaseChatAvailable()) {
                        const conversationRef = firebase.database().ref(`conversations/${selectedConversation}`);
                        const snap = await conversationRef.once('value');
                        const data = snap.val() || {};
                        if (data.archived === true) {
                            await conversationRef.update({ archived: false, unarchivedAt: Date.now(), updatedAt: Date.now() });
                            // If currently viewing archived, switch to active so it appears there
                            if (currentConversationTab === 'archived') {
                                switchConversationTab('active');
                            } else {
                                loadActiveConversations();
                            }
                            showNotification('Conversation moved to Active', 'success');
                        }
                    }
                } catch (e) {
                    console.warn('Auto-unarchive on staff message failed:', e);
                }
            }).catch((error) => {
                console.error('Error saving message to Firebase:', error);
            });
            
            // Clear input
            input.value = '';
            input.style.height = '36px';
            
            // Update conversation metadata in Firebase with the new message immediately
            try {
                if (ENABLE_FIREBASE_CHAT_FALLBACK && isFirebaseChatAvailable()) {
                    const conversationRef = firebase.database().ref(`conversations/${selectedConversation}`);
                    await conversationRef.update({
                        lastMessage: message,
                        lastMessageTime: newMessage.timestamp,
                        lastMessageSender: 'staff',
                        updatedAt: Date.now()
                    }).catch(err => console.warn('Error updating conversation metadata:', err));
                }
            } catch (e) {
                console.warn('Error updating conversation metadata:', e);
            }
            
            // Update conversation preview immediately with the actual message
            updateConversationPreview(selectedConversation, message, 'staff', newMessage.timestamp);
            
            // Also update preview directly in the DOM
            const conversationItem = document.querySelector(`.conversation-item[data-conversation-id="${selectedConversation}"]`);
            if (conversationItem) {
                const preview = conversationItem.querySelector('.conversation-preview');
                const time = conversationItem.querySelector('.conversation-time');
                if (preview) {
                    preview.textContent = `You: ${message}`;
                }
                if (time) {
                    // CRITICAL: Normalize timestamp before formatting to ensure accurate display
                    const normalizedTimestamp = normalizeTimestamp(newMessage.timestamp ?? newMessage.createdAt ?? newMessage.id ?? newMessage.messageId ?? Date.now(), newMessage);
                    time.textContent = formatTime(normalizedTimestamp);
                }
                // Move conversation to top
                const parent = conversationItem.parentNode;
                if (parent && parent.firstChild !== conversationItem) {
                    parent.insertBefore(conversationItem, parent.firstChild);
                }
            }
            
            // No automatic customer response simulation
        }

        // Debounce conversation preview updates to prevent fast-forward effect
        if (!window.conversationPreviewDebounce) {
            window.conversationPreviewDebounce = {};
        }
        
        function updateConversationPreview(conversationId, lastMessage, messageSender = null, messageTimestamp = null) {
            // Debounce preview updates to prevent rapid-fire updates
            if (window.conversationPreviewDebounce[conversationId]) {
                clearTimeout(window.conversationPreviewDebounce[conversationId]);
            }
            
            window.conversationPreviewDebounce[conversationId] = setTimeout(() => {
                console.log('Updating conversation preview for:', conversationId, 'Message:', lastMessage?.substring(0, 30), 'Sender:', messageSender, 'Timestamp:', messageTimestamp);
                
                // Try multiple selectors to find the conversation item
                let conversationItem = document.querySelector(`.conversation-item[data-conversation-id="${conversationId}"]`);
                if (!conversationItem) {
                    // Try alternative selector
                    conversationItem = document.querySelector(`[onclick="selectConversation('${conversationId}')"]`);
                }
                if (!conversationItem) {
                    // Try finding by customer name or ID in the conversation list
                    const conversationItems = document.querySelectorAll('.conversation-item');
                    for (const item of conversationItems) {
                        if (item.onclick && item.onclick.toString().includes(conversationId)) {
                            conversationItem = item;
                            break;
                        }
                    }
                }
                
                if (conversationItem) {
                    console.log('Found conversation item, updating preview');
                    const preview = conversationItem.querySelector('.conversation-preview');
                    if (preview && lastMessage) {
                        // Format preview based on sender
                        let previewText = lastMessage;
                        if (messageSender === 'staff') {
                            previewText = `You: ${lastMessage}`;
                        }
                        preview.textContent = previewText;
                        console.log('Updated preview text to:', previewText);
                    }
                    
                    const time = conversationItem.querySelector('.conversation-time');
                    if (time) {
                        // CRITICAL: Use the actual message timestamp, not current time
                        // This ensures the time shown reflects when the message was sent, not when the conversation was clicked
                        const timestampToUse = messageTimestamp || Date.now();
                        time.textContent = formatTime(timestampToUse);
                        console.log('Updated time to:', formatTime(timestampToUse), '(timestamp:', timestampToUse, ')');
                    }
                    
                    // Apply unread styling for customer messages (even if conversation is selected)
                    // The conversation will be marked as read when staff focuses on input field
                    if (messageSender === 'customer') {
                        const nameElement = conversationItem.querySelector('.conversation-name');
                        if (nameElement) {
                            nameElement.classList.add('unread');
                        }
                        if (preview) {
                            preview.classList.add('unread');
                        }
                        // Also add unread class to the conversation item itself
                        conversationItem.classList.add('unread');
                        console.log('Applied unread styling - will be removed when input is focused');
                    }
                    
                    // NOTE: Removed "move to top" logic from here - conversations should only move to top when messages are sent/received,
                    // not when preview is updated (which can happen when clicking/loading conversations)
                } else {
                    console.log('Conversation item not found for ID:', conversationId);
                    // If conversation item doesn't exist, try to create/update it via ensureConversationExists
                    // This will create the conversation in Firebase and trigger a list refresh
                    if (isFirebaseChatAvailable() && lastMessage) {
                        try {
                            ensureConversationExists(conversationId, {
                                text: lastMessage,
                                sender: messageSender || 'customer',
                                timestamp: Date.now()
                            }).then(() => {
                                // After ensuring conversation exists, try to update preview again
                                setTimeout(() => {
                                    updateConversationPreview(conversationId, lastMessage, messageSender, messageTimestamp);
                                }, 500);
                            }).catch((e) => {
                                console.warn('Error ensuring conversation exists:', e);
                            });
                        } catch (e) {
                            console.warn('Error ensuring conversation exists:', e);
                        }
                    }
                }
            }, 300); // 300ms debounce
        }

        // Removed simulated customer response function - no automatic responses

        // Check if a conversation has unread messages by examining actual messages
        async function checkConversationForUnreadMessages(conversationId) {
            try {
                // FIRST: Check local state - if conversation exists in local state and has no unread messages, trust it
                // This ensures immediate badge updates when messages are marked as read
                if (chatMessages[conversationId] && Array.isArray(chatMessages[conversationId])) {
                    const hasLocalUnread = chatMessages[conversationId].some(message => 
                        message.sender === 'customer' && 
                        message.isRead === false && 
                        message.text && 
                        message.text.trim() !== ''
                    );
                    
                    // If local state shows no unread messages, trust it completely
                    // This prevents badge from showing after messages are marked as read
                    if (!hasLocalUnread) {
                        console.log('Local state shows no unread messages for conversation:', conversationId);
                        return false;
                    }
                }
                
                // SECOND: Check Firebase for conversations not in local state or to verify
                if (isFirebaseChatAvailable()) {
                    const messagesRef = firebase.database().ref('chatMessages');
                    const snapshot = await messagesRef
                        .orderByChild('conversationId')
                        .equalTo(conversationId)
                        .once('value');
                    
                    if (snapshot.exists()) {
                        let hasUnreadMessages = false;
                        snapshot.forEach((childSnapshot) => {
                            const message = childSnapshot.val();
                            // Only count as unread if isRead is EXPLICITLY false
                            // Treat undefined/null as read (for old messages)
                            if (message.sender === 'customer' && 
                                message.isRead === false && 
                                message.text && 
                                message.text.trim() !== '') {
                                hasUnreadMessages = true;
                                return false; // Stop iteration
                            }
                        });
                        return hasUnreadMessages;
                    }
                }
                return false;
            } catch (error) {
                console.error('Error checking conversation for unread messages:', error);
                return false;
            }
        }
        // Update badge with count of unique users with unread messages
        async function updateBadgeCount(forceUpdate = false) {
            const badge = document.getElementById('chatBadge');
            if (!badge) {
                console.error('Badge element not found');
                return;
            }

            // Don't update badge during initial load to prevent false positives
            // BUT allow updates for real-time new messages (forceUpdate = true)
            // CRITICAL: When forceUpdate is true, we MUST update the badge regardless of other conditions
            // This ensures badge appears immediately when customer sends message, even if chatbox is closed
            if (isInitialLoad && !forceUpdate) {
                console.log('Skipping badge update during initial load to prevent false counts');
                return;
            }
            
            // CRITICAL: Skip badge update if we're currently marking conversations as read
            // BUT allow force updates (for new customer messages) to bypass this check
            // This prevents badge from briefly appearing when switching to already-read conversations
            // but allows badge to show immediately for new unread messages
            if (isMarkingAsRead && !forceUpdate) {
                console.log('Skipping badge update while marking conversation as read');
                return;
            }
            
            // Also skip if any conversation is being marked as read (to prevent brief badge appearance)
            // BUT allow force updates (for new customer messages) to bypass this check
            // This ensures new messages always show the badge immediately
            if (window.markingAsReadConversations && window.markingAsReadConversations.size > 0 && !forceUpdate) {
                console.log('Skipping badge update - conversations being marked as read:', Array.from(window.markingAsReadConversations));
                // Use a longer delay to let Firebase sync complete and merge finish
                setTimeout(() => {
                    updateBadgeCount(forceUpdate);
                }, 500);
                return;
            }

            // Initialize persistent read conversations tracking if it doesn't exist
            if (!window.readConversations) {
                window.readConversations = new Set();
            }
            
            // CRITICAL: Use a single unified Set to track all counted conversations
            // This prevents double counting by ensuring each conversation is only counted once
            // regardless of whether it's found in local state or Firebase
            const allCountedConversations = new Set(); // Normalized IDs that have been counted
            const uniqueUsersWithUnread = new Set(); // Final set of unique conversations with unread messages
            
            // Helper function to get a canonical ID for a conversation
            // This ensures we always use the same ID representation for the same conversation
            // We'll use the normalized ID as the canonical form
            const getCanonicalId = (convId) => {
                const normalized = normalizeConversationId(convId);
                // CRITICAL: Ensure we always return the same canonical form
                // This prevents the same conversation from having different canonical IDs
                return String(normalized).trim();
            };
            
            // CRITICAL: Helper to check if two canonical IDs represent the same conversation
            // This is more robust than simple equality check
            const isSameCanonicalId = (id1, id2) => {
                const canon1 = getCanonicalId(id1);
                const canon2 = getCanonicalId(id2);
                if (canon1 === canon2) return true;
                // Also check if they match using conversationIdsMatch
                return conversationIdsMatch(canon1, canon2);
            };
            
            // Helper function to check if a conversation ID (any variation) has been counted
            const isConversationCounted = (convId) => {
                const canonicalId = getCanonicalId(convId);
                // Check exact match first
                if (allCountedConversations.has(canonicalId)) {
                    return true;
                }
                // Check all counted conversations for matches (handles ID variations)
                for (const countedId of allCountedConversations) {
                    if (conversationIdsMatch(countedId, canonicalId)) {
                        return true;
                    }
                }
                return false;
            };
            
            // Helper function to mark a conversation as counted (handles all ID variations)
            // Uses canonical ID to ensure consistency
            const markConversationAsCounted = (convId) => {
                const canonicalId = getCanonicalId(convId);
                allCountedConversations.add(canonicalId);
                // Also store original ID if different, to help with matching
                const normalizedId = normalizeConversationId(convId);
                if (normalizedId !== canonicalId) {
                    allCountedConversations.add(normalizedId);
                }
                if (convId !== canonicalId && convId !== normalizedId) {
                    allCountedConversations.add(convId);
                }
            };
            
            // Helper function to check if a conversation is marked as read (handles all ID variations)
            const isConversationRead = (convId) => {
                if (!window.readConversations) {
                    return false;
                }
                const normalizedId = normalizeConversationId(convId);
                // Check exact match first
                if (window.readConversations.has(normalizedId) || window.readConversations.has(convId)) {
                    return true;
                }
                // Check all read conversations for matches (handles ID variations)
                for (const readConvId of window.readConversations) {
                    if (conversationIdsMatch(readConvId, normalizedId)) {
                        return true;
                    }
                }
                // Also check markingAsReadConversations
                if (window.markingAsReadConversations) {
                    for (const markingConvId of window.markingAsReadConversations) {
                        const normalizedMarkingId = normalizeConversationId(markingConvId);
                        if (conversationIdsMatch(normalizedMarkingId, normalizedId)) {
                            return true;
                        }
                    }
                }
                return false;
            };
            
            // CRITICAL: First, build a map of ALL conversation IDs that exist in local state
            // Key: canonical ID, Value: set of all ID variations for that conversation
            // This includes conversations with or without unread messages
            // We need this to prevent counting conversations from Firebase that are already in local state
            const allConversationsInLocalState = new Map(); // canonicalId -> Set of all ID variations
            const allLocalStateIds = new Set(); // All ID variations for quick lookup
            
            Object.keys(chatMessages).forEach(conversationId => {
                const normalizedId = normalizeConversationId(conversationId);
                const canonicalId = getCanonicalId(normalizedId);
                
                // Store all variations
                allLocalStateIds.add(conversationId);
                allLocalStateIds.add(normalizedId);
                allLocalStateIds.add(canonicalId);
                
                // Store in map by canonical ID
                if (!allConversationsInLocalState.has(canonicalId)) {
                    allConversationsInLocalState.set(canonicalId, new Set());
                }
                allConversationsInLocalState.get(canonicalId).add(conversationId);
                allConversationsInLocalState.get(canonicalId).add(normalizedId);
                allConversationsInLocalState.get(canonicalId).add(canonicalId);
            });
            
            // Helper to check if a conversation exists in local state (handles all ID variations)
            const isConversationInLocalState = (convId) => {
                const normalizedId = normalizeConversationId(convId);
                const canonicalId = getCanonicalId(convId);
                
                // Quick check - if any variation exists in our set, it's in local state
                if (allLocalStateIds.has(convId) || allLocalStateIds.has(normalizedId) || allLocalStateIds.has(canonicalId)) {
                    return true;
                }
                
                // Detailed check - compare canonical IDs
                for (const [localCanonicalId, variations] of allConversationsInLocalState) {
                    // Use strict equality for canonical IDs (they should be normalized strings)
                    if (localCanonicalId === canonicalId) {
                        return true;
                    }
                    // Also check if normalized IDs match exactly
                    if (normalizedId === localCanonicalId || canonicalId === localCanonicalId) {
                        return true;
                    }
                    // Last resort: check if any variation matches
                    for (const variation of variations) {
                        if (variation === convId || variation === normalizedId || variation === canonicalId) {
                            return true;
                        }
                    }
                }
                
                return false;
            };
            
            // STEP 1: Check local state FIRST - this is our primary source of truth
            // Local state is updated immediately when messages are marked as read
            // CRITICAL: Process conversations by canonical ID to prevent duplicate counting
            // Even if the same conversation appears with different ID formats in chatMessages keys,
            // we only count it once using the canonical ID
            
            // First, group all conversations by their canonical ID
            // CRITICAL: We need to check all possible ID variations to ensure we group correctly
            const conversationsByCanonicalId = new Map(); // canonicalId -> { conversationId, messages }
            
            // Track which canonical IDs we've already processed to avoid duplicates
            const processedCanonicalIds = new Set();
            
            Object.keys(chatMessages).forEach(conversationId => {
                const normalizedId = normalizeConversationId(conversationId);
                const canonicalId = getCanonicalId(normalizedId);
                
                // Check if we've already processed this canonical ID from a different key
                // This prevents the same conversation from being counted multiple times
                if (processedCanonicalIds.has(canonicalId)) {
                    // This canonical ID was already processed - merge messages into existing entry
                    const existingData = conversationsByCanonicalId.get(canonicalId);
                    if (existingData) {
                        existingData.conversationIds.add(conversationId);
                        existingData.conversationIds.add(normalizedId);
                        
                        // Add messages from this conversation ID (avoid duplicates)
                        const messages = chatMessages[conversationId] || [];
                        messages.forEach(msg => {
                            // Check if message already exists (by id or timestamp+text+sender)
                            const exists = existingData.messages.some(existingMsg => 
                                (existingMsg.id && msg.id && existingMsg.id === msg.id) ||
                                (existingMsg.timestamp === msg.timestamp && 
                                 existingMsg.text === msg.text && 
                                 existingMsg.sender === msg.sender)
                            );
                            if (!exists) {
                                existingData.messages.push(msg);
                            }
                        });
                    }
                    return; // Skip - already processed
                }
                
                // Mark this canonical ID as processed
                processedCanonicalIds.add(canonicalId);
                
                // Group by canonical ID - if we already have this canonical ID, merge messages
                if (!conversationsByCanonicalId.has(canonicalId)) {
                    conversationsByCanonicalId.set(canonicalId, {
                        conversationIds: new Set([conversationId]),
                        messages: []
                    });
                }
                
                const conversationData = conversationsByCanonicalId.get(canonicalId);
                conversationData.conversationIds.add(conversationId);
                conversationData.conversationIds.add(normalizedId);
                
                // Add messages from this conversation ID (avoid duplicates)
                const messages = chatMessages[conversationId] || [];
                messages.forEach(msg => {
                    // Check if message already exists (by id or timestamp+text+sender)
                    const exists = conversationData.messages.some(existingMsg => 
                        (existingMsg.id && msg.id && existingMsg.id === msg.id) ||
                        (existingMsg.timestamp === msg.timestamp && 
                         existingMsg.text === msg.text && 
                         existingMsg.sender === msg.sender)
                    );
                    if (!exists) {
                        conversationData.messages.push(msg);
                    }
                });
            });
            
            console.log('Grouped conversations by canonical ID:', conversationsByCanonicalId.size, 'unique conversations');
            console.log('Total chatMessages keys:', Object.keys(chatMessages).length);
            
            // DEBUG: Log all conversation IDs and their canonical IDs
            console.log('=== BADGE COUNT DEBUG ===');
            console.log('All chatMessages keys:', Object.keys(chatMessages));
            console.log('Total unique keys:', Object.keys(chatMessages).length);
            
            // Show each conversation with details
            Object.keys(chatMessages).forEach(convId => {
                const normalized = normalizeConversationId(convId);
                const canonical = getCanonicalId(convId);
                const msgs = chatMessages[convId] || [];
                const unreadCount = msgs.filter(m => m.sender === 'customer' && m.isRead === false).length;
                const isRead = isConversationRead(convId);
                const isSelected = conversationIdsMatch(selectedConversation, convId);
                
                // Try to get customer name from conversation list
                const conversationItem = document.querySelector(`.conversation-item[data-conversation-id="${convId}"]`);
                const customerName = conversationItem ? 
                    (conversationItem.querySelector('.conversation-name')?.textContent || 'Unknown') : 
                    'Not in list';
                
                console.log(`   Original: "${convId}"`);
                console.log(`     Customer Name: "${customerName}"`);
                console.log(`     Normalized: "${normalized}"`);
                console.log(`     Canonical: "${canonical}"`);
                console.log(`     Total messages: ${msgs.length}, Unread customer messages: ${unreadCount}`);
                console.log(`     Is marked as read: ${isRead}`);
                console.log(`     Is selected: ${isSelected}`);
                console.log(`     Should count in badge: ${unreadCount > 0 && !isRead && !isSelected ? 'YES ' : 'NO '}`);
            });
            
            console.log('\n Conversations grouped by canonical ID:');
            conversationsByCanonicalId.forEach((data, canonicalId) => {
                const unreadMsgs = data.messages.filter(m => m.sender === 'customer' && m.isRead === false);
                console.log(`   Canonical ID: "${canonicalId}"`);
                console.log(`     ID Variations: [${Array.from(data.conversationIds).join(', ')}]`);
                console.log(`     Total messages: ${data.messages.length}`);
                console.log(`     Unread customer messages: ${unreadMsgs.length}`);
                if (unreadMsgs.length > 0) {
                    console.log(`      WILL BE COUNTED IN BADGE`);
                }
            });
            console.log('\n readConversations set:', window.readConversations ? Array.from(window.readConversations) : 'not initialized');
            console.log(' selectedConversation:', selectedConversation);
            console.log(' isChatboxOpen:', isChatboxOpen);
            console.log('=== END DEBUG ===');
            // Now process each unique conversation (by canonical ID)
            conversationsByCanonicalId.forEach((conversationData, canonicalId) => {
                // Skip if already counted
                if (isConversationCounted(canonicalId)) {
                    console.log('Skipping conversation - already counted:', canonicalId);
                    return;
                }
                
                const messages = conversationData.messages;
                if (!messages || messages.length === 0) {
                    // Mark as counted even if empty to skip in Firebase
                    markConversationAsCounted(canonicalId);
                    return;
                }
                
                // CRITICAL: Check if last message is from staff but there are unread customer messages
                // This is data corruption - fix it immediately
                const lastMessage = messages.length > 0 ? messages[messages.length - 1] : null;
                const hasCustomerMessagesMarkedUnread = messages.some(m => 
                    m.sender === 'customer' && m.isRead === false
                );
                
                if (lastMessage && lastMessage.sender === 'staff' && hasCustomerMessagesMarkedUnread) {
                    console.log(` CORRUPTION DETECTED: ${canonicalId} - Last message is from staff but has unread customer messages!`);
                    console.log('   Fixing immediately...');
                    
                    // Fix all customer messages to be read
                    const updates = {};
                    for (const message of messages) {
                        if (message.sender === 'customer' && message.isRead === false && message.id) {
                            updates[`${message.id}/isRead`] = true;
                            message.isRead = true; // Update local state immediately
                        }
                    }
                    
                    // Update Firebase
                    if (Object.keys(updates).length > 0 && isFirebaseChatAvailable()) {
                        firebase.database().ref('chatMessages').update(updates).then(() => {
                            console.log(` Fixed ${Object.keys(updates).length} corrupted messages in ${canonicalId}`);
                        }).catch(err => {
                            console.error('Error fixing corrupted messages:', err);
                        });
                    }
                }
                
                // Check if conversation has ANY unread customer messages
                let hasUnreadMessages = false;
                let unreadCount = 0;
                for (const message of messages) {
                    // Only count customer messages that are EXPLICITLY unread (isRead === false)
                    // Treat undefined/null as read
                    if (message.sender === 'customer' && 
                        message.isRead === false &&
                        message.text && 
                        message.text.trim() !== '') {
                        hasUnreadMessages = true;
                        unreadCount++;
                    }
                }
                
                // Check if conversation is marked as read (check all ID variations)
                let isRead = false;
                for (const convId of conversationData.conversationIds) {
                    if (isConversationRead(convId)) {
                        isRead = true;
                        break;
                    }
                }
                
                console.log('Checking conversation (canonical ID):', {
                    canonicalId: canonicalId,
                    conversationIdVariations: Array.from(conversationData.conversationIds),
                    messageCount: messages.length,
                    unreadCount: unreadCount,
                    hasUnreadMessages: hasUnreadMessages,
                    isRead: isRead
                });
                
                if (isRead && hasUnreadMessages) {
                    // New unread messages arrived - remove from readConversations (all variations)
                    for (const convId of conversationData.conversationIds) {
                        window.readConversations.delete(convId);
                    }
                    // Also remove any matching variations
                    for (const readConvId of Array.from(window.readConversations)) {
                        if (conversationIdsMatch(readConvId, canonicalId)) {
                            window.readConversations.delete(readConvId);
                        }
                    }
                    console.log('Removed conversation from readConversations (has new unread messages):', canonicalId);
                }
                
                // Count conversation if it has unread messages and is not read
                // CRITICAL: The badge should show the count of unique customers (conversations), not messages
                // One customer = 1, regardless of how many messages they sent
                if (hasUnreadMessages && !isRead) {
                    // CRITICAL: Use robust duplicate checking to prevent counting the same conversation twice
                    let alreadyInSet = false;
                    
                    // First check: exact match in Set
                    if (uniqueUsersWithUnread.has(canonicalId)) {
                        alreadyInSet = true;
                    } else {
                        // Second check: check all existing IDs using canonical comparison
                        for (const existingId of uniqueUsersWithUnread) {
                            if (isSameCanonicalId(existingId, canonicalId)) {
                                alreadyInSet = true;
                                console.log(' Found duplicate conversation using canonical comparison:', existingId, 'matches', canonicalId);
                                break;
                            }
                        }
                    }
                    
                    if (!alreadyInSet) {
                        // CRITICAL: Add canonical ID to set - this ensures each conversation is counted exactly once
                        uniqueUsersWithUnread.add(canonicalId);
                        markConversationAsCounted(canonicalId);
                        // Also mark all ID variations as counted to prevent future duplicates
                        for (const convId of conversationData.conversationIds) {
                            markConversationAsCounted(convId);
                        }
                        console.log(' Added conversation to uniqueUsersWithUnread:', canonicalId, '(', unreadCount, 'unread messages, count = 1 customer)');
                    } else {
                        // Already in the set - just mark as counted to prevent future processing
                        markConversationAsCounted(canonicalId);
                        for (const convId of conversationData.conversationIds) {
                            markConversationAsCounted(convId);
                        }
                        console.log(' Conversation already in uniqueUsersWithUnread (duplicate prevented):', canonicalId);
                    }
                } else {
                    // Mark as counted but don't add to unread count
                    markConversationAsCounted(canonicalId);
                    for (const convId of conversationData.conversationIds) {
                        markConversationAsCounted(convId);
                    }
                    console.log('Skipping conversation - no unread messages:', canonicalId, '(isRead:', isRead, ', hasUnread:', hasUnreadMessages, ')');
                }
            });
            
            console.log('Local state check complete - unique conversations with unread:', Array.from(uniqueUsersWithUnread));
            console.log('All conversations in local state (canonical IDs):', Array.from(allConversationsInLocalState.keys()));
            console.log('All local state ID variations:', Array.from(allLocalStateIds));
            console.log('Conversations marked as read:', Array.from(window.readConversations));
            
            // STEP 2: Check Firebase for conversations NOT in local state
            // CRITICAL: When staff logs in fresh, local state will be empty, so we MUST check Firebase
            // to show unread messages from previous sessions. This ensures badge persists across logins.
            // However, if we have conversations in local state, we trust local state and skip Firebase
            // to prevent double counting for conversations we've already loaded.
            const hasAnyLocalStateConversations = allLocalStateIds.size > 0 || Object.keys(chatMessages).length > 0;
            
            if (hasAnyLocalStateConversations) {
                console.log('Skipping Firebase check - we have conversations in local state. Using local state only to prevent double counting.');
                console.log('Local state conversations:', Object.keys(chatMessages));
            } else if (isFirebaseChatAvailable()) {
                // Local state is empty - this happens on fresh login
                // We MUST check Firebase to show unread messages from previous sessions
                console.log('Local state is empty (fresh login) - checking Firebase for unread conversations to persist badge across sessions');
                try {
                    // Get all conversations that are not archived
                    const conversationsRef = firebase.database().ref('conversations');
                    const conversationsSnapshot = await conversationsRef.once('value');
                    const conversations = conversationsSnapshot.val() || {};
                    
                    const activeConversationIds = Object.keys(conversations).filter(id => !conversations[id].archived);
                    
                    console.log('Checking', activeConversationIds.length, 'active conversations for unread messages in Firebase');
                    console.log('Local state has', allLocalStateIds.size, 'conversation ID variations');
                    
                    // Get all messages from Firebase
                    const messagesRef = firebase.database().ref('chatMessages');
                    const messagesSnapshot = await messagesRef.once('value');
                    const allMessages = messagesSnapshot.val() || {};
                    
                    // Group messages by conversation ID to check each conversation only once
                    const conversationUnreadMap = new Map(); // canonicalConversationId -> hasUnread
                    
                    Object.values(allMessages).forEach(message => {
                        // Only count customer messages that are explicitly unread
                        if (message.sender === 'customer' && 
                            message.isRead === false && 
                            message.text && 
                            message.text.trim() !== '') {
                            
                            // Get conversation ID from message
                            const msgConvId = message.conversationId || message.customerId;
                            if (!msgConvId) {
                                return; // Skip if no conversation ID
                            }
                            
                            const normalizedMsgConvId = normalizeConversationId(msgConvId);
                            const canonicalMsgConvId = getCanonicalId(msgConvId);
                            
                            // CRITICAL: Skip if conversation exists in local state (check all variations)
                            // We trust local state completely, so never count from Firebase if it's in local state
                            if (isConversationInLocalState(msgConvId) || 
                                isConversationInLocalState(normalizedMsgConvId) || 
                                isConversationInLocalState(canonicalMsgConvId)) {
                                console.log('Skipping Firebase message - conversation already in local state:', {
                                    original: msgConvId,
                                    normalized: normalizedMsgConvId,
                                    canonical: canonicalMsgConvId
                                });
                                return;
                            }
                            
                            // Skip if already counted from local state (double check)
                            if (isConversationCounted(msgConvId) || 
                                isConversationCounted(normalizedMsgConvId) || 
                                isConversationCounted(canonicalMsgConvId)) {
                                console.log('Skipping Firebase message - conversation already counted:', canonicalMsgConvId);
                                return;
                            }
                            
                            // Skip if marked as read
                            if (isConversationRead(msgConvId) || 
                                isConversationRead(normalizedMsgConvId) || 
                                isConversationRead(canonicalMsgConvId)) {
                                console.log('Skipping Firebase unread for conversation in readConversations:', canonicalMsgConvId);
                                return;
                            }
                            
                            // Check if this conversation is active (not archived)
                            const isActive = activeConversationIds.some(id => {
                                const normalizedActiveId = normalizeConversationId(id);
                                return conversationIdsMatch(normalizedActiveId, canonicalMsgConvId);
                            });
                            if (!isActive) {
                                return;
                            }
                            
                            // Mark this conversation as having unread messages (use canonical ID as key)
                            // This ensures unread messages from previous sessions are counted
                            conversationUnreadMap.set(canonicalMsgConvId, true);
                            console.log('Found unread message in Firebase for conversation:', canonicalMsgConvId, 'message:', message.text?.substring(0, 50));
                        }
                    });
                    
                    // Add Firebase conversations to the final count (if not already counted)
                    conversationUnreadMap.forEach((hasUnread, canonicalConvId) => {
                        if (hasUnread) {
                            // Triple-check: not in local state, not counted, not in uniqueUsersWithUnread
                            if (isConversationInLocalState(canonicalConvId)) {
                                console.log('Skipping Firebase conversation - found in local state during final check:', canonicalConvId);
                                return;
                            }
                            
                            if (isConversationCounted(canonicalConvId)) {
                                console.log('Skipping Firebase conversation - already counted:', canonicalConvId);
                                return;
                            }
                            
                            // Final check: make sure it's not already in uniqueUsersWithUnread
                            let alreadyAdded = false;
                            for (const existingId of uniqueUsersWithUnread) {
                                const existingCanonical = getCanonicalId(existingId);
                                if (existingCanonical === canonicalConvId || conversationIdsMatch(existingCanonical, canonicalConvId)) {
                                    alreadyAdded = true;
                                    console.log('Skipping Firebase conversation - already in uniqueUsersWithUnread:', canonicalConvId, 'matches', existingId);
                                    break;
                                }
                            }
                            
                            if (!alreadyAdded) {
                                uniqueUsersWithUnread.add(canonicalConvId);
                                markConversationAsCounted(canonicalConvId);
                                console.log(' Added Firebase conversation to uniqueUsersWithUnread:', canonicalConvId);
                            } else {
                                markConversationAsCounted(canonicalConvId);
                            }
                        }
                    });
                    
                    console.log('Firebase check complete - total unique conversations with unread:', uniqueUsersWithUnread.size);
                    console.log('Final uniqueUsersWithUnread:', Array.from(uniqueUsersWithUnread));
                    
                } catch (error) {
                    console.error('Error counting unread messages from Firebase:', error);
                    // Fallback: just use what we already counted from local state
                }
            } else {
                console.log('Firebase not available - using local state only');
            }

            // CRITICAL: Final deduplication pass to ensure no duplicates slipped through
            // Check if any conversations in the set match each other using canonical comparison
            const finalDeduplicated = new Set();
            for (const convId of uniqueUsersWithUnread) {
                let isDuplicate = false;
                for (const existingId of finalDeduplicated) {
                    if (conversationIdsMatch(convId, existingId)) {
                        console.log(' FINAL DEDUP: Found duplicate in final set:', convId, 'matches', existingId);
                        isDuplicate = true;
                        break;
                    }
                }
                if (!isDuplicate) {
                    finalDeduplicated.add(convId);
                }
            }
            
            const finalCount = finalDeduplicated.size;
            console.log('Final unique users with unread messages count:', finalCount);
            console.log('Unique conversations with unread (before dedup):', Array.from(uniqueUsersWithUnread));
            console.log('Unique conversations with unread (after dedup):', Array.from(finalDeduplicated));
            
            // Show customer names for conversations in badge
            if (finalCount > 0) {
                console.log(' BADGE WILL SHOW', finalCount, 'for these customers:');
                finalDeduplicated.forEach(convId => {
                    const conversationItem = document.querySelector(`.conversation-item[data-conversation-id="${convId}"]`);
                    const customerName = conversationItem ? 
                        (conversationItem.querySelector('.conversation-name')?.textContent || 'Unknown') : 
                        'Unknown';
                    console.log(`   - ${customerName} (${convId})`);
                });
            } else {
                console.log(' BADGE WILL BE HIDDEN (no unread conversations)');
            }

            // CRITICAL: The badge should show the count of unique customers (conversations) with unread messages
            // NOT the count of messages. One customer = 1, regardless of how many messages they sent.
            // Always show/hide badge based on unique users with unread messages
            if (finalCount > 0) {
                // Ensure we're showing the count of unique conversations, not messages
                badge.textContent = finalCount.toString();
                
                // Show badge immediately for instant appearance (even when chatbox is closed)
                // CRITICAL: Remove hidden class and add showing class immediately, no delays
                badge.classList.remove('hidden');
                badge.classList.add('showing');
                // Force immediate display with inline styles (these override CSS)
                badge.style.display = 'flex';
                badge.style.visibility = 'visible';
                badge.style.opacity = '1';
                
                console.log(' Badge displayed immediately with count:', finalCount, 'unique customers (conversations)');
                console.log('Badge classes:', badge.className);
                console.log('Badge display style:', badge.style.display);
                console.log('Badge computed display:', window.getComputedStyle(badge).display);
            } else {
                // Hide badge instantly (no transition)
                badge.classList.remove('showing');
                badge.classList.add('hidden');
                badge.textContent = '';
                badge.style.display = 'none';
                badge.style.visibility = 'hidden';
                badge.style.opacity = '0';
                console.log('Badge hidden instantly - no users with unread messages');
            }
        }

        // Show badge when customer sends message
        function showBadge() {
            updateBadgeCount();
        }

        function updateChatBadge() {
            const badge = document.getElementById('chatBadge');
            if (!badge) {
                console.log('Badge element not found');
                return;
            }
            
            // Don't update badge during initial load to prevent flash
            if (isInitialLoad) {
                console.log('Skipping badge update during initial load');
                return;
            }
            
            console.log('Updating chat badge...');
            
            // Count conversations with unread messages from Firebase
            if (isFirebaseChatAvailable()) {
                const conversationsRef = firebase.database().ref('conversations');
                conversationsRef.once('value', async (snapshot) => {
                    const conversations = snapshot.val() || {};
                    const conversationIds = Object.keys(conversations).filter(id => !conversations[id].archived);
                    let totalUnreadConversations = 0;
                    
                    console.log('Checking', conversationIds.length, 'conversations for unread messages');
                    
                    // Check each conversation for actual unread messages
                    for (const conversationId of conversationIds) {
                        const hasUnreadMessages = await checkConversationForUnreadMessages(conversationId);
                        if (hasUnreadMessages) {
                            totalUnreadConversations++;
                            console.log('Found unread messages in conversation:', conversationId);
                        }
                    }
                    
                    console.log('Total unread conversations:', totalUnreadConversations);
                    
                    // Update badge display
                    if (totalUnreadConversations > 0) {
                        badge.textContent = totalUnreadConversations.toString();
                        
                        // Show badge with smooth fade-in animation
                        if (badge.classList.contains('hidden')) {
                            badge.classList.remove('hidden');
                            badge.style.display = 'flex';
                            badge.style.visibility = 'visible';
                            void badge.offsetHeight; // Force reflow
                            requestAnimationFrame(() => {
                                badge.classList.add('showing');
                            });
                        }
                        console.log('Badge updated with count:', totalUnreadConversations);
                        
                        // Add visual feedback for new messages
                        badge.style.animation = 'pulse 1s ease-in-out';
                        setTimeout(() => {
                            badge.style.animation = '';
                        }, 1000);
                    } else {
                        // Hide badge instantly (no transition)
                        badge.classList.remove('showing');
                        badge.textContent = '';
                        badge.classList.add('hidden');
                        badge.style.display = 'none';
                        badge.style.visibility = 'hidden';
                        console.log('Badge hidden - no unread messages');
                    }
                });
            } else {
                console.log('Firebase not available, using local counting');
                // Fallback to local counting if Firebase not available
                const localUsersWithUnread = new Set();
                Object.keys(chatMessages).forEach(conversationId => {
                    const messages = chatMessages[conversationId];
                    if (messages && messages.length > 0) {
                        messages.forEach(message => {
                            // Only count customer messages that are EXPLICITLY unread (isRead === false)
                            // Treat undefined/null as read
                            if (message.sender === 'customer' && 
                                message.isRead === false &&
                                message.text && 
                                message.text.trim() !== '') {
                                localUsersWithUnread.add(conversationId);
                            }
                        });
                    }
                });
                
                const totalUnreadConversations = localUsersWithUnread.size;
                
                if (totalUnreadConversations > 0) {
                    badge.textContent = totalUnreadConversations.toString();
                    
                    // Show badge with smooth fade-in animation
                    if (badge.classList.contains('hidden')) {
                        badge.classList.remove('hidden');
                        badge.style.display = 'flex';
                        badge.style.visibility = 'visible';
                        void badge.offsetHeight; // Force reflow
                        requestAnimationFrame(() => {
                            badge.classList.add('showing');
                        });
                    }
                } else {
                    // Hide badge instantly (no transition)
                    badge.classList.remove('showing');
                    badge.textContent = '';
                    badge.classList.add('hidden');
                    badge.style.display = 'none';
                    badge.style.visibility = 'hidden';
                }
            }
        }
        function initializeChat() {
            // Auto-resize textarea
            const chatInput = document.getElementById('mainChatMessageInput');
            if (chatInput) {
                // Check if handlers are already attached to prevent duplicates
                if (chatInput.dataset.handlersAttached === 'true') {
                    console.log('Chat input handlers already attached, skipping re-initialization');
                    return;
                }
                
                // Mark that handlers are attached
                chatInput.dataset.handlersAttached = 'true';
                
                chatInput.addEventListener('input', function() {
                    this.style.height = '36px';
                    this.style.height = Math.min(this.scrollHeight, 100) + 'px';
                });
                
                // Send message on Enter (but allow Shift+Enter for new line)
                chatInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendMessageWithFirebase();
                    }
                });
                
                // CRITICAL: Mark conversation as read (unbold) when input is focused
                // This is the key handler that removes bold state when staff interacts with input
                // Note: No need for click handler - clicking the input will trigger focus automatically
                chatInput.addEventListener('focus', function() {
                    if (selectedConversation) {
                        console.log('Input focused - marking conversation as read:', selectedConversation);
                        markConversationAsReadOnInputFocus(selectedConversation);
                    }
                });
                
                console.log('Chat input event handlers attached successfully');
            } else {
                console.warn('Chat input field not found when initializing chat handlers');
            }
            
            // Don't update badge during loading - only for real-time messages
        }
        // Firebase Chat Integration
        function initializeFirebaseChat() {
            // Initialize Firebase chat listeners
            if (isFirebaseChatAvailable()) {
                console.log('Initializing Firebase chat listeners...');
                
                // Initialize real-time chat listeners only for NEW messages after init
                if (!window.chatRealtimeInitialized) {
                    window.chatRealtimeInitialized = true;
                    window.chatRealtimeCutoffTs = Date.now();
                }
                const chatRef = firebase.database().ref('chatMessages');
                const chatRealtimeRef = firebase.database().ref('chatMessages')
                    .orderByChild('timestamp')
                    .startAt(window.chatRealtimeCutoffTs + 1);
                const conversationsRef = firebase.database().ref('conversations');
                
                // Listen for new messages
                chatRealtimeRef.on('child_added', async function(snapshot) {
                    const message = snapshot.val();
                    console.log('New message received via real-time:', message);
                    if (message && (message.conversationId || message.customerId)) {
                        // CRITICAL: Exclude messages from rider-customer conversations
                        const msgConvId = normalizeConversationId(message?.conversationId);
                        const msgCustId = normalizeConversationId(message?.customerId);
                        const isRiderConversation = (message?.chatType === 'rider') || 
                                                   (msgConvId && msgConvId.includes('_rider_')) ||
                                                   (msgCustId && msgCustId.includes('_rider_'));
                        if (isRiderConversation) {
                            console.log(' Global real-time child_added filtered out - rider conversation:', message.id, 'conversationId:', msgConvId, 'customerId:', msgCustId, 'chatType:', message.chatType);
                            return; // Skip this message
                        }
                        
                        // Ensure message has an ID - use key if id is missing
                        if (!message.id && snapshot.key) {
                            message.id = snapshot.key;
                        }
                        
                        // CRITICAL: Preserve imageUrl and videoUrl fields from Firebase
                        // These fields are stored in Firebase and need to be preserved
                        if (message.imageUrl) {
                            message.imageUrl = String(message.imageUrl);
                        }
                        if (message.videoUrl) {
                            message.videoUrl = String(message.videoUrl);
                        }
                        
                        // Debug: Log media fields
                        if (message.imageUrl || message.videoUrl) {
                            console.log(' Real-time message has media:', {
                                id: message.id,
                                sender: message.sender,
                                imageUrl: message.imageUrl,
                                videoUrl: message.videoUrl
                            });
                        }
                        
                        // Determine conversationId - use conversationId if available, otherwise use customerId
                        // This handles cases where messages might have different conversationId/customerId values
                        let conversationId = message.conversationId || message.customerId;
                        
                        // If message is from staff, use customerId as conversationId (staff messages should have customerId matching conversationId)
                        if (message.sender === 'staff' && message.customerId) {
                            conversationId = message.customerId;
                        }
                        
                        // CRITICAL: Normalize conversation ID immediately for consistency
                        // This ensures all messages for the same conversation are stored under the same key
                        const normalizedConversationId = normalizeConversationId(conversationId);
                        
                        console.log(' child_added: Processing message for conversationId:', conversationId, 'normalized:', normalizedConversationId, 'message.conversationId:', message.conversationId, 'message.customerId:', message.customerId, 'sender:', message.sender);
                        
                        // Ensure conversation exists before adding message (use original ID for Firebase)
                        await ensureConversationExists(conversationId, message);
                        
                        // Check if message already exists in local array to prevent duplicates
                        // Use normalized ID for storing messages
                        if (!chatMessages[normalizedConversationId]) {
                            chatMessages[normalizedConversationId] = [];
                        }
                        
                        // Check if message exists by ID (exact match)
                        // Use normalized ID for checking
                        const exactMatch = chatMessages[normalizedConversationId].find(msg => 
                            msg.id && message.id && msg.id === message.id
                        );
                        
                        // Check if there's an optimistic message that matches (same text/sender, timestamp within 10 seconds)
                        // Use more lenient matching to handle timestamp differences and ID mismatches
                        // Priority: Check for optimistic messages first, then check for recent staff messages
                        // Use normalized ID for checking
                        const optimisticMatch = chatMessages[normalizedConversationId].find(msg => {
                            if (!msg || msg.sender !== message.sender || msg.text !== message.text) {
                                return false;
                            }
                            
                            // Check timestamp match (within 10 seconds for better matching)
                            const timeDiff = Math.abs((msg.timestamp || 0) - (message.timestamp || 0));
                            if (timeDiff > 10000) {
                                return false;
                            }
                            
                            // Check if it's an optimistic message
                            const isOptimistic = msg.isOptimistic === true;
                            
                            // Check for temporary or numeric IDs (common for optimistic messages)
                            const idString = msg && msg.id !== undefined && msg.id !== null ? String(msg.id) : '';
                            const isTempId = idString.startsWith('temp_') || idString.startsWith('staff_');
                            const isNumericId = idString && /^\d+$/.test(idString);
                            const isNumericType = typeof msg.id === 'number';
                            
                            // Match if it's optimistic OR has a temporary/numeric ID (likely optimistic)
                            return isOptimistic || isTempId || isNumericId || isNumericType;
                        });
                        
                        // Also check for messages with same text/sender/timestamp (for messages sent just now)
                        // This catches staff messages that were just sent but might not have isOptimistic flag
                        // Use normalized ID for checking
                        const recentMatch = !optimisticMatch ? chatMessages[normalizedConversationId].find(msg => 
                            msg.sender === message.sender &&
                            msg.text === message.text &&
                            Math.abs((msg.timestamp || 0) - (message.timestamp || 0)) < 10000 // Within 10 seconds
                        ) : null;
                        
                        if (exactMatch) {
                            // Message already exists with same ID, skip completely - don't render or process
                            console.log(' Message already exists in local array with same ID, skipping duplicate');
                            
                            // CRITICAL: For customer messages, always check if unread and ensure badge shows
                            // This handles the case where message was added but badge wasn't updated
                            if (message.sender === 'customer') {
                                // Check if the message is unread (in local state or Firebase)
                                const isUnread = exactMatch.isRead === false || message.isRead === false;
                                
                                if (isUnread) {
                                    console.log(' Duplicate customer message is UNREAD - ensuring badge shows');
                                    
                                    // Ensure local state shows unread
                                    if (exactMatch.isRead !== false) {
                                        exactMatch.isRead = false;
                                        console.log('   Updated local message to isRead: false');
                                    }
                                    
                                    // Remove from readConversations to allow badge to show
                                    if (window.readConversations) {
                                        const idsToRemove = [
                                            normalizedConversationId,
                                            conversationId,
                                            message.conversationId,
                                            message.customerId
                                        ].filter(id => id);
                                        
                                        console.log('   Removing from readConversations:', idsToRemove);
                                        idsToRemove.forEach(id => window.readConversations.delete(id));
                                        
                                        // Also remove matching variations
                                        const toRemove = [];
                                        for (const readConvId of Array.from(window.readConversations)) {
                                            if (conversationIdsMatch(readConvId, normalizedConversationId)) {
                                                toRemove.push(readConvId);
                                            }
                                        }
                                        toRemove.forEach(id => window.readConversations.delete(id));
                                    }
                                    
                                    // Force badge update immediately
                                    console.log('   Forcing badge update...');
                                    updateBadgeCount(true);
                                    setTimeout(() => updateBadgeCount(true), 100);
                                    setTimeout(() => updateBadgeCount(true), 300);
                                }
                            }
                            return; // Exit early to prevent any further processing or rendering
                        } else if (optimisticMatch || recentMatch) {
                            // Use optimisticMatch if available, otherwise use recentMatch
                            const matchToUpdate = optimisticMatch || recentMatch;
                            // Found optimistic or recent message - update it with real Firebase ID
                            console.log(' Found optimistic/recent message, updating with Firebase ID:', message.id);
                            // Use normalized conversation ID (already calculated above)
                            const optimisticIndex = chatMessages[normalizedConversationId].findIndex(msg => 
                                msg === matchToUpdate
                            );
                            if (optimisticIndex !== -1) {
                                // Update the optimistic message with the real Firebase ID (in place, don't add new)
                                // Use normalized conversation ID (already calculated above)
                                
                                // Check if the message is already identical (same ID) to avoid unnecessary updates
                                const currentMessage = chatMessages[normalizedConversationId][optimisticIndex];
                                if (currentMessage.id === message.id && !currentMessage.isOptimistic) {
                                    console.log(' Message already updated with Firebase ID, skipping duplicate update');
                                    // NOTE: Don't update badge here - if message already exists and is identical, badge should already be correct
                                    // Updating here could cause duplicate badge counts
                                    // Only update badge if this is a customer message that was previously missed
                                    if (message.sender === 'customer' && currentMessage.isRead === true && message.isRead === false) {
                                        currentMessage.isRead = false;
                                        if (window.readConversations) {
                                            window.readConversations.delete(normalizedConversationId);
                                            window.readConversations.delete(conversationId);
                                        }
                                        updateBadgeCount(true);
                                    }
                                    return; // Exit early - message is already correct
                                }
                                
                                // Replace optimistic message with Firebase version (same array position, no new message)
                                chatMessages[normalizedConversationId][optimisticIndex] = {
                                    ...message,
                                    isOptimistic: false
                                };
                                
                                // Re-sort messages using centralized function
                                chatMessages[normalizedConversationId] = sortMessagesByTimestamp(chatMessages[normalizedConversationId]);
                                
                                console.log(' Updated optimistic message with Firebase ID. Total messages:', chatMessages[normalizedConversationId].length);
                                
                                // Only render if this conversation is selected and we're not in the middle of another operation
                                // CRITICAL: Use normalized comparison to handle type mismatches
                                const normalizedSelected = normalizeConversationId(selectedConversation);
                                const isSelected = conversationIdsMatch(selectedConversation, normalizedConversationId);
                                
                                console.log(' child_added optimistic update check:', {
                                    selectedConversation: selectedConversation,
                                    conversationId: conversationId,
                                    normalizedSelected: normalizedSelected,
                                    normalizedConversationId: normalizedConversationId,
                                    isSelected: isSelected
                                });
                                
                                // IMPORTANT: Skip re-rendering entirely when updating optimistic messages
                                // The message is already displayed correctly, we're just updating its ID in the background
                                // Re-rendering causes the "bouncing" effect as the entire list gets re-rendered
                                const shouldSkipRerender = isRenderingOptimisticMessage && 
                                    (Date.now() - optimisticRenderTime) < 5000; // Skip re-render if optimistic render was less than 5 seconds ago
                                
                                if (shouldSkipRerender) {
                                    // Just update the data silently - don't re-render to prevent bouncing
                                    console.log(' Skipping re-render - optimistic message was just rendered, updating ID silently in background');
                                } else if (isSelected && !isMarkingAsRead) {
                                    // Only re-render if we're not in the optimistic render window
                                    const messagesContainer = document.getElementById('chatMessages');
                                    if (messagesContainer) {
                                        // Preserve scroll position before re-rendering
                                        const wasAtBottom = Math.abs(messagesContainer.scrollHeight - messagesContainer.scrollTop - messagesContainer.clientHeight) < 10;
                                        const scrollPosition = messagesContainer.scrollTop;
                                        
                                        // CRITICAL: Ensure container is visible
                                        messagesContainer.classList.add('active');
                                        console.log(' Rendering updated staff message with Firebase ID (replacing optimistic)');
                                        // Use normalized conversation ID (already calculated above)
                                        if (chatMessages[normalizedConversationId]) {
                                            renderMessages(chatMessages[normalizedConversationId], messagesContainer).then(() => {
                                                // Restore scroll position smoothly
                                                if (wasAtBottom) {
                                                    // If we were at bottom, scroll to bottom smoothly
                                                    setTimeout(() => {
                                                        if (messagesContainer) {
                                                            messagesContainer.scrollTop = messagesContainer.scrollHeight;
                                                        }
                                                    }, 50);
                                                } else {
                                                    // Otherwise, try to preserve scroll position
                                                    setTimeout(() => {
                                                        if (messagesContainer) {
                                                            const newScrollHeight = messagesContainer.scrollHeight;
                                                            const heightDiff = newScrollHeight - (messagesContainer.scrollHeight - scrollPosition);
                                                            messagesContainer.scrollTop = Math.max(0, scrollPosition + heightDiff);
                                                        }
                                                    }, 50);
                                                }
                                            });
                                        } else {
                                            console.error(' Messages array not found for conversation:', normalizedConversationId);
                                        }
                                    } else {
                                        console.error(' Messages container not found when trying to render updated message');
                                    }
                                } else {
                                    console.log(' Conversation not selected or marking as read, skipping render. selectedConversation:', selectedConversation, 'conversationId:', conversationId);
                                }
                                
                                // Update conversation metadata
                                // Use original conversationId for Firebase (it might be in a specific format)
                                try {
                                    if (isFirebaseChatAvailable()) {
                                        const firebaseConvId = normalizedConversationId || conversationId;
                                        const conversationRef = firebase.database().ref(`conversations/${firebaseConvId}`);
                                        await conversationRef.update({
                                            lastMessage: message.text,
                                            lastMessageTime: message.timestamp || Date.now(),
                                            lastMessageSender: message.sender,
                                            updatedAt: Date.now()
                                        }).catch(err => console.warn('Error updating conversation metadata:', err));
                                    }
                                } catch (e) {
                                    console.warn('Error updating conversation metadata:', e);
                                }
                                
                                // Update conversation preview
                                // Use normalized ID for consistency
                                updateConversationPreview(normalizedConversationId, message.text, message.sender, message.timestamp);
                                updateConversationListFromMessage(normalizedConversationId, message);
                                
                                // CRITICAL: For customer messages, ensure badge is updated even for optimistic matches
                                // This ensures badge appears for all customer messages, not just new ones
                                if (message.sender === 'customer') {
                                    // Ensure message is marked as unread
                                    if (message.isRead !== true) {
                                        chatMessages[normalizedConversationId][optimisticIndex].isRead = false;
                                        // Remove conversation from readConversations if it was marked as read
                                        if (window.readConversations) {
                                            window.readConversations.delete(normalizedConversationId);
                                            window.readConversations.delete(conversationId);
                                        }
                                    }
                                    // Force badge update immediately for instant appearance
                                    // Only update if message is actually unread to prevent duplicate counts
                                    if (chatMessages[normalizedConversationId][optimisticIndex].isRead === false) {
                                        updateBadgeCount(true);
                                    }
                                }
                            }
                        } else {
                            // New message - add it to conversation
                            console.log('Adding new message to conversation:', message.id, message.sender, message.text?.substring(0, 30));
                            
                            // CRITICAL: For customer messages received in real-time, explicitly mark as unread
                            // This ensures the badge will show immediately
                            if (message.sender === 'customer' && message.isRead !== true) {
                                message.isRead = false;
                                console.log('Real-time listener: Marked new customer message as unread');
                                
                                // CRITICAL: Remove conversation from readConversations immediately
                                // This ensures badge will count this conversation right away
                                // Remove ALL possible variations of the conversation ID
                                if (window.readConversations) {
                                    const idsToRemove = [
                                        normalizedConversationId,
                                        conversationId,
                                        message.conversationId,
                                        message.customerId
                                    ].filter(id => id); // Remove null/undefined values
                                    
                                    console.log(' Removing conversation from readConversations (all variations):', idsToRemove);
                                    idsToRemove.forEach(id => window.readConversations.delete(id));
                                    
                                    // Also check for any matching IDs using conversationIdsMatch
                                    const toRemove = [];
                                    for (const readConvId of Array.from(window.readConversations)) {
                                        if (conversationIdsMatch(readConvId, normalizedConversationId)) {
                                            toRemove.push(readConvId);
                                        }
                                    }
                                    toRemove.forEach(id => window.readConversations.delete(id));
                                    if (toRemove.length > 0) {
                                        console.log(' Also removed matching variations:', toRemove);
                                    }
                                }
                                
                                // Also update in Firebase to ensure consistency
                                try {
                                    if (isFirebaseChatAvailable() && snapshot.key) {
                                        const messageRef = firebase.database().ref(`chatMessages/${snapshot.key}`);
                                        await messageRef.update({ isRead: false });
                                        console.log('Updated message in Firebase as unread');
                                    }
                                } catch (error) {
                                    console.warn('Error updating message isRead in Firebase:', error);
                                }
                            }
                            
                            // addMessageToConversation will normalize the conversation ID internally
                            await addMessageToConversation(conversationId, message);
                            
                            // CRITICAL: For customer messages, force badge update immediately after adding to conversation
                            // This ensures badge appears instantly even when chatbox is closed
                            if (message.sender === 'customer' && message.isRead === false) {
                                console.log(' Real-time listener: Forcing immediate badge update for customer message');
                                console.log('   Chatbox state:', isChatboxOpen ? 'OPEN' : 'CLOSED');
                                // Force update multiple times to ensure it shows
                                updateBadgeCount(true);
                                setTimeout(() => updateBadgeCount(true), 100);
                                setTimeout(() => updateBadgeCount(true), 300);
                            }
                            
                            // ALWAYS render if this conversation is selected (for staff messages especially)
                            // CRITICAL: Use normalized comparison to handle type mismatches
                            // Use the normalized ID we already calculated
                            const normalizedSelected = normalizeConversationId(selectedConversation);
                            const isSelected = conversationIdsMatch(selectedConversation, normalizedConversationId);
                            
                            console.log(' child_added new message check:', {
                                selectedConversation: selectedConversation,
                                conversationId: conversationId,
                                normalizedSelected: normalizedSelected,
                                normalizedConversationId: normalizedConversationId,
                                isSelected: isSelected,
                                messageId: message.id,
                                messageSender: message.sender
                            });
                            
                            if (isSelected) {
                                const messagesContainer = document.getElementById('chatMessages');
                                // Use normalized conversation ID (already calculated above)
                                if (messagesContainer && chatMessages[normalizedConversationId]) {
                                    // CRITICAL: Ensure container is visible
                                    messagesContainer.classList.add('active');
                                    console.log(' Rendering new message in selected conversation. Message count:', chatMessages[normalizedConversationId].length);
                                    renderMessages(chatMessages[normalizedConversationId], messagesContainer).then(() => {
                                        // Scroll to bottom after render
                                        setTimeout(() => {
                                            if (messagesContainer) {
                                                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                                            }
                                        }, 100);
                                    });
                                } else {
                                    console.error(' Messages container not found or messages array is empty', {
                                        container: !!messagesContainer,
                                        messagesArray: !!chatMessages[normalizedConversationId],
                                        messageCount: chatMessages[normalizedConversationId]?.length || 0
                                    });
                                }
                            } else {
                                console.log(' Conversation not selected, skipping render. selectedConversation:', selectedConversation, 'conversationId:', conversationId);
                            }
                        }

                        // Don't reload entire conversation list - it will overwrite our preview
                        // The preview is already updated in addMessageToConversation
                        
                        // NOTE: Badge is updated in addMessageToConversation for customer messages
                        // DO NOT update badge here to prevent duplicate updates
                        // This prevents the badge from being counted twice (once here, once in addMessageToConversation)
                        // The badge update in addMessageToConversation is sufficient and happens immediately
                    }
                });
                
                // Listen for message updates (e.g., when message is marked as read)
                chatRealtimeRef.on('child_changed', function(snapshot) {
                    const message = snapshot.val();
                    console.log('Message updated:', message);
                    if (message && message.conversationId) {
                        // CRITICAL: Exclude messages from rider-customer conversations
                        const msgConvId = normalizeConversationId(message?.conversationId);
                        const isRiderConversation = (message?.chatType === 'rider') || 
                                                   (msgConvId && msgConvId.includes('_rider_'));
                        if (isRiderConversation) {
                            console.log(' Real-time child_changed filtered out - rider conversation:', message.id, 'conversationId:', msgConvId, 'chatType:', message.chatType);
                            return; // Skip this message
                        }
                        
                        // Skip noisy UI updates while bulk-marking as read
                        if (isMarkingAsRead && message.sender === 'customer') {
                            console.log('Skipping child_changed UI updates during mark-as-read');
                            return;
                        }
                        updateMessageInConversation(message.conversationId, message);

                        // Reorder on updates that change latest message
                        try { updateConversationListFromMessage(message.conversationId, message); } catch (e) { console.warn('reorder failed', e); }
                        
                        // Update badge count when message read status changes
                        // CRITICAL: Skip badge update if this conversation is in readConversations or being marked as read
                        // This prevents badge from appearing when messages are marked as read in Firebase
                        if (message.sender === 'customer') {
                            const normalizedConvId = normalizeConversationId(message.conversationId);
                            let isReadConv = false;
                            
                            // Check readConversations
                            if (window.readConversations && window.readConversations.has(normalizedConvId)) {
                                isReadConv = true;
                            } else if (window.readConversations) {
                                // Check with conversationIdsMatch to handle normalization differences
                                for (const readConvId of window.readConversations) {
                                    if (conversationIdsMatch(readConvId, normalizedConvId)) {
                                        isReadConv = true;
                                        break;
                                    }
                                }
                            }
                            
                            // Check markingAsReadConversations
                            if (!isReadConv && window.markingAsReadConversations) {
                                for (const markingConvId of window.markingAsReadConversations) {
                                    const normalizedMarkingId = normalizeConversationId(markingConvId);
                                    if (conversationIdsMatch(normalizedMarkingId, normalizedConvId)) {
                                        isReadConv = true;
                                        break;
                                    }
                                }
                            }
                            
                            if (isReadConv) {
                                console.log('Skipping badge update for conversation in readConversations/markingAsReadConversations:', normalizedConvId);
                            } else {
                                console.log('Customer message read status updated, updating badge count');
                                // Use a small delay to let Firebase sync complete and avoid race conditions
                                setTimeout(() => {
                                    updateBadgeCount();
                                }, 300);
                            }
                        }
                        console.log('Real-time: Message updated');
                    }
                });
                
                // Listen for conversations with debouncing and change detection
                if (!window.conversationsListenerDebounce) {
                    window.conversationsListenerDebounce = null;
                    window.lastConversationsData = null;
                }
                
                conversationsRef.on('value', function(snapshot) {
                    // Skip if we're in the middle of unarchiving to prevent reflection
                    if (isUnarchiving) {
                        console.log('Skipping Firebase listener update during unarchive process');
                        return;
                    }
                    
                    // Skip during initial load to prevent interference
                    if (isInitialLoad) {
                        console.log('Skipping Firebase listener update during initial load');
                        return;
                    }
                    
                    // Always skip if we're currently viewing archived tab to prevent interference
                    if (currentConversationTab === 'archived') {
                        console.log('Skipping Firebase listener update while viewing archived tab');
                        return;
                    }
                    
                    // Skip if we're already updating the conversation list to prevent duplicates
                    if (isUpdatingConversationList) {
                        console.log('Skipping Firebase listener update - conversation list is being updated');
                        return;
                    }
                    
                    // Skip if we're processing a new message to prevent duplicates
                    if (isProcessingNewMessage) {
                        console.log('Skipping Firebase listener update - processing new message');
                        return;
                    }
                    
                    const conversations = snapshot.val() || {};
                    
                    // Check if data actually changed to prevent unnecessary updates
                    const conversationsString = JSON.stringify(conversations);
                    if (window.lastConversationsData === conversationsString) {
                        console.log('Conversations data unchanged, skipping update');
                        return;
                    }
                    window.lastConversationsData = conversationsString;
                    
                    console.log('Conversations updated via Firebase listener:', Object.keys(conversations));
                    
                    // Debounce the update to prevent rapid-fire refreshes
                    if (window.conversationsListenerDebounce) {
                        clearTimeout(window.conversationsListenerDebounce);
                    }
                    
                    window.conversationsListenerDebounce = setTimeout(() => {
                        // Update active conversations
                        const activeConversations = {};
                        Object.keys(conversations).forEach(conversationId => {
                            const conversation = conversations[conversationId];
                            if (!conversation.archived) {
                                activeConversations[conversationId] = conversation;
                            }
                        });
                        
                        console.log('Firebase listener updating with active conversations:', Object.keys(activeConversations));
                        
                        // Only update if we're on the active tab
                        if (currentConversationTab === 'active') {
                            // Use updateConversationList which has its own duplicate prevention
                            updateConversationList(activeConversations);
                        }
                        
                        console.log('Real-time: Conversations updated (debounced)');
                    }, 500); // 500ms debounce
                });

                // Also listen to customerMessages tree for customer-originated writes (compatibility)
                try {
                    if (!window.customerMessagesRealtimeInitialized) {
                        window.customerMessagesRealtimeInitialized = true;
                        if (!window.customerMessageChildListeners) window.customerMessageChildListeners = {};

                        const custRoot = firebase.database().ref('customerMessages');
                        // For each conversation under customerMessages, attach a child_added listener for new messages after cutoff
                        custRoot.on('child_added', function(convSnap) {
                            const cid = convSnap.key;
                            if (!cid) return;
                            
                            // CRITICAL: Skip rider conversations
                            if (cid.includes('_rider_')) {
                                console.log('Skipping rider conversation in customerMessages real-time listener:', cid);
                                return;
                            }
                            
                            if (window.customerMessageChildListeners[cid]) return; // avoid duplicate listeners
                            const convPath = firebase.database().ref(`customerMessages/${cid}`)
                                .orderByChild('timestamp')
                                .startAt(window.chatRealtimeCutoffTs + 1);
                            const handler = async function(msgSnap) {
                                const m = msgSnap.val();
                                if (!m) return;
                                
                                // CRITICAL: Exclude messages from rider-customer conversations
                                const msgConvId = normalizeConversationId(m?.conversationId);
                                const isRiderConversation = (m?.chatType === 'rider') || 
                                                           (msgConvId && msgConvId.includes('_rider_')) ||
                                                           (cid && cid.includes('_rider_'));
                                if (isRiderConversation) {
                                    console.log(' customerMessages real-time listener filtered out - rider conversation:', m.id, 'conversationId:', msgConvId || cid, 'chatType:', m.chatType);
                                    return; // Skip this message
                                }
                                
                                // Ensure message has an ID - use key if id is missing
                                if (!m.id && msgSnap.key) {
                                    m.id = msgSnap.key;
                                }
                                
                                // CRITICAL: Preserve imageUrl and videoUrl fields from Firebase
                                if (m.imageUrl) {
                                    m.imageUrl = String(m.imageUrl);
                                }
                                if (m.videoUrl) {
                                    m.videoUrl = String(m.videoUrl);
                                }
                                
                                // Debug: Log media fields
                                if (m.imageUrl || m.videoUrl) {
                                    console.log(' customerMessages real-time message has media:', {
                                        id: m.id,
                                        sender: m.sender,
                                        imageUrl: m.imageUrl,
                                        videoUrl: m.videoUrl
                                    });
                                }
                                
                                const conversationId = m.conversationId || cid;
                                
                                // CRITICAL: Normalize conversation ID to ensure consistency
                                const normalizedConversationId = normalizeConversationId(conversationId);
                                
                                // Check if message already exists in local array to prevent duplicates
                                // Use normalized ID for checking
                                if (!chatMessages[normalizedConversationId]) {
                                    chatMessages[normalizedConversationId] = [];
                                }
                                
                                const messageExists = chatMessages[normalizedConversationId].some(msg => 
                                    (msg.id && m.id && msg.id === m.id) ||
                                    (msg.timestamp === m.timestamp && 
                                     msg.text === m.text && 
                                     msg.sender === m.sender)
                                );
                                
                                if (!messageExists) {
                                    console.log('New customerMessages entry:', conversationId, m.id, m.sender, m.text?.substring(0, 30));
                                    
                                    // CRITICAL: For customer messages, explicitly mark as unread
                                    if (m.sender === 'customer' && m.isRead !== true) {
                                        m.isRead = false;
                                        console.log('customerMessages listener: Marked customer message as unread');
                                    }
                                    
                                    // NOTE: addMessageToConversation will handle badge update
                                    // Don't update badge here to prevent duplicate updates
                                    // The badge update in addMessageToConversation is sufficient
                                    await addMessageToConversation(conversationId, m);
                                    
                                    // Ensure it's rendered if this conversation is selected
                                    // Use normalized ID for comparison
                                    if (isChatboxOpen && conversationIdsMatch(selectedConversation, normalizedConversationId)) {
                                        const messagesContainer = document.getElementById('chatMessages');
                                        if (messagesContainer && chatMessages[normalizedConversationId]) {
                                            renderMessages(chatMessages[normalizedConversationId], messagesContainer);
                                        }
                                    }
                                    
                                    try { updateConversationListFromMessage(normalizedConversationId, m); } catch (_) {}
                                    try { ensureConversationExists(conversationId, m); } catch (_) {}
                                    
                                    // NOTE: Badge is already updated in addMessageToConversation
                                    // DO NOT update badge here to prevent duplicate counts
                                } else {
                                    console.log('Message from customerMessages already exists, skipping duplicate');
                                    // NOTE: Don't update badge for duplicates - badge should already be correct
                                    // Updating here could cause the badge to show incorrect counts
                                }
                            };
                            convPath.on('child_added', handler);
                            window.customerMessageChildListeners[cid] = { ref: convPath, handler };
                        });
                    }
                } catch (e) { console.warn('customerMessages compatibility listener failed', e); }
                // Firestore compatibility listeners (if customer app uses Firestore)
                try {
                    if (firebase.firestore) {
                        const fs = firebase.firestore();
                        // Conversations snapshot -> update lists
                        fs.collection('conversations').onSnapshot(function(snap){
                            const data = {};
                            snap.forEach(function(doc){ data[doc.id] = doc.data() || {}; });
                            const active = {};
                            Object.keys(data).forEach(function(id){ const c = data[id]||{}; if (c.archived !== true) active[id]=c; });
                            try { updateConversationList(active); } catch(_) {}
                        });
                        // New chat messages -> reorder list and badge
                        fs.collection('chatMessages')
                          .where('timestamp','>=', window.chatRealtimeCutoffTs + 1)
                          .onSnapshot(function(snap){
                              snap.docChanges().forEach(function(ch){
                                  if (ch.type === 'added' || ch.type === 'modified') {
                                      const m = ch.doc.data() || {};
                                      const cid = m.conversationId;
                                      if (!cid) return;
                                      try { addMessageToConversation(cid, m); } catch(_) {}
                                      try { updateConversationListFromMessage(cid, m); } catch(_) {}
                                      // Badge is updated in addMessageToConversation for customer messages
                                      // This ensures badge appears immediately when customer sends a message
                                  }
                              });
                          });
                    }
                } catch(_) { console.warn('Firestore compatibility listeners failed'); }
            } else {
                // Firebase not needed - using Supabase instead
                // console.error('Firebase not initialized properly');
            }
        }
        function sendMessageToFirebase(conversationId, messageText, providedTimestamp = null, imageUrl = null, videoUrl = null, providedMessageId = null) {
            console.log('sendMessageToSupabase called with:', conversationId, messageText, 'providedTimestamp:', providedTimestamp, 'imageUrl:', imageUrl, 'videoUrl:', videoUrl);
            
            return new Promise(async (resolve, reject) => {
                const supabase = getSupabaseClientSafe();
                if (!supabase) {
                    reject(new Error('Supabase not available'));
                    return;
                }
                
                const staffUid = sessionStorage.getItem('staffUid') || sessionStorage.getItem('adminUid');
                const staffName = sessionStorage.getItem('staffName') || sessionStorage.getItem('adminName') || sessionStorage.getItem('username') || 'Staff Member';
                
                // Get role from URL params first, then sessionStorage, with proper handling for admin
                const urlParams = new URLSearchParams(window.location.search);
                let rawRole = urlParams.get('role');
                
                // If not in URL, check sessionStorage (check multiple keys)
                if (!rawRole) {
                    rawRole = sessionStorage.getItem('userRole') || 
                             sessionStorage.getItem('adminRole') || 
                             sessionStorage.getItem('role');
                }
                
                // Debug logging
                console.log(' Role detection for message:', {
                    urlRole: urlParams.get('role'),
                    userRole: sessionStorage.getItem('userRole'),
                    adminRole: sessionStorage.getItem('adminRole'),
                    role: sessionStorage.getItem('role'),
                    rawRole: rawRole,
                    staffName: staffName
                });
                
                // Default to Staff if no role found, but try to infer from adminUid or staff name
                if (!rawRole) {
                    if (sessionStorage.getItem('adminUid') || sessionStorage.getItem('adminName')) {
                        rawRole = 'admin';
                        console.log(' Inferred admin role from adminUid/adminName');
                    } else if (staffName && (staffName.toLowerCase().includes('administrator') || staffName === 'System Administrator')) {
                        rawRole = 'admin';
                        console.log(' Inferred admin role from staff name:', staffName);
                    } else {
                        rawRole = 'staff';
                    }
                }
                
                // Properly capitalize the role: 'admin' -> 'Admin', 'staff' -> 'Staff'
                let staffRole = 'Staff';
                if (typeof rawRole === 'string' && rawRole.length > 0) {
                    const lowerRole = rawRole.toLowerCase();
                    if (lowerRole === 'admin' || lowerRole === 'administrator') {
                        staffRole = 'Admin';
                    } else if (lowerRole === 'staff') {
                        staffRole = 'Staff';
                    } else {
                        // Capitalize first letter for any other role
                        staffRole = rawRole.charAt(0).toUpperCase() + rawRole.slice(1).toLowerCase();
                    }
                }
                
                console.log(' Final role for message:', staffRole, 'Display label will be:', `${staffName} - (Role: ${staffRole})`);
                const staffDisplayLabel = `${staffName} - (Role: ${staffRole})`;
                let finalMessageText = messageText || '';
                if (finalMessageText.trim() === '' && (imageUrl || videoUrl)) {
                    finalMessageText = imageUrl ? ' Image' : ' Video';
                }
                
                const clientTimestamp = providedTimestamp || Date.now();
                const messageId = providedMessageId || ((typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function')
                    ? crypto.randomUUID()
                    : `msg_${Date.now()}`);
                
                const payload = {
                    id: messageId,
                    conversationId: conversationId,
                    customerId: conversationId,
                    sender: 'staff',
                    text: finalMessageText,
                    staffId: staffUid,
                    staffUid: staffUid,
                    staffName: staffName,
                    staffDisplayName: staffDisplayLabel,
                    isRead: false,
                    timestamp: clientTimestamp,
                    clientTimestamp: clientTimestamp,
                    createdAt: clientTimestamp,
                    imageUrl: imageUrl || null,
                    videoUrl: videoUrl || null,
                    messageType: imageUrl ? 'image' : (videoUrl ? 'video' : 'text'),
                    status: 'sent',
                    fromStaff: true,
                    recipientId: conversationId,
                    senderType: 'staff',
                    messageDirection: 'outgoing',
                    customerDirection: 'incoming'
                };
                
                try {
                    const result = await supabaseInsertChatMessage(payload);
                    if (!result) {
                        throw new Error('Failed to insert chat message into Supabase');
                    }
                    
                    await updateConversationMetadata(conversationId, finalMessageText, 'staff');
                    createCustomerNotification(conversationId, finalMessageText, staffName);
                    resolve(messageId);
                } catch (error) {
                    console.error(' Error sending staff message to Supabase:', error);
                    reject(error);
                }
            });
        }

        // Debug function to check Firebase data
        function debugFirebaseData(conversationId) {
            console.log('=== DEBUG: Checking Firebase data for conversation:', conversationId);
            
            if (isFirebaseChatAvailable()) {
                // Check all messages in chatMessages
                firebase.database().ref('chatMessages').once('value').then((snapshot) => {
                    const allMessages = snapshot.val();
                    console.log('All messages in Firebase:', allMessages);
                    
                    if (allMessages) {
                        const conversationMessages = Object.values(allMessages).filter(msg => 
                            msg.conversationId === conversationId
                        );
                        console.log('Messages for this conversation:', conversationMessages);
                        console.log('Staff messages:', conversationMessages.filter(msg => msg.sender === 'staff'));
                        console.log('Customer messages:', conversationMessages.filter(msg => msg.sender === 'customer'));
                    }
                });
                
                // Check customerMessages path
                firebase.database().ref(`customerMessages/${conversationId}`).once('value').then((snapshot) => {
                    console.log('Customer messages path:', snapshot.val());
                });
            }
        }
        
        // Global debug function for console access
        window.debugChat = function(conversationId) {
            if (!conversationId) {
                conversationId = selectedConversation;
                console.log('Using current conversation:', conversationId);
            }
            debugFirebaseData(conversationId);
        };

        // Create notification for customer app when staff sends message
        async function createCustomerNotification(conversationId, messageText, staffName) {
            try {
                // Get Supabase client
                const supabase = window.getSupabaseClient ? window.getSupabaseClient() : window.supabaseClient;
                if (!supabase) {
                    console.error('Supabase client not available for creating notification');
                    return;
                }

                // Generate notification ID
                const notificationId = `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                
                // Create notification in Supabase
                const { error } = await supabase.from('customer_notifications').insert({
                    id: notificationId,
                    customer_id: conversationId,
                    type: 'new_message',
                    title: 'New Message from Staff',
                    message: `You have a new message from ${staffName}`,
                    timestamp: Date.now(),
                    is_read: false,
                    // Store additional data if needed (these won't be in the table, but won't cause errors)
                });

                if (error) {
                    console.error('Error creating customer notification:', error);
                } else {
                    console.log('Customer notification created:', notificationId);
                }
            } catch (error) {
                console.error('Error creating customer notification:', error);
            }
        }

        async function addMessageToConversation(conversationId, message) {
            console.log('Adding message to conversation:', conversationId, message);
            
            // CRITICAL: Normalize conversation ID immediately to ensure consistency
            // This prevents the same conversation from being stored under different keys
            const normalizedConversationId = normalizeConversationId(conversationId);
            
            // Use normalized ID for all operations
            if (!chatMessages[normalizedConversationId]) {
                chatMessages[normalizedConversationId] = [];
            }
            
            // Check if message already exists (check by id first, then timestamp and text to avoid duplicates)
            // Check in normalized conversation ID
            const exists = chatMessages[normalizedConversationId].some(msg => 
                (msg.id && message.id && msg.id === message.id) ||
                (msg.timestamp === message.timestamp && 
                 msg.text === message.text && 
                 msg.sender === message.sender)
            );
            
            if (!exists) {
                console.log('Message is new, processing...');
                console.log('Adding message to local array:', message);
                
                // CRITICAL: For customer messages, check if staff is currently viewing this conversation
                // If yes, mark as read immediately. If no, mark as unread.
                if (message.sender === 'customer' && message.isRead !== true) {
                    // Check if this message is for the currently selected conversation while chatbox is open
                    const isCurrentlyViewing = isChatboxOpen && conversationIdsMatch(selectedConversation, normalizedConversationId);
                    
                    if (isCurrentlyViewing) {
                        // Staff is actively viewing this conversation - mark message as read immediately
                        message.isRead = true;
                        console.log(' Customer message marked as READ immediately (staff is currently viewing this conversation)');
                        
                        // Update message in Firebase as read
                        if (isFirebaseChatAvailable() && message.id) {
                            try {
                                const messageRef = firebase.database().ref(`chatMessages/${message.id}`);
                                await messageRef.update({ isRead: true });
                                console.log('Updated message in Firebase as read:', message.id);
                            } catch (error) {
                                console.warn('Error updating message isRead in Firebase:', error);
                            }
                        }
                        
                        // Keep conversation in readConversations (don't remove it)
                        if (!window.readConversations) {
                            window.readConversations = new Set();
                        }
                        window.readConversations.add(normalizedConversationId);
                        window.readConversations.add(conversationId);
                        console.log('Conversation kept in readConversations (staff is viewing):', normalizedConversationId);
                    } else {
                        // Staff is NOT viewing this conversation - mark as unread
                        message.isRead = false;
                        console.log('Marked new customer message as unread (isRead: false) - staff not viewing');
                        
                        // CRITICAL: Remove conversation from readConversations if it was marked as read
                        // This allows the badge to appear for new unread messages
                        // Remove ALL ID variations to ensure proper tracking
                        if (window.readConversations) {
                            // Remove normalized ID
                            window.readConversations.delete(normalizedConversationId);
                            // Remove original ID
                            window.readConversations.delete(conversationId);
                            // Remove all variations that might match
                            for (const readConvId of Array.from(window.readConversations)) {
                                if (conversationIdsMatch(readConvId, normalizedConversationId)) {
                                    window.readConversations.delete(readConvId);
                                }
                            }
                            console.log('Removed conversation from readConversations (new unread message arrived):', normalizedConversationId, conversationId);
                        }
                    }
                }
                
                // Set flag to prevent Firebase listener interference
                isProcessingNewMessage = true;
                
                chatMessages[normalizedConversationId].push(message);
                
                // Sort messages using centralized function (oldest first, newest last)
                chatMessages[normalizedConversationId] = sortMessagesByTimestamp(chatMessages[normalizedConversationId]);
                
                // CRITICAL: Log that message was added for debugging
                console.log(' Message added to chatMessages. Conversation:', normalizedConversationId, 'Total messages:', chatMessages[normalizedConversationId].length);
                console.log('Message details:', { id: message.id, sender: message.sender, isRead: message.isRead, text: message.text?.substring(0, 50) });
                
                // Immediately render the message if this conversation is selected
                // For staff messages, always render if conversation is selected (don't check isChatboxOpen)
                const messagesContainer = document.getElementById('chatMessages');
                // Use normalized ID for comparison
                const normalizedSelected = normalizeConversationId(selectedConversation);
                if (conversationIdsMatch(selectedConversation, normalizedConversationId) && messagesContainer) {
                    console.log('Immediately rendering new message in selected conversation. Sender:', message.sender);
                    renderMessages(chatMessages[normalizedConversationId], messagesContainer).then(() => {
                        // Scroll to bottom after render
                        setTimeout(() => {
                            if (messagesContainer) {
                                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                            }
                        }, 100);
                    });
                }
                
                // Debug: Check conversation state
                console.log('=== MESSAGE PROCESSING DEBUG ===');
                console.log('Selected conversation:', selectedConversation);
                console.log('Normalized selected:', normalizedSelected);
                console.log('Message conversation:', conversationId);
                console.log('Normalized conversation:', normalizedConversationId);
                console.log('Are they equal?', conversationIdsMatch(selectedConversation, normalizedConversationId));
                console.log('Is chatbox open?', isChatboxOpen);
                console.log('Message sender:', message.sender);
                console.log('Message isRead:', message.isRead);
                console.log('Message text:', message.text);
                
                // Update conversation metadata in Firebase with the NEW message
                // Use original conversationId for Firebase (it might be in a specific format)
                try {
                    if (isFirebaseChatAvailable()) {
                        // Try normalized ID first, fallback to original
                        const firebaseConvId = normalizedConversationId || conversationId;
                        const conversationRef = firebase.database().ref(`conversations/${firebaseConvId}`);
                        const normalizedMessageTimestamp = normalizeTimestamp(message.timestamp ?? message.createdAt ?? message.clientTimestamp ?? message.id ?? Date.now(), message);
                        const serverNow = getServerTimestampValue();
                        await conversationRef.update({
                            lastMessage: message.text,
                            lastMessageTime: normalizedMessageTimestamp,
                            lastMessageSender: message.sender,
                            updatedAt: serverNow
                        }).catch(err => console.warn('Error updating conversation metadata:', err));
                    }
                } catch (e) {
                    console.warn('Error updating conversation metadata:', e);
                }
                
                // Handle new messages from customers
                if (message.sender === 'customer') {
                    console.log('Processing customer message for unread styling');
                    // Ensure conversation exists in Firebase conversations list first
                    // Use original conversationId for ensureConversationExists
                    await ensureConversationExists(conversationId, message);
                    
                    // Check if message was marked as read (because staff is currently viewing it)
                    const isCurrentlyViewing = isChatboxOpen && conversationIdsMatch(selectedConversation, normalizedConversationId);
                    
                    if (!isCurrentlyViewing) {
                        // Staff is NOT viewing this conversation - apply unread styling and update badge
                        
                        // Apply unread styling to conversation item
                        applyUnreadStylingToConversation(normalizedConversationId);
                        
                        // Update badge immediately
                        console.log('Customer message received - updating badge count immediately (force update)');
                        console.log('Chatbox state:', isChatboxOpen ? 'OPEN' : 'CLOSED');
                        console.log('Message added to chatMessages for conversation:', normalizedConversationId);
                        const messageCount = chatMessages[normalizedConversationId]?.length || 0;
                        console.log('Current chatMessages for this conversation:', messageCount, 'messages');
                        
                        // CRITICAL: Verify message is actually in chatMessages before updating badge
                        const hasUnreadCustomerMessage = chatMessages[normalizedConversationId]?.some(msg => 
                            msg.sender === 'customer' && msg.isRead === false && msg.text && msg.text.trim() !== ''
                        );
                        console.log('Has unread customer message in chatMessages?', hasUnreadCustomerMessage);
                        
                        // CRITICAL: Ensure isInitialLoad is false so badge can update
                        // This fixes the issue where badge doesn't show when chatbox is closed
                        if (isInitialLoad) {
                            console.log(' Received message during initial load - forcing isInitialLoad to false to allow badge update');
                            isInitialLoad = false;
                        }
                        
                        // Update badge immediately - use multiple attempts to ensure it shows
                        console.log('First badge update attempt - immediate');
                        updateBadgeCount(true); // Force update for real-time messages
                        
                        // Second attempt: after a small delay to ensure everything is processed
                        setTimeout(() => {
                            console.log('Second badge update attempt - ensuring badge is visible');
                            const badge = document.getElementById('chatBadge');
                            if (badge) {
                                console.log('Badge element found. Classes:', badge.className);
                                console.log('Badge display style:', badge.style.display);
                                console.log('Badge computed display:', window.getComputedStyle(badge).display);
                                console.log('Badge text content:', badge.textContent);
                            }
                            updateBadgeCount(true); // Force update again to ensure badge shows
                        }, 200); // Small delay to ensure message is fully processed
                        
                        // Third attempt: final check after a bit more time
                        setTimeout(() => {
                            console.log('Third badge update attempt - final check');
                            updateBadgeCount(true);
                        }, 500); // Final check to ensure badge is visible
                    } else {
                        // Staff IS currently viewing this conversation - message already marked as read
                        // Do NOT apply unread styling or update badge
                        console.log(' Staff is currently viewing this conversation - message marked as read, no badge update needed');
                        
                        // Still update badge to ensure count is correct (should remain same or decrease)
                        updateBadgeCount(true);
                    }
                } else if (message.sender === 'staff') {
                    // If staff sends a message to an archived conversation, auto-unarchive and move to Active
                    try {
                        if (isFirebaseChatAvailable()) {
                            const conversationRef = firebase.database().ref(`conversations/${conversationId}`);
                            const snapshot = await conversationRef.once('value');
                            const data = snapshot.val() || {};
                            if (data.archived === true) {
                                await conversationRef.update({ archived: false, unarchivedAt: Date.now(), updatedAt: Date.now() });
                                // If currently viewing archived, switch to active so it appears there
                                if (currentConversationTab === 'archived') {
                                    switchConversationTab('active');
                                } else {
                                    if (!window.__chatLocks || !window.__chatLocks.activePanelLocked) {
                                    loadActiveConversations();
                                    } else {
                                        console.debug('[chat-lock] Suppressed loadActiveConversations during active chat');
                                    }
                                }
                                showNotification('Conversation moved to Active', 'success');
                            }
                        }
                    } catch (e) {
                        console.warn('Auto-unarchive on staff message (listener) failed:', e);
                    }
                }
                
                // Update conversation preview with the ACTUAL new message text (debounced)
                // Use normalized ID for consistency
                updateConversationPreview(normalizedConversationId, message.text, message.sender, message.timestamp);
                
                // Also update conversation list from message to ensure preview is updated
                // Use normalized ID for consistency
                updateConversationListFromMessage(normalizedConversationId, message);
                
                // Clear the flag after processing
                setTimeout(() => {
                    isProcessingNewMessage = false;
                    console.log('New message processing complete, Firebase listener re-enabled');
                }, 1000);
            } else {
                console.log('Message already exists, skipping');
            }
        }

        function updateMessageInConversation(conversationId, message) {
            if (chatMessages[conversationId]) {
                const index = chatMessages[conversationId].findIndex(msg => msg.id === message.id);
                if (index !== -1) {
                    chatMessages[conversationId][index] = message;
                    
                    // Real-time listener will update UI automatically
                    // No need to manually reload messages
                }
            }
        }
        // Helper function to send a single message with media
        async function sendSingleMessageWithMedia(messageText, imageUrl = null, videoUrl = null) {
            const input = document.getElementById('mainChatMessageInput');
            if (!input) {
                console.error(' mainChatMessageInput not found!');
                return;
            }
            
            if (!messageText && !imageUrl && !videoUrl) {
                console.log(' Send message failed: message is empty and no media');
                return;
            }
            
            if (!selectedConversation) {
                console.error(' Send message failed: selectedConversation is null!');
                alert('Please select a conversation first');
                return;
            }
            
            // CRITICAL: Normalize conversation ID to ensure consistency
            const normalizedConversationId = normalizeConversationId(selectedConversation);
            console.log(' Sending staff message:', messageText, 'to conversation:', selectedConversation, 'normalized:', normalizedConversationId);
            
            // Verify selectedConversation is valid
            if (!normalizedConversationId) {
                console.error(' CRITICAL: selectedConversation is empty or invalid!', selectedConversation);
                alert('Please select a conversation first');
                return;
            }
            
            // Add message to local data first (simple approach like backup)
            // CRITICAL: Ensure new message timestamp is later than all existing messages
            // This ensures the new message always appears at the bottom
            const existingMessages = chatMessages[normalizedConversationId] || [];
            const maxTimestamp = existingMessages.length > 0 
                ? Math.max(...existingMessages.map(m => m.timestamp || 0))
                : 0;
            
            // Use current time, but ensure it's at least 1ms after the latest message
            // CRITICAL: Store actual current time as timestamp - this is the source of truth
            const actualCurrentTime = Date.now();
            const messageTimestamp = Math.max(actualCurrentTime, maxTimestamp + 1);
            const messageId = (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function')
                ? crypto.randomUUID()
                : `msg_${Date.now()}`;
            
            // Determine message text - use placeholder if only media
            let finalMessageText = messageText || '';
            if (finalMessageText.trim() === '' && (imageUrl || videoUrl)) {
                finalMessageText = imageUrl ? ' Image' : ' Video';
            }
            
            // Get current staff info for the message
            const staffUid = sessionStorage.getItem('staffUid') || sessionStorage.getItem('adminUid');
            const staffName = sessionStorage.getItem('staffName') || sessionStorage.getItem('adminName') || sessionStorage.getItem('username') || 'Staff Member';
            
            // Get role from URL params first, then sessionStorage, with proper handling for admin
            const urlParams = new URLSearchParams(window.location.search);
            let rawRole = urlParams.get('role');
            
            // If not in URL, check sessionStorage (check multiple keys)
            if (!rawRole) {
                rawRole = sessionStorage.getItem('userRole') || 
                         sessionStorage.getItem('adminRole') || 
                         sessionStorage.getItem('role');
            }
            
            // Default to Staff if no role found, but try to infer from adminUid or staff name
            if (!rawRole) {
                if (sessionStorage.getItem('adminUid') || sessionStorage.getItem('adminName')) {
                    rawRole = 'admin';
                } else {
                    rawRole = 'staff';
                }
            }
            
            // Properly capitalize the role: 'admin' -> 'Admin', 'staff' -> 'Staff'
            let staffRole = 'Staff';
            if (typeof rawRole === 'string' && rawRole.length > 0) {
                const lowerRole = rawRole.toLowerCase();
                if (lowerRole === 'admin' || lowerRole === 'administrator') {
                    staffRole = 'Admin';
                } else if (lowerRole === 'staff') {
                    staffRole = 'Staff';
                } else {
                    // Capitalize first letter for any other role
                    staffRole = rawRole.charAt(0).toUpperCase() + rawRole.slice(1).toLowerCase();
                }
            }
            
            const newMessage = {
                id: messageId,
                sender: 'staff',
                text: finalMessageText,
                time: formatTime(messageTimestamp), // Use formatTime for consistency
                timestamp: messageTimestamp,
                isOptimistic: true, // Mark as optimistic to prevent duplicates when Firebase echoes it back
                imageUrl: imageUrl || null,
                videoUrl: videoUrl || null,
                staffId: staffUid,
                staffUid: staffUid,
                staffName: staffName,
                staffDisplayName: `${staffName} - (Role: ${staffRole})`
            };
            
            // CRITICAL: Use normalized conversation ID as key to ensure consistency
            if (!chatMessages[normalizedConversationId]) {
                chatMessages[normalizedConversationId] = [];
            }
            
            // Check if message already exists to prevent duplicates
            const existingMessage = chatMessages[normalizedConversationId].find(msg => 
                (msg.id === newMessage.id) ||
                (msg.timestamp === newMessage.timestamp && 
                 msg.text === newMessage.text && 
                 msg.sender === newMessage.sender)
            );
            
            if (!existingMessage) {
                chatMessages[normalizedConversationId].push(newMessage);
                // CRITICAL: Sort messages using centralized function to maintain chronological order
                chatMessages[normalizedConversationId] = sortMessagesByTimestamp(chatMessages[normalizedConversationId]);
                console.log(' Added message to local array. Total messages:', chatMessages[normalizedConversationId].length);
            } else {
                console.log('Message already exists, skipping duplicate');
                return; // Exit early if message already exists
            }
            
            // Set flags to prevent duplicate rendering when Firebase echoes the message back
            isRenderingOptimisticMessage = true;
            optimisticRenderTime = Date.now();
            
            // Immediately render the message to the UI before Firebase save
            const messagesContainer = document.getElementById('chatMessages');
            if (!messagesContainer) {
                console.error(' chatMessages container not found!');
                isRenderingOptimisticMessage = false;
                return;
            }
            
            messagesContainer.classList.add('active');
            
            if (chatMessages[normalizedConversationId] && chatMessages[normalizedConversationId].length > 0) {
                chatMessages[normalizedConversationId] = sortMessagesByTimestamp(chatMessages[normalizedConversationId]);
                await renderMessages(chatMessages[normalizedConversationId], messagesContainer);
                
                // Scroll to bottom
                setTimeout(() => {
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                }, 50);
            }
            
            // Send to Firebase
            sendMessageToFirebase(normalizedConversationId, finalMessageText, messageTimestamp, imageUrl, videoUrl, messageId).then(() => {
                setTimeout(() => {
                    isRenderingOptimisticMessage = false;
                }, 1000);
            }).catch((error) => {
                console.error('Error saving message to Firebase:', error);
                isRenderingOptimisticMessage = false;
            });
            
            // Update conversation preview
            updateConversationPreview(normalizedConversationId, finalMessageText, 'staff', messageTimestamp);
        }

        // Enhanced sendMessage function with Firebase integration
        // SIMPLIFIED VERSION based on working backup - immediate render approach
        async function sendMessageWithFirebase(imageUrl = null, videoUrl = null) {
            console.log(' sendMessageWithFirebase() called', 'imageUrl:', imageUrl, 'videoUrl:', videoUrl);
            const input = document.getElementById('mainChatMessageInput');
            if (!input) {
                console.error(' mainChatMessageInput not found!');
                return;
            }
            
            const message = input.value.trim();
            
            // Check if we have media files in preview
            if (selectedMediaFiles && selectedMediaFiles.length > 0) {
                // Upload all media files first
                try {
                    if (input) {
                        input.disabled = true;
                        input.placeholder = 'Uploading media...';
                    }
                    
                    // Check if Supabase client is available
                    if (!window.supabaseClient) {
                        throw new Error('Supabase client not initialized');
                    }
                    
                    // Upload all files and send messages
                    for (let i = 0; i < selectedMediaFiles.length; i++) {
                        const file = selectedMediaFiles[i];
                        const isVideo = file.type.startsWith('video/');
                        
                        // Generate unique filename
                        const timestamp = Date.now();
                        const random = Math.floor(Math.random() * 10000);
                        const extension = file.name.split('.').pop();
                        const fileName = `${timestamp}_${random}_${i}.${extension}`;
                        
                        // Read file as array buffer
                        const arrayBuffer = await file.arrayBuffer();
                        
                        // Upload to Supabase
                        const { data, error } = await window.supabaseClient.storage
                            .from('customerconvo_uploads')
                            .upload(fileName, arrayBuffer, {
                                contentType: file.type,
                                upsert: true
                            });
                        
                        if (error) {
                            throw error;
                        }
                        
                        // Get public URL
                        const { data: urlData } = window.supabaseClient.storage
                            .from('customerconvo_uploads')
                            .getPublicUrl(data.path);
                        
                        const publicUrl = urlData.publicUrl;
                        
                        // Send message with this media (use text only for first message, empty for others)
                        const messageText = (i === 0) ? message : '';
                        await sendSingleMessageWithMedia(messageText, isVideo ? null : publicUrl, isVideo ? publicUrl : null);
                        
                        // Small delay between messages to ensure proper ordering
                        if (i < selectedMediaFiles.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                    }
                    
                    // Clear preview and reset input
                    clearMediaPreview();
                    if (input) {
                        input.value = '';
                        input.disabled = false;
                        input.placeholder = 'Type a message...';
                        input.style.height = '36px';
                    }
                    return; // Exit early since we've already sent the messages
                } catch (error) {
                    console.error('Error uploading media files:', error);
                    alert(`Failed to upload media: ${error.message || error}`);
                    if (input) {
                        input.disabled = false;
                        input.placeholder = 'Type a message...';
                    }
                    return;
                }
            }
            
            // If imageUrl or videoUrl provided directly (legacy support), use them
            if (imageUrl || videoUrl) {
                await sendSingleMessageWithMedia(message, imageUrl, videoUrl);
                if (input) {
                    input.value = '';
                    input.style.height = '36px';
                }
                return;
            }
            
            // Otherwise, send text-only message
            await sendSingleMessageWithMedia(message, null, null);
            if (input) {
                input.value = '';
                input.style.height = '36px';
            }
        }

        // Customer name cache to avoid repeated Firebase calls
        if (!window.customerNameCache) {
            window.customerNameCache = {};
        }
        // Get customer name from Firebase
        async function getCustomerName(customerId) {
            if (!customerId) {
                console.warn('getCustomerName called with empty customerId');
                return 'Customer';
            }
            
            // Check cache first, but skip if it's a fallback name (starts with "Customer ")
            const cachedName = window.customerNameCache[customerId];
            if (cachedName && cachedName !== 'Customer' && !cachedName.startsWith('Customer ')) {
                console.log('Using cached customer name:', cachedName, 'for ID:', customerId);
                return cachedName;
            }
            
            // Clear bad cache entry if it exists
            if (cachedName && (cachedName === 'Customer' || cachedName.startsWith('Customer '))) {
                console.log('Clearing bad cache entry:', cachedName, 'for ID:', customerId);
                delete window.customerNameCache[customerId];
            }
            
            try {
                // FIRST: Try to get from conversations table (might have fewer RLS restrictions)
                // This is faster and might work even if customers table is blocked
                try {
                    const supabaseRow = await supabaseFetchConversationRow(customerId);
                    if (supabaseRow && supabaseRow.customer_name && 
                        supabaseRow.customer_name !== 'Customer' && 
                        !supabaseRow.customer_name.startsWith('Customer ')) {
                        console.log(' Found customer name from conversations table (first check):', supabaseRow.customer_name);
                        window.customerNameCache[customerId] = supabaseRow.customer_name;
                        return supabaseRow.customer_name;
                    }
                } catch (convError) {
                    console.warn('Error fetching from conversations table (first check):', convError);
                }
                
                // SECOND: Try to get from Supabase customers table directly
                const supabase = getSupabaseClientSafe();
                if (supabase) {
                    try {
                        // Clean the customerId to remove any extra characters (like :1 port numbers)
                        let cleanCustomerId = String(customerId).trim();
                        // Remove any trailing port numbers or extra characters after UUID
                        cleanCustomerId = cleanCustomerId.split(':')[0].split(' ')[0];
                        console.log('Querying Supabase customers table for ID:', cleanCustomerId, '(original:', customerId, ')');
                        
                        // Try querying with proper error handling
                        let customerData = null;
                        let customerError = null;
                        
                        try {
                            const result = await supabase
                                .from('customers')
                                .select('full_name, first_name, last_name, name')
                                .eq('uid', cleanCustomerId)
                                .maybeSingle();
                            
                            customerData = result.data;
                            customerError = result.error;
                        } catch (queryError) {
                            console.warn('Supabase query threw exception:', queryError);
                            customerError = queryError;
                        }
                        
                        if (customerError) {
                            console.warn('Supabase customers query error:', customerError);
                            console.warn('Error details:', {
                                code: customerError.code,
                                message: customerError.message,
                                details: customerError.details,
                                hint: customerError.hint,
                                customerId: cleanCustomerId
                            });
                            // Try alternative query format if the first one fails
                            if (customerError.code === 'PGRST116' || customerError.code === '400' || customerError.code === 'PGRST301' || customerError.message?.includes('400') || customerError.message?.includes('permission') || customerError.message?.includes('policy')) {
                                console.log('Trying alternative query format...');
                                try {
                                    const altResult = await supabase
                                        .from('customers')
                                        .select('full_name, first_name, last_name, name')
                                        .eq('uid', cleanCustomerId)
                                        .limit(1);
                                    
                                    if (!altResult.error && altResult.data && altResult.data.length > 0) {
                                        const altData = altResult.data[0];
                                        const fullName = altData.full_name || 
                                                        (altData.first_name && altData.last_name ? 
                                                         `${altData.first_name} ${altData.last_name}` : null) || 
                                                        altData.name;
                                        
                                        if (fullName && fullName.trim() !== '' && fullName !== 'Customer' && !fullName.startsWith('Customer ')) {
                                            console.log(' Found customer name from Supabase (alternative query):', fullName);
                                            window.customerNameCache[customerId] = fullName;
                                            return fullName;
                                        }
                                    }
                                } catch (altError) {
                                    console.warn('Alternative query also failed:', altError);
                                }
                            }
                        }
                        
                        if (!customerError && customerData) {
                            const fullName = customerData.full_name || 
                                            (customerData.first_name && customerData.last_name ? 
                                             `${customerData.first_name} ${customerData.last_name}` : null) || 
                                            customerData.name;
                            
                            if (fullName && fullName.trim() !== '' && fullName !== 'Customer' && !fullName.startsWith('Customer ')) {
                                console.log(' Found customer name from Supabase customers table:', fullName, 'for ID:', customerId);
                                window.customerNameCache[customerId] = fullName;
                                return fullName;
                            } else {
                                console.log('Customer data found but name is invalid or fallback:', { fullName, customerData });
                            }
                        } else {
                            console.log('No customer data found in Supabase customers table for ID:', customerId);
                        }
                    } catch (error) {
                        console.warn('Error fetching customer from Supabase customers table:', error);
                    }
                } else {
                    console.warn('Supabase client not available');
                }
                
                // Already checked conversations table first, skip duplicate check
                
                if (isFirebaseChatAvailable()) {
                    // First try to get from conversation data (most recent)
                    const conversationRef = firebase.database().ref(`conversations/${customerId}`);
                    const conversationSnapshot = await conversationRef.once('value');
                    const conversationData = conversationSnapshot.val();
                    
                    if (conversationData && conversationData.customerName && conversationData.customerName !== 'Customer') {
                        console.log('Found customer name from conversation:', conversationData.customerName);
                        window.customerNameCache[customerId] = conversationData.customerName;
                        return conversationData.customerName;
                    }
                    
                    // Try to get from Supabase customer data via CustomerHelpers (might bypass RLS)
                    if (window.CustomerHelpers && typeof window.CustomerHelpers.getCustomer === 'function') {
                        try {
                            console.log('Trying CustomerHelpers.getCustomer for:', customerId);
                            const customerData = await window.CustomerHelpers.getCustomer(customerId);
                            
                            if (customerData) {
                                // Handle both camelCase and snake_case formats
                                const fullName = customerData.fullName || 
                                                customerData.full_name ||
                                                (customerData.firstName && customerData.lastName ? 
                                                 `${customerData.firstName} ${customerData.lastName}` : null) ||
                                                (customerData.first_name && customerData.last_name ? 
                                                 `${customerData.first_name} ${customerData.last_name}` : null) ||
                                                customerData.name;
                                
                                if (fullName && fullName.trim() !== '' && fullName !== 'Customer' && !fullName.startsWith('Customer ')) {
                                    console.log(' Found customer name from CustomerHelpers:', fullName, 'for ID:', customerId);
                                    window.customerNameCache[customerId] = fullName;
                                    return fullName;
                                }
                            }
                        } catch (error) {
                            console.warn('Error getting customer from CustomerHelpers:', error);
                        }
                    }
                    
                    // Try to get from latest message with customerName
                    const messagesRef = firebase.database().ref('chatMessages');
                    const messagesSnapshot = await messagesRef
                        .orderByChild('conversationId')
                        .equalTo(customerId)
                        .limitToLast(10) // Check last 10 messages
                        .once('value');
                    
                    if (messagesSnapshot.exists()) {
                        let foundCustomerName = null;
                        messagesSnapshot.forEach((childSnapshot) => {
                            const message = childSnapshot.val();
                            if (message.customerName && message.customerName !== 'Customer' && !foundCustomerName) {
                                foundCustomerName = message.customerName;
                                console.log('Found customer name from message:', message.customerName);
                            }
                        });
                        if (foundCustomerName) {
                            window.customerNameCache[customerId] = foundCustomerName;
                            return foundCustomerName;
                        }
                    }
                    
                    // Try to get from any message in the conversation (broader search)
                    const allMessagesSnapshot = await messagesRef
                        .orderByChild('customerId')
                        .equalTo(customerId)
                        .limitToLast(5)
                        .once('value');
                    
                    if (allMessagesSnapshot.exists()) {
                        let foundCustomerName = null;
                        allMessagesSnapshot.forEach((childSnapshot) => {
                            const message = childSnapshot.val();
                            if (message.customerName && message.customerName !== 'Customer' && !foundCustomerName) {
                                foundCustomerName = message.customerName;
                                console.log('Found customer name from customer messages:', message.customerName);
                            }
                        });
                        if (foundCustomerName) {
                            window.customerNameCache[customerId] = foundCustomerName;
                            return foundCustomerName;
                        }
                    }
                }
                
                // Try Supabase customers table as final attempt before fallback (with cleaned ID)
                const supabaseClient = getSupabaseClientSafe();
                if (supabaseClient) {
                    try {
                        const cleanCustomerId = String(customerId).trim();
                        const { data: customerData, error: customerError } = await supabaseClient
                            .from('customers')
                            .select('full_name, first_name, last_name, name')
                            .eq('uid', cleanCustomerId)
                            .limit(1)
                            .maybeSingle();
                        
                        if (!customerError && customerData) {
                            const fullName = customerData.full_name || 
                                            (customerData.first_name && customerData.last_name ? 
                                             `${customerData.first_name} ${customerData.last_name}` : null) || 
                                            customerData.name;
                            
                            if (fullName && fullName.trim() !== '' && fullName !== 'Customer' && !fullName.startsWith('Customer ')) {
                                console.log(' Found customer name from Supabase customers table (final attempt):', fullName);
                                window.customerNameCache[customerId] = fullName;
                                return fullName;
                            }
                        } else if (customerError) {
                            console.warn('Supabase query error (final attempt):', customerError);
                            console.warn('Error details:', {
                                code: customerError.code,
                                message: customerError.message,
                                details: customerError.details,
                                hint: customerError.hint
                            });
                        }
                    } catch (error) {
                        console.warn('Error fetching customer from Supabase customers table (final attempt):', error);
                        console.warn('Exception details:', error.message, error.stack);
                    }
                }
                
                // Try to get from CustomerHelpers as a fallback before giving up
                if (window.CustomerHelpers && typeof window.CustomerHelpers.getCustomer === 'function') {
                    try {
                        console.log('Trying CustomerHelpers.getCustomer as fallback for:', customerId);
                        const customerData = await window.CustomerHelpers.getCustomer(customerId);
                        if (customerData) {
                            const fullName = customerData.fullName || 
                                            (customerData.firstName && customerData.lastName ? 
                                             `${customerData.firstName} ${customerData.lastName}` : null) || 
                                            customerData.name ||
                                            (customerData.full_name || 
                                             (customerData.first_name && customerData.last_name ? 
                                              `${customerData.first_name} ${customerData.last_name}` : null) || 
                                             customerData.name);
                            
                            if (fullName && fullName.trim() !== '' && fullName !== 'Customer' && !fullName.startsWith('Customer ')) {
                                console.log(' Found customer name from CustomerHelpers:', fullName);
                                window.customerNameCache[customerId] = fullName;
                                return fullName;
                            }
                        }
                    } catch (helperError) {
                        console.warn('CustomerHelpers.getCustomer also failed:', helperError);
                    }
                }
                
                // Final fallback - return just "Customer" instead of "Customer {id}"
                // This prevents the ugly "Customer e93fea1b" display
                console.warn('Could not find customer name for:', customerId, '- using generic fallback');
                window.customerNameCache[customerId] = 'Customer';
                return 'Customer';
            } catch (error) {
                console.error('Error fetching customer name:', error);
                window.customerNameCache[customerId] = 'Customer';
                return 'Customer';
            }
        }
        // Refresh customer names for all conversations
        async function refreshCustomerNames() {
            try {
                console.log(' Refreshing customer names for all conversations...');
                const conversationsRef = firebase.database().ref('conversations');
                const snapshot = await conversationsRef.once('value');
                const conversations = snapshot.val();
                
                if (conversations) {
                    const conversationIds = Object.keys(conversations);
                    console.log(`Found ${conversationIds.length} conversations to refresh`);
                    
                    for (const conversationId of conversationIds) {
                        const conversation = conversations[conversationId];
                        if (conversation && conversation.customerName) {
                            const currentName = conversation.customerName;
                            
                            // Only refresh if the name is generic
                            if (currentName === 'Customer' || currentName.startsWith('Customer ')) {
                                console.log(`Refreshing name for conversation ${conversationId}: ${currentName}`);
                                const newName = await getCustomerName(conversationId);
                                
                                if (newName && newName !== 'Customer' && !newName.startsWith('Customer ')) {
                                    await conversationsRef.child(conversationId).update({
                                        customerName: newName,
                                        updatedAt: Date.now()
                                    });
                                    console.log(` Updated conversation ${conversationId} name: ${currentName}  ${newName}`);
                                }
                            }
                        }
                    }
                }
                
                console.log(' Customer names refresh completed');
            } catch (error) {
                console.error(' Error refreshing customer names:', error);
            }
        }

        // Create customer record in Supabase
        async function createCustomerRecord(customerId, message) {
            try {
                if (window.CustomerHelpers) {
                    // Check if customer already exists
                    const existingCustomer = await CustomerHelpers.getCustomer(customerId);
                    
                    if (!existingCustomer) {
                        // Create a basic customer record
                        const customerData = {
                            uid: customerId,
                            email: '', // Will be filled when customer provides it
                            fullName: 'Customer', // Default name
                            phoneNumber: '', // Will be filled when customer provides it
                            createdAt: Date.now(),
                            updatedAt: Date.now(),
                            status: 'active',
                            accountStatus: 'pending',
                            verificationStatus: 'pending',
                            isOnline: false,
                            hasLoggedInBefore: false,
                            totalOrders: 0,
                            totalSpent: 0.0,
                            favoriteProducts: []
                        };
                        
                        await CustomerHelpers.insertCustomer(customerData);
                        console.log('Created customer record in Supabase for ID:', customerId);
                    }
                }
            } catch (error) {
                console.error('Error creating customer record:', error);
            }
        }

        // Ensure conversation exists in Firebase conversations list
        async function ensureConversationExists(conversationId, message) {
            try {
                const nowTimestamp = message?.timestamp || Date.now();
                let customerName = message?.customerName || await getCustomerName(conversationId);
                try {
                    const existingRow = await supabaseFetchConversationRow(conversationId);
                    const currentUnread = existingRow && typeof existingRow.unread_count === 'number' ? existingRow.unread_count : 0;
                    const unreadCount = message.sender === 'customer' ? currentUnread + 1 : 0;
                    await supabaseUpsertConversation(conversationId, {
                        customerId: conversationId,
                        customerName,
                        lastMessage: message.text,
                        lastMessageTime: nowTimestamp,
                        lastMessageSender: message.sender,
                        unreadCount,
                        updatedAt: Date.now(),
                        chatType: message.chatType || 'staff',
                        riderId: message.riderId || null,
                        riderName: message.riderName || null
                    });
                } catch (error) {
                    console.warn('Supabase ensureConversationExists failed:', error);
                }
                
                if (isFirebaseChatAvailable()) {
                    const conversationRef = firebase.database().ref(`conversations/${conversationId}`);
                    const snapshot = await conversationRef.once('value');
                    
                    if (!snapshot.exists()) {
                        // Create conversation if it doesn't exist
                        customerName = message.customerName || customerName || await getCustomerName(conversationId);
                        
                        console.log('Creating conversation with customer name:', customerName);
                        
                        // If we couldn't get a proper name, try to create a customer record
                        if (customerName === 'Customer') {
                            console.log('Creating customer record for ID:', conversationId);
                            await createCustomerRecord(conversationId, message);
                            customerName = await getCustomerName(conversationId);
                        }
                        
                        const conversationData = {
                            customerId: conversationId,
                            customerName: customerName,
                            lastMessage: message.text,
                            lastMessageTime: message.timestamp,
                            lastMessageSender: message.sender,
                            unreadCount: message.sender === 'customer' ? 1 : 0,
                            updatedAt: getServerTimestampValue()
                        };
                        
                        await conversationRef.set(conversationData);
                        console.log('Created new conversation for customer:', customerName);
                    } else {
                        // Update existing conversation with latest message
                        const existingConversation = snapshot.val();
                        let firebaseCustomerName = message.customerName || existingConversation.customerName || await getCustomerName(conversationId);
                        
                        console.log('Updating conversation with customer name:', firebaseCustomerName);
                        
                        const currentUnreadCount = existingConversation.unreadCount || 0;
                        const newUnreadCount = message.sender === 'customer' ? currentUnreadCount + 1 : 0;
                        
                        const updateData = {
                            lastMessage: message.text,
                            lastMessageTime: message.timestamp,
                            lastMessageSender: message.sender,
                            customerName: firebaseCustomerName,
                            unreadCount: newUnreadCount,
                            updatedAt: getServerTimestampValue()
                        };
                        
                        await conversationRef.update(updateData);
                        console.log('Updated conversation for customer:', firebaseCustomerName);
                    }
                }
            } catch (error) {
                console.error('Error ensuring conversation exists:', error);
            }
        }
        // Update conversation metadata in Firebase
        async function updateConversationMetadata(conversationId, lastMessage, sender) {
            const customerName = await getCustomerName(conversationId);
            const nowTs = Date.now();
            
            try {
                const supabaseRow = await supabaseFetchConversationRow(conversationId);
                const currentUnread = supabaseRow && typeof supabaseRow.unread_count === 'number' ? supabaseRow.unread_count : 0;
                const unreadCount = sender === 'customer' ? currentUnread + 1 : 0;
                await supabaseUpsertConversation(conversationId, {
                    customerId: conversationId,
                    customerName,
                    lastMessage,
                    lastMessageTime: nowTs,
                    lastMessageSender: sender,
                    unreadCount,
                    updatedAt: nowTs,
                    hasUnreadStaffMessage: sender === 'staff',
                    lastStaffMessage: sender === 'staff' ? lastMessage : supabaseRow?.last_staff_message,
                    lastStaffMessageTime: sender === 'staff' ? nowTs : supabaseRow?.last_staff_message_time,
                    chatType: supabaseRow?.chat_type || 'staff'
                });
            } catch (error) {
                console.warn('Supabase updateConversationMetadata failed:', error);
            }
            
            if (isFirebaseChatAvailable()) {
                const conversationRef = firebase.database().ref(`conversations/${conversationId}`);
                const serverTimestampForUpdate = getServerTimestampValue();
                
                // Check if conversation exists first
                const snapshot = await conversationRef.once('value');
                if (snapshot.exists()) {
                    // Update existing conversation
                    const existingConversation = snapshot.val();
                    const currentUnreadCount = existingConversation.unreadCount || 0;
                    const newUnreadCount = sender === 'customer' ? currentUnreadCount + 1 : 0;
                    
                    const updateData = {
                        lastMessage: lastMessage,
                        lastMessageTime: serverTimestampForUpdate,
                        lastMessageSender: sender,
                        customerName: customerName,
                        unreadCount: newUnreadCount,
                        updatedAt: serverTimestampForUpdate,
                        // Additional metadata for customer app
                        hasUnreadStaffMessage: sender === 'staff' ? true : false,
                        lastStaffMessage: sender === 'staff' ? lastMessage : existingConversation.lastStaffMessage,
                        lastStaffMessageTime: sender === 'staff' ? serverTimestampForUpdate : existingConversation.lastStaffMessageTime
                    };
                    
                    // CRITICAL: If staff sends a message to a conversation that was deleted by staff,
                    // restore it by removing the deletedByStaff flag
                    if (sender === 'staff' && existingConversation.deletedByStaff === true) {
                        updateData.deletedByStaff = null; // Remove the flag
                        updateData.deletedByStaffAt = null;
                        console.log(' Restoring conversation for staff after new message:', conversationId);
                    }
                    
                    await conversationRef.update(updateData);
                } else {
                    // Create new conversation (shouldn't have deletedByStaff flag for new conversations)
                    const conversationData = {
                        customerId: conversationId,
                        customerName: customerName,
                        lastMessage: lastMessage,
                        lastMessageTime: serverTimestampForUpdate,
                        lastMessageSender: sender,
                        unreadCount: sender === 'customer' ? 1 : 0,
                        updatedAt: serverTimestampForUpdate,
                        // Additional metadata for customer app
                        hasUnreadStaffMessage: sender === 'staff' ? true : false,
                        lastStaffMessage: sender === 'staff' ? lastMessage : null,
                        lastStaffMessageTime: sender === 'staff' ? serverTimestampForUpdate : null
                    };
                    await conversationRef.set(conversationData);
                }
            }
        }

        // Debounce conversation list updates to prevent duplication
        if (!window.conversationListUpdateDebounce) {
            window.conversationListUpdateDebounce = {};
        }
        // Update conversation list when new message arrives
        function updateConversationListFromMessage(conversationId, message) {
            // Debounce to prevent rapid-fire updates
            if (window.conversationListUpdateDebounce[conversationId]) {
                clearTimeout(window.conversationListUpdateDebounce[conversationId]);
            }
            
            window.conversationListUpdateDebounce[conversationId] = setTimeout(() => {
            // Update the conversation in the list if it exists
            const conversationsList = document.getElementById('conversationsList');
            if (conversationsList) {
                // Find existing conversation item
                let found = false;
                let item = conversationsList.querySelector(`.conversation-item[data-conversation-id="${conversationId}"]`);
                if (!item) {
                    // Fallback to older detection via onclick string
                    const items = conversationsList.querySelectorAll('.conversation-item');
                    items.forEach(it => {
                        if (!item && it.onclick && it.onclick.toString().includes(conversationId)) {
                            item = it;
                        }
                    });
                }
                if (item) {
                    console.log('Found existing conversation item, updating it');
                    
                    // Only move to top if this is a NEW message (within last 10 seconds)
                    // This prevents moving to top when loading existing messages after clicking
                    if (message && message.timestamp) {
                        const messageTime = normalizeTimestamp(message.timestamp, message);
                        const timeSinceMessage = Date.now() - messageTime;
                        const isNewMessage = timeSinceMessage < 10000; // 10 seconds threshold
                        
                        if (isNewMessage) {
                            console.log('New message detected, moving conversation to top');
                            item.parentNode.insertBefore(item, item.parentNode.firstChild);
                        } else {
                            console.log('Old message, not moving conversation to top');
                        }
                    }
                    found = true;
                }

                // Do NOT create new items here; let the conversations listener/render handle additions to avoid duplicates
                if (!found) {
                    console.log('Conversation not in list yet; skipping create to avoid duplicates (will appear via list refresh).');
                }
                
                // Don't update badge count - only show for real-time customer messages
            }
            
                // Also update the conversation in Firebase to ensure unread count is correct
                // CRITICAL: Only update unread count if conversation is NOT marked as read
                // This prevents badge from appearing when loading messages for already-read conversations
                if (message && message.sender === 'customer') {
                    const normalizedConvoId = normalizeConversationId(conversationId);
                    const isReadConversation = window.readConversations && window.readConversations.has(normalizedConvoId);
                    if (!isReadConversation) {
                        updateConversationUnreadCount(conversationId, message);
                    } else {
                        console.log('Skipping updateConversationUnreadCount for read conversation:', normalizedConvoId);
                    }
                }
            }, 500); // 500ms debounce
        }
        
        // Update conversation unread count in Firebase
        async function updateConversationUnreadCount(conversationId, message) {
            try {
                try {
                    const supabaseRow = await supabaseFetchConversationRow(conversationId);
                    const currentUnread = supabaseRow && typeof supabaseRow.unread_count === 'number' ? supabaseRow.unread_count : 0;
                    await supabaseUpdateConversation(conversationId, {
                        unreadCount: currentUnread + 1,
                        lastMessage: message.text,
                        lastMessageTime: message.timestamp,
                        lastMessageSender: message.sender,
                        updatedAt: Date.now()
                    });
                } catch (error) {
                    console.warn('Supabase updateConversationUnreadCount failed:', error);
                }
                
                if (isFirebaseChatAvailable()) {
                    const conversationRef = firebase.database().ref(`conversations/${conversationId}`);
                    const snapshot = await conversationRef.once('value');
                    
                    if (snapshot.exists()) {
                        const existingConversation = snapshot.val();
                        const currentUnreadCount = existingConversation.unreadCount || 0;
                        const newUnreadCount = currentUnreadCount + 1;
                        
                        await conversationRef.update({
                            unreadCount: newUnreadCount,
                            lastMessage: message.text,
                            lastMessageTime: message.timestamp,
                            lastMessageSender: message.sender,
                            updatedAt: Date.now()
                        });
                    }
                }
            } catch (error) {
                console.error('Error updating conversation unread count:', error);
            }
        }

        // Immediately apply unread styling to conversation item
        function applyUnreadStylingToConversation(conversationId) {
            console.log('Applying unread styling to conversation:', conversationId);
            
            // Apply unread styling even if conversation is selected
            // This allows conversations to show as unread (bold) when new messages arrive,
            // even if the chat is open, until staff focuses on the input field
            
            const conversationsList = document.getElementById('conversationsList');
            if (!conversationsList) {
                console.log('Conversations list not found');
                return;
            }
            
            // Find the conversation item by data attribute or onclick
            const conversationItem = conversationsList.querySelector(`.conversation-item[data-conversation-id="${conversationId}"]`);
            
            if (conversationItem) {
                console.log('Found conversation item, applying unread styling');
                const nameElement = conversationItem.querySelector('.conversation-name');
                const previewElement = conversationItem.querySelector('.conversation-preview');
                
                // Apply unread styling immediately (bold text)
                conversationItem.classList.add('unread');
                if (nameElement) {
                    nameElement.classList.add('unread');
                }
                if (previewElement) {
                    previewElement.classList.add('unread');
                }
                
                console.log('Applied unread styling to conversation:', conversationId);
            } else {
                // Fallback: try finding by onclick attribute
                const conversationItems = conversationsList.querySelectorAll('.conversation-item');
                let found = false;
                conversationItems.forEach(item => {
                    if (item.onclick && item.onclick.toString().includes(conversationId)) {
                        found = true;
                        console.log('Found conversation item by onclick, applying unread styling');
                        const nameElement = item.querySelector('.conversation-name');
                        const previewElement = item.querySelector('.conversation-preview');
                        
                        // Apply unread styling immediately
                        item.classList.add('unread');
                        if (nameElement) {
                            nameElement.classList.add('unread');
                        }
                        if (previewElement) {
                            previewElement.classList.add('unread');
                        }
                    }
                });
                
                if (!found) {
                    console.log('Conversation item not found in UI for:', conversationId);
                }
            }
        }
        // Fix corrupted unread message data
        async function fixCorruptedUnreadData() {
            console.log(' Fixing corrupted unread message data...');
            
            // Use Supabase instead of Firebase
            const supabase = getSupabaseClientSafe();
            if (!supabase) {
                alert('Supabase not available. Please check your connection.');
                return;
            }
            
            const fixBtn = document.getElementById('fixDataBtn');
            if (fixBtn) {
                fixBtn.textContent = 'Fixing...';
                fixBtn.disabled = true;
            }
            
            try {
                let totalFixed = 0;
                
                // Check all conversations
                for (const convId of Object.keys(chatMessages)) {
                    const messages = chatMessages[convId] || [];
                    if (messages.length === 0) continue;
                    
                    // Get the last message
                    const lastMessage = messages[messages.length - 1];
                    
                    // If last message is from staff, ALL customer messages should be read
                    if (lastMessage.sender === 'staff') {
                        const unreadCustomerMessages = messages.filter(m => 
                            m.sender === 'customer' && m.isRead === false
                        );
                        
                        if (unreadCustomerMessages.length > 0) {
                            console.debug(` Found ${unreadCustomerMessages.length} corrupted unread messages in ${convId}`);
                            
                            // Mark as read in local state (Supabase updates handled elsewhere)
                            for (const msg of unreadCustomerMessages) {
                                if (msg.id) {
                                    msg.isRead = true; // Update local state
                                    totalFixed++;
                                }
                            }
                            
                            if (unreadCustomerMessages.length > 0) {
                                console.debug(` Fixed ${unreadCustomerMessages.length} messages in ${convId}`);
                            }
                        }
                    }
                }
                
                // Only log if messages were actually fixed
                if (totalFixed > 0) {
                    console.log(` Corruption fix complete! Fixed ${totalFixed} messages total`);
                    
                    // Only show alert if run manually AND messages were actually fixed
                    if (fixBtn && fixBtn.textContent === 'Fixing...') {
                        alert(`Fixed ${totalFixed} corrupted unread messages!\n\nBadge should now show correct count.`);
                    } else {
                        console.debug(` Auto-fix: Corrected ${totalFixed} corrupted unread messages`);
                    }
                }
                // Don't show anything if totalFixed is 0
                
                // Update badge
                await updateBadgeCount(true);
                
            } catch (error) {
                console.error('Error fixing corrupted data:', error);
                alert('Error fixing data: ' + error.message);
            } finally {
                if (fixBtn) {
                    fixBtn.textContent = '';
                    fixBtn.disabled = false;
                    fixBtn.style.display = 'none';
                }
            }
        }
        
        // Show/hide fix button on double-click chat button
        let chatButtonClickCount = 0;
        let chatButtonClickTimer = null;
        document.addEventListener('DOMContentLoaded', function() {
            const chatBtn = document.getElementById('chatToggleBtn');
            const fixBtn = document.getElementById('fixDataBtn');
            if (chatBtn && fixBtn) {
                chatBtn.addEventListener('dblclick', function(e) {
                    e.stopPropagation();
                    fixBtn.style.display = fixBtn.style.display === 'none' ? 'flex' : 'none';
                });
            }
        });
        
        // Clean up old unread messages from previous sessions
        async function cleanupOldUnreadMessages() {
            console.log(' Starting cleanup of old unread messages...');
            
            if (!isFirebaseChatAvailable()) {
                console.log('Firebase not available, skipping cleanup');
                return;
            }
            
            try {
                // Get all conversations from local state
                const conversationsToCheck = Object.keys(chatMessages);
                console.log('Checking', conversationsToCheck.length, 'conversations for old unread messages');
                
                for (const convId of conversationsToCheck) {
                    const messages = chatMessages[convId] || [];
                    const unreadMessages = messages.filter(m => 
                        m.sender === 'customer' && m.isRead === false
                    );
                    
                    if (unreadMessages.length > 0) {
                        console.log(`Found ${unreadMessages.length} unread messages in conversation:`, convId);
                        
                        // DISABLE automatic cleanup - don't mark messages as read automatically
                        // Messages should only be marked as read when staff actually interacts with the conversation
                        const oldUnreadMessages = [];
                        
                        if (oldUnreadMessages.length > 0) {
                            console.log(` Found ${oldUnreadMessages.length} OLD unread messages (>5 min) in conversation:`, convId);
                            console.log('These are likely from previous sessions. Marking as read...');
                            
                            // Mark these old messages as read in Firebase
                            const messagesRef = firebase.database().ref('chatMessages');
                            const updates = {};
                            
                            for (const msg of oldUnreadMessages) {
                                if (msg.id) {
                                    updates[`${msg.id}/isRead`] = true;
                                    // Also update local state
                                    msg.isRead = true;
                                }
                            }
                            
                            if (Object.keys(updates).length > 0) {
                                await messagesRef.update(updates);
                                console.log(` Marked ${Object.keys(updates).length} old messages as read in Firebase for conversation:`, convId);
                            }
                        }
                    }
                }
                
                // Force badge update after cleanup
                console.log(' Cleanup complete, updating badge...');
                updateBadgeCount(true);
                
            } catch (error) {
                console.error('Error cleaning up old unread messages:', error);
            }
        }
        
        // Mark conversation as read (remove unread styling) when input is focused
        async function markConversationAsReadOnInputFocus(conversationId) {
            console.log('Marking conversation as read on input focus:', conversationId);
            
            const conversationsList = document.getElementById('conversationsList');
            if (!conversationsList) {
                return;
            }
            
            // Normalize conversation ID for consistency
            const normalizedConvoId = normalizeConversationId(conversationId);
            
            // Find the conversation item - try both normalized and original ID
            let conversationItem = conversationsList.querySelector(`.conversation-item[data-conversation-id="${normalizedConvoId}"]`);
            if (!conversationItem) {
                conversationItem = conversationsList.querySelector(`.conversation-item[data-conversation-id="${conversationId}"]`);
            }
            
            // Fallback: try finding by onclick attribute
            if (!conversationItem) {
                const conversationItems = conversationsList.querySelectorAll('.conversation-item');
                conversationItems.forEach(item => {
                    if (item.onclick && item.onclick.toString().includes(conversationId)) {
                        conversationItem = item;
                    }
                });
            }
            
            if (conversationItem) {
                const nameElement = conversationItem.querySelector('.conversation-name');
                const previewElement = conversationItem.querySelector('.conversation-preview');
                
                // Remove unread styling (unbold text)
                conversationItem.classList.remove('unread');
                if (nameElement) {
                    nameElement.classList.remove('unread');
                }
                if (previewElement) {
                    previewElement.classList.remove('unread');
                }
                
                console.log('Removed unread styling from conversation:', normalizedConvoId);
                
                // CRITICAL: Mark messages as read in Firebase if this is the selected conversation
                // Use normalized comparison to handle string/number mismatches
                // AWAIT the call to ensure badge is updated immediately
                if (conversationIdsMatch(selectedConversation, normalizedConvoId)) {
                    console.log('Marking conversation as read and updating badge...');
                    await markConversationAsRead(normalizedConvoId);
                    console.log('Conversation marked as read, now force updating badge...');
                    // Force badge update multiple times to ensure it refreshes
                    await updateBadgeCount(true);
                    setTimeout(() => updateBadgeCount(true), 100);
                    setTimeout(() => updateBadgeCount(true), 300);
                    console.log('Badge updated after input focus');
                } else {
                    // If conversation is not selected, still update local state and badge
                    // This handles edge cases where input is focused but conversation might not match exactly
                    console.log('Conversation ID mismatch, but updating local state and badge anyway');
                    const normalizedSelected = normalizeConversationId(selectedConversation);
                    if (conversationIdsMatch(normalizedSelected, normalizedConvoId)) {
                        await markConversationAsRead(normalizedConvoId);
                    }
                }
            } else {
                console.log('Conversation item not found for:', normalizedConvoId);
                // Still try to mark as read even if UI element not found
                if (conversationIdsMatch(selectedConversation, normalizedConvoId)) {
                    await markConversationAsRead(normalizedConvoId);
                }
            }
        }

        // Add new conversation to the list
        async function addConversationToList(conversationId, message) {
            const conversationsList = document.getElementById('conversationsList');
            if (!conversationsList) return;
            
            const customerName = await getCustomerName(conversationId);
            
            // Prefer checking by conversation id to prevent duplicates
            let existingItem = conversationsList.querySelector(`.conversation-item[data-conversation-id="${conversationId}"]`);
            if (!existingItem) {
                // Fallback: check by customer name (legacy behavior)
                existingItem = findExistingConversationByCustomerName(customerName);
            }
            if (existingItem) {
                // Update existing conversation instead of creating duplicate
                const preview = existingItem.querySelector('.conversation-preview');
                const time = existingItem.querySelector('.conversation-time');
                
                if (preview) {
                    preview.textContent = message.text;
                    // Add unread styling for new customer messages (even if conversation is selected)
                    // The conversation will be marked as read when staff focuses on input field
                    if (message.sender === 'customer') {
                        existingItem.classList.add('unread');
                        preview.classList.add('unread');
                        const nameElement = existingItem.querySelector('.conversation-name');
                        if (nameElement) {
                            nameElement.classList.add('unread');
                        }
                    }
                }
                if (time) {
                    // CRITICAL: Normalize timestamp before formatting to ensure accurate display
                    const normalizedTimestamp = normalizeTimestamp(message.timestamp ?? message.createdAt ?? message.id ?? message.messageId ?? Date.now(), message);
                    time.textContent = formatTime(normalizedTimestamp);
                }
                
                // Move to top of list
                existingItem.parentNode.insertBefore(existingItem, existingItem.parentNode.firstChild);
                return; // Exit early, don't create duplicate
            }
            
            // Only create new conversation item if no duplicate found
            // Extra safety: remove any stray duplicates with same id
            const dupes = conversationsList.querySelectorAll(`.conversation-item[data-conversation-id="${conversationId}"]`);
            if (dupes && dupes.length > 0) {
                dupes.forEach((dupe, idx) => { if (idx > 0 && dupe.parentNode) dupe.parentNode.removeChild(dupe); });
            }
            const conversationItem = document.createElement('div');
            conversationItem.className = 'conversation-item';
            conversationItem.setAttribute('data-conversation-id', conversationId);
            if (message.sender === 'customer' && selectedConversation !== conversationId) {
                conversationItem.classList.add('unread');
            }
            conversationItem.onclick = () => selectConversation(conversationId);
            
            conversationItem.innerHTML = `
                <div class="conversation-avatar">
                    <i class="fas fa-user"></i>
                </div>
                <div class="conversation-details" style="flex: 1 1 0%; min-width: 0; overflow: hidden; max-width: 164px; box-sizing: border-box; width: 100%;">
                    <div class="conversation-name unread" style="white-space: nowrap !important; overflow: hidden !important; text-overflow: ellipsis !important; width: 100%; max-width: 164px; display: block; min-width: 0;">${customerName}</div>
                    <div class="conversation-preview-container" style="display: flex; align-items: center; gap: 8px; min-width: 0; width: 100%;">
                        <div class="conversation-preview unread" style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex: 1; min-width: 0;">${message.text}</div>
                        <div class="conversation-time" style="flex-shrink: 0; white-space: nowrap;">${getMessageDisplayTime(message, normalizeTimestamp(message.timestamp ?? message.createdAt ?? message.id ?? message.messageId ?? Date.now(), message))}</div>
                    </div>
                </div>
                <div class="conversation-actions">
                </div>
            `;
            
            // Add right-click context menu
            conversationItem.addEventListener('contextmenu', (e) => {
                showConversationContextMenu(conversationId, e);
            });
            
            // Add to top of list
            conversationsList.insertBefore(conversationItem, conversationsList.firstChild);
            
            // Update badge count after adding new conversation
            updateChatBadge();
        }

        // Show notification for new messages (kept for other uses)
        function showNewMessageNotification(conversationId, message) {
            // Create a simple notification
            const notification = document.createElement('div');
            notification.className = 'chat-notification';
            notification.innerHTML = `
                <div class="notification-content">
                    <strong>New message from ${conversationId}</strong>
                    <p>${message.text}</p>
                </div>
            `;
            
            // Style the notification
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #4CAF50;
                color: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                max-width: 300px;
                animation: slideIn 0.3s ease-out;
            `;
            
            document.body.appendChild(notification);
            
            // Remove notification after 5 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease-in';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 5000);
        }


        // Global flag to prevent multiple simultaneous conversation list updates (declared elsewhere)

        // Global function to check for duplicate conversations by customer name
        function findExistingConversationByCustomerName(customerName) {
            const conversationsList = document.getElementById('conversationsList');
            if (!conversationsList) return null;
            
            const existingItems = conversationsList.querySelectorAll('.conversation-item');
            for (const item of existingItems) {
                const nameElement = item.querySelector('.conversation-name');
                if (nameElement && nameElement.textContent.trim() === customerName) {
                    return item;
                }
            }
            return null;
        }

        // Update conversation preview with latest message from Firebase
        async function updateConversationPreviewFromFirebase(conversationId) {
            try {
                if (isFirebaseChatAvailable()) {
                    // Get the latest message from Firebase
                    const messagesRef = firebase.database().ref('chatMessages');
                    const snapshot = await messagesRef
                        .orderByChild('conversationId')
                        .equalTo(conversationId)
                        .once('value');
                    
                    if (snapshot.exists()) {
                        const messages = [];
                        snapshot.forEach((childSnapshot) => {
                            messages.push(childSnapshot.val());
                        });
                        // Sort to most recent
                        messages.sort((a, b) => b.timestamp - a.timestamp);
                        const latestMessage = messages[0];
                        
                        if (latestMessage) {
                            // Update the conversation preview with the latest message
                            const conversationItem = document.querySelector(`.conversation-item[data-conversation-id="${conversationId}"]`);
                            if (conversationItem) {
                                const preview = conversationItem.querySelector('.conversation-preview');
                                if (preview) {
                                    const text = latestMessage.sender === 'staff' ? `You: ${latestMessage.text}` : latestMessage.text;
                                    preview.textContent = text;
                                }
                                
                                const time = conversationItem.querySelector('.conversation-time');
                                if (time) {
                                    // CRITICAL: Normalize timestamp before formatting to ensure accurate display
                                    const normalizedTimestamp = normalizeTimestamp(latestMessage.timestamp ?? latestMessage.createdAt ?? latestMessage.id ?? latestMessage.messageId ?? Date.now(), latestMessage);
                                    time.textContent = formatTime(normalizedTimestamp);
                                }
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('Error updating conversation preview from Firebase:', error);
            }
        }

        // Refresh conversation list from Firebase
        async function refreshConversationList() {
            try {
                if (isFirebaseChatAvailable()) {
                    const conversationsRef = firebase.database().ref('conversations');
                    const snapshot = await conversationsRef.orderByChild('updatedAt').once('value');
                    
                    if (snapshot.exists()) {
                        const conversations = snapshot.val();
                        const activeConversations = {};
                        
                        // Filter out archived conversations
                        for (const [conversationId, conversation] of Object.entries(conversations)) {
                            if (!conversation.archived) {
                                activeConversations[conversationId] = conversation;
                            }
                        }
                        
                        // Update the conversation list in UI
                        await updateConversationList(activeConversations);
                    }
                }
            } catch (error) {
                console.error('Error refreshing conversation list:', error);
            }
        }

        // Fix unread counts in conversation metadata by checking actual messages
        async function fixConversationUnreadCounts() {
            try {
                if (isFirebaseChatAvailable()) {
                    const conversationsRef = firebase.database().ref('conversations');
                    const snapshot = await conversationsRef.once('value');
                    
                    if (snapshot.exists()) {
                        const conversations = snapshot.val();
                        const updates = {};
                        
                        for (const [conversationId, conversation] of Object.entries(conversations)) {
                            if (!conversation.archived) {
                                const hasUnreadMessages = await checkConversationForUnreadMessages(conversationId);
                                const correctUnreadCount = hasUnreadMessages ? 1 : 0;
                                
                                // Only update if the count is different
                                if (conversation.unreadCount !== correctUnreadCount) {
                                    updates[`${conversationId}/unreadCount`] = correctUnreadCount;
                                    console.log(`Fixing unread count for ${conversationId}: ${conversation.unreadCount} -> ${correctUnreadCount}`);
                                }
                            }
                        }
                        
                        // Apply all updates at once
                        if (Object.keys(updates).length > 0) {
                            await conversationsRef.update(updates);
                            console.log('Fixed unread counts for conversations');
                        }
                    }
                }
            } catch (error) {
                console.error('Error fixing conversation unread counts:', error);
            }
        }
        // Get the latest message for a conversation from Firebase
        async function getLatestMessageForConversation(conversationId) {
            try {
                if (isFirebaseChatAvailable()) {
                    const messagesRef = firebase.database().ref('chatMessages');
                    const snapshot = await messagesRef
                        .orderByChild('conversationId')
                        .equalTo(conversationId)
                        .once('value');
                    
                    if (snapshot.exists()) {
                        const messages = [];
                        snapshot.forEach((childSnapshot) => {
                            messages.push(childSnapshot.val());
                        });
                        
                        // Sort messages by timestamp to get the most recent
                        messages.sort((a, b) => b.timestamp - a.timestamp);
                        
                        // Return the latest message (most recent overall)
                        return messages[0];
                    }
                }
                return null;
            } catch (error) {
                console.error('Error getting latest message for conversation:', error);
                return null;
            }
        }

        // Get the latest customer message for a conversation from Firebase
        async function getLatestCustomerMessageForConversation(conversationId) {
            try {
                if (isFirebaseChatAvailable()) {
                    const messagesRef = firebase.database().ref('chatMessages');
                    const snapshot = await messagesRef
                        .orderByChild('conversationId')
                        .equalTo(conversationId)
                        .once('value');
                    
                    if (snapshot.exists()) {
                        const messages = [];
                        snapshot.forEach((childSnapshot) => {
                            const message = childSnapshot.val();
                            // Only include customer messages
                            if (message.sender === 'customer') {
                                messages.push(message);
                            }
                        });
                        
                        // Sort customer messages by timestamp to get the most recent
                        messages.sort((a, b) => b.timestamp - a.timestamp);
                        
                        // Return the latest customer message
                        return messages[0];
                    }
                }
                return null;
            } catch (error) {
                console.error('Error getting latest customer message for conversation:', error);
                return null;
            }
        }
        // Update conversation list in UI
        async function updateConversationList(conversations) {
            console.log('updateConversationList called with:', Object.keys(conversations));
            
            // CRITICAL: Don't update if we're currently viewing the archived tab
            if (currentConversationTab === 'archived') {
                console.log(' SKIPPING updateConversationList - currently viewing archived tab');
                return;
            }
            
            const conversationsList = document.getElementById('conversationsList');
            if (!conversationsList) {
                console.error('Conversations list element not found!');
                return;
            }
            
            // Prevent multiple simultaneous updates
            if (isUpdatingConversationList) {
                console.log('Already updating conversation list, skipping...');
                return;
            }
            isUpdatingConversationList = true;
            
            console.log('Starting conversation list update...');
            
            try {
                const conversationIds = Object.keys(conversations);
                console.log(`Found ${conversationIds.length} conversations to process`);
                
                // Store current selected conversation to restore highlight
                const currentSelected = selectedConversation;
                
                // Instead of clearing innerHTML immediately, update items in place where possible
                // Only clear if the structure significantly changed
                const existingItems = conversationsList.querySelectorAll('.conversation-item');
                const existingIds = Array.from(existingItems).map(item => item.getAttribute('data-conversation-id'));
                const newIds = conversationIds;
                
                // Build a map of existing items BEFORE potentially clearing innerHTML
                const existingItemsMap = new Map();
                existingItems.forEach(existingItem => {
                    const id = existingItem.getAttribute('data-conversation-id');
                    if (id) {
                        existingItemsMap.set(id, existingItem);
                    }
                });
                
                // Check if we can do an incremental update
                const idsChanged = existingIds.length !== newIds.length || 
                    !existingIds.every(id => newIds.includes(id)) ||
                    !newIds.every(id => existingIds.includes(id));
                
                if (idsChanged || existingItems.length === 0) {
                    // Only clear if structure changed significantly
                    conversationsList.innerHTML = '';
                    // Clear the map since we cleared the DOM
                    existingItemsMap.clear();
                }
                
                // Check if conversations list is visible
                const listStyle = window.getComputedStyle(conversationsList);
                console.log('Conversations list visibility:', {
                    display: listStyle.display,
                    visibility: listStyle.visibility,
                    opacity: listStyle.opacity,
                    height: listStyle.height,
                    width: listStyle.width
                });
            
            // Track unique customers to prevent duplicates
            const uniqueCustomers = new Map();
            
            console.log('Processing conversations for deduplication:', conversationIds);
            
            for (const conversationId of conversationIds) {
                const conversation = conversations[conversationId];
                
                // Skip archived conversations (strict check)
                if (conversation && conversation.archived === true) {
                    console.log(`Skipping archived conversation: ${conversationId}`);
                    continue;
                }
                
                // ALWAYS fetch customer name from database to ensure we have the correct one
                // This fixes cases where conversation data has "Customer e93fea1b" stored
                console.log(`Fetching customer name for conversation ${conversationId}...`);
                let customerName = await getCustomerName(conversationId);
                console.log(`Fetched customer name for ${conversationId}:`, customerName);
                
                // If we got a valid name (not "Customer" or "Customer {id}"), update the conversation data
                if (customerName && customerName !== 'Customer' && !customerName.startsWith('Customer ')) {
                    // Update Supabase conversations table
                    try {
                        const supabase = getSupabaseClientSafe();
                        if (supabase) {
                            const { error } = await supabase
                                .from('conversations')
                                .update({ customer_name: customerName })
                                .eq('customer_id', conversationId);
                            
                            if (error) {
                                console.warn('Error updating customer_name in Supabase:', error);
                            } else {
                                console.log(` Updated Supabase conversation ${conversationId} with customer name: ${customerName}`);
                            }
                        }
                    } catch (error) {
                        console.warn('Error updating Supabase conversation:', error);
                    }
                    
                    // Also update Firebase if available
                    if (isFirebaseChatAvailable()) {
                        try {
                            const conversationRef = firebase.database().ref(`conversations/${conversationId}`);
                            await conversationRef.update({
                                customerName: customerName,
                                updatedAt: Date.now()
                            });
                            console.log(`Updated Firebase conversation ${conversationId} with customer name: ${customerName}`);
                        } catch (error) {
                            console.warn('Error updating Firebase conversation:', error);
                        }
                    }
                } else {
                    console.warn(` Could not fetch valid customer name for ${conversationId}, got: ${customerName}`);
                    // Use conversation data as fallback, but still try to update
                    customerName = conversation.customerName || 'Customer';
                }
                
                console.log(`Processing conversation ${conversationId} for customer: ${customerName}`);
                
                // Use customer name as the key to prevent duplicates
                // If we already have this customer, keep the one with the most recent message
                if (!uniqueCustomers.has(customerName)) {
                    console.log(`Adding new customer: ${customerName} with conversation: ${conversationId}`);
                    uniqueCustomers.set(customerName, {
                        conversationId: conversationId,
                        conversation: conversation,
                        customerName: customerName
                    });
                } else {
                    const existing = uniqueCustomers.get(customerName);
                    const existingTime = existing.conversation.lastMessageTime || 0;
                    const currentTime = conversation.lastMessageTime || 0;
                    
                    console.log(`Duplicate customer found: ${customerName}`);
                    console.log(`Existing conversation ${existing.conversationId} time: ${existingTime}`);
                    console.log(`Current conversation ${conversationId} time: ${currentTime}`);
                    
                    // Keep the conversation with the most recent message
                    if (currentTime > existingTime) {
                        console.log(`Replacing with newer conversation: ${conversationId}`);
                        uniqueCustomers.set(customerName, {
                            conversationId: conversationId,
                            conversation: conversation,
                            customerName: customerName
                        });
                    } else {
                        console.log(`Keeping existing conversation: ${existing.conversationId}`);
                    }
                }
            }
            
            // Convert map to array and sort by last message time
            const uniqueConversations = Array.from(uniqueCustomers.values())
                .sort((a, b) => {
                    const timeA = a.conversation.lastMessageTime || 0;
                    const timeB = b.conversation.lastMessageTime || 0;
                    return timeB - timeA; // Most recent first
                });
            
            // Build conversation items in parallel and append once to render simultaneously
            const itemsData = await Promise.all(uniqueConversations.map(async ({ conversationId, conversation, customerName }) => {
                const [latestMessage, hasUnreadMessages] = await Promise.all([
                    getLatestMessageForConversation(conversationId),
                    checkConversationForUnreadMessages(conversationId)
                ]);
                let latestMessageText = latestMessage ? latestMessage.text : (conversation.lastMessage || 'No messages yet');
                const latestMessageTime = latestMessage ? latestMessage.timestamp : conversation.lastMessageTime;
                if (latestMessage && latestMessage.sender === 'staff') {
                    latestMessageText = `You: ${latestMessageText}`;
                }
                return { conversationId, customerName, latestMessageText, latestMessageTime, hasUnreadMessages };
            }));

            const fragment = document.createDocumentFragment();
            for (const item of itemsData) {
                // Check if this conversation item already exists in the DOM
                const existingItem = existingItemsMap.get(item.conversationId);
                
                if (existingItem) {
                    // Update existing item instead of creating a new one
                    
                    // CRITICAL: Check if conversation is already marked as read
                    // Even if hasUnreadMessages is true, don't apply styling if already read
                    const normalizedConvoId = normalizeConversationId(item.conversationId);
                    const isMarkedAsRead = window.readConversations && 
                        (window.readConversations.has(normalizedConvoId) || 
                         window.readConversations.has(item.conversationId));
                    
                    // Only apply unread styling if conversation has unread messages AND is not marked as read
                    const shouldBeUnread = item.hasUnreadMessages && !isMarkedAsRead;
                    
                    // Update unread styling
                    if (shouldBeUnread) {
                        existingItem.classList.add('unread');
                    } else {
                        existingItem.classList.remove('unread');
                    }
                    
                    // Update the content
                    const nameElement = existingItem.querySelector('.conversation-name');
                    const previewElement = existingItem.querySelector('.conversation-preview');
                    const timeElement = existingItem.querySelector('.conversation-time');
                    
                    if (nameElement) {
                        nameElement.textContent = item.customerName;
                        if (shouldBeUnread) {
                            nameElement.classList.add('unread');
                        } else {
                            nameElement.classList.remove('unread');
                        }
                    }
                    
                    if (previewElement) {
                        previewElement.textContent = item.latestMessageText;
                        if (shouldBeUnread) {
                            previewElement.classList.add('unread');
                        } else {
                            previewElement.classList.remove('unread');
                        }
                    }
                    
                    if (timeElement) {
                        // CRITICAL: Normalize timestamp before formatting to ensure accurate display
                        const normalizedTimestamp = normalizeTimestamp(item.latestMessageTime ?? item.id ?? Date.now(), item);
                        timeElement.textContent = formatTime(normalizedTimestamp);
                    }
                    
                    // Move existing item to top (will be handled by sorting below)
                    continue;
                }
                
                // Create new conversation item only if it doesn't exist
                const conversationItem = document.createElement('div');
                conversationItem.className = 'conversation-item';
                conversationItem.setAttribute('data-conversation-id', item.conversationId);
                conversationItem.onclick = () => selectConversation(item.conversationId);

                // CRITICAL: Check if conversation is already marked as read before applying styling
                const normalizedConvoIdNew = normalizeConversationId(item.conversationId);
                const isMarkedAsReadNew = window.readConversations && 
                    (window.readConversations.has(normalizedConvoIdNew) || 
                     window.readConversations.has(item.conversationId));
                
                // Only apply unread styling if conversation has unread messages AND is not marked as read
                const shouldBeUnreadNew = item.hasUnreadMessages && !isMarkedAsReadNew;
                const unreadClass = shouldBeUnreadNew ? 'unread' : '';
                if (shouldBeUnreadNew) {
                    conversationItem.classList.add('unread');
                }

                // Ensure customer name is not a fallback - fetch if needed
                let displayName = item.customerName;
                if (!displayName || displayName === 'Customer' || displayName.startsWith('Customer ')) {
                    // Fetch the real name asynchronously and update the UI
                    getCustomerName(item.conversationId).then(realName => {
                        if (realName && realName !== 'Customer' && !realName.startsWith('Customer ')) {
                            const nameElement = conversationItem.querySelector('.conversation-name');
                            if (nameElement) {
                                nameElement.textContent = realName;
                            }
                            // Update Supabase
                            const supabase = getSupabaseClientSafe();
                            if (supabase) {
                                supabase
                                    .from('conversations')
                                    .update({ customer_name: realName })
                                    .eq('customer_id', item.conversationId)
                                    .then(({ error }) => {
                                        if (error) {
                                            console.warn('Error updating customer_name:', error);
                                        }
                                    })
                                    .catch(err => console.warn('Error updating customer_name:', err));
                            }
                        } else {
                            // If we still don't have a good name, show a generic one instead of "Loading..."
                            const nameElement = conversationItem.querySelector('.conversation-name');
                            if (nameElement && nameElement.textContent === 'Loading...') {
                                nameElement.textContent = 'Customer';
                            }
                        }
                    }).catch(err => {
                        console.warn('Error fetching customer name:', err);
                        // If fetch fails, show generic name instead of "Loading..."
                        const nameElement = conversationItem.querySelector('.conversation-name');
                        if (nameElement && nameElement.textContent === 'Loading...') {
                            nameElement.textContent = 'Customer';
                        }
                    });
                    // Use a better placeholder that won't confuse users
                    displayName = item.customerName || 'Customer';
                }
                
                conversationItem.innerHTML = `
                    <div class="conversation-avatar">
                        <i class="fas fa-user"></i>
                    </div>
                    <div class="conversation-details" style="flex: 1 1 0%; min-width: 0; overflow: hidden; max-width: 164px; box-sizing: border-box; width: 100%;">
                        <div class="conversation-name ${unreadClass}" style="white-space: nowrap !important; overflow: hidden !important; text-overflow: ellipsis !important; width: 100%; max-width: 164px; display: block; min-width: 0;">${displayName}</div>
                        <div class="conversation-preview-container" style="display: flex; align-items: center; gap: 8px; min-width: 0; width: 100%;">
                            <div class="conversation-preview ${unreadClass}" style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex: 1; min-width: 0;">${item.latestMessageText}</div>
                            <div class="conversation-time" style="flex-shrink: 0; white-space: nowrap;">${getMessageDisplayTime(item, normalizeTimestamp(item.latestMessageTime ?? item.timestamp ?? item.id ?? Date.now(), item))}</div>
                        </div>
                    </div>
                    <div class="conversation-actions">
                    </div>
                `;

                // Ensure unread styling is applied immediately (only if conversation is not already read)
                if (shouldBeUnreadNew) {
                    const nameElement = conversationItem.querySelector('.conversation-name');
                    const previewElement = conversationItem.querySelector('.conversation-preview');
                    if (nameElement) { nameElement.classList.add('unread'); }
                    if (previewElement) { previewElement.classList.add('unread'); }
                }

                // Add right-click context menu
                conversationItem.addEventListener('contextmenu', (e) => {
                    showConversationContextMenu(item.conversationId, e);
                });

                fragment.appendChild(conversationItem);
            }
            
            // Append only new items
            if (fragment.hasChildNodes()) {
                conversationsList.appendChild(fragment);
            }
            
            // Reorder all items (existing and new) by latest message time
            const allItems = Array.from(conversationsList.querySelectorAll('.conversation-item[data-conversation-id]'));
            const itemsMap = new Map();
            allItems.forEach(item => {
                const id = item.getAttribute('data-conversation-id');
                if (id) {
                    const itemData = itemsData.find(d => d.conversationId === id);
                    itemsMap.set(id, { item: item, time: itemData ? itemData.latestMessageTime : 0 });
                }
            });
            
            // Sort by time (most recent first) and reorder DOM
            const sortedItems = Array.from(itemsMap.entries())
                .sort((a, b) => b[1].time - a[1].time);
            
            sortedItems.forEach(([id, { item }]) => {
                conversationsList.appendChild(item);
            });
            
            const newItemsCount = fragment.childNodes.length;
            const updatedItemsCount = itemsData.length - newItemsCount;
            if (updatedItemsCount > 0) {
                console.log(`Updated ${updatedItemsCount} existing conversation items and added ${newItemsCount} new items`);
            } else {
                console.log(`Added ${itemsData.length} conversation items to DOM in a single batch`);
            }

            // Re-apply active highlight to the currently selected conversation, if any
            if (selectedConversation) {
                const activeItem = document.querySelector(`.conversation-item[data-conversation-id="${selectedConversation}"]`);
                if (activeItem) {
                    activeItem.classList.add('active');
                }
            }
            
            console.log(`Total conversation items added: ${uniqueConversations.length}`);
            console.log('Conversation list update complete');
            
            // Final check of the conversations list
            const finalStyle = window.getComputedStyle(conversationsList);
            console.log('Final conversations list style:', {
                display: finalStyle.display,
                visibility: finalStyle.visibility,
                height: finalStyle.height,
                minHeight: finalStyle.minHeight,
                childElementCount: conversationsList.children.length
            });
            
            // If no conversations were added, add a test item to see if the issue is with visibility
            if (uniqueConversations.length === 0) {
                console.log('No conversations found, adding test item...');
                const testItem = document.createElement('div');
                testItem.className = 'conversation-item';
                testItem.innerHTML = `
                    <div class="conversation-avatar">
                        <i class="fas fa-user"></i>
                    </div>
                    <div class="conversation-details">
                        <div class="conversation-name">Test Customer</div>
                        <div class="conversation-preview">This is a test conversation</div>
                    </div>
                    <div class="conversation-actions">
                        <div class="conversation-time">now</div>
                    </div>
                `;
                conversationsList.appendChild(testItem);
                console.log('Test item added to conversations list');
                
                // Check if the test item is visible
                const testItemStyle = window.getComputedStyle(testItem);
                console.log('Test item style:', {
                    display: testItemStyle.display,
                    visibility: testItemStyle.visibility,
                    height: testItemStyle.height,
                    opacity: testItemStyle.opacity
                });
            }
            
            // Don't update badge count - only show for real-time customer messages
            } finally {
                isUpdatingConversationList = false;
            }
        }

        // Mark conversation as read and update UI
        async function markConversationAsRead(conversationId) {
            try {
                // CRITICAL: Add conversation to readConversations IMMEDIATELY at the start
                // This ensures any badge updates that happen during marking will skip this conversation
                const normalizedConvoId = normalizeConversationId(conversationId);
                if (!window.readConversations) {
                    window.readConversations = new Set();
                }
                window.readConversations.add(normalizedConvoId);
                console.log('Added conversation to readConversations (at start of marking):', normalizedConvoId);
                
                // Suppress rapid UI updates while we batch mark as read
                isMarkingAsRead = true;
                // Track that this conversation is being marked as read to prevent false badge updates
                if (!window.markingAsReadConversations) {
                    window.markingAsReadConversations = new Set();
                }
                window.markingAsReadConversations.add(conversationId);
                console.log('Tracking conversation as being marked as read:', conversationId);
                const nowTs = Date.now();
                let supabaseUpdated = false;
                try {
                    supabaseUpdated = await supabaseUpdateConversation(conversationId, {
                        unreadCount: 0,
                        updatedAt: nowTs
                    });
                } catch (error) {
                    console.warn('Supabase markConversationAsRead failed:', error);
                }
                
                // Mark messages as read in Firebase (fallback / for mobile sync)
                if (!supabaseUpdated && isFirebaseChatAvailable()) {
                    const messagesRef = firebase.database().ref('chatMessages');
                    const snapshot = await messagesRef
                        .orderByChild('conversationId')
                        .equalTo(conversationId)
                        .once('value');

                    if (snapshot.exists()) {
                        const updates = {};
                        snapshot.forEach((childSnapshot) => {
                            const message = childSnapshot.val();
                            // Mark all customer messages as read, including those with undefined isRead status
                            // This ensures old messages without isRead field are also marked as read
                            if (message.sender === 'customer' && message.isRead !== true) {
                                updates[`${childSnapshot.key}/isRead`] = true;
                            }
                        });

                        if (Object.keys(updates).length > 0) {
                            await messagesRef.update(updates);
                            console.log('Marked', Object.keys(updates).length, 'messages as read in Firebase for conversation:', conversationId);
                        }
                    }

                    // Update conversation metadata to reset unread count
                    const conversationRef = firebase.database().ref(`conversations/${conversationId}`);
                    await conversationRef.update({
                        unreadCount: 0,
                        updatedAt: nowTs
                    });
                }

                // Update UI to remove unread styling
                const conversationItem = document.querySelector(`[onclick="selectConversation('${conversationId}')"]`);
                if (conversationItem) {
                    conversationItem.classList.remove('unread');
                    const nameElement = conversationItem.querySelector('.conversation-name');
                    const previewElement = conversationItem.querySelector('.conversation-preview');
                    
                    if (nameElement) {
                        nameElement.classList.remove('unread');
                    }
                    if (previewElement) {
                        previewElement.classList.remove('unread');
                    }
                    
                    // Update the preview with the latest message from Firebase
                    await updateConversationPreviewFromFirebase(conversationId);
                }

                // Update local message data to mark all messages as read
                // This must happen BEFORE badge update to ensure badge reflects correct state
                // CRITICAL: Check all possible variations of the conversation ID to handle normalization issues
                const normalizedId = normalizeConversationId(conversationId);
                const allPossibleIds = [conversationId, normalizedId];
                
                // Also check all keys in chatMessages to find any matching conversation
                Object.keys(chatMessages).forEach(key => {
                    const normalizedKey = normalizeConversationId(key);
                    if (conversationIdsMatch(conversationId, key) || 
                        conversationIdsMatch(normalizedId, normalizedKey) ||
                        conversationIdsMatch(conversationId, normalizedKey) ||
                        conversationIdsMatch(normalizedId, key)) {
                        if (!allPossibleIds.includes(key) && !allPossibleIds.includes(normalizedKey)) {
                            allPossibleIds.push(key, normalizedKey);
                        }
                    }
                });
                
                // Mark messages as read in all variations
                allPossibleIds.forEach(id => {
                    if (chatMessages[id]) {
                        chatMessages[id].forEach(message => {
                            if (message.sender === 'customer') {
                                message.isRead = true; // Explicitly set to true
                            }
                        });
                        console.log('Marked all customer messages as read in local state for conversation:', id);
                    }
                });
                
                // CRITICAL: Also ensure conversation is in readConversations with ALL ID variations
                // This ensures badge count will skip this conversation regardless of which ID format is used
                if (!window.readConversations) {
                    window.readConversations = new Set();
                }
                // Add all possible ID variations to readConversations
                allPossibleIds.forEach(id => {
                    window.readConversations.add(id);
                    const normalizedVar = normalizeConversationId(id);
                    if (normalizedVar !== id) {
                        window.readConversations.add(normalizedVar);
                    }
                });
                // Also ensure normalized and original IDs are added
                window.readConversations.add(normalizedId);
                window.readConversations.add(conversationId);
                console.log('Added conversation to readConversations (all variations):', Array.from(allPossibleIds), normalizedId, conversationId);
                
                // Note: Conversation was already added to readConversations at the start of this function
                // This ensures badge updates during marking will skip this conversation

                // CRITICAL: Update badge count immediately - local state is already updated
                // This ensures badge disappears immediately when input is focused/clicked
                // Force update to bypass any delays or checks
                console.log('Updating badge count after marking conversation as read...');
                console.log('Conversation marked as read:', normalizedConvoId);
                console.log('readConversations now contains:', Array.from(window.readConversations));
                await updateBadgeCount(true); // Force update to ensure immediate badge refresh
                console.log('Badge count updated after marking conversation as read');
                
                // CRITICAL: Also update badge after a short delay to ensure it's correct
                // This handles any race conditions where messages might still be loading
                setTimeout(() => {
                    console.log('Second badge update after marking as read - ensuring accuracy');
                    updateBadgeCount(true);
                }, 200);
                
                // Don't update badge again after delay - this was causing the brief reappearance
                // The badge will be updated again when loadMessagesFromFirebase completes
                // and the merge preserves the isRead state

            } catch (error) {
                console.error('Error marking conversation as read:', error);
            } finally {
                // Re-enable rendering and do a single refresh of messages
                const convoId = conversationId;
                setTimeout(() => {
                    isMarkingAsRead = false;
                    // Remove from tracking set after a delay to allow merge to complete
                    // This prevents badge from briefly appearing when messages are loaded
                    if (window.markingAsReadConversations) {
                        setTimeout(() => {
                            window.markingAsReadConversations.delete(convoId);
                            console.log('Removed conversation from markingAsRead tracking:', convoId);
                        }, 300);
                    }
                    // Note: loadMessagesFromFirebase is now called from selectConversation after markConversationAsRead completes
                }, 100);
            }
        }

        // Mark individual message as read
        async function markMessageAsRead(messageId, conversationId) {
            try {
                if (isFirebaseChatAvailable()) {
                    const messagesRef = firebase.database().ref('chatMessages');
                    const snapshot = await messagesRef
                        .orderByChild('conversationId')
                        .equalTo(conversationId)
                        .once('value');

                    if (snapshot.exists()) {
                        snapshot.forEach((childSnapshot) => {
                            const message = childSnapshot.val();
                            // Only mark the specific message that was just received
                            // Mark messages that are not explicitly read (false or undefined)
                            if (message.sender === 'customer' && message.isRead !== true && 
                                (message.id === messageId || message.timestamp === messageId)) {
                                // Mark this specific message as read in Firebase
                                childSnapshot.ref.update({ isRead: true });
                                console.log('Marked specific message as read:', messageId);
                                
                                // Also update local message data - must happen before badge update
                                if (chatMessages[conversationId]) {
                                    chatMessages[conversationId].forEach(localMessage => {
                                        if (localMessage.id === messageId || localMessage.timestamp === messageId) {
                                            localMessage.isRead = true;
                                            console.log('Updated local message as read');
                                        }
                                    });
                                }
                                
                                // Update badge count immediately - local state is already updated
                                updateBadgeCount();
                                
                                // Also update badge again after Firebase update completes
                                setTimeout(() => {
                                    updateBadgeCount();
                                }, 500);
                            }
                        });
                    }
                }
            } catch (error) {
                console.error('Error marking message as read:', error);
            }
        }
        // Delete conversation function (HARD DELETE)
        // Permanently removes conversation metadata and all messages for this conversation ID.
        // Note: This will remove the thread and its history for all sides.
        async function deleteConversation(conversationId, event) {
            // Prevent event bubbling to avoid selecting conversation
            event.stopPropagation();
            
            // Get customer name for confirmation
            const customerName = await getCustomerName(conversationId);
            // Show confirmation dialog - clarify this is permanent
            const confirmed = confirm(`Permanently delete the conversation with ${customerName}?\n\nThis will remove all messages and conversation history for both staff and customer.`);
            
            if (confirmed) {
                try {
                    const deletionTimestamp = Date.now();
                    try {
                        await supabaseUpdateConversation(conversationId, {
                            deletedByStaff: true,
                            deletedByStaffAt: deletionTimestamp,
                            updatedAt: deletionTimestamp
                        });
                    } catch (error) {
                        console.warn('Supabase deleteConversation failed:', error);
                    }
                    
                    // STAFF-LOCAL delete: mark as deleted for staff and record purge timestamp, then return
                    if (isFirebaseChatAvailable()) {
                        const db = firebase.database();
                        const normalizedId = (typeof normalizeConversationId === 'function')
                            ? normalizeConversationId(conversationId)
                            : conversationId;
                        const targets = Array.from(new Set([conversationId, normalizedId])).filter(Boolean);
                        const staffUid = sessionStorage.getItem('staffUid');
                        // Mark conversations as deletedByStaff
                        for (const cid of targets) {
                            try {
                                const convRef = db.ref(`conversations/${cid}`);
                                const snap = await convRef.once('value');
                                if (snap.exists()) {
                                    await convRef.update({ deletedByStaff: true, deletedByStaffAt: deletionTimestamp, updatedAt: deletionTimestamp });
                                } else {
                                    const custName = await getCustomerName(cid);
                                    await convRef.set({
                                        customerId: cid,
                                        customerName: custName,
                                        deletedByStaff: true,
                                        deletedByStaffAt: deletionTimestamp,
                                        updatedAt: deletionTimestamp,
                                        lastMessage: '', lastMessageTime: deletionTimestamp, lastMessageSender: '', unreadCount: 0, archived: false
                                    });
                                }
                            } catch(_) {}
                        }
                        // Per-staff purge timestamp so old history is hidden for this staff
                        if (staffUid) {
                            const nowTs = deletionTimestamp;
                            const purge = {};
                            targets.forEach(cid => { purge[`staffDeletedBefore/${staffUid}/${cid}`] = nowTs; });
                            await db.ref().update(purge).catch(()=>{});
                            // Also remove staff-only message store so history is permanently gone for this staff
                            for (const cid of targets) {
                                try { await db.ref(`staffMessages/${staffUid}/${cid}`).remove(); } catch(_) {}
                            }
                        }
                    }
                    // Clear UI and refresh lists for staff
                    if (selectedConversation === conversationId) {
                        selectedConversation = null;
                        document.getElementById('customerName').textContent = 'Select a conversation';
                        document.getElementById('chatMessages').innerHTML = '';
                        document.getElementById('mainChatMessageInput').value = '';
                        document.querySelectorAll('.conversation-item').forEach(item => item.classList.remove('active'));
                    }
                    try {
                        if (typeof currentConversationTab !== 'undefined' && currentConversationTab === 'active') {
                            await loadActiveConversations();
                        } else if (typeof currentConversationTab !== 'undefined' && currentConversationTab === 'archived') {
                            await loadArchivedConversations();
                        }
                    } catch(_) {}
                    return; // Prevent any global/hard-delete logic from running
                } catch (error) {
                    console.error('Error deleting conversation:', error);
                }
            }
        }

        // Archive conversation function
        async function archiveConversation(conversationId) {
            try {
                const customerName = await getCustomerName(conversationId);
                const archiveTimestamp = Date.now();
                
                try {
                    await supabaseUpdateConversation(conversationId, {
                        archived: true,
                        archivedAt: archiveTimestamp,
                        updatedAt: archiveTimestamp
                    });
                } catch (error) {
                    console.warn('Supabase archiveConversation failed:', error);
                }
                
                // Update conversation metadata in Firebase
                if (isFirebaseChatAvailable()) {
                    const conversationRef = firebase.database().ref(`conversations/${conversationId}`);
                    const snap = await conversationRef.once('value');
                    const data = snap.val() || {};
                    if (data.archived === true) {
                        // Already archived: treat as success and avoid error state/idempotent
                        showNotification(`Conversation with ${customerName} archived`, 'success');
                    } else {
                        await conversationRef.update({
                            archived: true,
                            archivedAt: archiveTimestamp,
                            updatedAt: archiveTimestamp
                        });
                    }
                }
                
                // Remove from UI (archived conversations are hidden)
                const conversationItem = document.querySelector(`.conversation-item[data-conversation-id="${conversationId}"]`);
                if (conversationItem) {
                    conversationItem.remove();
                }
                
                // If this was the selected conversation, clear the chat
                if (selectedConversation === conversationId) {
                    selectedConversation = null;
                    document.getElementById('customerName').textContent = 'Select a conversation';
                    document.getElementById('chatMessages').innerHTML = '';
                    document.getElementById('mainChatMessageInput').value = '';
                    
                    // Clear active conversation
                    document.querySelectorAll('.conversation-item').forEach(item => {
                        item.classList.remove('active');
                    });
                }
                
                // Show success notification (already shown earlier for idempotent case too)
                showNotification(`Conversation with ${customerName} archived`, 'success');
                
                // Update badge count
                updateChatBadge();
                
                // Only refresh the appropriate tab based on current view
                if (currentConversationTab === 'active') {
                    // If viewing active tab, refresh only active conversations
                    loadActiveConversations();
                } else if (currentConversationTab === 'archived') {
                    // If viewing archived tab, refresh only archived conversations
                    loadArchivedConversations();
                }
                
            } catch (error) {
                console.error('Error archiving conversation:', error);
                showNotification('Error archiving conversation', 'error');
            }
        }
        // Unarchive conversation function
        async function unarchiveConversation(conversationId) {
            try {
                const customerName = await getCustomerName(conversationId);
                const unarchiveTimestamp = Date.now();
                
                try {
                    await supabaseUpdateConversation(conversationId, {
                        archived: false,
                        unarchivedAt: unarchiveTimestamp,
                        updatedAt: unarchiveTimestamp
                    });
                } catch (error) {
                    console.warn('Supabase unarchiveConversation failed:', error);
                }
                
                // Update conversation metadata in Firebase
                if (isFirebaseChatAvailable()) {
                    const conversationRef = firebase.database().ref(`conversations/${conversationId}`);
                    await conversationRef.update({
                        archived: false,
                        unarchivedAt: unarchiveTimestamp,
                        updatedAt: unarchiveTimestamp
                    });
                }
                
                // Remove from archived UI
                const conversationItem = document.querySelector(`[onclick="selectArchivedConversation('${conversationId}')"]`);
                if (conversationItem) {
                    conversationItem.remove();
                }
                
                // If this was the selected conversation, clear the chat
                if (selectedConversation === conversationId) {
                    selectedConversation = null;
                    document.getElementById('customerName').textContent = 'Select a conversation';
                    document.getElementById('chatMessages').innerHTML = '';
                    document.getElementById('mainChatMessageInput').value = '';
                    
                    // Clear active conversation
                    document.querySelectorAll('.conversation-item').forEach(item => {
                        item.classList.remove('active');
                    });
                }
                
                // Show success notification
                showNotification(`Conversation with ${customerName} unarchived and moved to active`, 'success');
                
                // Refresh the active conversations list to show the unarchived conversation
                loadActiveConversations();
                
            } catch (error) {
                console.error('Error unarchiving conversation:', error);
                showNotification('Error unarchiving conversation', 'error');
            }
        }
        // Show context menu for conversation
        function showConversationContextMenu(conversationId, event) {
            // Prevent default right-click menu
            event.preventDefault();
            event.stopPropagation();
            
            // Remove existing context menu
            const existingMenu = document.querySelector('.conversation-context-menu');
            if (existingMenu) {
                existingMenu.remove();
            }
            
            // Create context menu
            const contextMenu = document.createElement('div');
            contextMenu.className = 'conversation-context-menu';
            contextMenu.style.left = event.clientX + 'px';
            contextMenu.style.top = event.clientY + 'px';
            
            // Archive option
            const archiveOption = document.createElement('div');
            archiveOption.className = 'context-menu-item archive';
            archiveOption.innerHTML = '<i class="fas fa-archive"></i> Archive';
            archiveOption.onclick = () => {
                archiveConversation(conversationId);
                contextMenu.remove();
            };
            
            // Delete option
            const deleteOption = document.createElement('div');
            deleteOption.className = 'context-menu-item delete';
            deleteOption.innerHTML = '<i class="fas fa-trash"></i> Delete';
            deleteOption.onclick = () => {
                deleteConversation(conversationId, { stopPropagation: () => {} });
                contextMenu.remove();
            };
            
            contextMenu.appendChild(archiveOption);
            contextMenu.appendChild(deleteOption);
            document.body.appendChild(contextMenu);
            
            // Close menu when clicking outside
            const closeMenu = (e) => {
                if (!contextMenu.contains(e.target)) {
                    contextMenu.remove();
                    document.removeEventListener('click', closeMenu);
                }
            };
            
            setTimeout(() => {
                document.addEventListener('click', closeMenu);
            }, 100);
        }

        // Archive current conversation from chat view
        async function archiveCurrentConversation() {
            if (!selectedConversation) return;
            
            const customerName = await getCustomerName(selectedConversation);
            const confirmed = confirm(`Archive conversation with ${customerName}? You can restore it later from the Archived section.`);
            
            if (confirmed) {
                await archiveConversation(selectedConversation);
                
                // Clear the chat view
                selectedConversation = null;
                document.getElementById('customerName').textContent = 'Select a conversation';
                document.getElementById('chatMessages').innerHTML = `
                    <div class="chat-empty">
                        <i class="fas fa-comment-dots"></i>
                        <h4>Select a conversation</h4>
                        <p>Choose a conversation from the list to start chatting</p>
                    </div>
                `;
                document.getElementById('chatInputArea').classList.remove('active');
                document.getElementById('conversationActions').style.display = 'none';
                
                // Clear active conversation
                document.querySelectorAll('.conversation-item').forEach(item => {
                    item.classList.remove('active');
                });
                
                // Immediately refresh the active conversations to remove the archived one
                if (currentConversationTab === 'active') {
                    console.log('Refreshing active conversations after archiving');
                    loadActiveConversations();
                }
            }
        }
        // Unarchive current conversation from chat view
        async function unarchiveCurrentConversation() {
            if (!selectedConversation) return;
            
            const customerName = await getCustomerName(selectedConversation);
            const confirmed = confirm(`Unarchive conversation with ${customerName}? It will be moved back to Active conversations.`);
            
            if (confirmed) {
                try {
                    // Set flag to prevent Firebase listener interference
                    isUnarchiving = true;
                    const unarchiveTimestamp = Date.now();
                    
                    try {
                        await supabaseUpdateConversation(selectedConversation, {
                            archived: false,
                            unarchivedAt: unarchiveTimestamp,
                            updatedAt: unarchiveTimestamp
                        });
                    } catch (error) {
                        console.warn('Supabase unarchiveCurrentConversation failed:', error);
                    }
                    
                    if (isFirebaseChatAvailable()) {
                        const conversationRef = firebase.database().ref(`conversations/${selectedConversation}`);
                        await conversationRef.update({
                            archived: false,
                            unarchivedAt: unarchiveTimestamp,
                            updatedAt: unarchiveTimestamp
                        });
                    }
                    
                    // Show success notification
                    showNotification(`Conversation with ${customerName} unarchived and moved to active`, 'success');
                    
                    // Update badge count
                    updateChatBadge();
                    
                    // Clear the chat view immediately
                    selectedConversation = null;
                    document.getElementById('customerName').textContent = 'Select a conversation';
                    document.getElementById('chatMessages').innerHTML = `
                        <div class="chat-empty">
                            <i class="fas fa-comment-dots"></i>
                            <h4>Select a conversation</h4>
                            <p>Choose a conversation from the list to start chatting</p>
                        </div>
                    `;
                    document.getElementById('chatInputArea').classList.remove('active');
                    
                    // Always refresh both active and archived conversations after unarchiving
                    console.log('Refreshing both active and archived conversations after unarchiving');
                    
                    // Refresh active conversations to show the unarchived conversation
                    loadActiveConversations();
                    
                    // If currently viewing archived tab, also refresh archived conversations
                    if (currentConversationTab === 'archived') {
                        console.log('Currently viewing archived tab, also refreshing archived conversations');
                        // Force refresh the archived tab multiple times to ensure it shows only archived
                        loadArchivedConversations();
                        setTimeout(() => {
                            loadArchivedConversations();
                        }, 100);
                        setTimeout(() => {
                            loadArchivedConversations();
                        }, 300);
                    }
                    
                    // Re-enable Firebase listener after a delay
                    setTimeout(() => {
                        isUnarchiving = false;
                        console.log('Unarchive process complete, Firebase listener re-enabled');
                    }, 1000);
                    document.getElementById('conversationActions').style.display = 'none';
                    
                    // Clear active conversation
                    document.querySelectorAll('.conversation-item').forEach(item => {
                        item.classList.remove('active');
                    });
                    
                } catch (error) {
                    console.error('Error unarchiving conversation:', error);
                    showNotification('Error unarchiving conversation', 'error');
                }
            }
        }

        // Delete current conversation from chat view
        async function deleteCurrentConversation() {
            if (!selectedConversation) return;
            
            const customerName = await getCustomerName(selectedConversation);
            const confirmed = confirm(`Delete conversation with ${customerName}? This action cannot be undone.`);
            
            if (confirmed) {
                await deleteConversation(selectedConversation, { stopPropagation: () => {} });
                
                // Clear the chat view
                selectedConversation = null;
                document.getElementById('customerName').textContent = 'Select a conversation';
                document.getElementById('chatMessages').innerHTML = `
                    <div class="chat-empty">
                        <i class="fas fa-comment-dots"></i>
                        <h4>Select a conversation</h4>
                        <p>Choose a conversation from the list to start chatting</p>
                    </div>
                `;
                document.getElementById('chatInputArea').classList.remove('active');
                document.getElementById('conversationActions').style.display = 'none';
                
                // Clear active conversation
                document.querySelectorAll('.conversation-item').forEach(item => {
                    item.classList.remove('active');
                });
            }
        }

        // Global variable to track current tab
        let currentConversationTab = 'active';
        
        // Flag to prevent Firebase listener from interfering during unarchive
        let isUnarchiving = false;
        
        // Flag to prevent multiple simultaneous conversation list updates
        let isUpdatingConversationList = false;
        
        // Flag to prevent Firebase listener from interfering during initial load
        let isInitialLoad = true;
        
        // Flag to prevent Firebase listener from interfering during new message processing
        let isProcessingNewMessage = false;
        // Flag to suppress rapid UI updates while marking messages as read
        let isMarkingAsRead = false;

        // Switch between Active and Archived conversation tabs
        function switchConversationTab(tab) {
            console.log(' Switching conversation tab to:', tab);
            currentConversationTab = tab;
            
            // CRITICAL: Always reset UI when switching tabs
            // This ensures "Select a conversation" shows when opening chatbox normally
            // or switching to archived
            selectedConversation = null;
            document.getElementById('chatMessages').classList.remove('active');
            document.getElementById('chatInputArea').classList.remove('active');
            document.getElementById('customerName').textContent = 'Select a conversation';
            document.getElementById('conversationActions').style.display = 'none';
            
            // Clear active conversation styling
            document.querySelectorAll('.conversation-item').forEach(item => {
                item.classList.remove('active');
            });
            
            console.log(' Reset chat UI - showing "Select a conversation"');
            
            // CRITICAL: Immediately clear the conversations list to prevent showing wrong conversations
            const conversationsList = document.getElementById('conversationsList');
            if (conversationsList) {
                conversationsList.innerHTML = '';
                console.log(' Cleared conversations list');
            }
            
            // Update tab buttons
            document.querySelectorAll('.chatbox-tab').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(tab + 'Tab').classList.add('active');
            
            // Add a small delay to ensure DOM is cleared before loading new conversations
            setTimeout(() => {
                // Load appropriate conversations based on tab
                if (tab === 'active') {
                    console.log(' Loading active conversations...');
                    loadActiveConversations();
                } else {
                    console.log(' Loading archived conversations...');
                    loadArchivedConversations();
                }
            }, 10);
        }
        // Expose to global so other scripts can invoke reliably
        if (typeof window !== 'undefined') { window.switchConversationTab = switchConversationTab; }
        // Load active conversations
        async function loadActiveConversations() {
            console.log('Loading active conversations...');
            try {
                const supabaseConversations = await supabaseFetchConversationsMap({
                    archived: false,
                    excludeDeleted: true
                });
                if (supabaseConversations) {
                    const filtered = {};
                    Object.keys(supabaseConversations).forEach((conversationId) => {
                        const conversation = supabaseConversations[conversationId];
                        const chatType = (conversation?.chatType || 'staff').toLowerCase();
                        if (chatType === 'rider') {
                            return;
                        }
                        filtered[conversationId] = conversation;
                    });
                    
                    const conversationsList = document.getElementById('conversationsList');
                    if (conversationsList) {
                        conversationsList.innerHTML = '';
                    }
                    
                    await updateConversationList(filtered);
                    try { isInitialLoad = false; } catch(_) {}
                    setTimeout(() => {
                        if (!isInitialLoad && typeof updateBadgeCount === 'function') {
                            updateBadgeCount(true);
                        }
                    }, 500);
                    return;
                }
            } catch (error) {
                console.warn('Supabase loadActiveConversations failed, falling back to Firebase:', error);
            }
            
            return new Promise((resolve, reject) => {
                if (isFirebaseChatAvailable()) {
                    console.log('Firebase is available, fetching conversations...');
                    const conversationsRef = firebase.database().ref('conversations');
                    conversationsRef.once('value', async (snapshot) => {
                    const conversations = snapshot.val() || {};
                    const activeConversations = {};
                    
                    console.log('All conversations:', Object.keys(conversations));
                    console.log('Conversations data:', conversations);
                    
                    // Filter out archived conversations, conversations deleted by staff, and rider conversations (strict check)
                    Object.keys(conversations).forEach(conversationId => {
                        const conversation = conversations[conversationId];
                        const chatType = conversation.chatType || 'staff'; // Default to 'staff' for backward compatibility
                        
                        console.log(`Conversation ${conversationId}:`, {
                            chatType: chatType,
                            archived: conversation.archived,
                            deletedByStaff: conversation.deletedByStaff,
                            lastMessage: conversation.lastMessage,
                            lastMessageTime: conversation.lastMessageTime,
                            unreadCount: conversation.unreadCount
                        });
                        
                        // CRITICAL: Exclude rider-customer conversations from staff view
                        // Staff should only see staff-customer conversations (chatType === 'staff' or undefined/null)
                        if (chatType === 'rider') {
                            console.log(`Skipped ${conversationId} - it's a rider conversation (chatType: ${chatType})`);
                            return; // Skip this conversation
                        }
                        
                        // Also check if conversation ID format indicates it's a rider conversation (customerId_rider_riderId)
                        if (conversationId.includes('_rider_')) {
                            console.log(`Skipped ${conversationId} - conversation ID indicates it's a rider conversation`);
                            return; // Skip this conversation
                        }
                        
                        // Only include conversations that are NOT archived AND NOT deleted by staff AND NOT rider conversations
                        if (conversation.archived !== true && conversation.deletedByStaff !== true) {
                            activeConversations[conversationId] = conversation;
                            console.log(`Added ${conversationId} to active conversations`);
                        } else {
                            if (conversation.archived === true) {
                                console.log(`Skipped ${conversationId} - it's archived`);
                            }
                            if (conversation.deletedByStaff === true) {
                                console.log(`Skipped ${conversationId} - it's deleted by staff`);
                            }
                        }
                    });
                    
                    console.log('Active conversations found:', Object.keys(activeConversations));
                    
                    // Clear the conversations list first to prevent duplicates
                    const conversationsList = document.getElementById('conversationsList');
                    if (conversationsList) {
                        console.log('Clearing conversations list...');
                        conversationsList.innerHTML = '';
                    } else {
                        console.error('Conversations list element not found!');
                    }
                    
                    console.log('Updating conversation list with:', Object.keys(activeConversations));
                    
                    // If no active conversations metadata, fallback: derive from chatMessages AND customerMessages
                    if (Object.keys(activeConversations).length === 0) {
                        console.log('No active conversations metadata. Falling back to chatMessages and customerMessages to derive list...');
                        try {
                            const [msgSnap, custSnap] = await Promise.all([
                                firebase.database().ref('chatMessages').once('value').catch(() => null),
                                firebase.database().ref('customerMessages').once('value').catch(() => null)
                            ]);
                            
                            const msgs = (msgSnap && msgSnap.val()) || {};
                            const custMsgs = (custSnap && custSnap.val()) || {};
                            const derived = {};
                            
                            // Process messages from chatMessages
                            Object.keys(msgs).forEach(function(mid){
                                const m = msgs[mid];
                                if (!m || !m.conversationId) return;
                                
                                // CRITICAL: Filter out rider-customer conversations
                                const cid = String(m.conversationId);
                                const isRiderConversation = (m.chatType === 'rider') || cid.includes('_rider_');
                                if (isRiderConversation) {
                                    console.log('Skipping rider conversation message:', mid, 'conversationId:', cid, 'chatType:', m.chatType);
                                    return; // Skip this message
                                }
                                
                                const prev = derived[cid] || { 
                                    lastMessageTime: 0, 
                                    lastMessage: '', 
                                    lastMessageSender: '',
                                    archived: false,
                                    customerId: cid,
                                    customerName: m.customerName || null
                                };
                                if ((m.timestamp||0) >= (prev.lastMessageTime||0)) {
                                    prev.lastMessageTime = m.timestamp || Date.now();
                                    prev.lastMessage = m.text || '';
                                    prev.lastMessageSender = m.sender || '';
                                    if (m.customerName && !prev.customerName) {
                                        prev.customerName = m.customerName;
                                    }
                                }
                                derived[cid] = prev;
                            });
                            
                            // Process messages from customerMessages/{conversationId}
                            Object.keys(custMsgs).forEach(function(cid){
                                // CRITICAL: Skip if conversation ID indicates it's a rider conversation
                                if (cid.includes('_rider_')) {
                                    console.log('Skipping rider conversation in customerMessages:', cid);
                                    return; // Skip this conversation
                                }
                                
                                const convMsgs = custMsgs[cid] || {};
                                Object.keys(convMsgs).forEach(function(mid){
                                    const m = convMsgs[mid];
                                    if (!m || !m.conversationId) return;
                                    
                                    // CRITICAL: Filter out rider-customer conversations
                                    const conversationId = String(m.conversationId || cid);
                                    const isRiderConversation = (m.chatType === 'rider') || conversationId.includes('_rider_');
                                    if (isRiderConversation) {
                                        console.log('Skipping rider conversation message:', mid, 'conversationId:', conversationId, 'chatType:', m.chatType);
                                        return; // Skip this message
                                    }
                                    
                                    const prev = derived[conversationId] || { 
                                        lastMessageTime: 0, 
                                        lastMessage: '', 
                                        lastMessageSender: '',
                                        archived: false,
                                        customerId: conversationId,
                                        customerName: m.customerName || null
                                    };
                                    if ((m.timestamp||0) >= (prev.lastMessageTime||0)) {
                                        prev.lastMessageTime = m.timestamp || Date.now();
                                        prev.lastMessage = m.text || '';
                                        prev.lastMessageSender = m.sender || '';
                                        if (m.customerName && !prev.customerName) {
                                            prev.customerName = m.customerName;
                                        }
                                    }
                                    derived[conversationId] = prev;
                                });
                            });
                            
                            if (Object.keys(derived).length === 0) {
                                console.log('No messages found to derive conversations');
                                const listEl = document.getElementById('conversationsList');
                                if (listEl) listEl.innerHTML = '<div class="no-conversations">No active conversations</div>';
                                try { isInitialLoad = false; } catch(_) {}
                                resolve();
                                return;
                            }
                            
                            // Create conversation metadata in Firebase for derived conversations
                            // But first check if conversations are marked as deletedByStaff
                            const db = firebase.database();
                            const conversationUpdates = {};
                            const filteredDerived = {};
                            
                            // Check each derived conversation before creating/updating metadata
                            for (const [cid, conv] of Object.entries(derived)) {
                                try {
                                    // Check if conversation already exists or is tombstoned
                                    const convRef = db.ref(`conversations/${cid}`);
                                    const convSnap = await convRef.once('value');
                                    const tombstoneSnap = await db.ref(`deletedConversations/${cid}`).once('value').catch(()=>null);
                                    const isTombstoned = tombstoneSnap && tombstoneSnap.exists();
                                    
                                    if (isTombstoned) {
                                        console.log(`Skipping ${cid} - tombstoned (hard-deleted previously)`);
                                        continue;
                                    } else if (convSnap.exists()) {
                                        const convData = convSnap.val();
                                        // If marked as deleted by staff, skip it from staff view
                                        if (convData.deletedByStaff === true) {
                                            console.log(`Skipping ${cid} - marked as deleted by staff`);
                                            continue;
                                        }
                                        // Update existing conversation (preserve deletedByStaff flag if it exists)
                                        conversationUpdates[`conversations/${cid}`] = {
                                            ...convData, // Preserve existing data
                                            customerId: conv.customerId || cid,
                                            customerName: conv.customerName || convData.customerName || null,
                                            lastMessage: conv.lastMessage,
                                            lastMessageTime: conv.lastMessageTime,
                                            lastMessageSender: conv.lastMessageSender,
                                            updatedAt: Date.now()
                                        };
                                    } else {
                                        // Create new conversation metadata (not deleted)
                                        conversationUpdates[`conversations/${cid}`] = {
                                            customerId: conv.customerId || cid,
                                            customerName: conv.customerName || null,
                                            lastMessage: conv.lastMessage,
                                            lastMessageTime: conv.lastMessageTime,
                                            lastMessageSender: conv.lastMessageSender,
                                            unreadCount: 0,
                                            updatedAt: Date.now(),
                                            archived: false
                                        };
                                    }
                                    
                                    // Only add to filteredDerived if not deleted by staff
                                    filteredDerived[cid] = conv;
                                } catch (err) {
                                    console.warn(`Error checking conversation ${cid}:`, err);
                                    // On error, still add it (better to show than hide)
                                    filteredDerived[cid] = conv;
                                }
                            }
                            
                            if (Object.keys(conversationUpdates).length > 0) {
                                await db.ref().update(conversationUpdates).catch(err => {
                                    console.warn('Error creating conversation metadata:', err);
                                });
                            }
                            
                            console.log('Derived conversations from messages (filtered):', Object.keys(filteredDerived));
                            updateConversationList(filteredDerived).then(() => {
                                try { isInitialLoad = false; } catch(_) {}
                                // CRITICAL: Update badge after initial load is complete
                                // This ensures unread messages from previous sessions are shown
                                setTimeout(() => {
                                    if (!isInitialLoad) {
                                        console.log('Initial load complete (fallback) - updating badge count to show unread messages');
                                        updateBadgeCount(true); // Force update to ensure badge shows unread messages
                                    }
                                }, 500); // Longer delay to ensure all Firebase data is loaded
                                resolve();
                            }).catch((e)=>{ 
                                console.warn('Fallback updateConversationList error', e); 
                                try { isInitialLoad = false; } catch(_) {}
                                // Still try to update badge even on error
                                setTimeout(() => {
                                    if (!isInitialLoad) {
                                        updateBadgeCount(true);
                                    }
                                }, 500);
                                resolve(); 
                            });
                        } catch (e) {
                            console.warn('Fallback derive conversations failed', e);
                        const conversationsList = document.getElementById('conversationsList');
                        if (conversationsList) {
                            conversationsList.innerHTML = '<div class="no-conversations">No active conversations</div>';
                        }
                            try { isInitialLoad = false; } catch(_) {}
                        resolve();
                        }
                        return;
                    }
                    
                    console.log('Calling updateConversationList with active conversations...');
                    updateConversationList(activeConversations).then(() => {
                        console.log('Conversation list updated successfully');
                        try { isInitialLoad = false; } catch(_) {}
                        // CRITICAL: Update badge after initial load is complete
                        // This ensures unread messages from previous sessions are shown
                        // Use a longer delay to ensure Firebase data is fully loaded
                        setTimeout(() => {
                            if (!isInitialLoad) {
                                console.log('Initial load complete - updating badge count to show unread messages from previous sessions');
                                updateBadgeCount(true); // Force update to ensure badge shows unread messages
                            }
                        }, 500); // Longer delay to ensure all Firebase data is loaded
                        resolve();
                    }).catch((error) => {
                        console.error('Error updating conversation list:', error);
                        try { isInitialLoad = false; } catch(_) {}
                        // Still try to update badge even on error
                        setTimeout(() => {
                            if (!isInitialLoad) {
                                updateBadgeCount(true);
                            }
                        }, 500);
                        resolve();
                    });
                    }); // Close the once('value') async callback
                } else {
                    const conversationsList = document.getElementById('conversationsList');
                    if (conversationsList) {
                        conversationsList.innerHTML = '<div class="no-conversations">No active conversations</div>';
                    }
                    try { isInitialLoad = false; } catch(_) {}
                    resolve();
                }
            });
        }
        if (typeof window !== 'undefined') { window.loadActiveConversations = loadActiveConversations; }

        // Load archived conversations
        async function loadArchivedConversations() {
            console.log(' Loading archived conversations...');
            
            // Immediately clear the conversation list to prevent showing active chats
            const conversationsList = document.getElementById('conversationsList');
            if (conversationsList) {
                conversationsList.innerHTML = '<div class="chat-loading">Loading archived conversations...</div>';
            }
            
            try {
                const supabaseConversations = await supabaseFetchConversationsMap({
                    archived: true,
                    excludeDeleted: false
                });
                if (supabaseConversations) {
                    if (conversationsList) {
                        conversationsList.innerHTML = '';
                    }
                    updateArchivedConversationList(supabaseConversations);
                    return;
                }
            } catch (error) {
                console.warn('Supabase loadArchivedConversations failed, falling back to Firebase:', error);
            }
            
            if (isFirebaseChatAvailable()) {
                const conversationsRef = firebase.database().ref('conversations');
                conversationsRef.once('value', (snapshot) => {
                    const conversations = snapshot.val() || {};
                    const archivedConversations = {};
                    
                    console.log(' Total conversations in database:', Object.keys(conversations).length);
                    console.log('All conversation IDs:', Object.keys(conversations));
                    
                    // Filter ONLY archived conversations (strict check)
                    let activeCount = 0;
                    let archivedCount = 0;
                    
                    Object.keys(conversations).forEach(conversationId => {
                        const conversation = conversations[conversationId];
                        const isArchived = conversation.archived === true;
                        
                        console.log(`   ${conversationId}: archived=${isArchived}`);
                        
                        // Only include conversations that are EXPLICITLY archived
                        if (isArchived) {
                            archivedConversations[conversationId] = conversation;
                            archivedCount++;
                            console.log(`    ADDED archived: ${conversationId}`);
                        } else {
                            activeCount++;
                            console.log(`    SKIPPED active: ${conversationId}`);
                        }
                    });
                    
                    console.log(` Results: ${archivedCount} archived, ${activeCount} active`);
                    console.log(' Archived conversations to show:', Object.keys(archivedConversations));
                    
                    // Clear the list again before displaying archived conversations
                    if (conversationsList) {
                        conversationsList.innerHTML = '';
                    }
                    
                    // ONLY pass archived conversations to update function
                    updateArchivedConversationList(archivedConversations);
                });
            } else {
                if (conversationsList) {
                    conversationsList.innerHTML = '<div class="chat-empty"><i class="fas fa-archive"></i><h4>No archived conversations</h4><p>Archived conversations will appear here</p></div>';
            }
        }
        }
        if (typeof window !== 'undefined') { window.loadArchivedConversations = loadArchivedConversations; }

        // Update archived conversation list in UI
        async function updateArchivedConversationList(conversations) {
            const conversationsList = document.getElementById('conversationsList');
            if (!conversationsList) return;
            
            // CRITICAL: Immediately clear the list to prevent showing active conversations
            conversationsList.innerHTML = '';
            
            // Double-check that we're only showing archived conversations
            const conversationIds = Object.keys(conversations);
            const verifiedArchivedConversations = {};
            
            console.log(' Verifying archived conversations, starting with', conversationIds.length, 'conversations');
            
            // Filter again to ensure ONLY archived conversations
            let verifiedCount = 0;
            let rejectedCount = 0;
            
            conversationIds.forEach(conversationId => {
                const conversation = conversations[conversationId];
                const isArchived = conversation && conversation.archived === true;
                
                console.log(`   Checking ${conversationId}: archived=${isArchived}`);
                
                // STRICT CHECK: Only include conversations that are EXPLICITLY archived
                if (isArchived) {
                    verifiedArchivedConversations[conversationId] = conversation;
                    verifiedCount++;
                    console.log(`    KEEPING archived: ${conversationId}`);
                } else {
                    rejectedCount++;
                    console.log(`    REJECTING active: ${conversationId}`);
                }
            });
            
            const verifiedConversationIds = Object.keys(verifiedArchivedConversations);
            console.log(` Verification complete: ${verifiedCount} archived, ${rejectedCount} active rejected`);
            console.log(' Final archived conversations to display:', verifiedConversationIds);
            
            if (verifiedConversationIds.length === 0) {
                conversationsList.innerHTML = `
                    <div class="chat-empty">
                        <i class="fas fa-archive"></i>
                        <h4>No archived conversations</h4>
                        <p>Archived conversations will appear here</p>
                    </div>
                `;
                return;
            }
            
            // Track unique customers to prevent duplicates
            const uniqueCustomers = new Map();
            
            for (const conversationId of verifiedConversationIds) {
                const conversation = verifiedArchivedConversations[conversationId];
                const customerName = await getCustomerName(conversationId);
                
                // Use customer name as the key to prevent duplicates
                if (!uniqueCustomers.has(customerName) || 
                    (conversation.lastMessageTime && 
                     uniqueCustomers.get(customerName).lastMessageTime < conversation.lastMessageTime)) {
                    uniqueCustomers.set(customerName, {
                        conversationId: conversationId,
                        conversation: conversation,
                        customerName: customerName
                    });
                }
            }
            
            // Convert map to array and sort by last message time
            const uniqueConversations = Array.from(uniqueCustomers.values())
                .sort((a, b) => {
                    const timeA = a.conversation.lastMessageTime || 0;
                    const timeB = b.conversation.lastMessageTime || 0;
                    return timeB - timeA; // Most recent first
                });
            
            // Create conversation items for unique customers only
            for (const { conversationId, conversation, customerName } of uniqueConversations) {
                // FINAL CHECK: Verify this conversation is archived before adding to DOM
                if (!conversation || conversation.archived !== true) {
                    console.error(` CRITICAL: Attempted to add non-archived conversation to archived list: ${conversationId}`);
                    continue; // Skip this conversation
                }
                
                console.log(` Creating DOM element for archived conversation: ${conversationId}`);
                
                // Get the latest message for this conversation (from either staff or customer)
                const latestMessage = await getLatestMessageForConversation(conversationId);
                let latestMessageText = latestMessage ? latestMessage.text : (conversation.lastMessage || 'No messages yet');
                const latestMessageTime = latestMessage ? latestMessage.timestamp : conversation.lastMessageTime;
                
                // Format preview based on sender
                if (latestMessage && latestMessage.sender === 'staff') {
                    latestMessageText = `You: ${latestMessageText}`;
                }
                
                const conversationItem = document.createElement('div');
                conversationItem.className = 'conversation-item archived';
                conversationItem.onclick = () => selectArchivedConversation(conversationId);
                
                conversationItem.innerHTML = `
                    <div class="conversation-avatar">
                        <i class="fas fa-user"></i>
                    </div>
                    <div class="conversation-details" style="flex: 1 1 0%; min-width: 0; overflow: hidden; max-width: 164px; box-sizing: border-box; width: 100%;">
                        <div class="conversation-name" style="white-space: nowrap !important; overflow: hidden !important; text-overflow: ellipsis !important; width: 100%; max-width: 164px; display: block; min-width: 0;">${customerName}</div>
                        <div class="conversation-preview-container" style="display: flex; align-items: center; gap: 8px; min-width: 0; width: 100%;">
                            <div class="conversation-preview" style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex: 1; min-width: 0;">${latestMessageText}</div>
                            <div class="conversation-time" style="flex-shrink: 0; white-space: nowrap;">${getMessageDisplayTime(latestMessage || conversation, normalizeTimestamp(latestMessageTime ?? conversation.lastMessageTime ?? Date.now(), latestMessage || conversation))}</div>
                        </div>
                    </div>
                    <div class="conversation-actions">
                    </div>
                `;
                
                conversationsList.appendChild(conversationItem);
                console.log(`    Added to DOM: ${conversationId}`);
            }
            
            console.log(` Finished rendering archived conversations. Total in DOM: ${conversationsList.children.length}`);
        }

        // Select archived conversation
        async function selectArchivedConversation(conversationId) {
            console.log(' Selecting archived conversation:', conversationId);
            
            // VERIFY that this conversation is actually archived
            if (isFirebaseChatAvailable()) {
                const conversationRef = firebase.database().ref(`conversations/${conversationId}`);
                const snapshot = await conversationRef.once('value');
                const conversation = snapshot.val();
                
                if (!conversation || conversation.archived !== true) {
                    console.error(' Attempted to select non-archived conversation as archived:', conversationId);
                    alert('This conversation is not archived. Please refresh and try again.');
                    return;
                }
                
                console.log(' Verified archived conversation:', conversationId);
            }
            
            selectedConversation = conversationId;
            
            // Clear any existing messages first
            const messagesContainer = document.getElementById('chatMessages');
            if (messagesContainer) {
                messagesContainer.innerHTML = '';
            }
            
            // Update active conversation
            document.querySelectorAll('.conversation-item').forEach(item => {
                item.classList.remove('active');
            });
            event.target.closest('.conversation-item').classList.add('active');
            
            // Update customer name in right panel header
            const customerName = event.target.closest('.conversation-item').querySelector('.conversation-name').textContent;
            document.getElementById('customerName').textContent = customerName;
            
            // Show chat messages and input
            document.getElementById('chatMessages').classList.add('active');
            document.getElementById('chatInputArea').classList.add('active');
            
            // Show conversation action buttons
            document.getElementById('conversationActions').style.display = 'flex';
            
            // Show unarchive button for archived conversations
            document.getElementById('archiveBtn').style.display = 'none';
            document.getElementById('unarchiveBtn').style.display = 'inline-flex';
            
            // Load messages from Firebase
            loadMessagesFromFirebase(conversationId);
        }
        // Restore archived conversation
        async function restoreConversation(conversationId, event) {
            console.log('Restore conversation called for:', conversationId);
            event.stopPropagation();
            
            const customerName = await getCustomerName(conversationId);
            console.log('Customer name:', customerName);
            const confirmed = confirm(`Restore conversation with ${customerName}? It will be moved back to Active conversations.`);
            
            if (confirmed) {
                console.log('User confirmed restore');
                try {
                    // Set flag to prevent Firebase listener interference
                    isUnarchiving = true;
                    
                    if (isFirebaseChatAvailable()) {
                        console.log('Updating Firebase conversation:', conversationId);
                        const conversationRef = firebase.database().ref(`conversations/${conversationId}`);
                        await conversationRef.update({
                            archived: false,
                            restoredAt: Date.now(),
                            updatedAt: Date.now()
                        });
                        console.log('Firebase conversation updated successfully');
                    } else {
                        console.error('Firebase not available');
                    }
                    
                    // Remove from archived list
                    console.log('Removing conversation from archived list');
                    const conversationItem = document.querySelector(`[onclick="selectArchivedConversation('${conversationId}')"]`);
                    if (conversationItem) {
                        console.log('Found conversation item, removing it');
                        conversationItem.remove();
                    } else {
                        console.log('Conversation item not found in archived list');
                    }
                    
                    // If this was the selected conversation, clear the chat
                    if (selectedConversation === conversationId) {
                        selectedConversation = null;
                        document.getElementById('customerName').textContent = 'Select a conversation';
                        document.getElementById('chatMessages').innerHTML = `
                            <div class="chat-empty">
                                <i class="fas fa-comment-dots"></i>
                                <h4>Select a conversation</h4>
                                <p>Choose a conversation from the list to start chatting</p>
                            </div>
                        `;
                        document.getElementById('chatInputArea').classList.remove('active');
                        document.getElementById('conversationActions').style.display = 'none';
                    }
                    
                    // Show success notification
                    console.log('Showing success notification');
                    showNotification(`Conversation with ${customerName} restored`, 'success');
                    
                    // Update badge count
                    console.log('Updating chat badge');
                    updateChatBadge();
                    
                    // Immediately clear the archived UI to prevent any reflection
                    if (currentConversationTab === 'archived') {
                        console.log('Currently viewing archived tab, clearing UI immediately');
                        const conversationsList = document.getElementById('conversationsList');
                        if (conversationsList) {
                            // Clear everything immediately to prevent reflection
                            conversationsList.innerHTML = '<div class="chat-empty"><i class="fas fa-spinner fa-spin"></i><h4>Refreshing...</h4></div>';
                        }
                    }
                    
                    // Refresh archived conversations first to prevent reflection
                    console.log('Loading archived conversations');
                    loadArchivedConversations();
                    
                    // If currently viewing archived tab, force multiple refreshes
                    if (currentConversationTab === 'archived') {
                        console.log('Currently viewing archived tab, forcing multiple refreshes');
                        // Force refresh the archived tab multiple times
                        setTimeout(() => {
                            loadArchivedConversations();
                        }, 50);
                        setTimeout(() => {
                            loadArchivedConversations();
                        }, 150);
                        setTimeout(() => {
                            loadArchivedConversations();
                        }, 300);
                    }
                    
                    // Add a longer delay before refreshing active conversations and re-enabling listener
                    setTimeout(() => {
                        console.log('Loading active conversations');
                        if (!window.__chatLocks || !window.__chatLocks.activePanelLocked) {
                        loadActiveConversations();
                        } else {
                            console.debug('[chat-lock] Suppressed loadActiveConversations during active chat');
                        }
                        // Keep the flag active longer to prevent any Firebase listener interference
                        setTimeout(() => {
                            isUnarchiving = false;
                            console.log('Restore process complete, Firebase listener re-enabled');
                        }, 1000);
                    }, 500);
                    
                } catch (error) {
                    console.error('Error restoring conversation:', error);
                    showNotification('Error restoring conversation', 'error');
                }
            }
        }
        // Format timestamp for display
        // CRITICAL: Ensures accurate time display by properly handling milliseconds timestamps
        function formatTime(timestamp) {
            if (!timestamp && timestamp !== 0) {
                console.warn(' formatTime: Empty timestamp');
                return '';
            }
            
            const normalized = normalizeTimestamp(timestamp);
            if (!normalized || normalized <= 0) {
                console.warn(' formatTime: Invalid normalized timestamp:', normalized, 'from original:', timestamp);
                return '';
            }
            
            const date = new Date(normalized);
            if (isNaN(date.getTime())) {
                console.warn(' formatTime: Invalid date from timestamp:', timestamp, 'normalized:', normalized);
                return '';
            }
            
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const month = months[date.getMonth()];
            const day = date.getDate();
            const year = date.getFullYear();
            
            const hours = date.getHours();
            const minutes = date.getMinutes();
            const ampm = hours >= 12 ? 'PM' : 'AM';
            const displayHours = hours % 12 || 12;
            const displayMinutes = minutes.toString().padStart(2, '0');
            const timeString = `${displayHours}:${displayMinutes} ${ampm}`;
            
            return `${month} ${day}, ${year}  ${timeString}`;
        }

        function formatDateOnly(timestamp) {
            if (!timestamp && timestamp !== 0) return '';
            const date = new Date(timestamp);
            if (isNaN(date.getTime())) return '';
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const month = months[date.getMonth()];
            const day = date.getDate();
            const year = date.getFullYear();
            return `${month} ${day}, ${year}`;
        }

        function getMessageDisplayTime(message, normalizedTimestamp) {
            let timestampForDisplay = normalizedTimestamp;
            if (!timestampForDisplay || !isFinite(timestampForDisplay) || timestampForDisplay <= 0) {
                timestampForDisplay = Date.now();
            }
            const tsDate = new Date(timestampForDisplay);
            const nowDate = new Date();
            const isToday = tsDate.toDateString() === nowDate.toDateString();
            if (message && typeof message === 'object') {
                const source = message.__timestampSource || message.__timestampSourceFallback;
                const rawStrings = [
                    message.timestampFormatted,
                    message.createdAtFormatted,
                    message.sentAt,
                    message.displayTime,
                    message.formattedTime,
                    message.time
                ];
                for (const candidate of rawStrings) {
                    if (typeof candidate !== 'string') continue;
                    const trimmed = candidate.trim();
                    if (!trimmed) continue;
                    if (hasDateIndicators(trimmed)) {
                        // Respect today formatting: show time only if today, date+time otherwise
                        return formatTime(timestampForDisplay);
                    }
                    if (TIME_ONLY_REGEX.test(trimmed)) {
                        if (isToday) {
                            return trimmed;
                        } else {
                            const dateOnly = formatDateOnly(timestampForDisplay);
                            if (dateOnly) {
                                return `${dateOnly}, ${trimmed}`;
                            }
                            return trimmed;
                        }
                    }
                }

                if (source === 'context_string_time_combined' && typeof message.time === 'string' && message.time.trim()) {
                    const onlyTime = message.time.trim();
                    if (isToday) {
                        return onlyTime;
                    } else {
                        const dateOnly = formatDateOnly(timestampForDisplay);
                        if (dateOnly) {
                            return `${dateOnly}, ${onlyTime}`;
                        }
                        return onlyTime;
                    }
                }
            }
            return formatTime(timestampForDisplay);
        }

        // Format date header for message grouping
        function formatDateHeader(timestamp) {
            if (!timestamp) return '';
            const date = new Date(timestamp);
            const now = new Date();
            
            // Check if the message is from today
            const isToday = date.toDateString() === now.toDateString();
            
            if (isToday) {
                return 'Today';
            } else {
                // Check if the message is from yesterday
                const yesterday = new Date(now);
                yesterday.setDate(yesterday.getDate() - 1);
                const isYesterday = date.toDateString() === yesterday.toDateString();
                
                if (isYesterday) {
                    return 'Yesterday';
                } else {
                    // Show full date for older messages (e.g., "November 3, 2025")
                    return date.toLocaleDateString([], {
                        month: 'long',
                        day: 'numeric',
                        year: 'numeric'
                    });
                }
            }
        }

        // Open chat with specific customer
        async function openChatWithCustomer(customerId, customerName) {
            // CRITICAL: Prepare EVERYTHING before opening chatbox
            // This ensures smooth transition without any empty state
            
            // CRITICAL: Disable transitions on all conversation items to prevent hover animation
            // This ensures smooth, instant switch between conversations without visible transitions
            document.querySelectorAll('.conversation-item').forEach(item => {
                item.classList.add('no-transition');
            });
            
            // Get actual customer name if not provided
            if (!customerName || customerName === 'Customer') {
                customerName = await getCustomerName(customerId);
            }
            
            // Initialize messages array for this customer if it doesn't exist
            const normalizedId = normalizeConversationId(customerId);
            if (!chatMessages[normalizedId]) {
                chatMessages[normalizedId] = [];
            }
            
            // CRITICAL: Set selectedConversation BEFORE doing anything else
            selectedConversation = normalizedId;
            
            // CRITICAL: Load messages from Firebase FIRST before opening chatbox
            // This ensures messages are ready to display immediately
            console.log(' Pre-loading messages for customer:', customerId);
            
            // Check if we have local messages already
            let messages = chatMessages[normalizedId];
            
            // If no local messages or very few, load from Firebase
            if (!messages || messages.length === 0) {
                if (isFirebaseChatAvailable()) {
                    try {
                        const messagesRef = firebase.database().ref('chatMessages');
                        const snapshot = await messagesRef
                            .orderByChild('conversationId')
                            .equalTo(customerId)
                            .once('value');
                        
                        const messagesData = snapshot.val() || {};
                        const messagesArray = [];
                        
                        Object.keys(messagesData).forEach(messageId => {
                            const msg = messagesData[messageId];
                            if (msg && typeof msg === 'object') {
                                messagesArray.push({
                                    id: messageId,
                                    text: msg.message || msg.text || '',
                                    sender: msg.sender || 'customer',
                                    timestamp: msg.timestamp || msg.createdAt || Date.now(),
                                    isRead: msg.isRead !== false,
                                    conversationId: msg.conversationId || msg.customerId || customerId,
                                    imageUrl: msg.imageUrl || null,
                                    videoUrl: msg.videoUrl || null
                                });
                            }
                        });
                        
                        // Store in local cache
                        chatMessages[normalizedId] = messagesArray;
                        messages = messagesArray;
                        console.log(' Pre-loaded', messages.length, 'messages from Firebase');
                    } catch (error) {
                        console.error('Error pre-loading messages:', error);
                        messages = [];
                    }
                } else {
                    messages = [];
                }
            }
            
            // CRITICAL: Render messages into container BEFORE opening chatbox
            const chatMessagesContainer = document.getElementById('chatMessages');
            if (chatMessagesContainer && messages) {
                chatMessagesContainer.innerHTML = '';
                chatMessagesContainer.classList.add('active');
                
                // Render messages immediately
                await renderMessages(messages, chatMessagesContainer);
                console.log(' Messages pre-rendered into container');
            }
            
            // Set customer name
            const customerNameElement = document.getElementById('customerName');
            if (customerNameElement) {
                customerNameElement.textContent = customerName;
            }
            
            // Show input area
            const inputArea = document.getElementById('chatInputArea');
            if (inputArea) {
                inputArea.classList.add('active');
            }
            
            // Show conversation actions
            const actions = document.getElementById('conversationActions');
            if (actions) {
                actions.style.display = 'flex';
            }
            
            // NOW open the chatbox - messages are already rendered!
            // Pass skipInit=true to prevent resetting to "Select a conversation"
            openChatBox(true);
            
            // Scroll to bottom after a brief moment
            setTimeout(() => {
                if (chatMessagesContainer) {
                    chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
                }
            }, 50);
            
            // Update conversation list in background
            await selectConversationWithCustomer(customerId, customerName);
        }
        // Select or create conversation with specific customer
        async function selectConversationWithCustomer(customerId, customerName) {
            // Get actual customer name if not provided
            if (!customerName || customerName === 'Customer') {
                customerName = await getCustomerName(customerId);
            }
                
            // Initialize empty messages array for this customer if it doesn't exist
                if (!chatMessages[customerId]) {
                    chatMessages[customerId] = [];
                }
                
            // Check if conversation already exists in Firebase
                const conversationsList = document.getElementById('conversationsList');
            let conversationItem = null;
            
            // First, check if conversation item exists in UI by customerId
                if (conversationsList) {
                conversationItem = conversationsList.querySelector(`[data-conversation-id="${customerId}"]`);
            }
                    
            // If no conversation item in UI, check by customer name
                    if (!conversationItem) {
                conversationItem = findExistingConversationByCustomerName(customerName);
            }
            
            // If conversation item doesn't exist in UI, create it
            if (!conversationItem && conversationsList) {
                        conversationItem = document.createElement('div');
                conversationItem.setAttribute('data-conversation-id', customerId);
                conversationItem.className = 'conversation-item';
                        conversationItem.onclick = () => selectConversation(customerId);
                        
                        conversationItem.innerHTML = `
                            <div class="conversation-avatar">
                                <i class="fas fa-user"></i>
                            </div>
                            <div class="conversation-details" style="flex: 1 1 0%; min-width: 0; overflow: hidden; max-width: 164px; box-sizing: border-box; width: 100%;">
                                <div class="conversation-name" style="white-space: nowrap !important; overflow: hidden !important; text-overflow: ellipsis !important; width: 100%; max-width: 164px; display: block; min-width: 0;">${customerName}</div>
                                <div class="conversation-preview-container" style="display: flex; align-items: center; gap: 8px; min-width: 0; width: 100%;">
                                    <div class="conversation-preview" style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex: 1; min-width: 0;">Start a conversation</div>
                                    <div class="conversation-time" style="flex-shrink: 0; white-space: nowrap;">now</div>
                                </div>
                            </div>
                            <div class="conversation-actions">
                            </div>
                        `;
                        
                        // Add right-click context menu
                        conversationItem.addEventListener('contextmenu', (e) => {
                            showConversationContextMenu(customerId, e);
                        });
                        
                        conversationsList.appendChild(conversationItem);
            }
                
                // Update conversation metadata in Firebase with proper customer name
                if (isFirebaseChatAvailable()) {
                    const conversationRef = firebase.database().ref(`conversations/${customerId}`);
                    
                    // Check if conversation already exists
                    const snapshot = await conversationRef.once('value');
                    if (!snapshot.exists()) {
                        const conversationData = {
                            customerId: customerId,
                            customerName: customerName,
                            lastMessage: '',
                            lastMessageTime: Date.now(),
                            lastMessageSender: '',
                            unreadCount: 0,
                        updatedAt: Date.now(),
                        archived: false
                        };
                        
                    await conversationRef.set(conversationData);
                } else {
                    // Update customer name if it changed
                    const existingData = snapshot.val();
                    if (existingData.customerName !== customerName) {
                        await conversationRef.update({
                            customerName: customerName,
                            updatedAt: Date.now()
                        });
                    }
                }
            }
            
            // Always call selectConversation to properly display the conversation and customer name
            // This ensures the conversation is immediately visible and the customer name appears at the top
            await selectConversation(customerId);
            
            // Ensure customer name is set in the header immediately (in case selectConversation didn't set it)
            const customerNameElement = document.getElementById('customerName');
            if (customerNameElement) {
                customerNameElement.textContent = customerName;
            }
        }

        // Close chatbox when clicking overlay
        const chatboxOverlay = document.getElementById('chatboxOverlay');
        if (chatboxOverlay) {
            chatboxOverlay.addEventListener('click', function(e) {
                if (e.target === this) {
                    closeChatBox();
                }
            });
        }

        // Notification Management Functions
        function initializeNotifications() {
            const savedNotifications = localStorage.getItem('notifications') || 'enabled';
            const notificationBtn = document.querySelector('.compact-btn[data-action="notifications"]');
            
            if (notificationBtn) {
                notificationBtn.dataset.status = savedNotifications;
                updateNotificationButton(notificationBtn);
            }
        }

        function toggleNotifications() {
            const btn = document.querySelector('.compact-btn[data-action="notifications"]');
            const currentStatus = btn.dataset.status || 'enabled';
            const newStatus = currentStatus === 'enabled' ? 'disabled' : 'enabled';
            
            btn.dataset.status = newStatus;
            localStorage.setItem('notifications', newStatus);
            updateNotificationButton(btn);
            
            // Show feedback
            showNotification(`Notifications ${newStatus === 'enabled' ? 'enabled' : 'disabled'}`, 'success');
        }

        function updateNotificationButton(btn) {
            if (!btn) return; // Safety check
            
            const status = btn.dataset.status;
            const icon = btn.querySelector('i');
            
            if (!icon) return; // Safety check - prevent null reference error
            
            if (status === 'enabled') {
                icon.className = 'fas fa-bell';
                btn.title = 'Disable Notifications';
            } else {
                icon.className = 'fas fa-bell-slash';
                btn.title = 'Enable Notifications';
            }
        }

        // Data Export Functions
        function exportUserData() {
            try {
                const userData = {
                    profile: {
                        name: document.getElementById('profileStaffName')?.textContent || 'Staff Member',
                        email: document.getElementById('profileStaffEmail')?.textContent || 'staff@example.com',
                        role: 'Staff'
                    },
                    settings: {
                        theme: localStorage.getItem('theme') || 'light',
                        notifications: localStorage.getItem('notifications') || 'enabled',
                        language: localStorage.getItem('language') || 'en'
                    },
                    exportDate: new Date().toISOString()
                };

                const dataStr = JSON.stringify(userData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = `staff-data-export-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                
                showNotification('Data exported successfully!', 'success');
            } catch (error) {
                console.error('Export error:', error);
                showNotification('Failed to export data', 'error');
            }
        }

        // Cache Clearing Functions
        function clearApplicationCache() {
            try {
                // Clear localStorage (except essential settings, but reset theme)
                const notifications = localStorage.getItem('notifications');
                const language = localStorage.getItem('language');
                
                localStorage.clear();
                
                // Restore essential settings (but reset theme to light)
                localStorage.setItem('theme', 'light');
                if (notifications) localStorage.setItem('notifications', notifications);
                if (language) localStorage.setItem('language', language);
                
                // Clear session storage
                sessionStorage.clear();
                
                // Clear any cached data in memory
                if (window.staffManager && typeof window.staffManager.clearCache === 'function') {
                    window.staffManager.clearCache();
                }
                
                showNotification('Cache cleared successfully!', 'success');
                
                // Reload the page to ensure clean state
                setTimeout(() => {
                    window.location.reload();
                }, 1500);
                
            } catch (error) {
                console.error('Cache clearing error:', error);
                showNotification('Failed to clear cache', 'error');
            }
        }

        // Notification System
        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.innerHTML = `
                <div class="notification-content">
                    <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle'}"></i>
                    <span>${message}</span>
                </div>
            `;
            
            // Add styles if not already added
            if (!document.querySelector('#notification-styles')) {
                const style = document.createElement('style');
                style.id = 'notification-styles';
                style.textContent = `
                    .notification {
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: white;
                        border: 1px solid #e2e8f0;
                        border-radius: 8px;
                        padding: 12px 16px;
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                        z-index: 10000;
                        transform: translateX(100%);
                        transition: transform 0.3s ease;
                        max-width: 300px;
                    }
                    .notification.show {
                        transform: translateX(0);
                    }
                    .notification-success {
                        border-left: 4px solid #10b981;
                    }
                    .notification-error {
                        border-left: 4px solid #ef4444;
                    }
                    .notification-info {
                        border-left: 4px solid #3b82f6;
                    }
                    .notification-content {
                        display: flex;
                        align-items: center;
                        gap: 8px;
                    }
                    .notification-content i {
                        color: #10b981;
                    }
                    .notification-error .notification-content i {
                        color: #ef4444;
                    }
                    .notification-info .notification-content i {
                        color: #3b82f6;
                    }
                    .dark-theme .notification {
                        background: #2d2d2d;
                        border-color: #404040;
                        color: white;
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.body.appendChild(notification);
            
            // Show notification
            setTimeout(() => notification.classList.add('show'), 100);
            
            // Hide notification after 3 seconds
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        async function showProfileSection() {
            closeDropdown();
            if (window.staffManager) {
                await window.staffManager.showProfileSection();
            }
        }

        function showSettingsSection() {
            closeDropdown();
            if (window.staffManager) {
                window.staffManager.switchSection('staff-settings');
            }
        }

        function logoutStaff() {
            closeDropdown();
            if (window.staffManager) {
                window.staffManager.logout();
            }
        }
        // Function to close dropdown
        function closeDropdown() {
            const dropdown = document.getElementById('profileDropdownMenu');
            const profileSection = document.getElementById('staffProfileBtn');
            
            if (dropdown) {
                dropdown.classList.remove('show', 'force-visible', 'test-visible');
                dropdown.style.opacity = '0';
                dropdown.style.visibility = 'hidden';
                dropdown.style.transform = 'translateY(-10px)';
                dropdown.style.pointerEvents = 'none';
            }
            if (profileSection) {
                profileSection.classList.remove('active');
            }
        }

        // Function to ensure dropdown is always clickable
        function ensureDropdownClickable() {
            const dropdown = document.getElementById('profileDropdownMenu');
            if (dropdown && dropdown.classList.contains('show')) {
                dropdown.style.pointerEvents = 'auto';
                dropdown.style.cursor = 'pointer';
                
                const dropdownItems = dropdown.querySelectorAll('.dropdown-item');
                dropdownItems.forEach(item => {
                    item.style.pointerEvents = 'auto';
                    item.style.cursor = 'pointer';
                    
                    // Add click event listener to ensure items are clickable
                    item.addEventListener('click', function(e) {
                        e.stopPropagation();
                    });
                });
            }
        }
        // Function to reset dropdown state completely
        function resetDropdownState() {
            const dropdown = document.getElementById('profileDropdownMenu');
            const profileSection = document.getElementById('staffProfileBtn');
            
            if (dropdown) {
                dropdown.classList.remove('show', 'force-visible', 'test-visible');
                dropdown.style.opacity = '0';
                dropdown.style.visibility = 'hidden';
                dropdown.style.transform = 'translateY(-10px)';
                dropdown.style.pointerEvents = 'none';
            }
            if (profileSection) {
                profileSection.classList.remove('active');
            }
        }



        // Mock auth manager for staff dashboard
        const authManager = {
            currentUser: null,
            currentUserRole: 'staff'
        };
        
            // Initialize staff dashboard on load
            document.addEventListener('DOMContentLoaded', async function() {
                // Initialize chat badge on page load - keep hidden and clean
                const badge = document.getElementById('chatBadge');
                if (badge) {
                    console.log('Badge found on DOMContentLoaded - initializing as hidden');
                    // Ensure badge is completely hidden and clean on page load
                    badge.classList.add('hidden');
                    badge.classList.remove('showing');
                    badge.textContent = '';
                    badge.style.display = 'none';
                    badge.style.visibility = 'hidden';
                    badge.style.opacity = '0';
                    console.log('Badge initialized as hidden - will only show after initial load completes and unread messages are confirmed');
                } else {
                    console.error('Badge not found on DOMContentLoaded');
                }
                
                // Initialize theme and settings
                initializeTheme();
                initializeNotifications();
                
                // Initialize system health monitoring (after Supabase is ready)
                setTimeout(() => {
                    if (window.staffManager && typeof window.staffManager.setupSystemHealthMonitoring === 'function') {
                        window.staffManager.setupSystemHealthMonitoring();
                        console.log(' System health monitoring initialized');
                    }
                }, 2000); // Wait 2 seconds for Supabase to be ready
                
                // Initialize Firebase chat
                initializeFirebaseChat();
                
                // Load active conversations after Firebase is initialized
                setTimeout(() => {
                    console.log('Loading active conversations after Firebase initialization...');
                    loadActiveConversations().then(() => {
                        console.log('Active conversations loaded successfully');
                        
                        // CRITICAL: Fix corrupted unread message data automatically on page load
                        // This fixes conversations where last message is from staff but customer messages are still unread
                        setTimeout(() => {
                            // Auto-fix disabled - only run manually if needed
                            // console.log(' Auto-fixing corrupted unread message data...');
                            // fixCorruptedUnreadData();
                        }, 1500);
                        
                        // CRITICAL: Force isInitialLoad to false and update badge immediately
                        // This ensures badge shows existing unread messages from before page load
                        console.log('Forcing isInitialLoad to false and updating badge...');
                        isInitialLoad = false;
                        
                        // Force badge update with multiple attempts to ensure it shows
                        updateBadgeCount(true); // Immediate update
                        
                        setTimeout(() => {
                            console.log('Second badge update attempt after load');
                            updateBadgeCount(true);
                        }, 300);
                        
                        setTimeout(() => {
                            console.log('Final badge update attempt after load');
                            updateBadgeCount(true);
                        }, 800);
                        
                        // Refresh customer names to ensure accuracy
                        setTimeout(() => {
                            refreshCustomerNames();
                        }, 2000);
                        
                        // Set up periodic refresh of customer names every 30 seconds
                        setInterval(() => {
                            refreshCustomerNames();
                        }, 30000);
                    }).catch((error) => {
                        console.error('Error loading active conversations:', error);
                    });
                }, 1000);
                
                // Get user info from URL parameters or session storage
                const urlParams = new URLSearchParams(window.location.search);
                const userId = urlParams.get('uid') || sessionStorage.getItem('staffUid') || sessionStorage.getItem('adminUid');
                const userRole = urlParams.get('role') || sessionStorage.getItem('userRole') || sessionStorage.getItem('adminRole');
                
                if (!userId || (userRole !== 'staff' && userRole !== 'admin')) {
                    // Redirect back to login if no valid staff or admin session
                    window.location.href = 'index.html';
                    return;
                }
                
                // Store session info - ensure role is properly set
                sessionStorage.setItem('staffUid', userId);
                sessionStorage.setItem('userRole', userRole);
                // Also store in adminRole if it's an admin
                if (userRole === 'admin') {
                    sessionStorage.setItem('adminRole', 'admin');
                    sessionStorage.setItem('adminUid', userId);
                    // Also store adminName if available
                    const adminName = urlParams.get('username') || sessionStorage.getItem('adminName') || sessionStorage.getItem('username');
                    if (adminName) {
                        sessionStorage.setItem('adminName', adminName);
                    }
                } else {
                    sessionStorage.setItem('staffName', urlParams.get('username') || sessionStorage.getItem('staffName') || sessionStorage.getItem('username'));
                }
                
                // Fetch staff data from database to get the actual name
                let staffName = 'Staff Member';
                let staffEmail = urlParams.get('email') || sessionStorage.getItem('userEmail');
                
                try {
                    // Load staff data from Supabase
                    if (typeof window.getSupabaseClient !== 'function') {
                        throw new Error('Supabase client not initialized');
                    }
                    const supabase = window.getSupabaseClient();
                    if (supabase) {
                        const { data: staffData, error: staffError } = await supabase
                            .from('staff')
                            .select('*')
                            .eq('uuid', userId)
                            .limit(1)
                            .maybeSingle();
                        
                        if (!staffError && staffData) {
                            staffName = staffData.full_name || staffData.fullName || staffData.name || 'Staff Member';
                            staffEmail = staffData.email || staffEmail;
                            
                            // Update session storage with the actual staff data
                            sessionStorage.setItem('staffName', staffName);
                            sessionStorage.setItem('userEmail', staffEmail);
                            sessionStorage.setItem('username', staffName);
                        } else if (staffError) {
                            // Only log if it's not a "not found" error (PGRST116)
                            // "Not found" is expected if staff member doesn't exist in database
                            if (staffError.code !== 'PGRST116') {
                                console.error('Error fetching staff data from Supabase:', staffError);
                            } else {
                                // Staff not found - use fallback data (this is fine)
                                console.debug('Staff not found in database, using URL parameters');
                            }
                        }
                    }
                } catch (error) {
                    // Only log actual errors, not expected cases (like network timeouts or not found)
                    if (error.message && !error.message.includes('not found') && !error.message.includes('PGRST116')) {
                        console.error('Error fetching staff data:', error);
                    }
                    // Fallback to URL parameters or session storage
                    staffName = urlParams.get('username') || sessionStorage.getItem('username') || 'Staff Member';
                }
                
                // Set up mock auth manager
                authManager.currentUser = {
                    uid: userId,
                    email: staffEmail,
                    displayName: staffName
                };
                
                // Set up user display - check if admin or staff
                const displayName = userRole === 'admin' ? (sessionStorage.getItem('adminName') || staffName) : staffName;
                const displayRole = userRole === 'admin' ? 'admin' : 'Staff';
                
                document.getElementById('dropdownStaffName').textContent = displayName;
                document.getElementById('dropdownStaffRole').textContent = displayRole;
                
                // Initialize staff manager
                // Wait for staffManager to be available (it's created at end of staff.js)
                const initStaffManager = () => {
                    if (window.staffManager) {
                        console.log('Staff manager found, initializing...');
                        // Show loading screen before initialization
                        if (window.staffManager.showLoadingScreen) {
                            window.staffManager.showLoadingScreen('Initializing dashboard...');
                        }
                        window.staffManager.initialize().then(() => {
                            console.log('Staff manager initialized and dashboard data loaded');
                            
                            // Loading screen is already hidden by staffManager.initialize() after data loads
                            // Just ensure it's hidden as a safety measure
                            const loadingScreen = document.getElementById('loadingScreen');
                            if (loadingScreen) {
                                loadingScreen.classList.add('hidden');
                                document.body.classList.remove('loading');
                            }
                            
                            // Update staff name after staff manager is initialized
                            setTimeout(() => {
                                console.log('Updating user name after initialization...');
                                const currentUserRole = sessionStorage.getItem('userRole') || 'staff';
                                const displayName = currentUserRole === 'admin' ? (sessionStorage.getItem('adminName') || staffName) : staffName;
                                const displayRole = currentUserRole === 'admin' ? 'admin' : 'Staff';
                                
                                const nameEl = document.getElementById('dropdownStaffName');
                                const roleEl = document.getElementById('dropdownStaffRole');
                                if (nameEl) nameEl.textContent = displayName;
                                if (roleEl) roleEl.textContent = displayRole;
                                console.log('User name updated to:', displayName, 'with role:', displayRole);
                            }, 100);
                            
                            // Dashboard data is already loaded by initialize(), no need to load again
                            
                            // Test direct event listener setup
                            setTimeout(() => {
                                console.log('Setting up direct event listeners...');
                                document.querySelectorAll('.menu-item').forEach((item, index) => {
                                    console.log(`Direct setup for item ${index}:`, item.dataset.section);
                                    item.onclick = function(e) {
                                        e.preventDefault();
                                        console.log('Direct click handler triggered for:', this.dataset.section);
                                        if (window.staffManager) {
                                            window.staffManager.switchSection(this.dataset.section);
                                        }
                                    };
                                });
                            }, 500);
                        }).catch(err => {
                            console.error('Error initializing staff manager:', err);
                            // Ensure loading screen is hidden even on error
                            const loadingScreen = document.getElementById('loadingScreen');
                            if (loadingScreen) {
                                loadingScreen.classList.add('hidden');
                                document.body.classList.remove('loading');
                            }
                        });
                    } else {
                        // Retry after a short delay if not ready yet (max 2 seconds)
                        const retryCount = (initStaffManager._retryCount || 0) + 1;
                        initStaffManager._retryCount = retryCount;
                        if (retryCount < 40) { // 40 * 50ms = 2 seconds max
                            setTimeout(initStaffManager, 50);
                        } else {
                            console.error('Staff manager not found after 2 seconds!');
                            // Hide loading screen as fallback
                            const loadingScreen = document.getElementById('loadingScreen');
                            if (loadingScreen) {
                                loadingScreen.classList.add('hidden');
                                document.body.classList.remove('loading');
                            }
                        }
                    }
                };
                
                // Start initialization attempt
                initStaffManager();
                
                // Global timeout fallback - ensure loading screen is always hidden after max 10 seconds
                setTimeout(() => {
                    const loadingScreen = document.getElementById('loadingScreen');
                    if (loadingScreen && !loadingScreen.classList.contains('hidden')) {
                        console.warn(' Force hiding loading screen after timeout');
                        loadingScreen.classList.add('hidden');
                        document.body.classList.remove('loading');
                    }
                }, 10000); // 10 second maximum wait
                
                // Logout functionality is now handled through the profile dropdown
        });
        
        // Section loading message mapping
        const sectionLoadingMessages = {
            'staff-overview': 'Dashboard loading....',
            'product-listing': 'Product Listing loading....',
            'order-management': 'Order Management loading....',
            'assign-orders': 'Assign Orders loading....',
            'user-management': 'Farmer Record loading....',
            'reports-analytics': 'Sales and Reports loading....',
            'delivery-settings': 'Delivery Settings loading....',
            'staff-profile': 'Profile loading....'
        };

        // Sub-tab loading message mapping
        const subTabLoadingMessages = {
            'farmer-users': 'Farmer Record loading....',
            'customer-users': 'Customer Record loading....',
            'staff-users': 'Staff Record loading....',
            'rider-users': 'Rider Record loading....',
            'confirmed': 'Confirmed Orders loading....',
            'processing': 'Processing Orders loading....',
            'shipped': 'Shipped Orders loading....',
            'delivered': 'Delivered Orders loading....',
            'failed': 'Failed Orders loading....'
        };

        // Function to check if error is network-related
        function isNetworkError(error) {
            if (!error) return false;
            
            const errorMessage = String(error.message || error).toLowerCase();
            const errorCode = error.code || error.status || error.statusCode;
            
            // Check for common network error indicators
            const networkErrorPatterns = [
                'network error',
                'failed to fetch',
                'network request failed',
                'internet connection',
                'no internet',
                'offline',
                'timeout',
                'connection refused',
                'connection reset',
                'connection closed',
                'econnrefused',
                'enotfound',
                'etimedout',
                'econnreset'
            ];
            
            // Check error message
            if (networkErrorPatterns.some(pattern => errorMessage.includes(pattern))) {
                return true;
            }
            
            // Check for fetch API network errors
            if (error instanceof TypeError && errorMessage.includes('fetch')) {
                return true;
            }
            
            // Check for HTTP status codes that indicate network issues
            if (errorCode === 0 || errorCode === 408 || errorCode === 504 || errorCode === 503) {
                return true;
            }
            
            // Check if navigator.onLine is false
            if (typeof navigator !== 'undefined' && navigator.onLine === false) {
                return true;
            }
            
            return false;
        }

        // Function to show loading message for a section
        function showSectionLoading(sectionId, customMessage = null) {
            // Remove any existing loading messages in this section
            const contentSection = document.getElementById(sectionId);
            if (!contentSection) return;
            
            const existingLoading = contentSection.querySelector('.section-loading-message');
            if (existingLoading) existingLoading.remove();
            
            // Hide all section content while loading (hide all direct children except loading messages)
            Array.from(contentSection.children).forEach(child => {
                if (!child.classList.contains('section-loading-message')) {
                    child.style.opacity = '0';
                    child.style.visibility = 'hidden';
                    child.style.pointerEvents = 'none';
                }
            });
            
            const loadingMessage = customMessage || sectionLoadingMessages[sectionId] || 'Loading....';
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'section-loading-message';
            loadingDiv.id = `loading-${sectionId}`;
            loadingDiv.innerHTML = `<i class="fas fa-spinner"></i><span>${loadingMessage}</span>`;
            contentSection.appendChild(loadingDiv);
            
            // Store start time for minimum display duration
            loadingDiv.dataset.startTime = Date.now().toString();
        }

        // Function to show network error message
        function showNetworkError(sectionId) {
            const contentSection = document.getElementById(sectionId);
            if (!contentSection) return;
            
            // Remove any existing loading messages
            const existingLoading = contentSection.querySelector('.section-loading-message');
            if (existingLoading) existingLoading.remove();
            
            const errorDiv = document.createElement('div');
            errorDiv.className = 'section-loading-message error';
            errorDiv.id = `loading-${sectionId}`;
            errorDiv.innerHTML = `<i class="fas fa-exclamation-triangle"></i><span>Web is unavailable. Please check your internet connection and try again. Thank you</span>`;
            contentSection.appendChild(errorDiv);
        }

        // Function to hide loading message for a section
        function hideSectionLoading(sectionId) {
            const contentSection = document.getElementById(sectionId);
            if (!contentSection) return;
            
            const loadingDiv = contentSection.querySelector('.section-loading-message');
            if (loadingDiv) {
                // Calculate elapsed time
                const startTime = parseInt(loadingDiv.dataset.startTime || '0');
                const elapsed = Date.now() - startTime;
                const minDisplayTime = 2000; // 2 seconds minimum
                const remainingTime = Math.max(0, minDisplayTime - elapsed);
                
                // Wait for minimum display time, then hide and show content
                setTimeout(() => {
                    loadingDiv.classList.add('hidden');
                    setTimeout(() => {
                        loadingDiv.remove();
                        
                        // Show all section content after loading is removed
                        Array.from(contentSection.children).forEach(child => {
                            if (!child.classList.contains('section-loading-message')) {
                                child.style.opacity = '1';
                                child.style.visibility = 'visible';
                                child.style.pointerEvents = 'auto';
                                child.style.transition = 'opacity 0.3s ease';
                            }
                        });
                    }, 300);
                }, remainingTime);
            }
        }

        // Function to show loading message for a sub-tab
        function showSubTabLoading(sectionId, subTabId) {
            const contentSection = document.getElementById(sectionId);
            if (!contentSection) return;
            
            const loadingMessage = subTabLoadingMessages[subTabId] || 'Loading....';
            showSectionLoading(sectionId, loadingMessage);
        }

        // Expose functions globally for use in staff.js
        window.showSectionLoading = showSectionLoading;
        window.hideSectionLoading = hideSectionLoading;
        window.showSubTabLoading = showSubTabLoading;
        window.showNetworkError = showNetworkError;
        window.isNetworkError = isNetworkError;

        // Retry configuration for extremely slow internet connections (mountain/remote areas)
        // Optimized for users in remote/mountain areas with very limited connectivity
        // Minimum viable connection: ~14.4 kbps (1.8 KB/s) - very slow 2G or satellite connections
        // Typical API request size: 10-50 KB
        // At 14.4 kbps: ~5-28 seconds per request
        // At 28.8 kbps: ~2-14 seconds per request
        // At 56 kbps: ~1-7 seconds per request
        // With retries and delays: up to 10 minutes total wait time for extremely slow connections
        const RETRY_CONFIG = {
            maxRetries: 5,              // Try up to 5 times (increased from 3)
            initialTimeout: 120000,     // 2 minutes for first attempt (very slow connections)
            maxTimeout: 600000,         // 10 minutes maximum timeout per request (allows for extremely slow connections)
            backoffMultiplier: 1.3,     // Exponential backoff multiplier (120s, 156s, 203s, 264s, 343s delays)
            minConnectionSpeed: 1.8    // Minimum KB/s to consider connection viable (1.8 KB/s = ~14.4 kbps)
        };

        // Helper function to create resilient API calls with retry logic
        // Optimized for extremely slow connections (14.4 kbps and above)
        async function resilientApiCall(apiCall, sectionId, retryCount = 0) {
            try {
                // Set a longer timeout for extremely slow connections
                // At 14.4 kbps (1.8 KB/s), a 50 KB request takes ~28 seconds
                // We allow up to 10 minutes to account for network fluctuations and retries
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => {
                        reject(new Error('Request timeout - connection may be extremely slow or unavailable'));
                    }, RETRY_CONFIG.maxTimeout);
                });

                // Race between API call and timeout
                const result = await Promise.race([apiCall(), timeoutPromise]);
                return result;
            } catch (error) {
                // Check if it's a network error
                const isNetworkErr = typeof window.isNetworkError === 'function' && window.isNetworkError(error);
                
                // If we haven't exceeded max retries and it's a network error, retry
                if (retryCount < RETRY_CONFIG.maxRetries && isNetworkErr) {
                    const delay = RETRY_CONFIG.initialTimeout * Math.pow(RETRY_CONFIG.backoffMultiplier, retryCount);
                    const delaySeconds = Math.round(delay / 1000);
                    console.log(`Retrying API call (attempt ${retryCount + 1}/${RETRY_CONFIG.maxRetries}) after ${delaySeconds}s delay...`);
                    
                    // Update loading message to show retry attempt with estimated time
                    const contentSection = document.getElementById(sectionId);
                    if (contentSection) {
                        const loadingDiv = contentSection.querySelector('.section-loading-message');
                        if (loadingDiv && !loadingDiv.classList.contains('error')) {
                            const originalMessage = sectionLoadingMessages[sectionId] || 'Loading....';
                            const minutes = Math.floor(delaySeconds / 60);
                            const seconds = delaySeconds % 60;
                            const timeText = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
                            loadingDiv.querySelector('span').textContent = `${originalMessage} (Retrying ${retryCount + 1}/${RETRY_CONFIG.maxRetries} in ${timeText})...`;
                        }
                    }
                    
                    // Wait before retrying
                    await new Promise(resolve => setTimeout(resolve, delay));
                    
                    // Retry the API call
                    return resilientApiCall(apiCall, sectionId, retryCount + 1);
                }
                
                // If all retries failed or it's not a network error, throw
                throw error;
            }
        }

        // Expose resilient API call function globally
        window.resilientApiCall = resilientApiCall;
        window.RETRY_CONFIG = RETRY_CONFIG;

        // Listen for online/offline events
        window.addEventListener('online', () => {
            console.log('Internet connection restored');
            // Optionally hide network error messages when connection is restored
            // Users can manually refresh or switch sections to reload data
        });

        window.addEventListener('offline', () => {
            console.log('Internet connection lost');
            // Show network error for currently active section
            const activeSection = document.querySelector('.content-section.active');
            if (activeSection && activeSection.id) {
                const sectionId = activeSection.id;
                // Check if there's a loading message, replace it with network error
                const loadingDiv = document.getElementById(`loading-${sectionId}`);
                if (loadingDiv) {
                    showNetworkError(sectionId);
                }
            }
        });

        // Global function for menu navigation
        function switchToSection(sectionId) {
            console.log('switchToSection called with:', sectionId);
            
            // Update sidebar
            document.querySelectorAll('.menu-item').forEach(item => {
                item.classList.remove('active');
            });
            const menuItem = document.querySelector(`.menu-item[data-section="${sectionId}"]`);
            if (menuItem) {
                menuItem.classList.add('active');
                console.log('Updated menu item to active');
            }

            // Update content
            document.querySelectorAll('.content-section').forEach(section => {
                section.classList.remove('active');
            });
            const contentSection = document.getElementById(sectionId);
            if (contentSection) {
                contentSection.classList.add('active');
                console.log('Updated content section to active');
                
                // Show loading message (except for user-management, order-management, assign-orders, and staff-overview on initial page load)
                // staff-overview data is already loaded during initialization, so no loading needed on first view
                // order-management and assign-orders modules should not show loading interface
                const loadingScreen = document.getElementById('loadingScreen');
                const isInitialLoad = loadingScreen && !loadingScreen.classList.contains('hidden');
                if (sectionId !== 'user-management' && sectionId !== 'order-management' && sectionId !== 'assign-orders' && !(sectionId === 'staff-overview' && isInitialLoad)) {
                    showSectionLoading(sectionId);
                }
            } else {
                console.error('Content section not found for ID:', sectionId);
            }
            
            // Load section data using staffManager (retry until available)
            (async function waitForStaffManager(attempts) {
                if (window.staffManager && typeof window.staffManager.loadSectionData === 'function') {
                    console.log('Loading data for section:', sectionId);
                    
                    // Set a timeout to detect slow/no internet (10 minutes for extremely slow connections in mountain areas)
                    const timeoutDuration = window.RETRY_CONFIG ? window.RETRY_CONFIG.maxTimeout : 600000; // 10 minutes default
                    const timeoutId = setTimeout(() => {
                        // Check if still loading after timeout (skip for user-management)
                        if (sectionId !== 'user-management') {
                            const loadingDiv = document.getElementById(`loading-${sectionId}`);
                            if (loadingDiv && !loadingDiv.classList.contains('error')) {
                                console.warn('Data loading timeout - connection may be very slow or unavailable');
                                // Check if navigator.onLine is false
                                if (typeof navigator !== 'undefined' && navigator.onLine === false) {
                                    showNetworkError(sectionId);
                                } else {
                                    // Still show network error as it might be very slow connection
                                    showNetworkError(sectionId);
                                }
                            }
                        }
                    }, timeoutDuration);
                    
                    try {
                        // Wait for data to actually load (handles slow internet)
                        await window.staffManager.loadSectionData(sectionId);
                        // Clear timeout if data loaded successfully
                        clearTimeout(timeoutId);
                        // Loading message will be hidden by loadSectionData when data finishes loading (except for user-management)
                        if (sectionId !== 'user-management' && typeof window.hideSectionLoading === 'function') {
                            window.hideSectionLoading(sectionId);
                        }
                        console.log('Data loading completed for:', sectionId);
                        
                    } catch (error) {
                        // Clear timeout on error
                        clearTimeout(timeoutId);
                        console.error('Error loading data for section:', sectionId, error);
                        
                        // Check if it's a network error (skip for user-management)
                        if (sectionId !== 'user-management') {
                            if (typeof window.isNetworkError === 'function' && window.isNetworkError(error)) {
                                if (typeof window.showNetworkError === 'function') {
                                    window.showNetworkError(sectionId);
                                }
                            } else {
                                hideSectionLoading(sectionId);
                            }
                        }
                    }
                    return;
                }
                if (attempts <= 0) {
                    console.error('Staff manager not available for data loading');
                    hideSectionLoading(sectionId);
                    return;
                }
                setTimeout(() => waitForStaffManager(attempts - 1), 150);
            })(20);
        }
        // Toggle sidebar function (now fixed width - no toggle needed)
        function toggleSidebar() {
            // Sidebar is now fixed width - no toggle functionality needed
            console.log('Sidebar is now fixed width - no toggle needed');
        }

        // Sidebar is now fixed width - no hover management needed
        (function(){
            // Keep sidebar always expanded
            document.addEventListener('DOMContentLoaded', function(){
                try {
                    // Always add sidebar-open class to keep sidebar expanded
                    document.body.classList.add('sidebar-open');
                } catch(_){}
            });
        })();
        
        
		// Global function for order management tab switching (delegates to staffManager if available)
		function switchOrderManagementTab(tabId) {
			// Try to delegate to staffManager, but always run the UI toggle to ensure visibility
			try {
				if (window.staffManager && typeof window.staffManager.switchOrderManagementTab === 'function') {
					// Do not early-return; allow UI fallback to run to guarantee tab visibility
					window.staffManager.switchOrderManagementTab(tabId);
				}
			} catch(_) {}
			// UI toggle to ensure the correct tab is shown regardless of staffManager behavior
			try {
				document.querySelectorAll('.order-management-tabs .tab-btn').forEach(btn => btn.classList.remove('active'));
				const btn = document.querySelector(`.order-management-tabs .tab-btn[data-tab="${tabId}"]`);
				if (btn) btn.classList.add('active');
				document.querySelectorAll('.order-management-content .tab-content').forEach(content => content.classList.remove('active'));
				const tabEl = document.getElementById(`${tabId}-tab`);
				if (tabEl) tabEl.classList.add('active');
			} catch (e) { console.warn('Fallback tab switch failed', e); }
		}
        // Direct event handlers for order management tabs
        document.addEventListener('DOMContentLoaded', function() {
			// Helper: force a tab to stay active even if other code flips it back
			function forceOrderTab(tabId) {
				try { switchOrderManagementTab(tabId); } catch(_) {}
				setTimeout(() => { try { switchOrderManagementTab(tabId); } catch(_) {} }, 150);
				setTimeout(() => { try { switchOrderManagementTab(tabId); } catch(_) {} }, 400);
			}

            // Order Records button
            const orderRecordsBtn = document.getElementById('rejected-orders-btn');
            if (orderRecordsBtn) {
                orderRecordsBtn.addEventListener('click', function() {
                    console.log('Order Records button clicked');
                    
                    // Switch to order management section first
                    switchToSection('order-management');
                    
					// Then switch to the order records tab (with retries)
					setTimeout(() => {
						forceOrderTab('rejected-orders');
					}, 100);
                });
            }
            
            // Cancelled Orders button
            const cancelledOrdersBtn = document.getElementById('cancelled-orders-btn');
            if (cancelledOrdersBtn) {
                cancelledOrdersBtn.addEventListener('click', function() {
                    console.log('Cancelled Orders button clicked');
                    
                    // Switch to order management section first
                    switchToSection('order-management');
                    
					// Then switch to the cancelled orders tab (with retries)
					setTimeout(() => {
						forceOrderTab('cancelled-orders');
					}, 100);
                });
            }
            
            // Pending Orders button
            const pendingOrdersBtn = document.getElementById('pending-orders-btn');
            if (pendingOrdersBtn) {
                pendingOrdersBtn.addEventListener('click', function() {
                    console.log('Pending Orders button clicked');
                    
                    // Switch to order management section first
                    switchToSection('order-management');
                    
					// Then switch to the pending orders tab (with retries)
					setTimeout(() => {
						forceOrderTab('pending-orders');
					}, 100);
                });
            }
        });
        
        // Combined event handlers for better performance
        function setupCustomerManagementTabs() {
            console.log(' Setting up customer management tab event listeners...');
            // User Management tab buttons
            const farmerUsersBtn = document.querySelector('.user-management-tabs .tab-btn[data-tab="farmer-users"]');
            if (farmerUsersBtn) {
                farmerUsersBtn.addEventListener('click', function() {
                    if (window.staffManager) {
                        window.staffManager.switchUserManagementTab('farmer-users');
                    }
                });
            }
            
            const customerUsersBtn = document.querySelector('.user-management-tabs .tab-btn[data-tab="customer-users"]');
            if (customerUsersBtn) {
                customerUsersBtn.addEventListener('click', function() {
                    if (window.staffManager) {
                        window.staffManager.switchUserManagementTab('customer-users');
                    }
                });
            }
            
            // Customer Management tab buttons
            const customerRecordBtn = document.getElementById('approved-customers-btn');
            console.log('Setting up customer management buttons, customerRecordBtn:', customerRecordBtn);
            if (customerRecordBtn) {
                customerRecordBtn.addEventListener('click', function() {
                    console.log('Customer Record button clicked!');
                    if (window.staffManager) {
                        window.staffManager.switchCustomerManagementTab('approved-customers');
                    } else {
                        console.error('window.staffManager not available');
                    }
                });
            }
            
            const pendingVerificationsBtn = document.getElementById('pending-verifications-btn');
            console.log('pendingVerificationsBtn:', pendingVerificationsBtn);
            if (pendingVerificationsBtn) {
                pendingVerificationsBtn.addEventListener('click', function() {
                    console.log('Pending Verifications button clicked!');
                    if (window.staffManager) {
                        window.staffManager.switchCustomerManagementTab('pending-verifications');
                    } else {
                        console.error('window.staffManager not available');
                    }
                });
            }
            
            const rejectedVerificationsBtn = document.getElementById('rejected-verifications-btn');
            console.log('rejectedVerificationsBtn:', rejectedVerificationsBtn);
            if (rejectedVerificationsBtn) {
                rejectedVerificationsBtn.addEventListener('click', function() {
                    console.log('Rejected Verifications button clicked!');
                    if (window.staffManager) {
                        window.staffManager.switchCustomerManagementTab('rejected-verifications');
                    } else {
                        console.error('window.staffManager not available');
                    }
                });
            }
            console.log(' Customer management tab event listeners set up');
        }
        
        // Try to set up immediately if DOM is ready, otherwise wait for DOMContentLoaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupCustomerManagementTabs);
        } else {
            setupCustomerManagementTabs();
        }
    </script>
    <!-- Product Listing Functions -->
    <script>
        // Product Listing Functions
        function toggleSelectAllProducts() {
            const productCards = document.querySelectorAll('.product-card');
            const toggleBtn = document.getElementById('toggleSelectBtn');
            const toggleIcon = toggleBtn.querySelector('i');
            const toggleText = toggleBtn.querySelector('span') || toggleBtn.childNodes[2];
            
            // Check if all products are currently selected
            const allSelected = Array.from(productCards).every(card => {
                const checkbox = card.querySelector('input[type="checkbox"]');
                return checkbox && checkbox.checked;
            });
            
            if (allSelected) {
                // Deselect all products
                productCards.forEach(card => {
                    const checkbox = card.querySelector('input[type="checkbox"]');
                    if (checkbox) {
                        checkbox.checked = false;
                        card.classList.remove('selected');
                    }
                });
                // Update button text and icon
                toggleIcon.className = 'fas fa-square';
                toggleBtn.innerHTML = '<i class="fas fa-square"></i> Select All';
            } else {
                // Select all products
                productCards.forEach(card => {
                    const checkbox = card.querySelector('input[type="checkbox"]');
                    if (checkbox) {
                        checkbox.checked = true;
                        card.classList.add('selected');
                    }
                });
                // Update button text and icon
                toggleIcon.className = 'fas fa-check-square';
                toggleBtn.innerHTML = '<i class="fas fa-check-square"></i> Deselect All';
            }
            
            updateSelectedCount();
        }

        function updateSelectedCount() {
            const selectedCards = document.querySelectorAll('.product-card.selected');
            const countElement = document.getElementById('selectedCount');
            const deleteBtn = document.getElementById('deleteSelectedBtn');
            const toggleBtn = document.getElementById('toggleSelectBtn');
            const productCards = document.querySelectorAll('.product-card');
            
            if (countElement) {
                countElement.textContent = `${selectedCards.length} selected`;
            }
            
            // Show/hide delete button based on selection
            if (deleteBtn) {
                if (selectedCards.length > 0) {
                    deleteBtn.style.display = 'flex';
                } else {
                    deleteBtn.style.display = 'none';
                }
            }
            
            // Update toggle button text and icon based on selection state
            if (toggleBtn && productCards.length > 0) {
                const allSelected = selectedCards.length === productCards.length && productCards.length > 0;
                if (allSelected) {
                    toggleBtn.innerHTML = '<i class="fas fa-check-square"></i> Deselect All';
                } else {
                    toggleBtn.innerHTML = '<i class="fas fa-square"></i> Select All';
                }
            }
        }

        function deleteSelectedProducts() {
            const selectedCards = document.querySelectorAll('.product-card.selected');
            
            if (selectedCards.length === 0) {
                alert('No products selected for deletion.');
                return;
            }
            
            const confirmMessage = `Are you sure you want to delete ${selectedCards.length} selected product(s)? This action cannot be undone.`;
            
            if (confirm(confirmMessage)) {
                // Here you would typically make an API call to delete the products
                // For now, we'll just remove them from the DOM and show a success message
                selectedCards.forEach(card => {
                    card.remove();
                });
                
                // Update the selected count and hide delete button
                updateSelectedCount();
                
                // Show success notification
                if (window.staffManager && staffManager.showNotification) {
                    staffManager.showNotification(`Successfully deleted ${selectedCards.length} product(s).`, 'success');
                } else {
                    alert(`Successfully deleted ${selectedCards.length} product(s).`);
                }
                
                // Update product statistics
                updateProductStats();
            }
        }


        // Enhanced Filter functionality
        document.addEventListener('DOMContentLoaded', function() {
            const categoryFilter = document.getElementById('categoryFilter');
            const statusFilter = document.getElementById('statusFilter');
            const searchInput = document.getElementById('productSearchInput');
            
            console.log('Filter elements found:', { categoryFilter, statusFilter, searchInput });
            
            // Helper function to determine product status from card content
            function getProductStatusFromCard(card) {
                // Get all text content from the card
                const cardText = card.textContent.toLowerCase();
                
                // Look for explicit status indicators
                if (cardText.includes('inactive') || cardText.includes('disabled') || cardText.includes('unavailable')) {
                    return 'inactive';
                }
                
                if (cardText.includes('out of stock') || cardText.includes('out-of-stock') || 
                    cardText.includes('stock: 0') || cardText.includes('quantity: 0') ||
                    cardText.includes('no stock') || cardText.includes('unavailable')) {
                    return 'out-of-stock';
                }
                
                if (cardText.includes('active') || cardText.includes('available') || 
                    cardText.includes('in stock') || cardText.includes('stock:') && !cardText.includes('stock: 0')) {
                    return 'active';
                }
                
                // Look for status indicators in the card
                const statusElement = card.querySelector('.product-status, .status, [class*="status"]');
                if (statusElement) {
                    const statusText = statusElement.textContent.toLowerCase();
                    if (statusText.includes('active') || statusText.includes('available')) return 'active';
                    if (statusText.includes('inactive') || statusText.includes('unavailable')) return 'inactive';
                    if (statusText.includes('out') && statusText.includes('stock')) return 'out-of-stock';
                }
                
                // Look for stock indicators
                const stockElement = card.querySelector('.stock, .quantity, [class*="stock"]');
                if (stockElement) {
                    const stockText = stockElement.textContent.toLowerCase();
                    if (stockText.includes('0') || stockText.includes('out') || stockText.includes('unavailable')) {
                        return 'out-of-stock';
                    }
                    return 'active';
                }
                
                // Look for price indicators (products with prices are usually active)
                const priceElement = card.querySelector('.price, .cost, [class*="price"]');
                if (priceElement) {
                    return 'active';
                }
                
                // Default to active if we can't determine status
                return 'active';
            }
            
            function applyFilters() {
                const categoryValue = categoryFilter ? categoryFilter.value : '';
                const statusValue = statusFilter ? statusFilter.value : '';
                const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
                
                console.log('=== APPLYING FILTERS ===');
                console.log('Filter values:', { categoryValue, statusValue, searchTerm });
                
                // Find all product cards with multiple approaches
                let productCards = document.querySelectorAll('.product-card');
                
                // If no .product-card found, try other selectors
                if (productCards.length === 0) {
                    productCards = document.querySelectorAll('[class*="product"]');
                }
                if (productCards.length === 0) {
                    productCards = document.querySelectorAll('.card');
                }
                if (productCards.length === 0) {
                    productCards = document.querySelectorAll('[class*="card"]');
                }
                
                console.log('Found product cards:', productCards.length);
                
                if (productCards.length === 0) {
                    console.log('No products found to filter');
                    return;
                }
                
                let visibleCount = 0;
                
                productCards.forEach((card, index) => {
                    // Get all text content from the card
                    const cardText = card.textContent.toLowerCase();
                    
                    // Simple status detection based on text content
                    let detectedStatus = 'active'; // default
                    if (cardText.includes('inactive') || cardText.includes('disabled')) {
                        detectedStatus = 'inactive';
                    } else if (cardText.includes('out of stock') || cardText.includes('out-of-stock') || 
                              cardText.includes('stock: 0') || cardText.includes('no stock')) {
                        detectedStatus = 'out-of-stock';
                    } else if (cardText.includes('active') || cardText.includes('available') || 
                              cardText.includes('in stock')) {
                        detectedStatus = 'active';
                    }
                    
                    // Simple category detection
                    let detectedCategory = '';
                    if (cardText.includes('vegetable')) detectedCategory = 'vegetables';
                    else if (cardText.includes('fruit')) detectedCategory = 'fruits';
                    else if (cardText.includes('grain')) detectedCategory = 'grains';
                    else if (cardText.includes('dairy')) detectedCategory = 'dairy';
                    else if (cardText.includes('meat')) detectedCategory = 'meat';
                    else if (cardText.includes('seafood')) detectedCategory = 'seafood';
                    
                    // Get product name (try multiple selectors)
                    const productName = card.querySelector('h1, h2, h3, h4, h5, h6')?.textContent.toLowerCase() || 
                                      card.querySelector('.name, .title, .product-name')?.textContent.toLowerCase() || '';
                    
                    console.log(`Product ${index}: status="${detectedStatus}", category="${detectedCategory}", name="${productName}"`);
                    
                    let showCard = true;
                    
                    // Apply status filter
                    if (statusValue && detectedStatus !== statusValue) {
                        console.log(`Hiding product ${index}: status "${detectedStatus}" !== "${statusValue}"`);
                        showCard = false;
                    }
                    
                    // Apply category filter
                    if (categoryValue && detectedCategory !== categoryValue) {
                        console.log(`Hiding product ${index}: category "${detectedCategory}" !== "${categoryValue}"`);
                        showCard = false;
                    }
                    
                    // Apply search filter
                    if (searchTerm && !cardText.includes(searchTerm)) {
                        console.log(`Hiding product ${index}: search term "${searchTerm}" not found`);
                        showCard = false;
                    }
                    
                    // Show or hide the card while maintaining grid layout
                    if (showCard) {
                        card.classList.remove('filtered-out');
                        visibleCount++;
                        console.log(`Showing product ${index}`);
                    } else {
                        card.classList.add('filtered-out');
                        console.log(`Hiding product ${index}`);
                    }
                });
                
                console.log(`Filter complete: ${visibleCount} visible out of ${productCards.length} total`);
                
                // Update statistics
                updateProductStats();
                showFilterResults(visibleCount, productCards.length);
            }
            
            function showFilterResults(visible, total) {
                let message = '';
                if (visible === total) {
                    message = `Showing all ${total} products`;
                } else {
                    message = `Showing ${visible} of ${total} products`;
                }
                
                // Create or update filter results message
                let resultsMessage = document.getElementById('filterResults');
                if (!resultsMessage) {
                    resultsMessage = document.createElement('div');
                    resultsMessage.id = 'filterResults';
                    resultsMessage.style.cssText = 'margin-top: 8px; font-size: 13px; color: #64748b; font-weight: 500;';
                    const actionGroup = document.querySelector('.action-group h4').parentNode;
                    if (actionGroup) {
                        actionGroup.appendChild(resultsMessage);
                    }
                }
                resultsMessage.textContent = message;
            }
            
            // Event listeners
            if (categoryFilter) {
                categoryFilter.addEventListener('change', function(e) {
                    console.log('Category filter changed:', e.target.value);
                    applyFilters();
                });
            }
            
            if (statusFilter) {
                statusFilter.addEventListener('change', function(e) {
                    console.log('Status filter changed:', e.target.value);
                    applyFilters();
                });
            }
            
            if (searchInput) {
                searchInput.addEventListener('input', function(e) {
                    console.log('Search input changed:', e.target.value);
                    applyFilters();
                });
            }
            
            // Initialize filters after a short delay to ensure DOM is ready
            setTimeout(() => {
                applyFilters();
            }, 100);
            
            // Set up a global search function that can be called from anywhere
            window.searchProducts = function(searchTerm) {
                if (searchInput) {
                    searchInput.value = searchTerm;
                    applyFilters();
                }
            };
            
            // Re-apply filters when products are loaded (for dynamic loading)
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                        // Check if product cards were added
                        const hasProductCards = Array.from(mutation.addedNodes).some(node => 
                            node.nodeType === 1 && (node.classList?.contains('product-card') || node.querySelector?.('.product-card'))
                        );
                        if (hasProductCards) {
                            console.log('Product cards detected, re-applying filters...');
                            setTimeout(applyFilters, 100);
                        }
                    }
                });
            });
            
            // Start observing the products grid for changes
            const productsGrid = document.querySelector('.products-grid');
            if (productsGrid) {
                observer.observe(productsGrid, { childList: true, subtree: true });
            }
        });

        // Product statistics update
        function updateProductStats() {
            // Only count visible products (not filtered out)
            const visibleProductCards = document.querySelectorAll('.product-card:not(.filtered-out)');
            let totalProducts = visibleProductCards.length;
            let activeProducts = 0;
            let outOfStock = 0;
            
            console.log('Updating stats for visible products:', totalProducts);
            
            visibleProductCards.forEach(card => {
                // Get all text content from the card for status detection
                const cardText = card.textContent.toLowerCase();
                
                // Determine status from card content
                let status = 'active'; // default
                if (cardText.includes('inactive') || cardText.includes('disabled')) {
                    status = 'inactive';
                } else if (cardText.includes('out of stock') || cardText.includes('out-of-stock') || 
                          cardText.includes('stock: 0') || cardText.includes('no stock')) {
                    status = 'out-of-stock';
                } else if (cardText.includes('active') || cardText.includes('available') || 
                          cardText.includes('in stock')) {
                    status = 'active';
                }
                
                // Check for stock indicators
                let stock = 1; // default to in stock
                if (cardText.includes('stock: 0') || cardText.includes('quantity: 0') || 
                    cardText.includes('out of stock') || cardText.includes('no stock')) {
                    stock = 0;
                }
                
                console.log(`Product status: ${status}, stock: ${stock}`);
                
                if (status === 'active') {
                    activeProducts++;
                }
                
                if (stock === 0) {
                    outOfStock++;
                }
            });
            
            const totalElement = document.getElementById('totalProducts');
            const activeElement = document.getElementById('activeProducts');
            const stockElement = document.getElementById('outOfStock');
            
            console.log('Stats update:', { totalProducts, activeProducts, outOfStock });
            
            if (totalElement) totalElement.textContent = totalProducts;
            if (activeElement) activeElement.textContent = activeProducts;
            if (stockElement) stockElement.textContent = outOfStock;
        }

        // Initialize stats when page loads
        document.addEventListener('DOMContentLoaded', function() {
            updateProductStats();
            
            // Add event listeners for product checkboxes
            document.addEventListener('change', function(e) {
                if (e.target.type === 'checkbox' && e.target.closest('.product-card')) {
                    const productCard = e.target.closest('.product-card');
                    if (e.target.checked) {
                        productCard.classList.add('selected');
                    } else {
                        productCard.classList.remove('selected');
                    }
                    updateSelectedCount();
                }
            });
        });
    </script>
    <!-- Cooperative time heartbeat: publishes desktop time to Firebase -->
    <script src="coop-time-heartbeat.js"></script>
    <!-- Shopee-style Chatbox -->
    <div id="chatboxOverlay" class="chatbox-overlay">
        <div class="chatbox-container">
            <div class="chatbox-close-container">
                <button class="chatbox-close" onclick="closeChatBox()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="chatbox-content">
                <!-- Left Panel - Conversations List -->
                <div class="chatbox-left-panel">
                    <div class="chatbox-left-header">
                        <h4>Conversations</h4>
                    </div>
                    <script>
                        (function(){
                            if (!window.switchConversationTab) {
                                window.switchConversationTab = function(tab){
                                    try {
                                        // Update tab button styles
                                        document.querySelectorAll('.chatbox-tab').forEach(btn => btn.classList.remove('active'));
                                        const btn = document.getElementById(tab + 'Tab');
                                        if (btn) btn.classList.add('active');
                                        // Load conversations silently in background (no loading message)
                                        const list = document.getElementById('conversationsList');
                                        const hasConversations = list && list.querySelectorAll('.conversation-item').length > 0;
                                        // Load data silently if needed
                                        if (tab === 'active' && typeof loadActiveConversations === 'function') {
                                            if (!hasConversations) loadActiveConversations();
                                        } else if (tab === 'archived' && typeof loadArchivedConversations === 'function') {
                                            if (!hasConversations) loadArchivedConversations();
                                        }
                                    } catch(e) { console.warn('Fallback switchConversationTab error', e); }
                                };
                            }
                        })();
                    </script>
                    <div class="chatbox-tabs">
                        <button class="chatbox-tab active" onclick="switchConversationTab('active')" id="activeTab">
                            <i class="fas fa-comments"></i>
                            Active
                        </button>
                        <button class="chatbox-tab" onclick="switchConversationTab('archived')" id="archivedTab">
                            <i class="fas fa-archive"></i>
                            Archived
                        </button>
                    </div>
                    <div class="chatbox-search">
                        <input type="text" class="chatbox-search-input" placeholder="Search conversations..." id="conversationSearch">
                    </div>
                    <div id="conversationsList" class="conversations-list">
                        <!-- Conversations will be loaded dynamically from Firebase -->
                    </div>
                </div>

                <!-- Right Panel - Chat Messages -->
                <div class="chatbox-right-panel">
                    <div class="chatbox-right-header">
                        <div class="chatbox-customer-info" id="customerInfo">
                            <div class="chatbox-customer-avatar">
                                <i class="fas fa-user"></i>
                            </div>
                            <div class="chatbox-customer-name" id="customerName">Select a conversation</div>
                        </div>
                        <div class="chatbox-conversation-actions" id="conversationActions" style="display: none;">
                            <button class="conversation-action-btn archive-btn" id="archiveBtn" onclick="archiveCurrentConversation()" title="Archive conversation">
                                <i class="fas fa-archive"></i>
                                Archive
                            </button>
                            <button class="conversation-action-btn unarchive-btn" id="unarchiveBtn" onclick="unarchiveCurrentConversation()" title="Unarchive conversation" style="display: none;">
                                <i class="fas fa-undo"></i>
                                Unarchive
                            </button>
                            <button class="conversation-action-btn delete-btn" onclick="deleteCurrentConversation()" title="Delete conversation">
                                <i class="fas fa-trash"></i>
                                Delete
                            </button>
                        </div>
                    </div>
                    
                    <!-- Chat Messages -->
                    <div id="chatMessages" class="chat-messages">
                        <div class="chat-empty">
                            <i class="fas fa-comment-dots"></i>
                            <h4>Select a conversation</h4>
                            <p>Choose a conversation from the list to start chatting</p>
                        </div>
                    </div>

                    <!-- Chat Input -->
                    <div id="chatInputArea" class="chat-input-area">
                        <div id="mediaPreviewContainer" class="media-preview-container">
                            <div class="media-preview-grid" id="mediaPreviewGrid"></div>
                        </div>
                        <div class="chat-input-container">
                            <input type="file" id="chatMediaInput" accept="image/*,video/*" multiple style="display: none;" onchange="handleMediaSelection(event)">
                            <button id="chatAttachBtn" class="chat-attach-btn" onclick="document.getElementById('chatMediaInput').click()" title="Attach Image or Video">
                                <i class="fas fa-paperclip"></i>
                            </button>
                            <textarea id="mainChatMessageInput" class="chat-input" placeholder="Type a message..." rows="1"></textarea>
                            <button id="chatSendBtn" class="chat-send-btn" onclick="sendMessageWithFirebase()">
                                <i class="fas fa-paper-plane"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Image/Video Lightbox Modal -->
    <div id="imageLightboxOverlay" class="image-lightbox-overlay" onclick="closeImageLightbox(event)">
        <button class="image-lightbox-close" onclick="closeImageLightbox(event)" title="Close (ESC)">
            <i class="fas fa-times"></i>
        </button>
        <div class="image-lightbox-container" onclick="event.stopPropagation()">
            <img id="lightboxImage" class="image-lightbox-image" src="" alt="Image" style="display: none;">
            <video id="lightboxVideo" class="image-lightbox-image" controls style="display: none;">
                <source id="lightboxVideoSource" src="" type="video/mp4">
                <source id="lightboxVideoSourceWebm" src="" type="video/webm">
                <source id="lightboxVideoSourceQuicktime" src="" type="video/quicktime">
            </video>
            <div class="image-lightbox-actions">
                <button class="image-lightbox-btn" onclick="openMediaInNewTab()">
                    <i class="fas fa-external-link-alt"></i> Open in New Tab
                </button>
                <button class="image-lightbox-btn" onclick="downloadMedia()">
                    <i class="fas fa-download"></i> Download
                </button>
            </div>
        </div>
    </div>

    <!-- Chat Approval Modal (Staff  Customer) -->
    <style>
        .chat-approval-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.45); display: none; align-items: center; justify-content: center; z-index: 10000; }
        .chat-approval-modal { width: 100%; max-width: 680px; background: #ffffff; border: 1px solid #e2e8f0; border-radius: 12px; box-shadow: 0 12px 40px rgba(0,0,0,0.18); overflow: hidden; display: flex; flex-direction: column; }
        .dark-theme .chat-approval-modal { background: #1f1f1f !important; border-color: #2b2b2b !important; }
        .chat-approval-header { display: flex; align-items: center; justify-content: space-between; padding: 14px 16px; border-bottom: 1px solid #e2e8f0; }
        .dark-theme .chat-approval-header { border-bottom-color: #2b2b2b !important; }
        .chat-approval-header h3 { margin: 0; font-size: 16px; }
        .chat-approval-body { display: grid; grid-template-rows: auto 1fr auto; gap: 10px; padding: 12px 16px; min-height: 360px; }
        .chat-approval-banner { background: #fff8e6; border: 1px solid #ffe0b2; color: #995800; border-radius: 8px; padding: 10px 12px; font-size: 13px; display: flex; align-items: center; gap: 8px; }
        .dark-theme .chat-approval-banner { background: #2b241a !important; border-color: #40301a !important; color: #e6c899 !important; }
        .chat-approval-messages { border: 1px solid #e2e8f0; border-radius: 8px; padding: 10px; overflow-y: auto; max-height: 320px; background: #f9fafb; }
        .dark-theme .chat-approval-messages { border-color: #2b2b2b !important; background: #181818 !important; }
        .msg { display: inline-block; padding: 8px 10px; border-radius: 8px; margin: 6px 0; max-width: 82%; line-height: 1.35; font-size: 13px; }
        .msg-staff { background: #e8f5e9; color: #1b5e20; }
        .msg-customer { background: #e3f2fd; color: #0d47a1; }
        .msg-system { background: #f3f4f6; color: #374151; font-style: italic; }
        .dark-theme .msg-staff { background: #16311a !important; color: #b6e0b8 !important; }
        .dark-theme .msg-customer { background: #0f2438 !important; color: #b3d4fc !important; }
        .dark-theme .msg-system { background: #202020 !important; color: #c9c9c9 !important; }
        .chat-approval-input { display: grid; grid-template-columns: 1fr auto; gap: 10px; }
        .chat-approval-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 8px; flex-wrap: wrap; }
        .chat-input { width: 100%; padding: 10px 12px; border: 1px solid #e2e8f0; border-radius: 8px; font-size: 14px; }
        .dark-theme .chat-input { background: #2d2d2d !important; border-color: #404040 !important; color: #e0e0e0 !important; }

        .chat-meta { font-size: 12px; color: #6b7280; }
        @media (max-width: 520px) { .chat-approval-modal { max-width: 96%; } }
    </style>
    <div id="chatApprovalOverlay" class="chat-approval-overlay" role="dialog" aria-modal="true" aria-hidden="true">
        <div class="chat-approval-modal" role="document">
            <div class="chat-approval-header">
                <h3><i class="fas fa-comments"></i> Contact Customer</h3>
                <button id="chatApprovalCloseBtn" class="secondary-btn" style="width:auto; padding:6px 10px;">Close</button>
            </div>
            <div class="chat-approval-body">
                <div class="chat-approval-banner"><i class="fas fa-info-circle"></i><span>If this order can't be delivered this week, chat with the customer. If the customer agrees, we'll reschedule to next week. Otherwise, we'll proceed with refund or rejection.</span></div>
                    <div id="approvalChatMessages" class="chat-approval-messages" aria-live="polite"></div>
                <div class="chat-approval-input">
                    <input id="approvalChatMessageInput" class="chat-input" type="text" placeholder="Type a message to the customer..." />
                    <button id="approvalChatSendBtn" class="secondary-btn" style="width:auto;">Send</button>
                </div>
                <div class="chat-approval-actions">
                    <button id="agreeRescheduleBtn" class="primary-btn" style="width:auto;"><i class="fas fa-calendar-week"></i> Reschedule to next week</button>
                    <button id="rejectRefundBtn" class="danger-btn" style="width:auto;"><i class="fas fa-undo-alt"></i> Refund / Reject</button>
                </div>
                <div class="chat-meta" id="chatMeta"></div>
            </div>
        </div>
    </div>
    <script>
      (function(){
        const state = { orderId: null, customerId: null, lastLoadedAt: 0 };
        const els = {
          overlay: null, messages: null, input: null, send: null,
          close: null, agreeBtn: null, rejectBtn: null, meta: null
        };

        function $(id){ return document.getElementById(id); }

        function ensureEls(){
          els.overlay = els.overlay || $('chatApprovalOverlay');
          els.messages = els.messages || $('approvalChatMessages');
          els.input = els.input || $('approvalChatMessageInput');
          els.send = els.send || $('approvalChatSendBtn');
          els.close = els.close || $('chatApprovalCloseBtn');
          els.agreeBtn = els.agreeBtn || $('agreeRescheduleBtn');
          els.rejectBtn = els.rejectBtn || $('rejectRefundBtn');
          els.meta = els.meta || $('chatMeta');
        }

        function appendMsg(kind, text){
          ensureEls();
          if (!els.messages) return;
          const div = document.createElement('div');
          div.className = 'msg msg-' + kind;
          div.textContent = text;
          els.messages.appendChild(div);
          els.messages.scrollTop = els.messages.scrollHeight;
        }

        function writeChatMessage(orderId, author, text){
          try {
            const db = window.firebase && window.firebase.database ? window.firebase.database() : null;
            if (!db) return false;
            const ref = db.ref('chats/' + orderId).push();
            ref.set({ author: author, text: text, ts: Date.now() }).catch(function(){});
            return true;
          } catch(_) { return false; }
        }

        function loadRecentMessages(orderId){
          try {
            const db = window.firebase && window.firebase.database ? window.firebase.database() : null;
            if (!db) return;
            const ref = db.ref('chats/' + orderId).limitToLast(50);
            ref.off();
            ref.on('value', function(snap){
              ensureEls();
              if (!els.messages) return;
              els.messages.innerHTML = '';
              const val = snap && snap.val ? snap.val() : null;
              if (!val) return;
              Object.keys(val).sort(function(a,b){ return (val[a].ts||0) - (val[b].ts||0); }).forEach(function(k){
                const m = val[k];
                const who = (m.author === 'staff') ? 'staff' : (m.author === 'system' ? 'system' : 'customer');
                appendMsg(who, m.text || '');
              });
            });
          } catch(_) {}
        }

        function formatMeta(order){
          try {
            const id = String(order && order.id ? order.id : state.orderId || '');
            const name = (order && (order.customerName || (order.customer && order.customer.name))) || '';
            return 'Order #' + id + (name ? ('  Customer: ' + name) : '');
          } catch(_) { return ''; }
        }

        window.openChatApproval = function(order){
          ensureEls();
          if (!els.overlay) return;
          state.orderId = order && (order.id || order.orderId) ? (order.id || order.orderId) : null;
          state.customerId = order && (order.customerId || (order.customer && order.customer.id)) ? (order.customerId || order.customer.id) : null;
          if (els.meta) els.meta.textContent = formatMeta(order);
          els.overlay.style.display = 'flex';
          appendMsg('system', 'Started chat regarding delivery availability this week.');
          loadRecentMessages(state.orderId);
        };

        function closeOverlay(){ ensureEls(); if (els.overlay) els.overlay.style.display = 'none'; }

        function getNextWeekDateISO(){ const d = new Date(); d.setDate(d.getDate() + (7 - d.getDay() || 7)); return d.toISOString().slice(0,10); }

        function tryReschedule(orderId){
          // Prefer app logic if available
          try { if (window.staffManager && typeof window.staffManager.rescheduleOrderNextWeek === 'function') return window.staffManager.rescheduleOrderNextWeek(orderId); } catch(_) {}
          // Fallback: write to Firebase
          try {
            const db = window.firebase && window.firebase.database ? window.firebase.database() : null;
            if (!db) return false;
            const updates = {};
            updates['orders/' + orderId + '/status'] = 'pending';
            updates['orders/' + orderId + '/scheduledFor'] = getNextWeekDateISO();
            updates['orders/' + orderId + '/updatedAt'] = Date.now();
            return db.ref().update(updates).then(function(){ return true; }).catch(function(){ return false; });
          } catch(_) { return false; }
        }

        function tryRefundOrReject(orderId){
          try {
            if (window.staffManager && typeof window.staffManager.refundOrRejectOrder === 'function') return window.staffManager.refundOrRejectOrder(orderId);
            if (window.staffManager && typeof window.staffManager.rejectOrder === 'function') return window.staffManager.rejectOrder(orderId);
          } catch(_) {}
          try {
            // Save to Supabase - NO FIREBASE FALLBACK
            if (window.OrderSupabaseAdapter && typeof window.OrderSupabaseAdapter.updateOrder === 'function') {
              const nowMs = Date.now();
              return window.OrderSupabaseAdapter.updateOrder(orderId, {
                status: 'cancelled',
                cancellationRequested: true,
                cancellationInitiatedBy: 'staff',
                cancellationReason: 'Customer declined reschedule',
                updatedAt: nowMs
              }).then(function(){ return true; }).catch(function(err){ 
                console.error(' Supabase update failed:', err);
                alert('Failed to save cancellation to Supabase. Please try again.');
                return false;
              });
            }
            // If Supabase adapter not available, show error
            console.error('OrderSupabaseAdapter not available');
            alert('Database connection not available. Please refresh the page.');
            return false;
          } catch(err) { 
            console.error('Error in tryRefundOrReject:', err);
            return false; 
          }
        }

        function wireEvents(){
          ensureEls();
          if (els.close) els.close.onclick = closeOverlay;
          if (els.send) els.send.onclick = function(){
            ensureEls();
            var txt = (els.input && els.input.value) ? els.input.value.trim() : '';
            if (!txt) return;
            els.input.value = '';
            appendMsg('staff', txt);
            writeChatMessage(state.orderId, 'staff', txt);
          };
          if (els.input) els.input.addEventListener('keydown', function(e){ if (e.key === 'Enter') { e.preventDefault(); els.send && els.send.click(); }});
          if (els.agreeBtn) els.agreeBtn.onclick = function(){
            appendMsg('system', 'Reschedule to next week requested.');
            writeChatMessage(state.orderId, 'system', 'Reschedule to next week requested.');
            Promise.resolve(tryReschedule(state.orderId)).then(function(){ closeOverlay(); }).catch(function(){ closeOverlay(); });
          };
          if (els.rejectBtn) els.rejectBtn.onclick = function(){
            appendMsg('system', 'Refund/Reject requested.');
            writeChatMessage(state.orderId, 'system', 'Refund/Reject requested.');
            Promise.resolve(tryRefundOrReject(state.orderId)).then(function(){ closeOverlay(); }).catch(function(){ closeOverlay(); });
          };
        }

        // Helper function to add chat button to order cards
        function addChatButtonToCard(card, id, order) {
          try {
            const status = (order && (order.status || order.orderStatus || '')).toString().toLowerCase().trim();
            console.log(' addChatButtonToCard called for order:', id, 'status:', status);
            
            // Check if order status matches any of the tabs where we want the chat button
            const statusesWithChat = [
              'pending',
              'confirmed',
              'to_receive',
              'to receive',
              'out_for_delivery',
              'out for delivery',
              'delivered',
              'picked_up',
              'pickedup',
              'picked up',
              'failed'
            ];
            
            const shouldShowChatButton = statusesWithChat.some(statusToCheck => 
              status.includes(statusToCheck) || status === statusToCheck
            );
            
            console.log(' Should show chat button?', shouldShowChatButton, 'for status:', status);
            
            if (shouldShowChatButton) {
              // Find the order-details container (expanded view) or order-actions section
              const orderDetails = card && card.querySelector ? card.querySelector('#order-details-' + id) : null;
              const orderActions = orderDetails ? orderDetails.querySelector('.order-actions') : null;
              
              console.log(' Found orderDetails:', !!orderDetails, 'orderActions:', !!orderActions);
              
              if (!orderActions) {
                console.warn(' orderActions not found for order:', id);
                return;
              }
              
              // Check if button already exists to avoid duplicates
              const existingBtn = orderActions.querySelector('.contact-customer-btn');
              if (!existingBtn) {
                // Get customer ID and name
                const customerId = order?.customerId || order?.customer_id || id;
                let customerName = order?.customerName || order?.customer_name || order?.customer?.fullName || order?.customer?.name || 'Customer';
                
                // Create the button element
                const btn = document.createElement('button');
                btn.className = 'contact-customer-btn';
                btn.setAttribute('data-order-id', id);
                btn.innerHTML = '<i class="fas fa-comments"></i> Contact Customer';
                
                // Add click event listener
                btn.addEventListener('click', async function() {
                  let finalCustomerName = customerName;
                  
                  // If we have a customer ID but no name, try to get it from Firebase
                  if (finalCustomerName === 'Customer' && customerId) {
                    try {
                      finalCustomerName = await getCustomerName(customerId);
                    } catch (e) {
                      console.log('Could not fetch customer name, using default');
                    }
                  }
                  
                  openChatWithCustomer(customerId, finalCustomerName);
                });
                
                // Insert button at the end of order-actions
                orderActions.appendChild(btn);
                
                // Force button to be visible with inline styles that override any CSS
                btn.style.cssText = `
                  display: flex !important;
                  visibility: visible !important;
                  height: auto !important;
                  min-height: 40px !important;
                  width: 100% !important;
                  background: linear-gradient(135deg, #4CAF50, #45a049) !important;
                  color: white !important;
                  border: none !important;
                  border-radius: 8px !important;
                  padding: 10px 16px !important;
                  font-size: 14px !important;
                  font-weight: 600 !important;
                  cursor: pointer !important;
                  margin-top: 12px !important;
                  box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3) !important;
                `;
                
                console.log(' Chat button added to order-actions for order:', id);
                
                // Watch for when order card is expanded and ensure button is visible
                const orderHeader = card.querySelector('.order-header');
                if (orderHeader) {
                  // Use MutationObserver to watch for collapsed class changes
                  const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                      if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                        const isCollapsed = orderDetails.classList.contains('collapsed');
                        if (!isCollapsed && btn.offsetHeight === 0) {
                          // Card was expanded but button still has 0 height - force it visible
                          btn.style.cssText += 'display: flex !important; visibility: visible !important; height: auto !important; min-height: 40px !important; width: 100% !important;';
                          console.log(' Button visibility forced after expansion for order:', id);
                        }
                      }
                    });
                  });
                  
                  // Observe the order details element for class changes
                  if (orderDetails) {
                    observer.observe(orderDetails, { attributes: true, attributeFilter: ['class'] });
                  }
                }
                
                // Verify the button was actually added and is visible
                setTimeout(() => {
                  const verifyBtn = orderActions.querySelector('.contact-customer-btn[data-order-id="' + id + '"]');
                  if (verifyBtn) {
                    console.log(' Chat button verified in DOM for order:', id);
                    const styles = window.getComputedStyle(verifyBtn);
                    console.log(' Button display:', styles.display, 'visibility:', styles.visibility, 'height:', verifyBtn.offsetHeight, 'width:', verifyBtn.offsetWidth);
                    console.log(' Button parent:', verifyBtn.parentElement?.className);
                    console.log(' Order details collapsed?', orderDetails?.classList.contains('collapsed'));
                    
                    // If button still has 0 height, force it to be visible again
                    if (verifyBtn.offsetHeight === 0) {
                      verifyBtn.style.cssText += 'display: flex !important; visibility: visible !important; height: auto !important; min-height: 40px !important; width: 100% !important;';
                      console.log(' Forced button visibility for order:', id);
                    }
                  } else {
                    console.warn(' Chat button NOT found in DOM after adding! Order:', id);
                  }
                }, 100);
              } else {
                console.log(' Chat button already exists for order:', id);
              }
            }
          } catch(e) { 
            console.warn(' Attach chat button failed', e); 
          }
        }
        // Install button into order cards by wrapping createOrderCard and createAssignedOrderCard
        // Adds chat button to: Pending, Confirmed, To Receive, Successful, Failed orders
        (function installChatButtonPatch(){
          let createOrderCardPatched = false;
          let createAssignedOrderCardPatched = false;
          let retryCount = 0;
          const maxRetries = 50; // 10 seconds max (50 * 200ms)
          
          function defer(){
            retryCount++;
            if (retryCount > maxRetries) {
              console.warn(' Chat button patch: Max retries reached');
              return;
            }
            
            if (!window.staffManager) {
              // Only log every 5 retries to reduce console spam
              if (retryCount % 5 === 0) {
                console.log(' Waiting for staffManager...', retryCount);
              }
              return setTimeout(defer, 100); // Reduced from 200ms to 100ms for faster initialization
            }
            
            // Patch loadPendingOrders to add buttons after it directly renders cards
            if (typeof window.staffManager.loadPendingOrders === 'function' && !window.staffManager.loadPendingOrders._chatButtonPatched) {
              const originalLoadPending = window.staffManager.loadPendingOrders.bind(window.staffManager);
              window.staffManager.loadPendingOrders = async function() {
                const result = await originalLoadPending.apply(this, arguments);
                
                // After loadPendingOrders finishes, add buttons to all pending order cards
                const staffMgr = this; // Save reference to staffManager
                const addButtonsToPendingCards = () => {
                  const container = document.getElementById('ordersContainer');
                  if (container) {
                    const cards = container.querySelectorAll('.order-card');
                    console.log(' loadPendingOrders: Found', cards.length, 'cards to add buttons to');
                    let buttonsAdded = 0;
                    cards.forEach(card => {
                      const orderDetailsEl = card.querySelector('[id^="order-details-"]');
                      if (orderDetailsEl) {
                        const orderId = orderDetailsEl.id.replace('order-details-', '');
                        const orderActions = orderDetailsEl.querySelector('.order-actions');
                        
                        // Check if button exists - if it does but has 0 height, remove it and re-add
                        const existingBtn = orderActions.querySelector('.contact-customer-btn');
                        if (existingBtn && existingBtn.offsetHeight === 0) {
                          console.log(' Found existing button with 0 height, removing and re-adding for order:', orderId);
                          existingBtn.remove();
                        }
                        
                        if (!orderActions.querySelector('.contact-customer-btn')) {
                          // Get order from cache
                          const order = staffMgr._ordersCache && staffMgr._ordersCache[orderId] ? staffMgr._ordersCache[orderId] : null;
                          const status = order ? String(order.status || '').toLowerCase().trim() : 'pending';
                          
                          if (status === 'pending') {
                            const customerId = order?.customerId || order?.customer_id || orderId;
                            const customerName = order?.customerName || order?.customer_name || order?.customer?.fullName || order?.customer?.name || 'Customer';
                            
                            // Create button element
                            const btn = document.createElement('button');
                            btn.className = 'contact-customer-btn';
                            btn.setAttribute('data-order-id', orderId);
                            btn.innerHTML = '<i class="fas fa-comments"></i> Contact Customer';
                            
                            // Force inline styles to ensure visibility - use explicit height/width
                            btn.style.cssText = 'display: flex !important; visibility: visible !important; height: 40px !important; min-height: 40px !important; width: 100% !important; max-width: 100% !important; background: linear-gradient(135deg, #4CAF50, #45a049) !important; color: white !important; border: none !important; border-radius: 8px !important; padding: 10px 16px !important; font-size: 14px !important; font-weight: 600 !important; cursor: pointer !important; margin-top: 12px !important; box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3) !important; align-items: center !important; justify-content: center !important; gap: 8px !important; box-sizing: border-box !important;';
                            
                            // Add click handler
                            btn.addEventListener('click', async function() {
                              let finalCustomerName = customerName;
                              if (finalCustomerName === 'Customer' && customerId) {
                                try {
                                  finalCustomerName = await getCustomerName(customerId);
                                } catch (e) {
                                  console.log('Could not fetch customer name, using default');
                                }
                              }
                              openChatWithCustomer(customerId, finalCustomerName);
                            });
                            
                            // Append to order-actions
                            orderActions.appendChild(btn);
                            buttonsAdded++;
                            console.log(' loadPendingOrders: Chat button added for order:', orderId);
                            
                            // Watch for when order-details expands and ensure button is visible
                            const isCollapsed = orderDetailsEl.classList.contains('collapsed');
                            if (isCollapsed) {
                              // Watch for when the section expands
                              const observer = new MutationObserver((mutations) => {
                                mutations.forEach((mutation) => {
                                  if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                                    const nowCollapsed = orderDetailsEl.classList.contains('collapsed');
                                    if (!nowCollapsed) {
                                      // Section expanded - wait for transition to complete (0.3s) then force button visible
                                      setTimeout(() => {
                                        // First, ensure parent order-details is fully expanded (remove max-height restriction)
                                        if (orderDetailsEl) {
                                          orderDetailsEl.style.cssText += 'max-height: none !important; overflow: visible !important; padding: 20px !important;';
                                        }
                                        
                                        // Also ensure parent order-actions is visible
                                        if (orderActions) {
                                          orderActions.style.cssText += 'display: flex !important; visibility: visible !important; overflow: visible !important; max-height: none !important;';
                                        }
                                        
                                        // Force button to be visible with all possible overrides
                                        btn.style.cssText = 'display: flex !important; visibility: visible !important; height: 40px !important; min-height: 40px !important; width: 100% !important; max-width: 100% !important; background: linear-gradient(135deg, #4CAF50, #45a049) !important; color: white !important; border: none !important; border-radius: 8px !important; padding: 10px 16px !important; font-size: 14px !important; font-weight: 600 !important; cursor: pointer !important; margin-top: 12px !important; box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3) !important; align-items: center !important; justify-content: center !important; gap: 8px !important; box-sizing: border-box !important; opacity: 1 !important; position: relative !important; z-index: 10 !important;';
                                        
                                        console.log(' loadPendingOrders: Forced button visibility after expansion for order:', orderId, 'height:', btn.offsetHeight, 'orderDetails maxHeight:', window.getComputedStyle(orderDetailsEl).maxHeight);
                                      }, 350); // Wait for 0.3s transition + 50ms buffer
                                    }
                                  }
                                });
                              });
                              observer.observe(orderDetailsEl, { attributes: true, attributeFilter: ['class'] });
                            } else {
                              // Section is already expanded - ensure button is visible immediately
                              setTimeout(() => {
                                // Ensure parent order-details is fully expanded
                                if (orderDetailsEl) {
                                  orderDetailsEl.style.cssText += 'max-height: none !important; overflow: visible !important; padding: 20px !important;';
                                }
                                
                                // Ensure parent order-actions is visible
                                if (orderActions) {
                                  orderActions.style.cssText += 'display: flex !important; visibility: visible !important; overflow: visible !important; max-height: none !important;';
                                }
                                
                                btn.style.cssText = 'display: flex !important; visibility: visible !important; height: 40px !important; min-height: 40px !important; width: 100% !important; max-width: 100% !important; background: linear-gradient(135deg, #4CAF50, #45a049) !important; color: white !important; border: none !important; border-radius: 8px !important; padding: 10px 16px !important; font-size: 14px !important; font-weight: 600 !important; cursor: pointer !important; margin-top: 12px !important; box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3) !important; align-items: center !important; justify-content: center !important; gap: 8px !important; box-sizing: border-box !important; opacity: 1 !important; position: relative !important; z-index: 10 !important;';
                                console.log(' loadPendingOrders: Forced button visibility (already expanded) for order:', orderId, 'height:', btn.offsetHeight, 'orderDetails maxHeight:', window.getComputedStyle(orderDetailsEl).maxHeight);
                              }, 100);
                            }
                            
                            // Force button to be visible by checking after a delay
                            setTimeout(() => {
                              const verifyBtn = orderActions.querySelector('.contact-customer-btn[data-order-id="' + orderId + '"]');
                              if (verifyBtn) {
                                const styles = window.getComputedStyle(verifyBtn);
                                const isParentCollapsed = orderDetailsEl.classList.contains('collapsed');
                                if (verifyBtn.offsetHeight === 0 && !isParentCollapsed) {
                                  // Button still has 0 height but parent is expanded - force it visible
                                  verifyBtn.style.cssText += 'height: 40px !important; min-height: 40px !important; display: flex !important; visibility: visible !important;';
                                  console.log(' Forced button visibility for order:', orderId);
                                } else {
                                  console.log(' Verified button for order:', orderId, 'display:', styles.display, 'height:', verifyBtn.offsetHeight, 'parent collapsed:', isParentCollapsed);
                                }
                              } else {
                                console.warn(' Button NOT found after adding for order:', orderId);
                              }
                            }, 100);
                          }
                        }
                      }
                    });
                    console.log(' loadPendingOrders: Added', buttonsAdded, 'chat buttons total');
                  }
                };
                
                // Try multiple times to ensure buttons are added
                setTimeout(addButtonsToPendingCards, 100);
                setTimeout(addButtonsToPendingCards, 300);
                setTimeout(addButtonsToPendingCards, 500);
                
                // Fix for confirm button - ensure all confirm buttons are clickable
                setTimeout(() => {
                  const container = document.getElementById('ordersContainer');
                  if (container) {
                    const orderCards = container.querySelectorAll('.order-card');
                    orderCards.forEach(card => {
                      const orderDetails = card.querySelector('[id^="order-details-"]');
                      if (orderDetails) {
                        const orderActions = orderDetails.querySelector('.order-actions');
                        if (orderActions) {
                          const buttons = orderActions.querySelectorAll('button');
                          buttons.forEach((button, index) => {
                            const text = (button.textContent || '').toLowerCase();
                            // Fix confirm button (usually first button or contains "confirm")
                            if (text.includes('confirm') || index === 0) {
                              button.style.cssText += 'position: relative !important; z-index: 100 !important; pointer-events: auto !important; cursor: pointer !important;';
                              // Also ensure the button's parent doesn't block clicks
                              if (button.parentElement) {
                                button.parentElement.style.cssText += 'position: relative !important; z-index: 1 !important; pointer-events: auto !important;';
                              }
                            }
                          });
                        }
                      }
                    });
                  }
                }, 600);
                
                return result;
              };
              window.staffManager.loadPendingOrders._chatButtonPatched = true;
              console.log(' Patched loadPendingOrders for chat button');
            }
            
            // Patch createOrderCard (for Pending tab) - CRITICAL FOR PENDING ORDERS
            if (typeof window.staffManager.createOrderCard === 'function') {
              // Check if already patched (avoid re-patching)
              if (!window.staffManager.createOrderCard._chatButtonPatched) {
            const original = window.staffManager.createOrderCard.bind(window.staffManager);
            window.staffManager.createOrderCard = function(id, order){
              const card = original(id, order);
                  
                  // Add button immediately after card is created
                  const status = String(order?.status || '').toLowerCase().trim();
                  const statusesWithChat = ['pending', 'confirmed', 'to_receive', 'to receive', 'out_for_delivery', 'out for delivery', 'delivered', 'picked_up', 'pickedup', 'picked up', 'failed'];
                  const shouldShow = statusesWithChat.some(s => status.includes(s) || status === s);
                  
                  if (shouldShow) {
                    // Use setTimeout to ensure DOM is fully parsed
                    setTimeout(() => {
                      const orderDetails = card.querySelector('#order-details-' + id);
                      const orderActions = orderDetails ? orderDetails.querySelector('.order-actions') : null;
                      
                      if (orderActions && !orderActions.querySelector('.contact-customer-btn')) {
                        const customerId = order?.customerId || order?.customer_id || id;
                        const customerName = order?.customerName || order?.customer_name || order?.customer?.fullName || order?.customer?.name || 'Customer';
                        
                        // Create button element
                        const btn = document.createElement('button');
                        btn.className = 'contact-customer-btn';
                        btn.setAttribute('data-order-id', id);
                        btn.innerHTML = '<i class="fas fa-comments"></i> Contact Customer';
                        
                        // Force inline styles to ensure visibility
                        btn.style.cssText = 'display: flex !important; visibility: visible !important; height: auto !important; min-height: 40px !important; width: 100% !important; background: linear-gradient(135deg, #4CAF50, #45a049) !important; color: white !important; border: none !important; border-radius: 8px !important; padding: 10px 16px !important; font-size: 14px !important; font-weight: 600 !important; cursor: pointer !important; margin-top: 12px !important; box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3) !important; align-items: center !important; justify-content: center !important; gap: 8px !important;';
                        
                        // Add click handler
                        btn.addEventListener('click', async function() {
                          let finalCustomerName = customerName;
                          if (finalCustomerName === 'Customer' && customerId) {
                            try {
                              finalCustomerName = await getCustomerName(customerId);
                            } catch (e) {
                              console.log('Could not fetch customer name, using default');
                            }
                          }
                          openChatWithCustomer(customerId, finalCustomerName);
                        });
                        
                        // Append to order-actions
                        orderActions.appendChild(btn);
                        console.log(' Chat button added to order-actions for order:', id, 'status:', status);
                        console.log(' Button element:', btn);
                        console.log(' Button parent:', btn.parentElement);
                        console.log(' Button offsetHeight:', btn.offsetHeight, 'offsetWidth:', btn.offsetWidth);
                        
                        // Fix for confirm button - ensure it's clickable
                        setTimeout(() => {
                          const buttons = orderActions.querySelectorAll('button');
                          buttons.forEach((button, index) => {
                            const text = (button.textContent || '').toLowerCase();
                            if (text.includes('confirm') || index === 0) {
                              button.style.cssText += 'position: relative !important; z-index: 100 !important; pointer-events: auto !important; cursor: pointer !important;';
                              if (button.parentElement) {
                                button.parentElement.style.cssText += 'position: relative !important; z-index: 1 !important; pointer-events: auto !important;';
                              }
                            }
                          });
                        }, 100);
                      }
                    }, 50);
                  }
                  
                  return card;
                };
                window.staffManager.createOrderCard._chatButtonPatched = true;
                createOrderCardPatched = true;
                console.log(' Patched createOrderCard for chat button (Pending orders)');
              }
            } else {
              if (retryCount % 5 === 0) { // Log every 5 retries to avoid spam
                console.log(' createOrderCard not available yet...', retryCount);
              }
            }
            
            // Also patch renderPendingOrdersFromObject to ensure button is added after cards are appended
            if (typeof window.renderPendingOrdersFromObject === 'function' && !window.renderPendingOrdersFromObject._chatButtonPatched) {
              const originalRender = window.renderPendingOrdersFromObject;
              window.renderPendingOrdersFromObject = function(orders) {
                const result = originalRender.apply(this, arguments);
                // After rendering, add buttons to all cards - use multiple attempts to ensure it works
                const addButtonsToCards = () => {
                  const container = document.getElementById('ordersContainer');
                  if (container) {
                    const cards = container.querySelectorAll('.order-card');
                    console.log(' renderPendingOrdersFromObject: Found', cards.length, 'cards to add buttons to');
                    let buttonsAdded = 0;
                    cards.forEach(card => {
                      const orderDetailsEl = card.querySelector('[id^="order-details-"]');
                      if (orderDetailsEl) {
                        const orderId = orderDetailsEl.id.replace('order-details-', '');
                        if (orderId && orders && orders[orderId]) {
                          const order = orders[orderId];
                          const status = String(order?.status || '').toLowerCase().trim();
                          
                          // Check if button already exists - if it has 0 height, remove and re-add
                          const existingBtn = card.querySelector('.contact-customer-btn[data-order-id="' + orderId + '"]');
                          if (existingBtn && existingBtn.offsetHeight === 0) {
                            console.log(' renderPendingOrdersFromObject: Found existing button with 0 height, removing and re-adding for order:', orderId);
                            existingBtn.remove();
                          }
                          
                          if (!card.querySelector('.contact-customer-btn[data-order-id="' + orderId + '"]') && status === 'pending') {
                            console.log(' renderPendingOrdersFromObject: Adding chat button to card for order:', orderId);
                            
                            const orderActions = orderDetailsEl.querySelector('.order-actions');
                            if (orderActions) {
                              const customerId = order?.customerId || order?.customer_id || orderId;
                              const customerName = order?.customerName || order?.customer_name || order?.customer?.fullName || order?.customer?.name || 'Customer';
                              
                              // Create button element
                  const btn = document.createElement('button');
                  btn.className = 'contact-customer-btn';
                              btn.setAttribute('data-order-id', orderId);
                  btn.innerHTML = '<i class="fas fa-comments"></i> Contact Customer';
                              
                              // Force inline styles to ensure visibility - use explicit height
                              btn.style.cssText = 'display: flex !important; visibility: visible !important; height: 40px !important; min-height: 40px !important; width: 100% !important; max-width: 100% !important; background: linear-gradient(135deg, #4CAF50, #45a049) !important; color: white !important; border: none !important; border-radius: 8px !important; padding: 10px 16px !important; font-size: 14px !important; font-weight: 600 !important; cursor: pointer !important; margin-top: 12px !important; box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3) !important; align-items: center !important; justify-content: center !important; gap: 8px !important; box-sizing: border-box !important;';
                    
                              // Add click handler
                              btn.addEventListener('click', async function() {
                                let finalCustomerName = customerName;
                                if (finalCustomerName === 'Customer' && customerId) {
                      try {
                                    finalCustomerName = await getCustomerName(customerId);
                      } catch (e) {
                        console.log('Could not fetch customer name, using default');
                      }
                    }
                                openChatWithCustomer(customerId, finalCustomerName);
                              });
                              
                              // Append to order-actions
                              orderActions.appendChild(btn);
                              buttonsAdded++;
                              console.log(' renderPendingOrdersFromObject: Chat button added for order:', orderId);
                              
                              // Watch for when order-details expands and ensure button is visible
                              const isCollapsed = orderDetailsEl.classList.contains('collapsed');
                              if (isCollapsed) {
                                // Watch for when the section expands
                                const observer = new MutationObserver((mutations) => {
                                  mutations.forEach((mutation) => {
                                    if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                                      const nowCollapsed = orderDetailsEl.classList.contains('collapsed');
                                      if (!nowCollapsed) {
                                        // Section expanded - wait for transition to complete (0.3s) then force button visible
                                        setTimeout(() => {
                                          // First, ensure parent order-details is fully expanded (remove max-height restriction)
                                          if (orderDetailsEl) {
                                            orderDetailsEl.style.cssText += 'max-height: none !important; overflow: visible !important; padding: 20px !important;';
                                          }
                                          
                                          // Also ensure parent order-actions is visible
                                          if (orderActions) {
                                            orderActions.style.cssText += 'display: flex !important; visibility: visible !important; overflow: visible !important; max-height: none !important;';
                                          }
                                          
                                          // Force button to be visible with all possible overrides
                                          btn.style.cssText = 'display: flex !important; visibility: visible !important; height: 40px !important; min-height: 40px !important; width: 100% !important; max-width: 100% !important; background: linear-gradient(135deg, #4CAF50, #45a049) !important; color: white !important; border: none !important; border-radius: 8px !important; padding: 10px 16px !important; font-size: 14px !important; font-weight: 600 !important; cursor: pointer !important; margin-top: 12px !important; box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3) !important; align-items: center !important; justify-content: center !important; gap: 8px !important; box-sizing: border-box !important; opacity: 1 !important; position: relative !important; z-index: 10 !important;';
                                          
                                          console.log(' renderPendingOrdersFromObject: Forced button visibility after expansion for order:', orderId, 'height:', btn.offsetHeight, 'orderDetails maxHeight:', window.getComputedStyle(orderDetailsEl).maxHeight);
                                        }, 350); // Wait for 0.3s transition + 50ms buffer
                                      }
                                    }
                                  });
                                });
                                observer.observe(orderDetailsEl, { attributes: true, attributeFilter: ['class'] });
                              } else {
                                // Section is already expanded - ensure button is visible immediately
                                setTimeout(() => {
                                  // Ensure parent order-details is fully expanded
                                  if (orderDetailsEl) {
                                    orderDetailsEl.style.cssText += 'max-height: none !important; overflow: visible !important; padding: 20px !important;';
                                  }
                                  
                                  // Ensure parent order-actions is visible
                                  if (orderActions) {
                                    orderActions.style.cssText += 'display: flex !important; visibility: visible !important; overflow: visible !important; max-height: none !important;';
                                  }
                                  
                                  btn.style.cssText = 'display: flex !important; visibility: visible !important; height: 40px !important; min-height: 40px !important; width: 100% !important; max-width: 100% !important; background: linear-gradient(135deg, #4CAF50, #45a049) !important; color: white !important; border: none !important; border-radius: 8px !important; padding: 10px 16px !important; font-size: 14px !important; font-weight: 600 !important; cursor: pointer !important; margin-top: 12px !important; box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3) !important; align-items: center !important; justify-content: center !important; gap: 8px !important; box-sizing: border-box !important; opacity: 1 !important; position: relative !important; z-index: 10 !important;';
                                  console.log(' renderPendingOrdersFromObject: Forced button visibility (already expanded) for order:', orderId, 'height:', btn.offsetHeight, 'orderDetails maxHeight:', window.getComputedStyle(orderDetailsEl).maxHeight);
                                }, 100);
                              }
                              
                              // Also verify after a delay - check if button is visible when expanded
                              setTimeout(() => {
                                const isParentCollapsed = orderDetailsEl.classList.contains('collapsed');
                                if (btn.offsetHeight === 0 && !isParentCollapsed) {
                                  // Button has 0 height but parent is expanded - force it visible
                                  btn.style.cssText += 'height: 40px !important; min-height: 40px !important; display: flex !important; visibility: visible !important;';
                                  console.log(' renderPendingOrdersFromObject: Forced button visibility for order:', orderId, 'parent collapsed:', isParentCollapsed);
                                } else if (btn.offsetHeight > 0) {
                                  console.log(' renderPendingOrdersFromObject: Button is visible for order:', orderId, 'height:', btn.offsetHeight, 'parent collapsed:', isParentCollapsed);
                                } else {
                                  console.log(' renderPendingOrdersFromObject: Button hidden (parent collapsed) for order:', orderId);
                                }
                              }, 200);
                            }
                          }
                        }
                      }
                    });
                    console.log(' renderPendingOrdersFromObject: Added', buttonsAdded, 'chat buttons total');
                  }
                };
                
                // Try multiple times to ensure buttons are added after DOM is ready
                setTimeout(addButtonsToCards, 100);
                setTimeout(addButtonsToCards, 250);
                setTimeout(addButtonsToCards, 500);
                
                return result;
              };
              window.renderPendingOrdersFromObject._chatButtonPatched = true;
              console.log(' Patched renderPendingOrdersFromObject for chat button');
            }
            
            // Also watch the ordersContainer for changes and add buttons when cards are added
            const setupMutationObserver = () => {
              const ordersContainer = document.getElementById('ordersContainer');
              if (ordersContainer && !ordersContainer._chatButtonObserver) {
                const observer = new MutationObserver((mutations) => {
                  mutations.forEach((mutation) => {
                    if (mutation.addedNodes.length > 0) {
                      mutation.addedNodes.forEach((node) => {
                        if (node.nodeType === 1 && node.classList && node.classList.contains('order-card')) {
                          // New order card added - find the order ID and add button
                          setTimeout(() => {
                            const orderDetailsEl = node.querySelector('[id^="order-details-"]');
                            if (orderDetailsEl) {
                              const orderId = orderDetailsEl.id.replace('order-details-', '');
                              const orderActions = orderDetailsEl.querySelector('.order-actions');
                              
                              if (orderActions && !orderActions.querySelector('.contact-customer-btn')) {
                                // Try to get order data from staffManager cache
                                let order = null;
                                if (window.staffManager && window.staffManager._ordersCache && window.staffManager._ordersCache[orderId]) {
                                  order = window.staffManager._ordersCache[orderId];
                                }
                                
                                // Fallback: check status from DOM
                                const orderStatus = node.querySelector('.order-status')?.textContent?.toLowerCase() || '';
                                if (orderStatus.includes('pending')) {
                                  if (!order) {
                                    // Extract customer info from card if available
                                    const customerInfo = orderDetailsEl.querySelector('.order-info p')?.textContent || '';
                                    const customerName = customerInfo.includes('Customer:') ? customerInfo.split('Customer:')[1]?.trim() : 'Customer';
                                    order = { status: 'pending', customerId: orderId, customerName: customerName };
                                  }
                                  
                                  // Add button directly (same as renderPendingOrdersFromObject)
                                  const customerId = order?.customerId || order?.customer_id || orderId;
                                  const customerName = order?.customerName || order?.customer_name || order?.customer?.fullName || order?.customer?.name || 'Customer';
                                  
                                  const btn = document.createElement('button');
                                  btn.className = 'contact-customer-btn';
                                  btn.setAttribute('data-order-id', orderId);
                                  btn.innerHTML = '<i class="fas fa-comments"></i> Contact Customer';
                                  btn.style.cssText = 'display: flex !important; visibility: visible !important; height: auto !important; min-height: 40px !important; width: 100% !important; background: linear-gradient(135deg, #4CAF50, #45a049) !important; color: white !important; border: none !important; border-radius: 8px !important; padding: 10px 16px !important; font-size: 14px !important; font-weight: 600 !important; cursor: pointer !important; margin-top: 12px !important; box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3) !important; align-items: center !important; justify-content: center !important; gap: 8px !important;';
                                  
                                  // Fix for confirm button - ensure it's clickable
                                  setTimeout(() => {
                                    const orderActions = orderDetailsEl.querySelector('.order-actions');
                                    if (orderActions) {
                                      const buttons = orderActions.querySelectorAll('button');
                                      buttons.forEach((button, index) => {
                                        const text = (button.textContent || '').toLowerCase();
                                        if (text.includes('confirm') || index === 0) {
                                          button.style.cssText += 'position: relative !important; z-index: 100 !important; pointer-events: auto !important; cursor: pointer !important;';
                                        }
                                      });
                                    }
                                  }, 100);
                                  
                                  btn.addEventListener('click', async function() {
                                    let finalCustomerName = customerName;
                                    if (finalCustomerName === 'Customer' && customerId) {
                                      try {
                                        finalCustomerName = await getCustomerName(customerId);
                                      } catch (e) {
                                        console.log('Could not fetch customer name, using default');
                                      }
                                    }
                                    openChatWithCustomer(customerId, finalCustomerName);
                                  });
                                  
                                  orderActions.appendChild(btn);
                                  console.log(' MutationObserver: Chat button added for order:', orderId);
                                }
                              }
                            }
                          }, 100);
                        }
                      });
                    }
                  });
                });
                
                observer.observe(ordersContainer, { childList: true, subtree: true });
                ordersContainer._chatButtonObserver = observer;
                console.log(' Added MutationObserver for ordersContainer to watch for new cards');
              } else if (!ordersContainer) {
                // Container not ready yet, retry
                setTimeout(setupMutationObserver, 200);
              }
            };
            
            // Set up observer when container is ready
            if (document.readyState === 'loading') {
              document.addEventListener('DOMContentLoaded', setupMutationObserver);
            } else {
              setupMutationObserver();
            }
            
            // Patch createAssignedOrderCard (for Confirmed, To Receive, Successful, Failed tabs)
            if (typeof window.staffManager.createAssignedOrderCard === 'function') {
              // Check if already patched (avoid re-patching)
              if (!window.staffManager.createAssignedOrderCard._chatButtonPatched) {
                const originalAssigned = window.staffManager.createAssignedOrderCard.bind(window.staffManager);
                window.staffManager.createAssignedOrderCard = function(id, order){
                  const card = originalAssigned(id, order);
                  addChatButtonToCard(card, id, order);
              return card;
            };
                window.staffManager.createAssignedOrderCard._chatButtonPatched = true;
                createAssignedOrderCardPatched = true;
                console.log(' Patched createAssignedOrderCard for chat button');
              }
            }
            
            // Keep retrying until createOrderCard is patched (critical for pending orders)
            // createAssignedOrderCard is optional (may not exist in all contexts)
            if (!createOrderCardPatched) {
              return setTimeout(defer, 200);
            } else {
              if (createAssignedOrderCardPatched) {
                console.log(' All chat button patches applied successfully!');
              } else {
                console.log(' createOrderCard patched (Pending orders ready). createAssignedOrderCard will be patched when available.');
                // Still try to patch createAssignedOrderCard if it becomes available later
                setTimeout(defer, 1000);
              }
            }
          }
          
          // Start patching immediately
          defer();
          
          // Also try on DOMContentLoaded in case staff.js loads after
          if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', defer);
          }
          
          // Also try when window is fully loaded
          window.addEventListener('load', defer);
        })();

        wireEvents();
      })();
    </script>
    
    <!-- Language Translation System -->
    <script>
        // Language Translation System
        const translations = {
            en: {
                systemSettings: "System Settings",
                darkMode: "Dark Mode",
                darkModeDesc: "Toggle dark mode on/off",
                language: "Language",
                languageDesc: "Select your preferred language",
                dashboard: "Dashboard",
                orders: "Orders",
                products: "Products",
                farmers: "Farmers",
                customers: "Customers",
                riders: "Riders",
                staff: "Staff",
                settings: "Settings",
                profile: "Profile",
                logout: "Logout",
                welcome: "Welcome",
                totalOrders: "Total Orders",
                totalRevenue: "Total Revenue",
                activeUsers: "Active Users",
                pendingDeliveries: "Pending Deliveries",
                search: "Search",
                filter: "Filter",
                export: "Export",
                add: "Add",
                edit: "Edit",
                delete: "Delete",
                save: "Save",
                cancel: "Cancel",
                confirm: "Confirm",
                yes: "Yes",
                no: "No",
                loading: "Loading",
                success: "Success",
                error: "Error",
                warning: "Warning"
            },
            tl: {
                systemSettings: "Mga Setting ng System",
                darkMode: "Dark Mode",
                darkModeDesc: "I-on o i-off ang dark mode",
                language: "Wika",
                languageDesc: "Piliin ang iyong gustong wika",
                dashboard: "Dashboard",
                orders: "Mga Order",
                products: "Mga Produkto",
                farmers: "Mga Magsasaka",
                customers: "Mga Kostumer",
                riders: "Mga Rider",
                staff: "Mga Staff",
                settings: "Mga Setting",
                profile: "Profile",
                logout: "Mag-logout",
                welcome: "Maligayang pagdating",
                totalOrders: "Kabuuang Orders",
                totalRevenue: "Kabuuang Kita",
                activeUsers: "Aktibong Users",
                pendingDeliveries: "Naghihintay na Delivery",
                search: "Maghanap",
                filter: "I-filter",
                export: "I-export",
                add: "Magdagdag",
                edit: "I-edit",
                delete: "Tanggalin",
                save: "I-save",
                cancel: "Kanselahin",
                confirm: "Kumpirmahin",
                yes: "Oo",
                no: "Hindi",
                loading: "Naglo-load",
                success: "Tagumpay",
                error: "Error",
                warning: "Babala"
            },
            ceb: {
                systemSettings: "Mga Setting sa Sistema",
                darkMode: "Dark Mode",
                darkModeDesc: "I-on o i-off ang dark mode",
                language: "Pinulongan",
                languageDesc: "Pilia ang imong gusto nga pinulongan",
                dashboard: "Dashboard",
                orders: "Mga Order",
                products: "Mga Produkto",
                farmers: "Mga Mag-uuma",
                customers: "Mga Kustomer",
                riders: "Mga Rider",
                staff: "Mga Staff",
                settings: "Mga Setting",
                profile: "Profile",
                logout: "Pag-logout",
                welcome: "Maayong pag-abot",
                totalOrders: "Tibuok nga Orders",
                totalRevenue: "Tibuok nga Kita",
                activeUsers: "Aktibong Users",
                pendingDeliveries: "Naghulat nga Delivery",
                search: "Pangita",
                filter: "I-filter",
                export: "I-export",
                add: "Idugang",
                edit: "I-edit",
                delete: "Tangtanga",
                save: "I-save",
                cancel: "Kanselahon",
                confirm: "Kumpirmahon",
                yes: "Oo",
                no: "Dili",
                loading: "Nag-load",
                success: "Malampuson",
                error: "Error",
                warning: "Pahimangno"
            }
        };

        function changeLanguage(lang) {
            // Save language preference
            localStorage.setItem('language', lang);
            
            // Apply translations
            applyTranslations(lang);
            
            // Show notification
            const langNames = { en: 'English', tl: 'Tagalog', ceb: 'Cebuano' };
            showNotification(`Language changed to ${langNames[lang]}`, 'success');
        }

        function applyTranslations(lang) {
            const translation = translations[lang] || translations.en;
            
            // Translate all elements with data-translate attribute
            document.querySelectorAll('[data-translate]').forEach(element => {
                const key = element.getAttribute('data-translate');
                if (translation[key]) {
                    element.textContent = translation[key];
                }
            });
        }

        function initializeLanguage() {
            // Get saved language or default to English
            const savedLang = localStorage.getItem('language') || 'en';
            
            // Set the select value
            const languageSelect = document.getElementById('languageSelect');
            if (languageSelect) {
                languageSelect.value = savedLang;
            }
            
            // Apply translations
            applyTranslations(savedLang);
        }

        // Initialize language on page load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeLanguage);
        } else {
            initializeLanguage();
        }

        // Initialize dark mode toggle on page load
        function initializeDarkMode() {
            const darkModeToggle = document.getElementById('darkModeToggle');
            const savedDarkMode = localStorage.getItem('darkMode') === 'true';
            
            if (darkModeToggle) {
                darkModeToggle.checked = savedDarkMode;
            }
            
            // Apply saved theme
            if (savedDarkMode) {
                applyTheme('dark');
            } else {
                applyTheme('light');
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeDarkMode);
        } else {
            initializeDarkMode();
        }

        // Contact Support Settings Functions
        async function loadContactSupportSettings() {
            try {
                const supabase = typeof window.getSupabaseClient === 'function'
                    ? window.getSupabaseClient()
                    : (window.supabaseClient || null);

                if (!supabase) {
                    throw new Error('Supabase client not available');
                }

                // Load contact support settings from system_data table
                const { data, error } = await supabase
                    .from('system_data')
                    .select('support_email, support_phone')
                    .eq('id', 'contactSupport')
                    .maybeSingle();

                if (error) {
                    console.error('Error loading contact support settings:', error);
                    // Set default values if record doesn't exist
                    document.getElementById('supportEmail').value = 'calcoacoop@gmail.com';
                    document.getElementById('supportPhone').value = '+63 123 456 7890';
                    return;
                }

                if (data) {
                    document.getElementById('supportEmail').value = data.support_email || 'calcoacoop@gmail.com';
                    document.getElementById('supportPhone').value = data.support_phone || '+63 123 456 7890';
                } else {
                    // No record found, set defaults
                    document.getElementById('supportEmail').value = 'calcoacoop@gmail.com';
                    document.getElementById('supportPhone').value = '+63 123 456 7890';
                }
            } catch (error) {
                console.error('Error loading contact support settings:', error);
                showNotification('Failed to load contact settings', 'error');
            }
        }

        // Format Philippine phone number
        function formatPhoneNumber(input) {
            let rawValue = input.value;
            const phoneHelp = document.getElementById('phoneHelp');
            
            // Handle +63 format with or without spaces
            // Check if user typed +63 0XXX (with the redundant 0)
            if (rawValue.match(/^\+63\s*0\d/)) {
                // Remove the 0 after +63
                rawValue = rawValue.replace(/(\+63)\s*0/, '$1 ');
                input.value = rawValue;
            }
            
            // Now process the cleaned value
            let value = rawValue.replace(/\D/g, ''); // Remove all non-digits
            
            // If starts with 630 (typed +63 0XXX), remove the 0
            if (value.startsWith('630') && value.length === 12) {
                value = value.replace(/^630/, '63'); // Remove the 0
            }
            
            // If starts with 63, format as +63 9XX XXX XXXX (without the 0)
            if (value.startsWith('63') && value.length === 12) {
                value = '+' + value;
                input.value = value.replace(/(\+63)(\d{3})(\d{3})(\d{4})/, '$1 $2 $3 $4');
                phoneHelp.style.color = '#4caf50';
                phoneHelp.textContent = ' Valid Philippine mobile number (+63 format)';
                return;
            }
            
            // If starts with 0, format as 0917 123 4567 (local format with spaces)
            if (value.startsWith('0') && value.length === 11) {
                input.value = value.replace(/(\d{4})(\d{3})(\d{4})/, '$1 $2 $3');
                phoneHelp.style.color = '#4caf50';
                phoneHelp.textContent = ' Valid Philippine mobile number (will be saved as +63 format)';
                return;
            }
            
            // If starts with 9 (without 0), assume they mean 09, format with spaces
            if (value.startsWith('9') && value.length === 10) {
                value = '0' + value;
                input.value = value.replace(/(\d{4})(\d{3})(\d{4})/, '$1 $2 $3');
                phoneHelp.style.color = '#4caf50';
                phoneHelp.textContent = ' Valid Philippine mobile number (will be saved as +63 format)';
                return;
            }
            
            // Show error for invalid format
            if (value.length > 0 && value.length < 10) {
                phoneHelp.style.color = '#f44336';
                phoneHelp.textContent = ' Please enter 11 digits (e.g., 0917 123 4567)';
            } else if (value.length === 0) {
                phoneHelp.style.color = '#666';
                phoneHelp.textContent = 'Enter 11-digit Philippine mobile number (e.g., 0917 123 4567)';
            }
        }

        // Validate Philippine phone number
        function validatePhilippinePhone(phone) {
            const cleaned = phone.replace(/\D/g, '');
            
            // Check if it's 11 digits starting with 0
            if (/^0\d{10}$/.test(cleaned)) {
                return '+63' + cleaned.substring(1); // Convert to +63 format
            }
            
            // Check if it's 12 digits starting with 63
            if (/^63\d{10}$/.test(cleaned)) {
                return '+' + cleaned; // Add + prefix
            }
            
            // Check if already in +63 format
            if (/^\+63\d{10}$/.test(phone.replace(/\s/g, ''))) {
                return phone.replace(/\s/g, ''); // Remove spaces
            }
            
            return null; // Invalid format
        }

        async function saveContactSupportSettings() {
            try {
                const supportEmail = document.getElementById('supportEmail').value.trim();
                let supportPhone = document.getElementById('supportPhone').value.trim();

                // Validate inputs
                if (!supportEmail || !supportPhone) {
                    showNotification('Please fill in both email and phone number', 'error');
                    return;
                }

                // Basic email validation
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                if (!emailRegex.test(supportEmail)) {
                    showNotification('Please enter a valid email address', 'error');
                    return;
                }

                // Validate and format phone number
                const formattedPhone = validatePhilippinePhone(supportPhone);
                if (!formattedPhone) {
                    showNotification('Please enter a valid 11-digit Philippine mobile number (e.g., 09171234567)', 'error');
                    return;
                }
                
                // Use the formatted phone number
                supportPhone = formattedPhone;

                const supabase = typeof window.getSupabaseClient === 'function'
                    ? window.getSupabaseClient()
                    : (window.supabaseClient || null);

                if (!supabase) {
                    throw new Error('Supabase client not available');
                }

                // Check if record exists
                const { data: existing } = await supabase
                    .from('system_data')
                    .select('id')
                    .eq('id', 'contactSupport')
                    .maybeSingle();

                const now = Date.now();

                if (existing) {
                    // Update existing record
                    const { error } = await supabase
                        .from('system_data')
                        .update({
                            support_email: supportEmail,
                            support_phone: supportPhone,
                            updated_at: now
                        })
                        .eq('id', 'contactSupport');

                    if (error) throw error;
                } else {
                    // Insert new record
                    const { error } = await supabase
                        .from('system_data')
                        .insert({
                            id: 'contactSupport',
                            support_email: supportEmail,
                            support_phone: supportPhone,
                            epoch_ms: now,
                            updated_at: now
                        });

                    if (error) throw error;
                }

                showNotification('Contact support settings saved successfully! Changes will reflect on customer app login.', 'success');
            } catch (error) {
                console.error('Error saving contact support settings:', error);
                showNotification('Failed to save contact settings: ' + error.message, 'error');
            }
        }

        // Load contact support settings on page load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', loadContactSupportSettings);
        } else {
            loadContactSupportSettings();
        }
    </script>

    <!-- URL Parameter Cleanup Script - Hide parameters from URL bar -->
    <!-- This script runs immediately to clean URL before page fully loads -->
    <script>
        // Run immediately (synchronously) before any other scripts
        (function() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const hashParams = new URLSearchParams(window.location.hash.substring(1));
                
                // Get parameters from URL
                const uid = urlParams.get('uid') || hashParams.get('uid');
                const role = urlParams.get('role') || hashParams.get('role');
                const username = urlParams.get('username') || hashParams.get('username');
                const email = urlParams.get('email') || hashParams.get('email');
                
                // If parameters exist in URL, store them in sessionStorage
                if (uid) {
                    sessionStorage.setItem('staffUid', uid);
                    sessionStorage.setItem('userUid', uid);
                }
                if (role) {
                    sessionStorage.setItem('staffRole', role);
                    sessionStorage.setItem('userRole', role);
                }
                if (username) {
                    const decodedUsername = decodeURIComponent(username);
                    sessionStorage.setItem('staffName', decodedUsername);
                    sessionStorage.setItem('username', decodedUsername);
                }
                if (email) {
                    const decodedEmail = decodeURIComponent(email);
                    sessionStorage.setItem('userEmail', decodedEmail);
                    sessionStorage.setItem('staffEmail', decodedEmail);
                }
                
                // Clean the URL by removing parameters (only if they existed)
                if (uid || role || username || email) {
                    // Get the base URL without parameters
                    const baseUrl = window.location.pathname;
                    
                    // Replace the URL without parameters using history API
                    // This removes the query string from the URL bar
                    window.history.replaceState(
                        { page: 'staff-dashboard' },
                        document.title,
                        baseUrl
                    );
                    
                    console.log(' URL parameters stored in sessionStorage and URL cleaned');
                    console.log('Stored values:', {
                        uid: uid || 'not provided',
                        role: role || 'not provided',
                        username: username ? decodeURIComponent(username) : 'not provided',
                        email: email ? decodeURIComponent(email) : 'not provided'
                    });
                }
            } catch (error) {
                console.error('Error cleaning URL parameters:', error);
            }
        })();
    </script>
    
    <!-- Migration Script: Add delivery_proof to all existing delivery orders -->
    <script>
        // Run migration on page load (only once)
        (function() {
            const migrationKey = 'delivery_proof_migration_completed';
            const migrationCompleted = sessionStorage.getItem(migrationKey);
            
            if (!migrationCompleted && window.FirebaseUtils && typeof window.FirebaseUtils.migrateDeliveryOrdersAddProofField === 'function') {
                console.log(' Running delivery_proof migration...');
                
                // Wait a bit for Firebase to be ready
                setTimeout(async () => {
                    try {
                        const result = await window.FirebaseUtils.migrateDeliveryOrdersAddProofField();
                        console.log(' Migration result:', result);
                        
                        // Mark migration as completed
                        sessionStorage.setItem(migrationKey, 'true');
                        
                        // Show notification if orders were updated
                        if (result.updated > 0) {
                            console.log(` Successfully added delivery_proof field to ${result.updated} delivery orders`);
                        }
                    } catch (error) {
                        console.error(' Migration error:', error);
                        // Don't mark as completed if it failed, so it can retry
                    }
                }, 2000); // Wait 2 seconds for Firebase to initialize
            } else if (migrationCompleted) {
                console.log(' Migration already completed in this session');
            }
        })();
    </script>

    <!-- Auto-add Change Password button to profile/settings menu -->
    <script>
        (function() {
            function addChangePasswordButton() {
                // Try to find common profile/settings dropdown menus
                const selectors = [
                    '.sidebar-profile .dropdown-menu',
                    '.profile-dropdown .dropdown-menu',
                    '.user-menu .dropdown-menu',
                    '.settings-menu',
                    '[class*="dropdown-menu"]',
                ];

                let menuFound = false;

                for (const selector of selectors) {
                    const menus = document.querySelectorAll(selector);
                    menus.forEach(menu => {
                        // Check if we already added the button
                        if (menu.querySelector('[data-password-update-btn]')) {
                            return;
                        }

                        // Create change password menu item
                        const passwordItem = document.createElement('div');
                        passwordItem.className = 'dropdown-item';
                        passwordItem.setAttribute('data-password-update-btn', 'true');
                        passwordItem.style.cssText = 'padding: 10px 16px; cursor: pointer; display: flex; align-items: center; gap: 10px; color: #1e293b; transition: background 0.2s ease;';
                        passwordItem.innerHTML = '<i class="fas fa-key" style="width: 16px; color: var(--brand);"></i> <span>Change Password</span>';
                        
                        passwordItem.addEventListener('click', function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            if (typeof window.openPasswordUpdateModal === 'function') {
                                window.openPasswordUpdateModal();
                            }
                            // Close dropdown if it has a toggle
                            const dropdown = menu.closest('[class*="dropdown"]');
                            if (dropdown) {
                                dropdown.classList.remove('show');
                            }
                        });

                        passwordItem.addEventListener('mouseenter', function() {
                            this.style.background = '#f1f5f9';
                        });
                        passwordItem.addEventListener('mouseleave', function() {
                            this.style.background = 'transparent';
                        });

                        // Insert before logout or at the end
                        const logoutItem = menu.querySelector('[class*="logout"], [onclick*="logout"], [onclick*="Logout"]');
                        if (logoutItem) {
                            menu.insertBefore(passwordItem, logoutItem);
                        } else {
                            menu.appendChild(passwordItem);
                        }

                        menuFound = true;
                    });
                }

                // If no menu found, create a standalone button in sidebar
                if (!menuFound) {
                    const sidebar = document.querySelector('.sidebar');
                    if (sidebar && !sidebar.querySelector('[data-password-update-btn]')) {
                        const passwordBtn = document.createElement('button');
                        passwordBtn.className = 'menu-item';
                        passwordBtn.setAttribute('data-password-update-btn', 'true');
                        passwordBtn.innerHTML = '<i class="fas fa-key"></i> <span>Change Password</span>';
                        passwordBtn.addEventListener('click', function() {
                            if (typeof window.openPasswordUpdateModal === 'function') {
                                window.openPasswordUpdateModal();
                            }
                        });

                        // Try to insert before logout or at the end of sidebar
                        const logoutBtn = sidebar.querySelector('[class*="logout"], [onclick*="logout"]');
                        if (logoutBtn) {
                            sidebar.insertBefore(passwordBtn, logoutBtn);
                        } else {
                            const sidebarContent = sidebar.querySelector('.sidebar-content') || sidebar;
                            sidebarContent.appendChild(passwordBtn);
                        }
                    }
                }
            }

            // Try to add button when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', function() {
                    setTimeout(addChangePasswordButton, 500);
                });
            } else {
                setTimeout(addChangePasswordButton, 500);
            }

            // Also try after a delay in case menus are created dynamically
            setTimeout(addChangePasswordButton, 2000);
            setTimeout(addChangePasswordButton, 5000);
        })();
    </script>

    <!-- Password Update Modal -->
    <div id="passwordUpdateModal" class="password-modal" style="display: none;">
        <div class="password-modal-content">
            <div class="password-modal-header">
                <h2><i class="fas fa-key"></i> Update Password</h2>
                <button class="password-modal-close" id="closePasswordModal">&times;</button>
            </div>
            <div class="password-modal-body">
                <form id="passwordUpdateForm">
                    <div class="password-form-group">
                        <label for="currentPassword">Current Password</label>
                        <div class="password-input-wrapper">
                            <input 
                                type="password" 
                                id="currentPassword" 
                                placeholder="Enter your current password"
                                required
                                autocomplete="current-password"
                            />
                            <button 
                                type="button" 
                                class="password-toggle-btn" 
                                data-target="currentPassword"
                                aria-label="Toggle password visibility"
                            >
                                <i class="fas fa-eye"></i>
                            </button>
                        </div>
                        <div class="password-error-text" id="currentPasswordError"></div>
                    </div>

                    <div class="password-form-group">
                        <label for="newPasswordProfile">New Password</label>
                        <div class="password-input-wrapper">
                            <input 
                                type="password" 
                                id="newPasswordProfile" 
                                placeholder="Enter your new password (min. 6 characters)"
                                required
                                autocomplete="new-password"
                                minlength="6"
                            />
                            <button 
                                type="button" 
                                class="password-toggle-btn" 
                                data-target="newPasswordProfile"
                                aria-label="Toggle password visibility"
                            >
                                <i class="fas fa-eye"></i>
                            </button>
                        </div>
                        <div class="password-error-text" id="newPasswordError"></div>
                    </div>

                    <div class="password-form-group">
                        <label for="confirmPasswordProfile">Confirm New Password</label>
                        <div class="password-input-wrapper">
                            <input 
                                type="password" 
                                id="confirmPasswordProfile" 
                                placeholder="Confirm your new password"
                                required
                                autocomplete="new-password"
                                minlength="6"
                            />
                            <button 
                                type="button" 
                                class="password-toggle-btn" 
                                data-target="confirmPasswordProfile"
                                aria-label="Toggle password visibility"
                            >
                                <i class="fas fa-eye"></i>
                            </button>
                        </div>
                        <div class="password-error-text" id="confirmPasswordError"></div>
                    </div>

                    <div class="password-modal-actions">
                        <button type="button" class="password-btn-cancel" id="cancelPasswordUpdate">Cancel</button>
                        <button type="submit" class="password-btn-update" id="confirmPasswordUpdate">
                            <i class="fas fa-check"></i> Update Password
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <style>
        /* Password Update Modal Styles */
        .password-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            backdrop-filter: blur(4px);
            animation: fadeIn 0.3s ease;
        }

        .password-modal-content {
            background: white;
            border-radius: 16px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from { 
                opacity: 0;
                transform: translateY(20px);
            }
            to { 
                opacity: 1;
                transform: translateY(0);
            }
        }

        .password-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 24px;
            border-bottom: 1px solid #e2e8f0;
        }

        .password-modal-header h2 {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
            color: #1e293b;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .password-modal-header h2 i {
            color: var(--brand);
        }

        .password-modal-close {
            background: none;
            border: none;
            font-size: 28px;
            color: #64748b;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            transition: all 0.2s ease;
        }

        .password-modal-close:hover {
            background: #f1f5f9;
            color: #1e293b;
        }

        .password-modal-body {
            padding: 24px;
        }

        .password-form-group {
            margin-bottom: 20px;
        }

        .password-form-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 500;
            color: #1e293b;
        }

        .password-input-wrapper {
            position: relative;
        }

        .password-input-wrapper input {
            width: 100%;
            padding: 12px 45px 12px 14px;
            border: 1px solid #cbd5e1;
            border-radius: 10px;
            font-size: 14px;
            transition: all 0.2s ease;
            background: white;
        }

        .password-input-wrapper input:focus {
            outline: none;
            border-color: var(--brand);
            box-shadow: 0 0 0 3px rgba(154, 208, 97, 0.1);
        }

        .password-input-wrapper input.invalid {
            border-color: #ef4444;
        }

        .password-toggle-btn {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #64748b;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .password-toggle-btn:hover {
            color: var(--brand);
            background: rgba(154, 208, 97, 0.1);
        }

        .password-error-text {
            color: #ef4444;
            font-size: 12px;
            margin-top: 6px;
            display: none;
        }

        .password-form-group.has-error .password-error-text {
            display: block;
        }

        .password-modal-actions {
            display: flex;
            gap: 12px;
            margin-top: 24px;
            justify-content: flex-end;
        }

        .password-btn-cancel,
        .password-btn-update {
            padding: 12px 24px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .password-btn-cancel {
            background: #f1f5f9;
            color: #64748b;
        }

        .password-btn-cancel:hover {
            background: #e2e8f0;
            color: #1e293b;
        }

        .password-btn-update {
            background: linear-gradient(135deg, var(--brand), var(--brand-strong));
            color: white;
            box-shadow: 0 4px 12px rgba(154, 208, 97, 0.3);
        }

        .password-btn-update:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(154, 208, 97, 0.4);
        }

        .password-btn-update:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .password-btn-update.loading {
            position: relative;
            color: transparent;
        }

        .password-btn-update.loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 18px;
            height: 18px;
            border: 2px solid white;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
    </style>

    <script>
        // Password Update Modal Functionality
        (function() {
            const modal = document.getElementById('passwordUpdateModal');
            const form = document.getElementById('passwordUpdateForm');
            const closeBtn = document.getElementById('closePasswordModal');
            const cancelBtn = document.getElementById('cancelPasswordUpdate');
            const updateBtn = document.getElementById('confirmPasswordUpdate');
            const currentPasswordInput = document.getElementById('currentPassword');
            const newPasswordInput = document.getElementById('newPasswordProfile');
            const confirmPasswordInput = document.getElementById('confirmPasswordProfile');
            
            // Password toggle buttons
            const toggleButtons = document.querySelectorAll('.password-toggle-btn');
            
            // Toggle password visibility
            toggleButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    const targetId = this.getAttribute('data-target');
                    const input = document.getElementById(targetId);
                    const icon = this.querySelector('i');
                    
                    if (input.type === 'password') {
                        input.type = 'text';
                        icon.classList.remove('fa-eye');
                        icon.classList.add('fa-eye-slash');
                    } else {
                        input.type = 'password';
                        icon.classList.remove('fa-eye-slash');
                        icon.classList.add('fa-eye');
                    }
                });
            });

            // Open modal function (can be called from profile dropdown)
            window.openPasswordUpdateModal = function() {
                if (modal) {
                    modal.style.display = 'flex';
                    // Reset form
                    form.reset();
                    clearErrors();
                }
            };

            // Close modal
            function closeModal() {
                if (modal) {
                    modal.style.display = 'none';
                    form.reset();
                    clearErrors();
                }
            }

            if (closeBtn) closeBtn.addEventListener('click', closeModal);
            if (cancelBtn) cancelBtn.addEventListener('click', closeModal);

            // Close on backdrop click
            if (modal) {
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        closeModal();
                    }
                });
            }

            // Clear error messages
            function clearErrors() {
                document.querySelectorAll('.password-error-text').forEach(el => {
                    el.textContent = '';
                    el.style.display = 'none';
                });
                document.querySelectorAll('.password-form-group').forEach(el => {
                    el.classList.remove('has-error');
                });
                document.querySelectorAll('.password-input-wrapper input').forEach(el => {
                    el.classList.remove('invalid');
                });
            }

            // Show error
            function showError(inputId, message) {
                const input = document.getElementById(inputId);
                const errorEl = document.getElementById(inputId + 'Error');
                const formGroup = input.closest('.password-form-group');
                
                if (input) input.classList.add('invalid');
                if (errorEl) {
                    errorEl.textContent = message;
                    errorEl.style.display = 'block';
                }
                if (formGroup) formGroup.classList.add('has-error');
            }

            // Validate form
            function validateForm() {
                let isValid = true;
                clearErrors();

                const currentPwd = currentPasswordInput.value.trim();
                const newPwd = newPasswordInput.value.trim();
                const confirmPwd = confirmPasswordInput.value.trim();

                if (!currentPwd) {
                    showError('currentPassword', 'Current password is required');
                    isValid = false;
                }

                if (!newPwd || newPwd.length < 6) {
                    showError('newPasswordProfile', 'New password must be at least 6 characters');
                    isValid = false;
                }

                if (newPwd !== confirmPwd) {
                    showError('confirmPasswordProfile', 'Passwords do not match');
                    isValid = false;
                }

                if (currentPwd && newPwd && currentPwd === newPwd) {
                    showError('newPasswordProfile', 'New password must be different from current password');
                    isValid = false;
                }

                return isValid;
            }

            // Handle form submission
            if (form) {
                form.addEventListener('submit', async function(e) {
                    e.preventDefault();

                    if (!validateForm()) {
                        return;
                    }

                    const currentPwd = currentPasswordInput.value.trim();
                    const newPwd = newPasswordInput.value.trim();

                    try {
                        // Disable button and show loading
                        updateBtn.disabled = true;
                        updateBtn.classList.add('loading');

                        const supabase = typeof window.getSupabaseClient === 'function'
                            ? window.getSupabaseClient()
                            : (window.supabaseClient || null);

                        if (!supabase) {
                            throw new Error('Supabase client not available');
                        }

                        // Get current user email from sessionStorage
                        const userEmail = sessionStorage.getItem('userEmail') || sessionStorage.getItem('staffEmail');
                        if (!userEmail) {
                            throw new Error('User email not found. Please log in again.');
                        }

                        console.log(' Starting password update process...');

                        // Step 1: Verify current password by attempting to sign in
                        console.log('Step 1: Verifying current password...');
                        const verifySignIn = await supabase.auth.signInWithPassword({
                            email: userEmail.toLowerCase(),
                            password: currentPwd,
                        });

                        if (verifySignIn.error) {
                            throw new Error('Current password is incorrect');
                        }

                        console.log(' Current password verified');

                        // Step 2: Update password in Auth
                        console.log('Step 2: Updating password in Auth...');
                        const { data: updateData, error: updateError } = await supabase.auth.updateUser({
                            password: newPwd,
                        });

                        if (updateError) {
                            throw new Error(`Failed to update password in Auth: ${updateError.message}`);
                        }

                        console.log(' Auth password updated successfully');

                        // Step 3: Update password in staff table
                        console.log('Step 3: Updating password in staff table...');
                        const { error: staffUpdateError } = await supabase
                            .from('staff')
                            .update({ password: newPwd })
                            .eq('email', userEmail.toLowerCase());

                        if (staffUpdateError) {
                            console.warn('Failed to update staff table password:', staffUpdateError);
                            // Don't throw - Auth password is updated
                        } else {
                            console.log(' Staff table password updated successfully');
                        }

                        // Step 4: Also try to update admin table if it's an admin
                        const { error: adminUpdateError } = await supabase
                            .from('admins')
                            .update({ password: newPwd })
                            .eq('email', userEmail.toLowerCase());

                        if (adminUpdateError) {
                            console.warn('Failed to update admin password (may not be admin):', adminUpdateError);
                        } else {
                            console.log(' Admin table password updated (if applicable)');
                        }

                        // Success!
                        if (typeof showNotification === 'function') {
                            showNotification('Password updated successfully!', 'success');
                        } else {
                            alert('Password updated successfully!');
                        }

                        // Close modal
                        closeModal();

                        // Sign out and redirect to login (for security)
                        await supabase.auth.signOut();
                        setTimeout(() => {
                            window.location.href = 'index.html';
                        }, 1500);

                    } catch (error) {
                        console.error(' Password update error:', error);
                        
                        if (error.message.includes('Current password is incorrect')) {
                            showError('currentPassword', 'Current password is incorrect');
                        } else {
                            if (typeof showNotification === 'function') {
                                showNotification('Failed to update password: ' + error.message, 'error');
                            } else {
                                alert('Failed to update password: ' + error.message);
                            }
                        }
                    } finally {
                        updateBtn.disabled = false;
                        updateBtn.classList.remove('loading');
                    }
                });
            }
        })();
    </script>
</body>
</html>