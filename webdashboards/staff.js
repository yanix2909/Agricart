// Utility function to convert barangay name to SQL column name
// This matches the column names in the Supabase delivery_fees table
function formatCustomerFullAddress(record) {
    if (!record) return "Not specified";

    // If individual address components are available, use them to build the address
    // This prevents duplication when the address field already contains formatted data
    const hasIndividualComponents = 
        record.street || record.sitio || record.barangay || record.city || 
        record.state || record.zipCode || record.zip_code;

    if (hasIndividualComponents) {
    const parts = [];
    const seen = new Set();

    const addPart = (value) => {
        if (value === undefined || value === null) return;
        const normalized = String(value).trim();
        if (!normalized) return;
        const condensed = normalized.replace(/\s+/g, " ");
        const key = condensed.toLowerCase();
        if (seen.has(key)) return;
        seen.add(key);
        parts.push(condensed);
    };

    addPart(record.street);

    if (record.sitio) {
        const sitioValue = String(record.sitio).trim();
        const normalizedSitio = sitioValue
            ? /^sitio/i.test(sitioValue)
                ? sitioValue
                : `Sitio ${sitioValue}`
            : "";
        addPart(normalizedSitio);
    }

    addPart(record.barangay || record.barangayName);
    addPart(record.city || record.town);
    addPart(record.state || record.province);
    addPart(record.zipCode || record.zip_code);

        if (parts.length > 0) {
            return parts.join(", ");
        }
    }

    // Fallback to address field if individual components are not available
        const fallback = (
            record.fullAddress ||
            record.full_address ||
            record.address ||
            ""
        )
            .toString()
            .trim();
        return fallback || "Not specified";
}

function formatStaffActionDisplay(name, role, fallback = "Unknown staff") {
    const cleanName = (name || "").toString().trim();
    const cleanRole = (role || "").toString().trim();

    if (!cleanName && !cleanRole) {
        return fallback;
    }

    if (!cleanName) {
        return cleanRole || fallback;
    }

    if (!cleanRole) {
        return cleanName;
    }

    return `${cleanName} Â· ${cleanRole}`;
}

/**
 * Calculate Saturday and Sunday dates of the next week
 * Always returns the weekend of the NEXT week (not the current week)
 * @returns {Object} Object with saturday and sunday Date objects
 */
function getNextWeekendDates() {
    const now = new Date();
    const currentDay = now.getDay(); // 0 = Sunday, 6 = Saturday

    // Calculate days until next week's Saturday
    let daysUntilNextSaturday;
    if (currentDay === 0) {
        // Today is Sunday, next week's Saturday is 6 + 7 = 13 days away
        daysUntilNextSaturday = 13;
    } else if (currentDay === 6) {
        // Today is Saturday, next week's Saturday is 7 days away
        daysUntilNextSaturday = 7;
    } else {
        // Monday-Friday: days until this Saturday, then add 7 for next week
        daysUntilNextSaturday = (6 - currentDay) + 7;
    }

    const nextSaturday = new Date(now);
    nextSaturday.setDate(now.getDate() + daysUntilNextSaturday);
    nextSaturday.setHours(0, 0, 0, 0);

    const nextSunday = new Date(nextSaturday);
    nextSunday.setDate(nextSaturday.getDate() + 1);

    return { saturday: nextSaturday, sunday: nextSunday };
}

/**
 * Format date as MM/DD/YY
 * @param {Date} date - Date object to format
 * @returns {string} Formatted date string (MM/DD/YY)
 */
function formatDateMMDDYY(date) {
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const year = String(date.getFullYear()).slice(-2);
    return `${month}/${day}/${year}`;
}

function barangayNameToColumnName(barangayName) {
    if (!barangayName) {
        console.warn("barangayNameToColumnName: Empty barangay name");
        return "";
    }

    // Trim whitespace
    barangayName = String(barangayName).trim();

    // Handle specific mappings FIRST (before sanitization) for barangays with special names
    const specialMappings = {
        "Bagong (also Bagongbong)": "bagong_also_bagongbong",
        "bagong (also bagongbong)": "bagong_also_bagongbong",
        "Bagong(also Bagongbong)": "bagong_also_bagongbong",
        "bagong(also bagongbong)": "bagong_also_bagongbong",
        Bagongbong: "bagong_also_bagongbong", // Handle shortened name
        bagongbong: "bagong_also_bagongbong", // Handle shortened name lowercase
        "Barangay 1 (Poblacion South)": "barangay_1_poblacion_south",
        "barangay 1 (poblacion south)": "barangay_1_poblacion_south",
        "Barangay 2 (Poblacion South)": "barangay_2_poblacion_south",
        "barangay 2 (poblacion south)": "barangay_2_poblacion_south",
        "Barangay 3 (Poblacion South)": "barangay_3_poblacion_south",
        "barangay 3 (poblacion south)": "barangay_3_poblacion_south",
        "Barangay 4 (Poblacion South)": "barangay_4_poblacion_south",
        "barangay 4 (poblacion south)": "barangay_4_poblacion_south",
        "Barangay 5 (Poblacion South)": "barangay_5_poblacion_south",
        "barangay 5 (poblacion south)": "barangay_5_poblacion_south",
        "Barangay 6 (Poblacion South)": "barangay_6_poblacion_south",
        "barangay 6 (poblacion south)": "barangay_6_poblacion_south",
        "Barangay 7 (Poblacion South)": "barangay_7_poblacion_south",
        "barangay 7 (poblacion south)": "barangay_7_poblacion_south",
        "Barangay 8 (Poblacion South)": "barangay_8_poblacion_south",
        "barangay 8 (poblacion south)": "barangay_8_poblacion_south",
        "Barangay 9 (Poblacion South)": "barangay_9_poblacion_south",
        "barangay 9 (poblacion south)": "barangay_9_poblacion_south",
        "Barangay 10 (Poblacion South)": "barangay_10_poblacion_south",
        "barangay 10 (poblacion south)": "barangay_10_poblacion_south",
        "Barangay 11 (Poblacion North)": "barangay_11_poblacion_north",
        "barangay 11 (poblacion north)": "barangay_11_poblacion_north",
        "Barangay 12 (Poblacion North)": "barangay_12_poblacion_north",
        "barangay 12 (poblacion north)": "barangay_12_poblacion_north",
        "Barangay 13 (Poblacion North)": "barangay_13_poblacion_north",
        "barangay 13 (poblacion north)": "barangay_13_poblacion_north",
        "Barangay 14 (Poblacion North)": "barangay_14_poblacion_north",
        "barangay 14 (poblacion north)": "barangay_14_poblacion_north",
        "Barangay 15 (Poblacion North)": "barangay_15_poblacion_north",
        "barangay 15 (poblacion north)": "barangay_15_poblacion_north",
        "Barangay 16 (Poblacion North)": "barangay_16_poblacion_north",
        "barangay 16 (poblacion north)": "barangay_16_poblacion_north",
        "Barangay 17 (Poblacion North)": "barangay_17_poblacion_north",
        "barangay 17 (poblacion north)": "barangay_17_poblacion_north",
        "Barangay 18 (Poblacion North)": "barangay_18_poblacion_north",
        "barangay 18 (poblacion north)": "barangay_18_poblacion_north",
        "Barangay 19 (Poblacion North)": "barangay_19_poblacion_north",
        "barangay 19 (poblacion north)": "barangay_19_poblacion_north",
        "Barangay 20 (Poblacion North)": "barangay_20_poblacion_north",
        "barangay 20 (poblacion north)": "barangay_20_poblacion_north",
        "Barangay 21 (Poblacion East)": "barangay_21_poblacion_east",
        "barangay 21 (poblacion east)": "barangay_21_poblacion_east",
        "Barangay 22 (Poblacion East)": "barangay_22_poblacion_east",
        "barangay 22 (poblacion east)": "barangay_22_poblacion_east",
        "Barangay 23 (Poblacion East)": "barangay_23_poblacion_east",
        "barangay 23 (poblacion east)": "barangay_23_poblacion_east",
        "Barangay 24 (Poblacion East)": "barangay_24_poblacion_east",
        "barangay 24 (poblacion east)": "barangay_24_poblacion_east",
        "Barangay 25 (Poblacion East)": "barangay_25_poblacion_east",
        "barangay 25 (poblacion east)": "barangay_25_poblacion_east",
        "Barangay 26 (Poblacion West)": "barangay_26_poblacion_west",
        "barangay 26 (poblacion west)": "barangay_26_poblacion_west",
        "Barangay 27 (Poblacion West)": "barangay_27_poblacion_west",
        "barangay 27 (poblacion west)": "barangay_27_poblacion_west",
        "Barangay 28 (Poblacion West)": "barangay_28_poblacion_west",
        "barangay 28 (poblacion west)": "barangay_28_poblacion_west",
        "Barangay 29 (Poblacion West)": "barangay_29_poblacion_west",
        "barangay 29 (poblacion west)": "barangay_29_poblacion_west",
        "Labrador (Balion)": "labrador_balion",
        "labrador (balion)": "labrador_balion",
        "Don Felipe Larrazabal": "don_felipe_larrazabal",
        "don felipe larrazabal": "don_felipe_larrazabal",
        "Don Potenciano Larrazabal": "don_potenciano_larrazabal",
        "don potenciano larrazabal": "don_potenciano_larrazabal",
        "DoÃ±a Feliza Z. Mejia": "dona_feliza_z_mejia",
        "doÃ±a feliza z. mejia": "dona_feliza_z_mejia",
        "San Pablo (Simangan)": "san_pablo_simangan",
        "san pablo (simangan)": "san_pablo_simangan",
        "Quezon, Jr.": "quezon_jr",
        "quezon, jr.": "quezon_jr",
        "Rufina M. Tan": "rufina_m_tan",
        "rufina m. tan": "rufina_m_tan",
        "Rufina M. Tan (Rawis)": "rufina_m_tan", // Handle with (Rawis) suffix
        "rufina m. tan (rawis)": "rufina_m_tan",
        "Rufina M. Tan (rawis)": "rufina_m_tan",
        "rufina m. tan (Rawis)": "rufina_m_tan",
        "Cabaonâ€‘an": "cabaon_an", // Handle non-breaking hyphen
        "Cabaon-an": "cabaon_an", // Handle regular hyphen
        "cabaonâ€‘an": "cabaon_an",
        "cabaon-an": "cabaon_an",
        "Canâ€‘adieng": "can_adieng", // Handle non-breaking hyphen
        "Can-adieng": "can_adieng", // Handle regular hyphen
        "canâ€‘adieng": "can_adieng",
        "can-adieng": "can_adieng",
        "Canâ€‘untog": "can_untog", // Handle non-breaking hyphen
        "Can-untog": "can_untog", // Handle regular hyphen
        "canâ€‘untog": "can_untog",
        "can-untog": "can_untog",
        "Masâ€‘in": "mas_in", // Handle non-breaking hyphen
        "Mas-in": "mas_in", // Handle regular hyphen
        "masâ€‘in": "mas_in",
        "mas-in": "mas_in",
        "Maticaâ€‘a": "matica_a", // Handle non-breaking hyphen
        "Matica-a": "matica_a", // Handle regular hyphen
        "maticaâ€‘a": "matica_a",
        "matica-a": "matica_a",
        "Guintiguiâ€‘an": "guintigui_an", // Handle non-breaking hyphen
        "Guintigui-an": "guintigui_an", // Handle regular hyphen
        "guintiguiâ€‘an": "guintigui_an",
        "guintigui-an": "guintigui_an",
        Esperansa: "esperanza", // Handle typo: Esperansa (with 's') should map to esperanza (with 'z')
        esperansa: "esperanza",
        Esperanza: "esperanza", // Also handle correct spelling
        esperanza: "esperanza",
        "Lake Danao": "danao", // Lake Danao maps to danao column
        "lake danao": "danao",
        "Lake danao": "danao",
        "lake Danao": "danao",
    };

    // Check if there's a direct mapping first
    if (specialMappings[barangayName]) {
        console.log(
            "barangayNameToColumnName: Direct mapping found for",
            barangayName,
            "->",
            specialMappings[barangayName]
        );
        return specialMappings[barangayName];
    }

    // Convert to lowercase and replace spaces/special chars with underscores
    let columnName = String(barangayName)
        .toLowerCase()
        .replace(/\s+/g, "_") // Replace spaces with underscores
        .replace(/[()]/g, "") // Remove parentheses
        .replace(/[.,]/g, "") // Remove periods and commas
        .replace(/[-â€‘â€“â€”]/g, "_") // Replace all types of hyphens/dashes with underscores (regular -, non-breaking â€‘, en-dash â€“, em-dash â€”)
        .replace(/'/g, "") // Remove apostrophes
        .replace(/Ã±/g, "n") // Replace Ã± with n
        .replace(/[^a-z0-9_]/g, "") // Remove any other special characters
        .replace(/_+/g, "_") // Replace multiple underscores with single
        .replace(/^_|_$/g, ""); // Remove leading/trailing underscores

    // Check if there's a special mapping for the sanitized name
    if (specialMappings[columnName]) {
        console.log(
            "barangayNameToColumnName: Sanitized mapping found for",
            barangayName,
            "->",
            columnName,
            "->",
            specialMappings[columnName]
        );
        return specialMappings[columnName];
    }

    console.log(
        "barangayNameToColumnName: Final mapping",
        barangayName,
        "->",
        columnName
    );
    return columnName;
}

// Staff Dashboard Manager
// Customer Helper Functions for Supabase Migration
// These functions handle conversion between Firebase format (camelCase) and Supabase format (snake_case)
const CustomerHelpers = {
    // Convert Supabase customer data (snake_case) to Firebase format (camelCase) for compatibility
    supabaseToFirebase(customer) {
        if (!customer) return null;
        return {
            uid: customer.uid,
            email: customer.email || "",
            fullName: customer.full_name || "",
            firstName: customer.first_name || "",
            lastName: customer.last_name || "",
            middleInitial: customer.middle_initial || "",
            suffix: customer.suffix || "",
            username: customer.username || "",
            age: customer.age || 0,
            gender: customer.gender || "",
            phoneNumber: customer.phone_number || "",
            address: customer.address || "",
            street: customer.street || "",
            sitio: customer.sitio || "",
            barangay: customer.barangay || "",
            city: customer.city || "Ormoc",
            state: customer.state || "Leyte",
            zipCode: customer.zip_code || "",
            profileImageUrl: customer.profile_image_url || "",
            createdAt: customer.created_at || Date.now(),
            updatedAt: customer.updated_at || Date.now(),
            customerLastUpdatedAt: customer.customer_last_updated_at || null,
            isOnline: customer.is_online || false,
            lastSeen: customer.last_seen || null,
            status: customer.status || "active",
            accountStatus: customer.account_status || "pending",
            verificationStatus: customer.verification_status || "pending",
            rejectionReason: customer.rejection_reason || null,
            rejectedAt: customer.rejected_at || null,
            rejectedBy: customer.rejected_by || null,
            rejectedByName: customer.rejected_by_name || "",
            rejectedByRole: customer.rejected_by_role || "",
            idType: customer.id_type || "Not specified",
            verificationDate: customer.verification_date || null,
            verifiedBy: customer.verified_by || null,
            verifiedByName: customer.verified_by_name || "",
            verifiedByRole: customer.verified_by_role || "",
            favoriteProducts: customer.favorite_products || [],
            totalOrders: customer.total_orders || 0,
            totalSpent: customer.total_spent || 0.0,
            hasLoggedInBefore: customer.has_logged_in_before || false,
            idFrontPhoto: customer.id_front_photo || null,
            idBackPhoto: customer.id_back_photo || null,
            registrationDate:
                customer.registration_date || customer.created_at || Date.now(),
            birthday: customer.birthday || customer.birth_date || null,
            birthDate: customer.birthday || customer.birth_date || null,
        };
    },

    // Convert Firebase customer data (camelCase) to Supabase format (snake_case)
    firebaseToSupabase(customer) {
        if (!customer) return null;
        return {
            uid: customer.uid,
            email: customer.email || "",
            full_name: customer.fullName || "",
            first_name: customer.firstName || "",
            last_name: customer.lastName || "",
            middle_initial: customer.middleInitial || "",
            suffix: customer.suffix || "",
            username: customer.username || "",
            age: customer.age || 0,
            gender: customer.gender || "",
            phone_number: customer.phoneNumber || "",
            address: customer.address || "",
            street: customer.street || "",
            sitio: customer.sitio || "",
            barangay: customer.barangay || "",
            city: customer.city || "Ormoc",
            state: customer.state || "Leyte",
            zip_code: customer.zipCode || "",
            profile_image_url: customer.profileImageUrl || "",
            created_at: customer.createdAt || Date.now(),
            updated_at: customer.updatedAt || Date.now(),
            is_online: customer.isOnline || false,
            last_seen: customer.lastSeen || null,
            status: customer.status || "active",
            account_status: customer.accountStatus || "pending",
            verification_status: customer.verificationStatus || "pending",
            rejection_reason: customer.rejectionReason || null,
            rejected_at: customer.rejectedAt || null,
            rejected_by: customer.rejectedBy || null,
            rejected_by_name: customer.rejectedByName || "",
            rejected_by_role: customer.rejectedByRole || "",
            id_type: customer.idType || "Not specified",
            verification_date: customer.verificationDate || null,
            verified_by: customer.verifiedBy || null,
            verified_by_name: customer.verifiedByName || "",
            verified_by_role: customer.verifiedByRole || "",
            favorite_products: customer.favoriteProducts || [],
            total_orders: customer.totalOrders || 0,
            total_spent: customer.totalSpent || 0.0,
            has_logged_in_before: customer.hasLoggedInBefore || false,
            id_front_photo: customer.idFrontPhoto || null,
            id_back_photo: customer.idBackPhoto || null,
            registration_date:
                customer.registrationDate || customer.createdAt || Date.now(),
            birthday: customer.birthday || null,
            birth_date: customer.birthday || customer.birthDate || null,
        };
    },

    // Get Supabase client
    getSupabaseClient() {
        return window.getSupabaseClient
            ? window.getSupabaseClient()
            : window.supabaseClient || null;
    },

    // Get customer by UID from Supabase
    async getCustomer(uid) {
        try {
            const supabase = this.getSupabaseClient();
            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            const { data, error } = await supabase
                .from("customers")
                .select("*")
                .eq("uid", uid)
                .single();

            if (error) {
                if (error.code === "PGRST116") {
                    // No rows returned
                    return null;
                }
                throw error;
            }

            return this.supabaseToFirebase(data);
        } catch (error) {
            console.error("Error getting customer from Supabase:", error);
            throw error;
        }
    },

    // Get all customers from Supabase
    async getAllCustomers() {
        try {
            const supabase = this.getSupabaseClient();
            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            const { data, error } = await supabase.from("customers").select("*");

            if (error) {
                throw error;
            }

            // Convert to Firebase format and return as object with uid as key
            const customers = {};
            if (data) {
                data.forEach((customer) => {
                    customers[customer.uid] = this.supabaseToFirebase(customer);
                });
            }

            return customers;
        } catch (error) {
            console.error("Error getting all customers from Supabase:", error);
            throw error;
        }
    },

    // Get customers by verification status
    async getCustomersByVerificationStatus(status) {
        try {
            const supabase = this.getSupabaseClient();
            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            const { data, error } = await supabase
                .from("customers")
                .select("*")
                .eq("verification_status", status);

            if (error) {
                throw error;
            }

            // Convert to Firebase format and return as object with uid as key
            const customers = {};
            if (data) {
                data.forEach((customer) => {
                    customers[customer.uid] = this.supabaseToFirebase(customer);
                });
            }

            return customers;
        } catch (error) {
            console.error(
                "Error getting customers by verification status from Supabase:",
                error
            );
            throw error;
        }
    },

    // Update customer in Supabase
    async updateCustomer(uid, updates) {
        try {
            const supabase = this.getSupabaseClient();
            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            // Map camelCase to snake_case field names
            const fieldMapping = {
                accountStatus: "account_status",
                verificationStatus: "verification_status",
                rejectionReason: "rejection_reason",
                idType: "id_type",
                verificationDate: "verification_date",
                verifiedBy: "verified_by",
                verifiedByName: "verified_by_name",
                verifiedByRole: "verified_by_role",
                favoriteProducts: "favorite_products",
                totalOrders: "total_orders",
                totalSpent: "total_spent",
                hasLoggedInBefore: "has_logged_in_before",
                idFrontPhoto: "id_front_photo",
                idBackPhoto: "id_back_photo",
                registrationDate: "registration_date",
                fullName: "full_name",
                firstName: "first_name",
                lastName: "last_name",
                middleInitial: "middle_initial",
                phoneNumber: "phone_number",
                zipCode: "zip_code",
                profileImageUrl: "profile_image_url",
                createdAt: "created_at",
                updatedAt: "updated_at",
                customerLastUpdatedAt: "customer_last_updated_at",
                isOnline: "is_online",
                lastSeen: "last_seen",
            };

            // Convert updates to Supabase format
            const supabaseUpdates = {};
            Object.keys(updates).forEach((key) => {
                // Use mapping if available, otherwise convert camelCase to snake_case
                const snakeKey =
                    fieldMapping[key] || key.replace(/([A-Z])/g, "_$1").toLowerCase();
                supabaseUpdates[snakeKey] = updates[key];
            });

            // Always update updated_at
            supabaseUpdates.updated_at = Date.now();

            const { error } = await supabase
                .from("customers")
                .update(supabaseUpdates)
                .eq("uid", uid);

            if (error) {
                throw error;
            }

            return true;
        } catch (error) {
            console.error("Error updating customer in Supabase:", error);
            throw error;
        }
    },

    // Insert customer in Supabase
    async insertCustomer(customerData) {
        try {
            const supabase = this.getSupabaseClient();
            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            // Convert to Supabase format
            const supabaseData = this.firebaseToSupabase(customerData);

            const { error } = await supabase.from("customers").insert([supabaseData]);

            if (error) {
                throw error;
            }

            return true;
        } catch (error) {
            console.error("Error inserting customer in Supabase:", error);
            throw error;
        }
    },

    // Delete customer from Supabase
    async deleteCustomer(uid) {
        try {
            const supabase = this.getSupabaseClient();
            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            const { error } = await supabase
                .from("customers")
                .delete()
                .eq("uid", uid);

            if (error) {
                throw error;
            }

            return true;
        } catch (error) {
            console.error("Error deleting customer from Supabase:", error);
            throw error;
        }
    },

    // Find customer by email
    async findCustomerByEmail(email) {
        try {
            const supabase = this.getSupabaseClient();
            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            const { data, error } = await supabase
                .from("customers")
                .select("*")
                .eq("email", email.toLowerCase())
                .limit(1)
                .single();

            if (error) {
                if (error.code === "PGRST116") {
                    return null;
                }
                throw error;
            }

            return this.supabaseToFirebase(data);
        } catch (error) {
            console.error("Error finding customer by email in Supabase:", error);
            throw error;
        }
    },

    // Find customer by phone
    async findCustomerByPhone(phone) {
        try {
            const supabase = this.getSupabaseClient();
            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            const { data, error } = await supabase
                .from("customers")
                .select("*")
                .eq("phone_number", phone)
                .limit(1)
                .single();

            if (error) {
                if (error.code === "PGRST116") {
                    return null;
                }
                throw error;
            }

            return this.supabaseToFirebase(data);
        } catch (error) {
            console.error("Error finding customer by phone in Supabase:", error);
            throw error;
        }
    },
};

// Make CustomerHelpers available globally
window.CustomerHelpers = CustomerHelpers;

// Notification Helper for sending notifications to all customers
const NotificationHelpers = {
    getSupabaseClient() {
        return window.getSupabaseClient ? window.getSupabaseClient() : null;
    },

    getSupabaseUrl() {
        return window.SUPABASE_URL || 'https://afkwexvvuxwbpioqnelp.supabase.co';
    },

    getSupabaseAnonKey() {
        return window.SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFma3dleHZ2dXh3YnBpb3FuZWxwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI5MzA3MjcsImV4cCI6MjA3ODUwNjcyN30.7r5j1xfWdJwiRZZm8AcOIaBp9VaXoD2QWE3WrGYZNyM';
    },

    // Send notification to all customers via Edge Function (bypasses RLS)
    async notifyAllCustomers(title, message, type, productId = null) {
        try {
            const supabaseUrl = this.getSupabaseUrl();
            const anonKey = this.getSupabaseAnonKey();
            
            if (!supabaseUrl || !anonKey) {
                throw new Error("Supabase configuration not available");
            }

            // Call Edge Function to create notifications with service role permissions
            const edgeFunctionUrl = `${supabaseUrl}/functions/v1/create-notifications`;
            
            console.log(`ðŸ“¡ Calling Edge Function: ${edgeFunctionUrl}`);
            console.log(`ðŸ“¦ Payload:`, { title, message, type, productId });
            
            const response = await fetch(edgeFunctionUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${anonKey}`,
                    'apikey': anonKey,
                },
                body: JSON.stringify({
                    title: title,
                    message: message,
                    type: type,
                    productId: productId,
                }),
            });

            const responseText = await response.text();
            console.log(`ðŸ“¥ Edge Function response status: ${response.status}`);
            console.log(`ðŸ“¥ Edge Function response:`, responseText);

            if (!response.ok) {
                // Check if Edge Function doesn't exist (404)
                if (response.status === 404) {
                    throw new Error(
                        `Edge Function 'create-notifications' not found. ` +
                        `Please deploy it first. See DEPLOY_NOTIFICATION_EDGE_FUNCTION.md for instructions. ` +
                        `Response: ${responseText}`
                    );
                }
                throw new Error(`Edge Function error: ${response.status} - ${responseText}`);
            }

            let result;
            try {
                result = JSON.parse(responseText);
            } catch (e) {
                throw new Error(`Invalid JSON response from Edge Function: ${responseText}`);
            }
            
            if (result.success) {
                console.log(`âœ… Successfully created ${result.count} notifications via Edge Function`);
                if (result.errors && result.errors.length > 0) {
                    console.warn(`âš ï¸ Some batches had errors:`, result.errors);
                }
            } else {
                console.error("âŒ Edge Function returned error:", result.error);
                throw new Error(result.error || "Failed to create notifications");
            }

            return result;
        } catch (error) {
            console.error("âŒ Error sending notifications to all customers:", error);
            console.error("âŒ Full error:", error);
            throw error;
        }
    },
};

// Make NotificationHelpers available globally
window.NotificationHelpers = NotificationHelpers;

// Order Helper/Adapter for Supabase-backed orders table
const OrderSupabaseAdapter = {
    getSupabaseClient() {
        return window.getSupabaseClient
            ? window.getSupabaseClient()
            : window.supabaseClient || null;
    },

    toCamelCase(key) {
        if (!key || typeof key !== "string") return key;
        return key.replace(/[_-]([a-zA-Z0-9])/g, (_, char) =>
            char ? char.toUpperCase() : ""
        );
    },

    normalizeTimestamp(...values) {
        for (const value of values) {
            if (value === undefined || value === null || value === "") continue;
            if (value instanceof Date) return value.getTime();
            if (typeof value === "number") {
                if (!Number.isNaN(value)) {
                    if (value > 1e12) return value;
                    if (value > 1e9) return value * 1000;
                    return value;
                }
            }
            if (typeof value === "string") {
                const trimmed = value.trim();
                if (trimmed === "") continue;
                const numeric = Number(trimmed);
                if (!Number.isNaN(numeric)) {
                    if (numeric > 1e12) return numeric;
                    if (numeric > 1e9) return numeric * 1000;
                    return numeric;
                }
                const parsed = Date.parse(trimmed);
                if (!Number.isNaN(parsed)) return parsed;
            }
        }
        return null;
    },

    normalizeNumber(...values) {
        for (const value of values) {
            if (value === undefined || value === null || value === "") continue;
            const num = Number(value);
            if (!Number.isNaN(num)) return num;
        }
        return 0;
    },

    ensureArray(value) {
        if (value === undefined || value === null) return [];
        if (Array.isArray(value)) return value;
        if (typeof value === "string") {
            const trimmed = value.trim();
            if (trimmed.startsWith("[") || trimmed.startsWith("{")) {
                try {
                    const parsed = JSON.parse(trimmed);
                    if (Array.isArray(parsed)) return parsed;
                    if (parsed && typeof parsed === "object") {
                        return Object.keys(parsed).map((key) => parsed[key]);
                    }
                } catch (_) { }
            }
            return [];
        }
        if (typeof value === "object") {
            return Object.keys(value).map((key) => value[key]);
        }
        return [];
    },

    // Helper function to remove duplicate city and province from addresses
    removeDuplicateCityProvince(address) {
        if (!address || typeof address !== "string") return address;
        
        // Split address by comma
        const parts = address.split(",").map(p => p.trim()).filter(p => p);
        if (parts.length < 4) return address; // Need at least 4 parts to have duplication
        
        // Check if last two parts duplicate the previous two parts
        // Pattern: "X, Y, City, Province, City, Province"
        // For "Coob, Tambulilid, Ormoc, Leyte, Ormoc, Leyte":
        //   parts[2]="Ormoc", parts[3]="Leyte" (original)
        //   parts[4]="Ormoc", parts[5]="Leyte" (duplicate)
        const lastPart = parts[parts.length - 1];
        const secondLastPart = parts[parts.length - 2];
        const thirdLastPart = parts.length >= 3 ? parts[parts.length - 3] : "";
        const fourthLastPart = parts.length >= 4 ? parts[parts.length - 4] : "";
        
        // Normalize for comparison (case-insensitive)
        const lastLower = lastPart.toLowerCase();
        const secondLastLower = secondLastPart.toLowerCase();
        const thirdLastLower = thirdLastPart.toLowerCase();
        const fourthLastLower = fourthLastPart.toLowerCase();
        
        // Check if last two parts match fourth and third last parts (duplicate pattern)
        // secondLastPart should match fourthLastPart, lastPart should match thirdLastPart
        if (parts.length >= 4) {
            // Simple check: if secondLast matches fourthLast AND last matches thirdLast
            if (secondLastLower === fourthLastLower && lastLower === thirdLastLower) {
                // Remove duplicate (last two parts)
                return parts.slice(0, -2).join(", ");
            }
            
            // Also check for partial matches (e.g., "Ormoc" matches "Ormoc City")
            if ((secondLastLower === fourthLastLower || 
                 secondLastLower.includes(fourthLastLower) || 
                 fourthLastLower.includes(secondLastLower)) &&
                (lastLower === thirdLastLower || 
                 lastLower.includes(thirdLastLower) || 
                 thirdLastLower.includes(lastLower))) {
                // Remove duplicate (last two parts)
                return parts.slice(0, -2).join(", ");
            }
        }
        
        // Check for longer patterns: "X, Y, Z, City, Province, City, Province"
        if (parts.length >= 6) {
            const fifthLastPart = parts[parts.length - 5];
            const sixthLastPart = parts[parts.length - 6];
            const fifthLastLower = fifthLastPart.toLowerCase();
            const sixthLastLower = sixthLastPart.toLowerCase();
            
            // Check if last two match fifth and sixth (for pattern: X, Y, Z, City, Province, City, Province)
            if ((secondLastLower === fifthLastLower || 
                 secondLastLower.includes(fifthLastLower) || 
                 fifthLastLower.includes(secondLastLower)) &&
                (lastLower === sixthLastLower || 
                 lastLower.includes(sixthLastLower) || 
                 sixthLastLower.includes(lastLower))) {
                // Remove duplicate (last two parts)
                return parts.slice(0, -2).join(", ");
            }
        }
        
        return address;
    },

    normalizeItems(items) {
        const list = this.ensureArray(items);
        return list.map((item) => {
            if (!item || typeof item !== "object") return item;
            const normalizedItem = {};
            Object.keys(item).forEach((key) => {
                const camel = this.toCamelCase(key);
                normalizedItem[camel] = item[key];
                if (camel !== key && normalizedItem[key] === undefined) {
                    normalizedItem[key] = item[key];
                }
            });
            return normalizedItem;
        });
    },

    normalizeRow(row) {
        if (!row || typeof row !== "object") return null;
        const normalized = {};

        Object.keys(row).forEach((originalKey) => {
            const camelKey = this.toCamelCase(originalKey);
            let value = row[originalKey];
            if (camelKey === "items" || camelKey === "orderItems") {
                value = this.normalizeItems(value);
            }
            normalized[camelKey] = value;
            if (camelKey !== originalKey && normalized[originalKey] === undefined) {
                normalized[originalKey] = value;
            }
        });

        const idCandidates = [
            normalized.id,
            normalized.orderId,
            normalized.order_id,
            row.id,
            row.order_id,
            row.uid,
        ];
        const resolvedId =
            idCandidates.find(
                (val) => typeof val === "string" && val.trim() !== ""
            ) ?? idCandidates.find((val) => val !== undefined && val !== null);
        normalized.id = resolvedId
            ? String(resolvedId)
            : `supabase_${Date.now()}_${Math.random().toString(36).slice(2, 10)}`;
        normalized.orderId = normalized.orderId || normalized.id;

        normalized.items =
            normalized.items ||
            this.normalizeItems(
                normalized.orderItems ||
                normalized.itemsJson ||
                normalized.items_json ||
                row.items
            );

        normalized.customerId =
            normalized.customerId || normalized.customer_id || "";
        normalized.customerName =
            normalized.customerName || normalized.customer_name || "";
        normalized.customerPhone =
            normalized.customerPhone ||
            normalized.customer_phone ||
            normalized.contactNumber ||
            "";

        normalized.customerAddress =
            normalized.customerAddress || normalized.customer_address || "";
        // Clean delivery address to remove duplicate city/province
        const rawDeliveryAddress =
            normalized.deliveryAddress ||
            normalized.delivery_address ||
            normalized.customerAddress ||
            "";
        normalized.deliveryAddress = this.removeDuplicateCityProvince(rawDeliveryAddress);
        normalized.delivery_address = normalized.deliveryAddress; // Also set snake_case version

        // Clean pickup address to remove duplicate city/province
        const rawPickupAddress =
            normalized.pickupAddress || normalized.pickup_address || "";
        normalized.pickupAddress = this.removeDuplicateCityProvince(rawPickupAddress);
        normalized.pickup_address = normalized.pickupAddress; // Also set snake_case version
        normalized.pickupName =
            normalized.pickupName || normalized.pickup_name || "";
        normalized.pickupStreet =
            normalized.pickupStreet || normalized.pickup_street || "";
        normalized.pickupSitio =
            normalized.pickupSitio || normalized.pickup_sitio || "";
        normalized.pickupBarangay =
            normalized.pickupBarangay || normalized.pickup_barangay || "";
        normalized.pickupCity =
            normalized.pickupCity || normalized.pickup_city || "";
        normalized.pickupProvince =
            normalized.pickupProvince || normalized.pickup_province || "";
        normalized.pickupLandmark =
            normalized.pickupLandmark || normalized.pickup_landmark || "";
        normalized.pickupInstructions =
            normalized.pickupInstructions || normalized.pickup_instructions || "";
        normalized.pickupMapLink =
            normalized.pickupMapLink || normalized.pickup_map_link || "";

        normalized.subtotal = this.normalizeNumber(
            normalized.subtotal,
            normalized.sub_total,
            row.subtotal
        );
        normalized.deliveryFee = this.normalizeNumber(
            normalized.deliveryFee,
            normalized.delivery_fee,
            row.delivery_fee
        );
        const totalAmount = this.normalizeNumber(
            normalized.totalAmount,
            normalized.total,
            normalized.total_amount,
            normalized.total_price,
            normalized.totalAmountDue,
            normalized.total_amount_due,
            row.total,
            row.total_amount
        );
        normalized.total = totalAmount;
        normalized.totalAmount = totalAmount;

        normalized.paymentMethod = String(
            normalized.paymentMethod || normalized.payment_method || "cash"
        );
        normalized.paymentStatus = String(
            normalized.paymentStatus || normalized.payment_status || "pending"
        );
        normalized.deliveryOption = String(
            normalized.deliveryOption ||
            normalized.delivery_option ||
            (normalized.pickupAddress ? "pickup" : "delivery") ||
            "delivery"
        );
        normalized.status = String(
            normalized.status ||
            normalized.orderStatus ||
            normalized.order_status ||
            "pending"
        ).toLowerCase();

        normalized.gcashReceiptUrl =
            normalized.gcashReceiptUrl || normalized.gcash_receipt_url || null;
        normalized.refundReceiptUrl =
            normalized.refundReceiptUrl || normalized.refund_receipt_url || null;

        // Normalize refund confirmation fields
        normalized.refundConfirmedAt = this.normalizeTimestamp(
            normalized.refundConfirmedAt,
            normalized.refund_confirmed_at,
            row.refund_confirmed_at
        );
        normalized.refundConfirmedBy =
            normalized.refundConfirmedBy ||
            normalized.refund_confirmed_by ||
            row.refund_confirmed_by ||
            null;
        normalized.refundConfirmedByName =
            normalized.refundConfirmedByName ||
            normalized.refund_confirmed_by_name ||
            row.refund_confirmed_by_name ||
            null;

        // Normalize refund denial fields
        if (normalized.refundDenied === undefined) {
            normalized.refundDenied =
                normalized.refund_denied ??
                (row.refund_denied === true ||
                    row.refund_denied === "true" ||
                    row.refund_denied === 1) ??
                null;
        }
        normalized.refundDeniedReason =
            normalized.refundDeniedReason ||
            normalized.refund_denied_reason ||
            row.refund_denied_reason ||
            null;
        normalized.refundDeniedAt = this.normalizeTimestamp(
            normalized.refundDeniedAt,
            normalized.refund_denied_at,
            row.refund_denied_at
        );
        normalized.refundDeniedBy =
            normalized.refundDeniedBy ||
            normalized.refund_denied_by ||
            row.refund_denied_by ||
            null;
        normalized.refundDeniedByName =
            normalized.refundDeniedByName ||
            normalized.refund_denied_by_name ||
            row.refund_denied_by_name ||
            null;

        normalized.riderId = normalized.riderId || normalized.rider_id || "";
        normalized.riderName = normalized.riderName || normalized.rider_name || "";
        normalized.riderPhone =
            normalized.riderPhone || normalized.rider_phone || "";

        normalized.readyForPickup =
            normalized.readyForPickup ?? normalized.ready_for_pickup ?? false;

        // Normalize delivery proof images (from delivery_proof JSONB field)
        normalized.deliveryProof =
            normalized.deliveryProof || normalized.delivery_proof || null;
        if (
            normalized.deliveryProof &&
            typeof normalized.deliveryProof === "string"
        ) {
            try {
                normalized.deliveryProof = JSON.parse(normalized.deliveryProof);
            } catch (e) {
                // If parsing fails, treat as single URL or array
                normalized.deliveryProof = [normalized.deliveryProof];
            }
        }
        if (!Array.isArray(normalized.deliveryProof)) {
            normalized.deliveryProof = normalized.deliveryProof
                ? [normalized.deliveryProof]
                : null;
        }

        // Normalize delivered fields
        normalized.deliveredAt = this.normalizeTimestamp(
            normalized.deliveredAt,
            normalized.delivered_at,
            row.delivered_at
        );
        normalized.deliveredBy =
            normalized.deliveredBy || normalized.delivered_by || "";
        normalized.deliveredByName =
            normalized.deliveredByName || normalized.delivered_by_name || "";

        // Normalize failed delivery fields
        normalized.failedAt = this.normalizeTimestamp(
            normalized.failedAt,
            normalized.failed_at,
            row.failed_at
        );
        normalized.failureReason =
            normalized.failureReason || normalized.failure_reason || "";
        normalized.failedBy = normalized.failedBy || normalized.failed_by || "";
        normalized.failedByName =
            normalized.failedByName || normalized.failed_by_name || "";
        normalized.deliverySchedule = this.normalizeTimestamp(
            normalized.deliverySchedule,
            normalized.delivery_schedule,
            row.delivery_schedule
        );
        normalized.rescheduledNextWeek =
            normalized.rescheduledNextWeek ??
            normalized.rescheduled_next_week ??
            false;

        // Normalize rescheduled fields
        normalized.rescheduledAt = this.normalizeTimestamp(
            normalized.rescheduledAt,
            normalized.rescheduled_at,
            row.rescheduled_at
        );
        normalized.rescheduledBy =
            normalized.rescheduledBy ||
            normalized.rescheduled_by ||
            row.rescheduled_by ||
            null;
        normalized.rescheduledByName =
            normalized.rescheduledByName ||
            normalized.rescheduled_by_name ||
            row.rescheduled_by_name ||
            null;
        normalized.rescheduledByRole =
            normalized.rescheduledByRole ||
            normalized.rescheduled_by_role ||
            row.rescheduled_by_role ||
            null;

        const rejectedTimestamp = this.normalizeTimestamp(
            normalized.rejectedAt,
            normalized.rejected_at,
            row.rejected_at,
            row.rejectedAt
        );
        if (rejectedTimestamp) {
            normalized.rejectedAt = rejectedTimestamp;
        }
        const rejectedBy =
            normalized.rejectedBy || normalized.rejected_by || row.rejected_by;
        if (rejectedBy != null) {
            normalized.rejectedBy = String(rejectedBy);
        }
        const rejectedByName =
            normalized.rejectedByName ||
            normalized.rejected_by_name ||
            row.rejected_by_name;
        if (rejectedByName != null) {
            normalized.rejectedByName = rejectedByName;
        }

        normalized.createdAt =
            this.normalizeTimestamp(
                normalized.createdAt,
                normalized.created_at,
                row.created_at,
                row.createdAt
            ) || Date.now();
        normalized.updatedAt =
            this.normalizeTimestamp(
                normalized.updatedAt,
                normalized.updated_at,
                row.updated_at,
                row.updatedAt
            ) || normalized.createdAt;
        normalized.orderDate =
            this.normalizeTimestamp(
                normalized.orderDate,
                normalized.order_date,
                row.order_date
            ) || normalized.createdAt;

        // Normalize confirmed_at field
        normalized.confirmedAt = this.normalizeTimestamp(
            normalized.confirmedAt,
            normalized.confirmed_at,
            row.confirmed_at
        );

        // Normalize confirmed_by fields
        normalized.confirmedBy =
            normalized.confirmedBy ||
            normalized.confirmed_by ||
            row.confirmed_by ||
            null;
        normalized.confirmedByName =
            normalized.confirmedByName ||
            normalized.confirmed_by_name ||
            row.confirmed_by_name ||
            null;

        // Normalize cancellation fields (from Supabase snake_case to camelCase)
        if (normalized.cancellationRequested === undefined) {
            normalized.cancellationRequested =
                normalized.cancellation_requested ??
                (row.cancellation_requested === true ||
                    row.cancellation_requested === "true" ||
                    row.cancellation_requested === 1);
        }
        normalized.cancellationRequestedAt = this.normalizeTimestamp(
            normalized.cancellationRequestedAt,
            normalized.cancellation_requested_at,
            row.cancellation_requested_at
        );
        normalized.cancellationInitiatedBy =
            normalized.cancellationInitiatedBy ||
            normalized.cancellation_initiated_by ||
            row.cancellation_initiated_by ||
            null;
        normalized.cancellationReason =
            normalized.cancellationReason ||
            normalized.cancellation_reason ||
            row.cancellation_reason ||
            null;
        // Normalize cancellation confirmation fields
        if (normalized.cancellationConfirmed === undefined) {
            normalized.cancellationConfirmed =
                normalized.cancellation_confirmed ??
                (row.cancellation_confirmed === true ||
                    row.cancellation_confirmed === "true" ||
                    row.cancellation_confirmed === 1) ??
                false;
        }
        normalized.cancellationConfirmedAt = this.normalizeTimestamp(
            normalized.cancellationConfirmedAt,
            normalized.cancellation_confirmed_at,
            row.cancellation_confirmed_at
        );
        normalized.cancellationConfirmedByName =
            normalized.cancellationConfirmedByName ||
            normalized.cancellation_confirmed_by_name ||
            row.cancellation_confirmed_by_name ||
            null;
        normalized.cancellationConfirmedByRole =
            normalized.cancellationConfirmedByRole ||
            normalized.cancellation_confirmed_by_role ||
            row.cancellation_confirmed_by_role ||
            null;

        normalized.source = "supabase";
        return normalized;
    },

    rowsToOrdersMap(rows) {
        const map = {};
        (rows || []).forEach((row) => {
            const normalized = this.normalizeRow(row);
            if (normalized && normalized.id) {
                map[normalized.id] = normalized;
            }
        });
        return map;
    },

    async fetchOrders() {
        try {
            const supabase = this.getSupabaseClient();
            if (!supabase) {
                console.warn("Supabase client not available for orders fetch");
                return null;
            }
            const { data, error } = await supabase.from("orders").select("*");
            if (error) {
                console.warn("Supabase orders fetch error:", error);
                return null;
            }
            const ordersMap = this.rowsToOrdersMap(data || []);

            // For delivered orders, also fetch delivery_proof from delivery_orders table
            const deliveredOrderIds = Object.keys(ordersMap).filter(
                (id) =>
                    String(ordersMap[id]?.status || "").toLowerCase() === "delivered"
            );

            if (deliveredOrderIds.length > 0) {
                try {
                    const { data: deliveryData, error: deliveryError } = await supabase
                        .from("delivery_orders")
                        .select("id, delivery_proof, proof_delivery_images, payment_proof")
                        .in("id", deliveredOrderIds);

                    if (!deliveryError && deliveryData) {
                        deliveryData.forEach((deliveryOrder) => {
                            const orderId = deliveryOrder.id;
                            if (ordersMap[orderId]) {
                                if (deliveryOrder.delivery_proof) {
                                    ordersMap[orderId].delivery_proof =
                                        deliveryOrder.delivery_proof;
                                    ordersMap[orderId].deliveryProof =
                                        deliveryOrder.delivery_proof;
                                }
                                if (deliveryOrder.proof_delivery_images) {
                                    ordersMap[orderId].proof_delivery_images =
                                        deliveryOrder.proof_delivery_images;
                                    ordersMap[orderId].proofImages =
                                        deliveryOrder.proof_delivery_images;
                                }
                                if (deliveryOrder.payment_proof) {
                                    ordersMap[orderId].payment_proof =
                                        deliveryOrder.payment_proof;
                                    ordersMap[orderId].paymentProof =
                                        deliveryOrder.payment_proof;
                                }
                            }
                        });
                    }
                } catch (deliveryErr) {
                    console.warn(
                        "Failed to fetch delivery_proof from delivery_orders:",
                        deliveryErr
                    );
                }
            }

            return ordersMap;
        } catch (err) {
            console.warn("Supabase orders fetch failed:", err);
            return null;
        }
    },

    async fetchOrderById(orderId) {
        try {
            if (!orderId) return null;
            const supabase = this.getSupabaseClient();
            if (!supabase) {
                console.warn("Supabase client not available for single order fetch");
                return null;
            }
            const sanitisedId = String(orderId).trim();

            const fetchSingle = async (column) => {
                const { data, error } = await supabase
                    .from("orders")
                    .select("*")
                    .eq(column, sanitisedId)
                    .limit(1)
                    .maybeSingle();
                if (error) {
                    if (error.code !== "PGRST116") {
                        throw error;
                    }
                    return null;
                }
                return data ? this.normalizeRow(data) : null;
            };

            const order =
                (await fetchSingle("id")) || (await fetchSingle("order_id"));

            // If order is delivered, also fetch delivery_proof from delivery_orders table
            if (order && String(order.status || "").toLowerCase() === "delivered") {
                try {
                    const { data: deliveryData, error: deliveryError } = await supabase
                        .from("delivery_orders")
                        .select("delivery_proof, proof_delivery_images, payment_proof")
                        .eq("id", sanitisedId)
                        .limit(1)
                        .maybeSingle();

                    if (!deliveryError && deliveryData) {
                        // Merge delivery_proof from delivery_orders into order
                        if (deliveryData.delivery_proof) {
                            order.delivery_proof = deliveryData.delivery_proof;
                            order.deliveryProof = deliveryData.delivery_proof;
                        }
                        if (deliveryData.proof_delivery_images) {
                            order.proof_delivery_images = deliveryData.proof_delivery_images;
                            order.proofImages = deliveryData.proof_delivery_images;
                        }
                        if (deliveryData.payment_proof) {
                            order.payment_proof = deliveryData.payment_proof;
                            order.paymentProof = deliveryData.payment_proof;
                        }
                    }
                } catch (deliveryErr) {
                    console.warn(
                        "Failed to fetch delivery_proof from delivery_orders:",
                        deliveryErr
                    );
                }
            }

            return order;
        } catch (err) {
            console.warn("Supabase fetchOrderById failed:", err);
            return null;
        }
    },

    computeHash(orders) {
        try {
            const entries = Object.entries(orders || {}).map(([id, order]) => [
                id,
                order?.updatedAt || order?.status || 0,
            ]);
            entries.sort((a, b) => a[0].localeCompare(b[0]));
            return JSON.stringify(entries);
        } catch (err) {
            return String(Date.now());
        }
    },

    async updateOrder(orderId, updates) {
        try {
            if (!orderId) {
                throw new Error("Order ID is required");
            }
            const supabase = this.getSupabaseClient();
            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            // Convert camelCase updates to snake_case for Supabase
            // Improved conversion that handles edge cases better
            const supabaseUpdates = {};
            const fieldMapping = {
                // Explicit mappings for refund fields to ensure correctness
                refundReceiptUrl: "refund_receipt_url",
                refundConfirmedAt: "refund_confirmed_at",
                refundConfirmedBy: "refund_confirmed_by",
                refundConfirmedByName: "refund_confirmed_by_name",
                refundDenied: "refund_denied",
                refundDeniedReason: "refund_denied_reason",
                refundDeniedAt: "refund_denied_at",
                refundDeniedBy: "refund_denied_by",
                refundDeniedByName: "refund_denied_by_name",
                cancellationConfirmed: "cancellation_confirmed",
                cancellationConfirmedAt: "cancellation_confirmed_at",
                cancellationConfirmedByName: "cancellation_confirmed_by_name",
                cancellationConfirmedByRole: "cancellation_confirmed_by_role",
                cancellationRequested: "cancellation_requested",
                cancellationRequestedAt: "cancellation_requested_at",
                cancellationInitiatedBy: "cancellation_initiated_by",
                cancellationReason: "cancellation_reason",
                confirmedAt: "confirmed_at",
                confirmedBy: "confirmed_by",
                confirmedByName: "confirmed_by_name",
                updatedAt: "updated_at",
                createdAt: "created_at",
                orderDate: "order_date",
                deliveryDate: "delivery_date",
                customerId: "customer_id",
                customerName: "customer_name",
                customerPhone: "customer_phone",
                customerAddress: "customer_address",
                deliveryAddress: "delivery_address",
                paymentMethod: "payment_method",
                paymentStatus: "payment_status",
                gcashReceiptUrl: "gcash_receipt_url",
                // Rider assignment fields
                riderId: "rider_id",
                riderName: "rider_name",
                riderPhone: "rider_phone",
                assignedAt: "assigned_at",
                outForDeliveryAt: "out_for_delivery_at",
                readyForPickup: "ready_for_pickup",
                pickedUpAt: "picked_up_at",
                failedPickupAt: "failed_pickup_at",
            };

            Object.keys(updates).forEach((key) => {
                // Use explicit mapping if available, otherwise use regex conversion
                let snakeKey = fieldMapping[key];
                if (!snakeKey) {
                    // Fallback to regex conversion for unmapped fields
                    snakeKey = key.replace(/([A-Z])/g, "_$1").toLowerCase();
                    // Remove leading underscore if present
                    if (snakeKey.startsWith("_")) {
                        snakeKey = snakeKey.substring(1);
                    }
                }
                supabaseUpdates[snakeKey] = updates[key];
            });

            console.log("ðŸ”„ Updating order in Supabase:", {
                orderId: orderId,
                updates: supabaseUpdates,
            });

            // Try updating by uid, id, or order_id
            const sanitisedId = String(orderId).trim();
            let error = null;
            let updated = false;
            let data = null;

            // Try by uid first (primary key)
            const { data: data1, error: error1 } = await supabase
                .from("orders")
                .update(supabaseUpdates)
                .eq("uid", sanitisedId)
                .select();
            if (!error1 && data1 && data1.length > 0) {
                updated = true;
                data = data1;
                console.log(
                    "âœ… Order updated by uid:",
                    sanitisedId,
                    "Rows affected:",
                    data.length
                );
            } else if (error1) {
                error = error1;
                console.log("âš ï¸ Update by uid failed:", error1);
            } else {
                console.log(
                    "âš ï¸ Update by uid returned no rows. Trying other columns..."
                );
            }

            // Try by id if uid didn't work
            if (!updated) {
                const { data: data2, error: error2 } = await supabase
                    .from("orders")
                    .update(supabaseUpdates)
                    .eq("id", sanitisedId)
                    .select();
                if (!error2 && data2 && data2.length > 0) {
                    updated = true;
                    error = null;
                    data = data2;
                    console.log(
                        "âœ… Order updated by id:",
                        sanitisedId,
                        "Rows affected:",
                        data.length
                    );
                } else if (error2) {
                    error = error2;
                    console.log("âš ï¸ Update by id failed:", error2);
                } else {
                    console.log("âš ï¸ Update by id returned no rows. Trying order_id...");
                }
            }

            // Try by order_id if id didn't work
            if (!updated) {
                const { data: data3, error: error3 } = await supabase
                    .from("orders")
                    .update(supabaseUpdates)
                    .eq("order_id", sanitisedId)
                    .select();
                if (!error3 && data3 && data3.length > 0) {
                    updated = true;
                    error = null;
                    data = data3;
                    console.log(
                        "âœ… Order updated by order_id:",
                        sanitisedId,
                        "Rows affected:",
                        data.length
                    );
                } else if (error3) {
                    error = error3;
                    console.log("âš ï¸ Update by order_id failed:", error3);
                } else {
                    console.log("âš ï¸ Update by order_id returned no rows.");
                }
            }

            if (error && !updated) {
                console.error(
                    "âŒ All update attempts failed for order:",
                    sanitisedId,
                    "Error:",
                    error
                );
                throw error;
            }

            // If still not updated, try to fetch the order first to find which column it's stored in
            if (!updated || !data || data.length === 0) {
                console.log(
                    "ðŸ”„ Order not found by direct update. Fetching order to find correct ID column..."
                );

                // Try to fetch the order by any ID column to see which one matches
                const fetchByColumn = async (column) => {
                    const { data: fetchData, error: fetchError } = await supabase
                        .from("orders")
                        .select("uid, id, order_id")
                        .eq(column, sanitisedId)
                        .limit(1)
                        .maybeSingle();
                    return { data: fetchData, error: fetchError, column };
                };

                const fetchResults = await Promise.all([
                    fetchByColumn("uid"),
                    fetchByColumn("id"),
                    fetchByColumn("order_id"),
                ]);

                const foundResult = fetchResults.find((r) => r.data && !r.error);

                if (foundResult) {
                    console.log(`âœ… Found order using column: ${foundResult.column}`);
                    // Now update using the column that worked
                    const { data: data4, error: error4 } = await supabase
                        .from("orders")
                        .update(supabaseUpdates)
                        .eq(foundResult.column, sanitisedId)
                        .select();

                    if (!error4 && data4 && data4.length > 0) {
                        updated = true;
                        error = null;
                        data = data4;
                        console.log(
                            `âœ… Order updated using ${foundResult.column}:`,
                            sanitisedId,
                            "Rows affected:",
                            data.length
                        );
                    } else if (error4) {
                        console.error(
                            `âŒ Update using ${foundResult.column} failed:`,
                            error4
                        );
                    }
                } else {
                    console.log("âš ï¸ Order not found in any ID column");
                }
            }

            if (!updated || !data || data.length === 0) {
                const errorMsg = `Failed to update order: No rows were affected. Order may not exist or ID mismatch. Order ID: ${sanitisedId}. Please verify the order exists in the database.`;
                console.error("âŒ", errorMsg);
                throw new Error(errorMsg);
            }

            // Sync order status to Firebase Database if status was updated
            // This allows the Cloud Function to trigger push notifications
            // CRITICAL: Skip Firebase sync for picked_up status - notification is created directly in Supabase
            // and FCM is sent via database trigger, preventing duplicate notifications
            if (updates.status !== undefined && updates.status !== 'picked_up') {
                try {
                    await this.syncOrderStatusToFirebase(orderId, updates.status, data[0]);
                } catch (syncError) {
                    // Don't fail the update if Firebase sync fails
                    console.warn("âš ï¸ Failed to sync order status to Firebase:", syncError);
                }
            } else if (updates.status === 'picked_up') {
                console.log('ðŸ”• Skipping Firebase sync for picked_up status - notification handled directly in Supabase');
            }

            return true;
        } catch (err) {
            console.error("âŒ Supabase updateOrder failed:", err);
            throw err;
        }
    },

    // Send FCM push notification to customer using serverless function (HTTP v1 API)
    async sendFCMNotification(fcmToken, title, body, data = {}) {
        if (!fcmToken || !fcmToken.trim()) {
            console.warn('âš ï¸ Cannot send FCM notification: FCM token is empty');
            return false;
        }

        // Get Supabase Edge Function URL from config
        const edgeFunctionUrl = window.firebaseConfig?.SUPABASE_EDGE_FUNCTION_URL || '';
        if (!edgeFunctionUrl || !edgeFunctionUrl.trim()) {
            console.warn('âš ï¸ Cannot send FCM notification: Supabase Edge Function URL not configured. Please add it to firebase-config.js');
            return false;
        }

        // Get customer ID from data
        const customerId = data?.customerId || data?.customer_id || null;
        if (!customerId) {
            console.warn('âš ï¸ Cannot send FCM notification: customer ID not provided in data');
            return false;
        }

        try {
            console.log('ðŸ“¤ Sending FCM notification via Supabase Edge Function');
            console.log('ðŸ“¤ Edge Function URL:', edgeFunctionUrl);
            console.log('ðŸ“¤ Customer ID:', customerId);
            console.log('ðŸ“¤ FCM Token:', fcmToken.substring(0, 20) + '...');
            console.log('ðŸ“¤ Title:', title);
            console.log('ðŸ“¤ Body:', body);

            // Call Supabase Edge Function
            // The Edge Function expects: { customer_id, title, body, data }
            const response = await fetch(edgeFunctionUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${window.firebaseConfig?.SUPABASE_ANON_KEY || ''}`
                },
                body: JSON.stringify({
                    customer_id: customerId,
                    fcm_token: fcmToken,
                    title: title,
                    body: body,
                    data: data
                })
            });

            console.log('ðŸ“¥ Response status:', response.status);
            console.log('ðŸ“¥ Response ok:', response.ok);

            const result = await response.json();
            console.log('ðŸ“¥ Response body:', result);

            if (response.ok && (result.success || result.message)) {
                console.log('âœ… FCM notification sent successfully');
                return true;
            } else {
                console.warn('âš ï¸ FCM notification failed:', result);
                console.warn('âš ï¸ Response status:', response.status);
                console.warn('âš ï¸ Response body:', result);
                return false;
            }
        } catch (error) {
            console.error('âŒ Error sending FCM notification:', error);
            console.error('âŒ Error details:', error.message, error.stack);
            return false;
        }
    },

    // Get notification title and message based on order status
    getNotificationContent(status, orderId, totalAmount) {
        const statusLower = status.toLowerCase();
        // Format order code to match customer app (last 8 chars, uppercase)
        const shortOrderId = orderId.length > 8 ? orderId.substring(orderId.length - 8).toUpperCase() : orderId.toUpperCase();
        const formattedAmount = `â‚±${parseFloat(totalAmount || 0).toFixed(2)}`;

        let title, message;

        switch (statusLower) {
            case 'confirmed':
                title = 'Order Confirmed';
                message = `Your order #${shortOrderId} has been confirmed! Total: ${formattedAmount}`;
                break;
            case 'rejected':
                title = 'Order Rejected';
                message = `Your order #${shortOrderId} has been rejected. Total: ${formattedAmount}`;
                break;
            case 'cancelled':
                title = 'Order Cancelled';
                message = `Your order #${shortOrderId} has been cancelled. Total: ${formattedAmount}`;
                break;
            case 'cancellation_confirmed':
                title = 'Cancellation Confirmed';
                message = `Your cancellation request for order #${shortOrderId} has been confirmed. Total: ${formattedAmount}`;
                break;
            case 'to_receive':
                title = 'Order Ready for Harvesting';
                message = `Your order #${shortOrderId} is ready for harvesting and packaging. Cancellation is no longer applicable. Total: ${formattedAmount}`;
                break;
            case 'out_for_delivery':
                title = 'Order Out for Delivery';
                message = `Your order #${shortOrderId} is out for delivery! Please prepare the total amount of ${formattedAmount}`;
                break;
            case 'pickup_ready':
                title = 'Order Ready To PickUp!';
                message = `Your order #${shortOrderId} is ready for pickup! Total: ${formattedAmount}`;
                break;
            case 'delivered':
                title = 'Order Delivered';
                message = `Your order #${shortOrderId} has been delivered successfully! Total: ${formattedAmount}`;
                break;
            case 'picked_up':
                // CRITICAL: Return null for picked_up - notification is created directly in Supabase
                // This prevents duplicate FCM push notifications (Supabase trigger handles FCM)
                return null;
            case 'failed':
            case 'delivery_failed':
                title = 'Delivery Failed';
                message = `Your order #${shortOrderId} has been failed to delivery. Please contact support. Total: ${formattedAmount}`;
                break;
            case 'failed_pickup':
                title = 'Pickup Failed';
                message = `Your order #${shortOrderId} has been failed to pickup. Please contact support. Total: ${formattedAmount}`;
                break;
            default:
                return null; // Don't send notification for unknown statuses
        }

        return { title, message };
    },

    // Sync order status to Firebase Realtime Database for push notifications
    async syncOrderStatusToFirebase(orderId, status, orderData) {
        try {
            if (!window.firebase || !window.firebase.database) {
                console.warn("Firebase Database not available for status sync");
                return;
            }

            const database = window.firebase.database();

            // Get customer ID and FCM token from order data
            const customerId = orderData?.customer_id || orderData?.customerId || null;

            if (!customerId) {
                console.warn(`âš ï¸ Cannot sync order ${orderId} to Firebase: customerId not found`);
                return;
            }

            // Get FCM token from customer record
            let fcmToken = null;
            try {
                const customerRef = database.ref(`customers/${customerId}/fcmToken`);
                const tokenSnapshot = await customerRef.once('value');
                fcmToken = tokenSnapshot.val();
            } catch (e) {
                console.warn(`âš ï¸ Could not fetch FCM token for customer ${customerId}:`, e);
            }

            // Get order total amount
            const totalAmount = orderData?.total || orderData?.total_amount || 0;

            // Get notification content
            let notificationContent = this.getNotificationContent(status, orderId, totalAmount);

            // CRITICAL: For "to_receive" status, check if order is rescheduled and use custom message
            if (status.toLowerCase() === 'to_receive' && notificationContent) {
                const isRescheduled = orderData?.rescheduled_next_week === true ||
                    orderData?.rescheduled_next_week === 1 ||
                    orderData?.rescheduledNextWeek === true ||
                    orderData?.rescheduledNextWeek === 1;

                if (isRescheduled) {
                    // Calculate next week's Saturday and Sunday dates
                    const { saturday, sunday } = getNextWeekendDates();
                    const satDate = formatDateMMDDYY(saturday);
                    const sunDate = formatDateMMDDYY(sunday);

                    const shortOrderId = orderId.length > 8 ? orderId.substring(orderId.length - 8).toUpperCase() : orderId.toUpperCase();
                    const formattedAmount = `â‚±${parseFloat(totalAmount || 0).toFixed(2)}`;

                    notificationContent = {
                        title: 'Order Re-scheduled',
                        message: `Your Order: #${shortOrderId} (Total: ${formattedAmount}) has been Re-scheduled on Estimated Delivery (${satDate} - ${sunDate}). Thank you for your patience and feel free to chat our staff for your further concerns.`
                    };

                    console.log('âœ… Using rescheduled notification message for order:', orderId);
                }
            }

            // Send FCM push notification if token exists and status requires notification
            if (fcmToken && notificationContent) {
                const notificationType = status.toLowerCase().replace(/\s+/g, '_');
                await this.sendFCMNotification(
                    fcmToken,
                    notificationContent.title,
                    notificationContent.message,
                    {
                        type: `order_${notificationType}`,
                        orderId: orderId,
                        customerId: customerId
                    }
                );
            }

            // Write to order_status_updates table in Firebase Realtime Database
            // Structure: order_status_updates/{orderId} with columns: fcmToken, orderId, customerId, status
            const statusUpdateRef = database.ref(`order_status_updates/${orderId}`);
            await statusUpdateRef.set({
                fcmToken: fcmToken || '',
                orderId: orderId,
                customerId: customerId,
                status: status,
                updatedAt: Date.now(),
            });

            console.log(`âœ… Synced order ${orderId} status "${status}" to Firebase Realtime Database`);
        } catch (error) {
            console.error("âŒ Error syncing order status to Firebase:", error);
            throw error;
        }
    },
};

window.OrderSupabaseAdapter = OrderSupabaseAdapter;

// Product Helper Functions for Supabase Migration
// These functions handle conversion between Firebase format (camelCase) and Supabase format (snake_case)
const ProductHelpers = {
    // Convert Supabase product data (snake_case) to Firebase format (camelCase) for compatibility
    supabaseToFirebase(product) {
        if (!product) return null;
        return {
            uid: product.uid,
            name: product.name || "",
            description: product.description || "",
            category: product.category || "",
            price: product.price || 0.0,
            unit: product.unit || "kg",
            harvestDate: product.harvest_date || "",
            availableQuantity: product.available_quantity ?? product.quantity ?? 0,
            quantity: product.quantity ?? product.available_quantity ?? 0, // Legacy field
            currentReserved: product.current_reserved ?? 0,
            soldQuantity: product.sold_quantity ?? 0,
            imageUrl: product.image_url || product.imageUrl || "",
            image_url: product.image_url || "",
            imageUrls: product.image_urls || product.imageUrls || [],
            imagesStored: product.images_stored ?? false,
            videoUrl: product.video_url || product.videoUrl || "",
            video_url: product.video_url || "",
            videoUrls: product.video_urls || product.videoUrls || [],
            videosStored: product.videos_stored ?? false,
            status: product.status || "active",
            isAvailable: product.is_available ?? true,
            farmerId: product.farmer_id || "",
            farmerName: product.farmer_name || "",
            createdBy: product.created_by || "",
            staffId: product.staff_id || "",
            managedBy: product.managed_by || "",
            updatedBy: product.updated_by || "",
            updatedByName: product.updated_by_name || "",
            updatedByRole: product.updated_by_role || "",
            addedBy: product.added_by || "",
            addedByName: product.added_by_name || "",
            addedByRole: product.added_by_role || "",
            rating: product.rating ?? 0.0,
            reviewCount: product.review_count ?? 0,
            tags: product.tags || [],
            location: product.location || "",
            createdAt: product.created_at || Date.now(),
            // If updated_at is null/undefined, use createdAt so they're equal (product hasn't been updated)
            // This ensures hasBeenUpdated check works correctly
            updatedAt: product.updated_at || product.created_at || Date.now(),
        };
    },

    // Convert Firebase product data (camelCase) to Supabase format (snake_case)
    firebaseToSupabase(product) {
        if (!product) return null;
        return {
            uid: product.uid || product.id,
            name: product.name || "",
            description: product.description || "",
            category: product.category || "",
            price: product.price || 0.0,
            unit: product.unit || "kg",
            harvest_date: product.harvestDate || "",
            available_quantity: product.availableQuantity ?? product.quantity ?? 0,
            quantity: product.quantity ?? product.availableQuantity ?? 0, // Legacy field
            current_reserved: product.currentReserved ?? 0,
            sold_quantity: product.soldQuantity ?? 0,
            image_url: product.image_url || product.imageUrl || "",
            image_urls: product.imageUrls || product.image_urls || [],
            images_stored: product.imagesStored ?? false,
            video_url: product.video_url || product.videoUrl || "",
            video_urls: product.videoUrls || product.video_urls || [],
            videos_stored: product.videosStored ?? false,
            status: product.status || "active",
            is_available: product.isAvailable ?? true,
            farmer_id: product.farmerId || "",
            farmer_name: product.farmerName || "",
            created_by: product.createdBy || "",
            staff_id: product.staffId || "",
            managed_by: product.managedBy || "",
            updated_by: product.updatedBy || "",
            updated_by_name: product.updatedByName || "",
            updated_by_role: product.updatedByRole || "",
            added_by: product.addedBy || "",
            added_by_name: product.addedByName || "",
            added_by_role: product.addedByRole || "",
            rating: product.rating ?? 0.0,
            review_count: product.reviewCount ?? 0,
            tags: product.tags || [],
            location: product.location || "",
            created_at: product.createdAt || Date.now(),
            // If updatedAt is null/undefined, use createdAt (database requires NOT NULL)
            // This ensures updated_at equals created_at for new products (hasn't been updated)
            updated_at: product.updatedAt || product.createdAt || Date.now(),
        };
    },

    // Get Supabase client
    getSupabaseClient() {
        return window.getSupabaseClient
            ? window.getSupabaseClient()
            : window.supabaseClient || null;
    },

    // Get product by UID from Supabase
    async getProduct(uid) {
        try {
            const supabase = this.getSupabaseClient();
            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            const { data, error } = await supabase
                .from("products")
                .select("*")
                .eq("uid", uid)
                .single();

            if (error) {
                if (error.code === "PGRST116") {
                    // No rows returned
                    return null;
                }
                throw error;
            }

            return this.supabaseToFirebase(data);
        } catch (error) {
            console.error("Error getting product from Supabase:", error);
            throw error;
        }
    },

    // Get all products from Supabase
    async getAllProducts() {
        try {
            const supabase = this.getSupabaseClient();
            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            const { data, error } = await supabase
                .from("products")
                .select("*")
                .order("created_at", { ascending: false });

            if (error) {
                throw error;
            }

            // Convert to Firebase format and return as object with uid as key
            const products = {};
            if (data) {
                data.forEach((product) => {
                    products[product.uid] = this.supabaseToFirebase(product);
                });
            }

            return products;
        } catch (error) {
            console.error("Error getting all products from Supabase:", error);
            throw error;
        }
    },

    // Get products by farmer ID from Supabase
    async getProductsByFarmerId(farmerId) {
        try {
            const supabase = this.getSupabaseClient();
            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            const { data, error } = await supabase
                .from("products")
                .select("*")
                .eq("farmer_id", farmerId)
                .order("created_at", { ascending: false });

            if (error) {
                throw error;
            }

            // Convert to Firebase format and return as object with uid as key
            const products = {};
            if (data) {
                data.forEach((product) => {
                    products[product.uid] = this.supabaseToFirebase(product);
                });
            }

            return products;
        } catch (error) {
            console.error(
                "Error getting products by farmer ID from Supabase:",
                error
            );
            throw error;
        }
    },

    // Create product in Supabase
    async createProduct(productData) {
        try {
            const supabase = this.getSupabaseClient();
            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            const supabaseData = this.firebaseToSupabase(productData);

            const { data, error } = await supabase
                .from("products")
                .insert([supabaseData])
                .select()
                .single();

            if (error) {
                throw error;
            }

            return this.supabaseToFirebase(data);
        } catch (error) {
            console.error("Error creating product in Supabase:", error);
            throw error;
        }
    },

    // Update product in Supabase
    async updateProduct(uid, updates) {
        try {
            const supabase = this.getSupabaseClient();
            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            // Map camelCase to snake_case field names
            const fieldMapping = {
                availableQuantity: "available_quantity",
                currentReserved: "current_reserved",
                soldQuantity: "sold_quantity",
                imageUrl: "image_url",
                imageUrls: "image_urls",
                imagesStored: "images_stored",
                videoUrl: "video_url",
                videoUrls: "video_urls",
                videosStored: "videos_stored",
                isAvailable: "is_available",
                farmerId: "farmer_id",
                farmerName: "farmer_name",
                createdBy: "created_by",
                staffId: "staff_id",
                managedBy: "managed_by",
                updatedBy: "updated_by",
                updatedByName: "updated_by_name",
                updatedByRole: "updated_by_role",
                reviewCount: "review_count",
                harvestDate: "harvest_date",
                createdAt: "created_at",
                updatedAt: "updated_at",
            };

            // Convert updates to Supabase format
            const supabaseUpdates = {};
            Object.keys(updates).forEach((key) => {
                // Use mapping if available, otherwise convert camelCase to snake_case
                const snakeKey =
                    fieldMapping[key] || key.replace(/([A-Z])/g, "_$1").toLowerCase();
                supabaseUpdates[snakeKey] = updates[key];
            });

            // Always update updated_at
            supabaseUpdates.updated_at = Date.now();

            console.log(
                `[ProductHelpers.updateProduct] Updating product ${uid} with:`,
                supabaseUpdates
            );

            const { data, error } = await supabase
                .from("products")
                .update(supabaseUpdates)
                .eq("uid", uid)
                .select();

            if (error) {
                console.error(
                    `[ProductHelpers.updateProduct] Error updating product ${uid}:`,
                    error
                );
                throw error;
            }

            console.log(
                `[ProductHelpers.updateProduct] Successfully updated product ${uid}. Response:`,
                data
            );
            return true;
        } catch (error) {
            console.error("Error updating product in Supabase:", error);
            throw error;
        }
    },

    // Delete product from Supabase
    async deleteProduct(uid) {
        try {
            const supabase = this.getSupabaseClient();
            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            const { error } = await supabase.from("products").delete().eq("uid", uid);

            if (error) {
                throw error;
            }

            return true;
        } catch (error) {
            console.error("Error deleting product from Supabase:", error);
            throw error;
        }
    },
};

// Make ProductHelpers available globally
window.ProductHelpers = ProductHelpers;

class StaffManager {
    constructor() {
        this.currentSection = "staff-overview";
        this.currentTab = null;
        this.currentCustomerManagementTab = "pending-verifications";
        this.listeners = [];
        this.currentModal = null;
        this.charts = {};
        this.selectedProducts = new Set();
        this.displayedPendingOrderIds = new Set();
        this._ordersCache = {}; // live in-memory orders map
        this.autoRefreshInterval = null;
        this.pendingVerificationsListener = null;
        this.rejectedVerificationsListener = null;
        this.ridersListener = null;
        // Cache for approved customers to support re-render filtering
        this._approvedCustomersCache = [];
        // Realtime guard for products listeners
        this._productsRealtimeBound = false;
        // Active pickup area ID for persistence across page refreshes
        this._activePickupId = localStorage.getItem("activePickupAreaId") || null;
        // Supabase orders integration state
        this.__usingSupabaseOrders = false;
        this.__supabaseOrdersPollingTimer = null;
        this.__supabaseOrdersHash = null;
        this._barangayOptionsCache = null;

        // Role detection - check if user is admin or staff
        this.userRole = this.detectUserRole();
        this.userUid = this.getUserUid();
        this.userName = this.getUserName();
        this.userEmail = this.getUserEmail();
    }

    detectUserRole() {
        // Check URL parameters first
        const urlParams = new URLSearchParams(window.location.search);
        const roleParam = urlParams.get("role");
        if (roleParam === "admin" || roleParam === "staff") {
            return roleParam;
        }

        // Check session storage
        const userRole = sessionStorage.getItem("userRole");
        if (userRole === "admin" || userRole === "staff") {
            return userRole;
        }

        // Check admin-specific session storage
        if (
            sessionStorage.getItem("adminRole") === "admin" ||
            sessionStorage.getItem("adminUid")
        ) {
            return "admin";
        }

        // Check staff-specific session storage
        if (
            sessionStorage.getItem("staffRole") === "staff" ||
            sessionStorage.getItem("staffUid")
        ) {
            return "staff";
        }

        // Default to staff for backward compatibility
        return "staff";
    }

    getUserUid() {
        const urlParams = new URLSearchParams(window.location.search);
        const uidParam = urlParams.get("uid");
        if (uidParam) return uidParam;

        if (this.userRole === "admin") {
            return (
                sessionStorage.getItem("adminUid") || sessionStorage.getItem("staffUid")
            );
        } else {
            return (
                sessionStorage.getItem("staffUid") || sessionStorage.getItem("adminUid")
            );
        }
    }

    getUserName() {
        const urlParams = new URLSearchParams(window.location.search);
        const nameParam = urlParams.get("username");
        if (nameParam) return decodeURIComponent(nameParam);

        // Don't return default values - return null/empty if not found
        // This prevents showing wrong names before auth completes
        if (this.userRole === "admin") {
            return (
                sessionStorage.getItem("adminName") ||
                sessionStorage.getItem("staffName") ||
                null
            );
        } else {
            return (
                sessionStorage.getItem("staffName") ||
                sessionStorage.getItem("adminName") ||
                null
            );
        }
    }

    getUserEmail() {
        const urlParams = new URLSearchParams(window.location.search);
        const emailParam = urlParams.get("email");
        if (emailParam) return decodeURIComponent(emailParam);

        return (
            sessionStorage.getItem("userEmail") ||
            sessionStorage.getItem("adminEmail") ||
            ""
        );
    }

    // Helper: parse full_name into individual name components
    // This ensures consistent parsing across admin and staff views
    parseFullName(fullName) {
        if (!fullName || !fullName.trim()) {
            return { firstName: '', middleName: '', lastName: '', suffix: '' };
        }

        // Handle common suffixes (Jr, Sr, II, III, etc.)
        const suffixPattern = /\s+(Jr\.?|Sr\.?|II|III|IV|V|VI|VII|VIII|IX|X)$/i;
        const trimmedName = fullName.trim();
        const suffixMatch = trimmedName.match(suffixPattern);
        const suffix = suffixMatch ? suffixMatch[1] : '';
        const nameWithoutSuffix = suffix ? trimmedName.replace(suffixPattern, '').trim() : trimmedName;
        
        const nameParts = nameWithoutSuffix.split(/\s+/).filter(part => part);
        
        if (nameParts.length === 0) {
            return { firstName: '', middleName: '', lastName: '', suffix };
        } else if (nameParts.length === 1) {
            // Only one word - treat as first name
            return { firstName: nameParts[0], middleName: '', lastName: '', suffix };
        } else if (nameParts.length === 2) {
            // Two words - first name and last name
            return { firstName: nameParts[0], middleName: '', lastName: nameParts[1], suffix };
        } else {
            // Three or more words - need to determine if middle parts are part of first name or middle name
            // Heuristic: If middle parts are short (initials like "M.", "J") or very short words, 
            // they're likely part of the first name (e.g., "Mae M. Smith" -> first="Mae M.", last="Smith")
            const middleParts = nameParts.slice(1, -1);
            const lastPart = nameParts[nameParts.length - 1];
            
            // Check if a part is likely an initial (1-2 chars, possibly with period)
            const isInitial = (part) => {
                if (!part) return false;
                const trimmed = part.trim();
                // Remove periods and any trailing/leading punctuation
                const cleaned = trimmed.replace(/[\.\s]/g, '');
                // Must be 1-2 letters only (like "M", "M.", "Jr", "Jr.")
                if (cleaned.length >= 1 && cleaned.length <= 2 && /^[A-Za-z]+$/i.test(cleaned)) {
                    return true;
                }
                return false;
            };
            
            // Strategy: If there are multiple words and the last middle part is an initial,
            // treat everything before the initial as first name, initial as middle name
            // Example: "Joylyn Mae M. Olacao" -> first="Joylyn Mae", middle="M.", last="Olacao"
            // Example: "Mae M. Smith" -> first="Mae", middle="M.", last="Smith"
            
            const lastMiddlePart = middleParts[middleParts.length - 1];
            const isLastMiddleInitial = lastMiddlePart ? isInitial(lastMiddlePart.trim()) : false;
            
            if (isLastMiddleInitial && middleParts.length > 1) {
                // Last middle part is an initial AND there are multiple middle parts
                // Everything before the initial is first name, initial is middle name
                const firstNameParts = [nameParts[0], ...middleParts.slice(0, -1)];
                const result = {
                    firstName: firstNameParts.join(' ').trim(),
                    middleName: lastMiddlePart.trim(),
                    lastName: lastPart.trim(),
                    suffix
                };
                console.log(`parseFullName [${fullName}]: Multiple words + initial detected. Result:`, result);
                return result;
            } else if (isLastMiddleInitial && middleParts.length === 1) {
                // Single middle part that's an initial - keep as middle name
                const result = {
                    firstName: nameParts[0],
                    middleName: lastMiddlePart.trim(),
                    lastName: lastPart.trim(),
                    suffix
                };
                console.log(`parseFullName [${fullName}]: Single initial as middle. Result:`, result);
                return result;
            }
            
            // Standard separation: first word = first name, middle words = middle name, last word = last name
            const result = {
                firstName: nameParts[0],
                middleName: middleParts.join(' '),
                lastName: lastPart.trim(),
                suffix
            };
            console.log(`parseFullName [${fullName}]: Standard separation. Result:`, result);
            return result;
        }
    }

    isAdmin() {
        return this.userRole === "admin";
    }

    isStaff() {
        return this.userRole === "staff";
    }

    async markReadyForPickup(orderId) {
        try {
            // Get Supabase client using OrderSupabaseAdapter (which has the method)
            const supabase = OrderSupabaseAdapter.getSupabaseClient();
            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            // Read order from Supabase
            const sanitisedId = String(orderId).trim();
            let order = null;

            // Try to find order by uid, id, or order_id
            const { data: orderData, error: orderError } = await supabase
                .from("orders")
                .select("*")
                .or(
                    `uid.eq.${sanitisedId},id.eq.${sanitisedId},order_id.eq.${sanitisedId}`
                )
                .limit(1)
                .maybeSingle();

            if (orderError && orderError.code !== "PGRST116") {
                console.error("âŒ Error fetching order from Supabase:", orderError);
                throw orderError;
            }

            if (!orderData) {
                alert(`Order not found in database. Order ID: ${orderId}`);
                return;
            }

            order = orderData;

            // Check if QR code exists for this order
            const qrCode = await this.fetchSupabaseQrRecord(orderId);

            if (!qrCode) {
                const orderCode = orderId.substr(-8).toUpperCase();
                alert(
                    `QR code must be generated first before marking order ready for pickup.\n\nOrder Code: ${orderCode}\n\nPlease generate a QR code for this order.`
                );
                return;
            }

            // Mark as delivered-ready or a specific flag
            const now = Date.now();
            const updates = {
                readyForPickup: true,
                ready_for_pickup_at: now,
                updatedAt: now,
            };

            // Only update status to "to_receive" if it isn't already
            const currentStatus = (order.status || "").toLowerCase();
            if (currentStatus !== "to_receive") {
                updates.status = "to_receive";
            }

            // Update Supabase only (customer app reads from Supabase)
            await OrderSupabaseAdapter.updateOrder(orderId, updates);
            console.log(
                "âœ… Successfully updated order in Supabase for ready for pickup:",
                orderId
            );

            // Create notification for customer about pickup ready
            try {
                const customerId = order.customer_id || order.customerId;
                if (customerId) {
                    // Check if notification already exists to prevent duplicates
                    const { data: existingNotifications } = await supabase
                        .from('customer_notifications')
                        .select('id')
                        .eq('customer_id', customerId)
                        .eq('order_id', orderId)
                        .eq('type', 'order_ready_to_pickup')
                        .limit(1);

                    if (existingNotifications && existingNotifications.length > 0) {
                        console.log('ðŸ“­ Pickup ready notification already exists for order', orderId, ', skipping duplicate');
                    } else {
                        // Format order code (last 8 characters, uppercase)
                        const orderCode = orderId.length > 8
                            ? orderId.substring(orderId.length - 8).toUpperCase()
                            : orderId.toUpperCase();

                        // Get total amount
                        const totalAmount = (order.total_amount || order.total || 0).toFixed(2);
                        const formattedAmount = `â‚±${totalAmount}`;

                        // Create notification
                        const notificationId = `order_${orderId}_pickup_ready_${Date.now()}`;
                        const notificationData = {
                            id: notificationId,
                            customer_id: customerId,
                            title: 'Order Ready To PickUp!',
                            message: `Your order #${orderCode} is ready for pickup! Total: ${formattedAmount}`,
                            type: 'order_ready_to_pickup',
                            timestamp: Date.now(),
                            is_read: false,
                            order_id: orderId,
                            fcm_sent: false, // Will be set to true by Edge Function after sending FCM
                        };

                        await supabase.from('customer_notifications').insert(notificationData);
                        console.log('âœ… Created pickup ready notification for customer:', customerId);
                    }
                } else {
                    console.warn('âš ï¸ Warning: Customer ID not found in order, skipping notification');
                }
            } catch (notificationError) {
                console.warn('âš ï¸ Warning: Failed to create pickup ready notification:', notificationError);
                // Don't fail the order update if notification creation fails
            }

            this.showSuccessMessage("Marked as Ready to Pick Up");
            this.loadAssignedOrders();
            this.loadPendingOrders();
        } catch (e) {
            console.error("Error marking ready for pickup:", e);
            alert(
                "Failed to mark as Ready to Pick Up: " + (e.message || e.toString())
            );
        }
    }

    async markOrderAsPickedUp(orderId) {
        try {
            const confirmed = confirm(
                "Are you sure the customer has picked up the order? This action cannot be undone."
            );
            if (!confirmed) return;

            // Get Supabase client using OrderSupabaseAdapter (which has the method)
            const supabase = OrderSupabaseAdapter.getSupabaseClient();
            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            // Read order from Supabase to get customer_id and total_amount
            const sanitisedId = String(orderId).trim();
            let order = null;

            // Try to find order by uid, id, or order_id
            const { data: orderData, error: orderError } = await supabase
                .from("orders")
                .select("*")
                .or(
                    `uid.eq.${sanitisedId},id.eq.${sanitisedId},order_id.eq.${sanitisedId}`
                )
                .limit(1)
                .maybeSingle();

            if (orderError && orderError.code !== "PGRST116") {
                console.error("âŒ Error fetching order from Supabase:", orderError);
                throw orderError;
            }

            if (!orderData) {
                alert(`Order not found in database. Order ID: ${orderId}`);
                return;
            }

            order = orderData;

            // Capture staff info for pickup verification
            const staffName =
                sessionStorage.getItem("staffName") ||
                sessionStorage.getItem("username") ||
                "Staff";
            const staffRole =
                sessionStorage.getItem("staffRole") ||
                sessionStorage.getItem("role") ||
                "Staff";

            const updates = {
                status: "picked_up",
                pickedUpAt: Date.now(),
                updatedAt: Date.now(),
                pickup_verified_by_name: staffName,
                pickup_verified_by_role: staffRole,
            };

            // Update Supabase only (customer app reads from Supabase)
            await OrderSupabaseAdapter.updateOrder(orderId, updates);
            console.log(
                "âœ… Successfully updated order in Supabase for picked up:",
                orderId
            );

            // Create notification for customer about order received (picked up)
            try {
                const customerId = order.customer_id || order.customerId;
                if (customerId) {
                    // Check if notification already exists to prevent duplicates
                    const { data: existingNotifications } = await supabase
                        .from('customer_notifications')
                        .select('id')
                        .eq('customer_id', customerId)
                        .eq('order_id', orderId)
                        .eq('type', 'order_successful')
                        .limit(1);

                    if (existingNotifications && existingNotifications.length > 0) {
                        console.log('ðŸ“­ Order received notification already exists for order', orderId, ', skipping duplicate');
                    } else {
                        // Format order code (last 8 characters, uppercase)
                        const orderCode = orderId.length > 8
                            ? orderId.substring(orderId.length - 8).toUpperCase()
                            : orderId.toUpperCase();

                        // Get total amount
                        const totalAmount = (order.total_amount || order.total || 0).toFixed(2);
                        const formattedAmount = `â‚±${totalAmount}`;

                        // Create notification
                        const notificationId = `order_${orderId}_picked_up_${Date.now()}`;
                        const notificationData = {
                            id: notificationId,
                            customer_id: customerId,
                            title: 'Order Received',
                            message: `Your order #${orderCode} has been received successfully! Total: ${formattedAmount}`,
                            type: 'order_successful',
                            timestamp: Date.now(),
                            is_read: false,
                            order_id: orderId,
                            fcm_sent: false, // Will be set to true by Edge Function after sending FCM
                        };

                        await supabase.from('customer_notifications').insert(notificationData);
                        console.log('âœ… Created order received notification for customer:', customerId);
                    }
                } else {
                    console.warn('âš ï¸ Warning: Customer ID not found in order, skipping notification');
                }
            } catch (notificationError) {
                console.warn('âš ï¸ Warning: Failed to create order received notification:', notificationError);
                // Don't fail the order update if notification creation fails
            }

            this.showSuccessMessage("Order marked as picked up successfully!");
            this.loadAssignedOrders();
            this.loadPendingOrders();
        } catch (e) {
            console.error("Error marking order as picked up:", e);
            alert(
                "Failed to mark order as picked up: " + (e.message || e.toString())
            );
        }
    }

    async markOrderAsFailedPickup(orderId) {
        try {
            const confirmed = confirm(
                "Are you sure the customer failed to pick up the order? This will move the order to the failed tab. This action cannot be undone."
            );
            if (!confirmed) return;

            // Capture staff info for pickup verification
            const staffName =
                sessionStorage.getItem("staffName") ||
                sessionStorage.getItem("username") ||
                "Staff";
            const staffRole =
                sessionStorage.getItem("staffRole") ||
                sessionStorage.getItem("role") ||
                "Staff";

            const updates = {
                status: "failed_pickup",
                failedPickupAt: Date.now(),
                updatedAt: Date.now(),
                pickup_verified_by_name: staffName,
                pickup_verified_by_role: staffRole,
            };

            // Update Supabase only (customer app reads from Supabase)
            await OrderSupabaseAdapter.updateOrder(orderId, updates);
            console.log(
                "âœ… Successfully updated order in Supabase for failed pickup:",
                orderId
            );

            this.showSuccessMessage("Order marked as failed pickup!");
            this.loadAssignedOrders();
            this.loadPendingOrders();
        } catch (e) {
            console.error("Error marking order as failed pickup:", e);
            alert(
                "Failed to mark order as failed pickup: " + (e.message || e.toString())
            );
        }
    }

    // Validate farmer contributions against the customer's order items (SUPABASE ONLY - NO FIREBASE)
    async recomputeContributionAllocation() {
        try {
            const rows = document.querySelectorAll("#qr-farmer-rows > div");
            const container = document.getElementById("qr-farmer-rows");
            const orderId = container ? container.getAttribute("data-order-id") : "";
            const summaryEl = document.getElementById("qr-alloc-summary");
            const saveBtn = orderId
                ? document.getElementById(`save-qr-button-${orderId}`)
                : null;

            if (!orderId) {
                if (summaryEl) {
                    summaryEl.innerHTML =
                        '<div style="color:#d32f2f;">Order ID not found</div>';
                }
                return;
            }

            // Fetch order data from Supabase to get items array (NO FIREBASE FALLBACK)
            let order = null;
            if (
                window.OrderSupabaseAdapter &&
                typeof window.OrderSupabaseAdapter.fetchOrderById === "function"
            ) {
                try {
                    order = await window.OrderSupabaseAdapter.fetchOrderById(orderId);
                    console.log(
                        "âœ… Fetched order from Supabase for validation:",
                        orderId
                    );
                } catch (supabaseErr) {
                    console.error(
                        "âŒ Failed to fetch order from Supabase for validation:",
                        supabaseErr
                    );
                    if (summaryEl) {
                        summaryEl.innerHTML =
                            '<div style="color:#d32f2f;">Failed to load order data</div>';
                    }
                    return;
                }
            } else {
                console.error("âŒ OrderSupabaseAdapter not available");
                if (summaryEl) {
                    summaryEl.innerHTML =
                        '<div style="color:#d32f2f;">OrderSupabaseAdapter not available</div>';
                }
                return;
            }

            // Build required totals per product from order.items array
            const requiredByProductName = {};
            if (order && order.items && Array.isArray(order.items)) {
                order.items.forEach((item) => {
                    // Handle different item structures (productName, product_name, name)
                    const productName = (
                        item.productName ||
                        item.product_name ||
                        item.name ||
                        ""
                    ).trim();
                    // Handle different quantity fields (quantity, qty)
                    const quantity = parseFloat(item.quantity || item.qty || 0) || 0;

                    if (productName && quantity > 0) {
                        requiredByProductName[productName] =
                            (requiredByProductName[productName] || 0) + quantity;
                    }
                });
            }

            // Sum contributions per productName from input fields
            const contributedByProductName = {};
            rows.forEach((r) => {
                const selects = r.querySelectorAll("select");
                const inputs = r.querySelectorAll("input");
                const productSelect = selects[1];
                const productName = productSelect
                    ? (
                        productSelect.options[productSelect.selectedIndex]?.text || ""
                    ).trim()
                    : "";
                const qtyVal = parseFloat((inputs[0]?.value || "0").trim()) || 0;
                if (productName && qtyVal > 0) {
                    contributedByProductName[productName] =
                        (contributedByProductName[productName] || 0) + qtyVal;
                }
            });

            // Produce summary and validity
            const lines = [];
            let allMatch = true;

            // Check each required product
            Object.keys(requiredByProductName).forEach((name) => {
                const req = requiredByProductName[name] || 0;
                const got = contributedByProductName[name] || 0;
                const diff = +(got - req).toFixed(2);
                const status =
                    diff === 0
                        ? "âœ“ OK"
                        : diff < 0
                            ? `âš  Missing ${Math.abs(diff)} kg`
                            : `âš  Excess ${diff} kg`;
                if (diff !== 0) allMatch = false;
                lines.push(
                    `${name}: required ${req} kg â€¢ contributed ${got} kg â€¢ ${status}`
                );
            });

            // Check for excess contributions (products not in order)
            Object.keys(contributedByProductName).forEach((name) => {
                if (!requiredByProductName.hasOwnProperty(name)) {
                    const got = contributedByProductName[name] || 0;
                    lines.push(
                        `${name}: ${got} kg contributed but NOT in order â€¢ âš  Remove`
                    );
                    allMatch = false;
                }
            });

            if (summaryEl) {
                if (lines.length > 0) {
                    summaryEl.innerHTML = lines
                        .map((l) => {
                            const isError = l.includes("âš ");
                            return `<div style="color:${isError ? "#d32f2f" : "#2e7d32"
                                }; margin-bottom:4px;">${l}</div>`;
                        })
                        .join("");
                } else {
                    summaryEl.innerHTML =
                        '<div style="color:#d32f2f;">No order items detected</div>';
                }
                summaryEl.style.color = allMatch ? "#2e7d32" : "#d32f2f";
            }

            if (saveBtn) {
                saveBtn.disabled = !allMatch;
                if (!allMatch) {
                    saveBtn.title = "Please match all required quantities before saving";
                } else {
                    saveBtn.title = "";
                }
            }
        } catch (e) {
            console.error("recomputeContributionAllocation error:", e);
            const summaryEl = document.getElementById("qr-alloc-summary");
            if (summaryEl) {
                summaryEl.innerHTML = `<div style="color:#d32f2f;">Error: ${e.message || "Unknown error"
                    }</div>`;
            }
        }
    }

    // Enhanced Delivery Settings Module
    async reloadDeliverySettings() {
        try {
            const tbody = document.getElementById("deliveryFeesTableBody");
            if (!tbody) return;
            tbody.innerHTML =
                '<tr><td colspan="5" style="text-align:center; color:#666;">Loading...</td></tr>';

            // Debug: Check if dbRefs is available
            const dbRefsToUse = window.dbRefs || dbRefs;
            console.log("dbRefs available:", !!dbRefsToUse);
            console.log(
                "dbRefs.systemData available:",
                !!(dbRefsToUse && dbRefsToUse.systemData)
            );
            console.log("window.dbRefs:", window.dbRefs);
            console.log("dbRefs:", dbRefs);

            if (!dbRefsToUse || !dbRefsToUse.systemData) {
                console.error("âŒ dbRefs or dbRefs.systemData not available");
                console.log("Available dbRefs keys:", Object.keys(window.dbRefs || {}));
                console.log("dbRefsToUse:", dbRefsToUse);
                tbody.innerHTML =
                    '<tr><td colspan="5" style="text-align:center; color:#c62828;">Database connection not available. Please refresh the page.</td></tr>';
                return;
            }

            // Load current fees from Supabase
            console.log("Fetching delivery fees from Supabase...");

            try {
                // Get Supabase client
                const supabase = window.getSupabaseClient
                    ? window.getSupabaseClient()
                    : window.supabaseClient || null;
                if (!supabase) {
                    throw new Error("Supabase client not available");
                }

                // Fetch the delivery_fees row (id=1)
                const { data, error } = await supabase
                    .from("delivery_fees")
                    .select("*")
                    .eq("id", 1)
                    .single();

                if (error && error.code !== "PGRST116") {
                    // PGRST116 = no rows returned
                    throw new Error("Supabase query failed: " + error.message);
                }

                console.log("âœ… Supabase fetch successful");
                console.log("Raw Supabase data:", data);

                // Convert Supabase row data to barangay name -> fee mapping
                const currentFees = {};

                if (data) {
                    // Get all barangays from the utility
                    const allBarangays = window.AccurateBarangayUtils
                        ? window.AccurateBarangayUtils.getAllBarangays()
                            .map((name) =>
                                window.AccurateBarangayUtils.getBarangayData(name)
                            )
                            .filter((b) => !b.isReference)
                        : [];

                    // Mapping of barangay numbers to their actual directions (based on database schema)
                    const barangayNumberToDirection = {
                        1: "south",
                        2: "south",
                        3: "south",
                        4: "south",
                        5: "south",
                        6: "south",
                        7: "south",
                        8: "south",
                        9: "south",
                        10: "south",
                        11: "north",
                        12: "north",
                        13: "north",
                        14: "north",
                        15: "north",
                        16: "north",
                        17: "north",
                        18: "north",
                        19: "north",
                        20: "north",
                        21: "east",
                        22: "east",
                        23: "east",
                        24: "east",
                        25: "east",
                        26: "west",
                        27: "west",
                        28: "west",
                        29: "west",
                    };

                    // Expand combined/grouped barangay entries into individual barangays
                    const expandedBarangays = [];
                    allBarangays.forEach((barangay) => {
                        const name = barangay.name || "";
                        // Check if this is a combined entry (e.g., "Barangay East (Poblacion) (9-11, 16, 18, 25, 28)")
                        const combinedMatch = name.match(
                            /Barangay\s+(East|West|North|South)\s+\(Poblacion\)\s+\(([^)]+)\)/i
                        );
                        if (combinedMatch) {
                            const numbersStr = combinedMatch[2]; // "9-11, 16, 18, 25, 28"

                            // Parse the numbers and ranges
                            const numbers = [];
                            numbersStr.split(",").forEach((part) => {
                                part = part.trim();
                                if (part.includes("-")) {
                                    // Range like "9-11"
                                    const [start, end] = part
                                        .split("-")
                                        .map((n) => parseInt(n.trim(), 10));
                                    for (let i = start; i <= end; i++) {
                                        numbers.push(i);
                                    }
                                } else {
                                    // Single number
                                    const num = parseInt(part.trim(), 10);
                                    if (!isNaN(num)) numbers.push(num);
                                }
                            });

                            // Create individual barangay entries using the correct direction mapping
                            numbers.forEach((num) => {
                                const direction = barangayNumberToDirection[num];
                                if (direction) {
                                    let individualName;
                                    if (direction === "east") {
                                        individualName = `Barangay ${num} (Poblacion East)`;
                                    } else if (direction === "west") {
                                        individualName = `Barangay ${num} (Poblacion West)`;
                                    } else if (direction === "north") {
                                        individualName = `Barangay ${num} (Poblacion North)`;
                                    } else if (direction === "south") {
                                        individualName = `Barangay ${num} (Poblacion South)`;
                                    }

                                    if (individualName) {
                                        expandedBarangays.push({
                                            name: individualName,
                                            distance: barangay.distance,
                                            classification: barangay.classification || "urban",
                                            suggestedFee: barangay.suggestedFee || 50,
                                            isReference: false,
                                        });
                                    }
                                }
                            });
                        } else {
                            // Regular individual barangay, add as-is
                            expandedBarangays.push(barangay);
                        }
                    });

                    // Map each individual barangay to its column name and get the fee
                    expandedBarangays.forEach((barangay) => {
                        const columnName = barangayNameToColumnName(barangay.name);
                        if (
                            columnName &&
                            data[columnName] !== undefined &&
                            data[columnName] !== null
                        ) {
                            const fee = parseFloat(data[columnName]) || 0;
                            currentFees[barangay.name] = fee;
                        }
                    });
                }

                console.log("Processed currentFees:", currentFees);
                console.log("Processed currentFees keys:", Object.keys(currentFees));
                console.log("Number of fees found:", Object.keys(currentFees).length);

                // Debug specific barangay
                if (currentFees.Alegria !== undefined) {
                    console.log(
                        "âœ… Alegria fee found:",
                        currentFees.Alegria,
                        "type:",
                        typeof currentFees.Alegria
                    );
                } else {
                    console.log("âŒ Alegria fee NOT found in currentFees");
                }

                // Continue with the rest of the function
                await this.processDeliveryFees(currentFees, tbody);
                return;
            } catch (e) {
                console.error("âŒ Supabase fetch failed:", e);
                console.error("Error details:", e.message);
                tbody.innerHTML =
                    '<tr><td colspan="5" style="text-align:center; color:#c62828;">Database fetch failed. Please refresh the page.</td></tr>';
                return;
            }
        } catch (e) {
            console.error("Error loading delivery fees:", e);
            const tbody = document.getElementById("deliveryFeesTableBody");
            if (tbody)
                tbody.innerHTML =
                    '<tr><td colspan="5" style="text-align:center; color:#c62828;">Failed to load fees</td></tr>';
        }
    }

    async processDeliveryFees(currentFees, tbody) {
        try {
            console.log("=== PROCESSING DELIVERY FEES ===");
            console.log("Loaded current fees from database:", currentFees);
            console.log("Number of fees loaded:", Object.keys(currentFees).length);
            console.log("All database fee keys:", Object.keys(currentFees));

            // Debug: Check specific barangay fees
            const sampleBarangays = [
                "Airport",
                "Alegria",
                "Alta Vista",
                "Tambulilid",
            ];
            sampleBarangays.forEach((name) => {
                if (currentFees.hasOwnProperty(name)) {
                    console.log(
                        `Database fee for ${name}: ${currentFees[name]
                        } (type: ${typeof currentFees[name]})`
                    );
                } else {
                    console.log(`No database fee found for ${name}`);
                }
            });

            // Debug: Check all keys in currentFees
            console.log("=== ALL KEYS IN CURRENTFEES ===");
            Object.keys(currentFees).forEach((key) => {
                console.log(
                    `Key: "${key}" = ${currentFees[key]} (type: ${typeof currentFees[
                    key
                    ]})`
                );
            });

            // Debug: Check if currentFees is actually populated
            if (Object.keys(currentFees).length === 0) {
                console.log(
                    "â„¹ï¸ currentFees object is empty - no fees have been set yet. This is normal for a new system."
                );
                console.log(
                    "âœ… Database connection is working, just no fees saved yet."
                );
            } else {
                console.log("âœ… currentFees object has data:", currentFees);
            }

            // Get all delivery areas from our data (excluding reference point)
            const allBarangays = window.AccurateBarangayUtils
                ? window.AccurateBarangayUtils.getAllBarangays()
                    .map((name) => window.AccurateBarangayUtils.getBarangayData(name))
                    .filter((b) => !b.isReference)
                : [];
            const referencePoint = window.AccurateBarangayUtils
                ? window.AccurateBarangayUtils.getReferencePoint()
                : null;

            console.log("All barangays loaded:", allBarangays.length);
            console.log(
                "First few barangay names:",
                allBarangays.slice(0, 5).map((b) => b.name)
            );

            if (allBarangays.length === 0) {
                tbody.innerHTML =
                    '<tr><td colspan="5" style="text-align:center; color:#c62828;">Barangay data not loaded. Please refresh the page.</td></tr>';
                return;
            }

            // Debug: Compare barangay names from code vs database
            console.log("=== BARANGAY NAME COMPARISON ===");
            console.log(
                "Barangay names from code (first 5):",
                allBarangays.slice(0, 5).map((b) => b.name)
            );
            console.log("Barangay names from database:", Object.keys(currentFees));

            // Check for exact matches
            const codeNames = allBarangays.map((b) => b.name);
            const dbNames = Object.keys(currentFees);
            const matches = codeNames.filter((name) => dbNames.includes(name));
            const noMatches = codeNames.filter((name) => !dbNames.includes(name));

            console.log("âœ… Exact matches found:", matches);
            console.log("âŒ No matches found:", noMatches.slice(0, 10)); // Show first 10

            // Mapping of barangay numbers to their actual directions (based on database schema)
            const barangayNumberToDirection = {
                1: "south",
                2: "south",
                3: "south",
                4: "south",
                5: "south",
                6: "south",
                7: "south",
                8: "south",
                9: "south",
                10: "south",
                11: "north",
                12: "north",
                13: "north",
                14: "north",
                15: "north",
                16: "north",
                17: "north",
                18: "north",
                19: "north",
                20: "north",
                21: "east",
                22: "east",
                23: "east",
                24: "east",
                25: "east",
                26: "west",
                27: "west",
                28: "west",
                29: "west",
            };

            // Expand combined/grouped barangay entries into individual barangays
            const expandedBarangays = [];
            allBarangays.forEach((barangay) => {
                const name = barangay.name || "";
                // Check if this is a combined entry (e.g., "Barangay East (Poblacion) (9-11, 16, 18, 25, 28)")
                const combinedMatch = name.match(
                    /Barangay\s+(East|West|North|South)\s+\(Poblacion\)\s+\(([^)]+)\)/i
                );
                if (combinedMatch) {
                    const numbersStr = combinedMatch[2]; // "9-11, 16, 18, 25, 28"

                    // Parse the numbers and ranges
                    const numbers = [];
                    numbersStr.split(",").forEach((part) => {
                        part = part.trim();
                        if (part.includes("-")) {
                            // Range like "9-11"
                            const [start, end] = part
                                .split("-")
                                .map((n) => parseInt(n.trim(), 10));
                            for (let i = start; i <= end; i++) {
                                numbers.push(i);
                            }
                        } else {
                            // Single number
                            const num = parseInt(part.trim(), 10);
                            if (!isNaN(num)) numbers.push(num);
                        }
                    });

                    // Create individual barangay entries using the correct direction mapping
                    numbers.forEach((num) => {
                        const direction = barangayNumberToDirection[num];
                        if (direction) {
                            let individualName;
                            if (direction === "east") {
                                individualName = `Barangay ${num} (Poblacion East)`;
                            } else if (direction === "west") {
                                individualName = `Barangay ${num} (Poblacion West)`;
                            } else if (direction === "north") {
                                individualName = `Barangay ${num} (Poblacion North)`;
                            } else if (direction === "south") {
                                individualName = `Barangay ${num} (Poblacion South)`;
                            }

                            if (individualName) {
                                expandedBarangays.push({
                                    name: individualName,
                                    distance: barangay.distance,
                                    classification: barangay.classification || "urban",
                                    suggestedFee: barangay.suggestedFee || 50,
                                    isReference: false,
                                    coordinates: barangay.coordinates,
                                    coastal: barangay.coastal || false,
                                });
                            }
                        }
                    });
                } else {
                    // Regular individual barangay, add as-is
                    expandedBarangays.push(barangay);
                }
            });

            // Render all individual barangays with current fees
            const rows = expandedBarangays.map((barangay) => {
                const currentFee = currentFees[barangay.name] || 0;
                console.log(`Processing ${barangay.name}: currentFee = ${currentFee}`);
                console.log(
                    `Checking if ${barangay.name} exists in currentFees:`,
                    currentFees.hasOwnProperty(barangay.name)
                );
                return this._renderEnhancedBrgyRow(barangay, currentFee);
            });

            tbody.innerHTML = rows.join("");
            this._updateSummaryStats(expandedBarangays, currentFees);
            this._setupSearchAndFilter();
            this._showReferencePointInfo(referencePoint);

            // Store current fees in window for the HTML caching system to use
            window.__currentDeliveryFees = currentFees;
            console.log(
                "Stored current fees in window.__currentDeliveryFees:",
                currentFees
            );

            // Directly apply the fees to the table rows - simple and reliable
            setTimeout(() => {
                console.log("Applying fees directly to table rows...");
                const tableRows = Array.from(
                    tbody.querySelectorAll("tr[data-barangay]")
                );
                console.log(`Found ${tableRows.length} table rows to process`);

                tableRows.forEach((tr) => {
                    const barangayName = tr.getAttribute("data-barangay");
                    if (!barangayName) return;

                    const feeVal = currentFees[barangayName];
                    console.log(
                        `Processing ${barangayName}: fee = ${feeVal} (type: ${typeof feeVal})`
                    );
                    console.log(
                        `Checking currentFees["${barangayName}"]:`,
                        currentFees[barangayName]
                    );
                    console.log(
                        `currentFees.hasOwnProperty("${barangayName}"):`,
                        currentFees.hasOwnProperty(barangayName)
                    );

                    const currentFeeSpan = tr.querySelector(".current-fee-text");
                    if (currentFeeSpan) {
                        const numericFee = Number(feeVal);
                        if (feeVal != null && !isNaN(numericFee) && numericFee > 0) {
                            currentFeeSpan.textContent = `â‚±${numericFee}`;
                            currentFeeSpan.style.color = "#2e7d32";
                            currentFeeSpan.style.fontWeight = "bold";
                            tr.style.background = "#e8f5e9";
                            tr.style.color = "#2e7d32";
                            console.log(`âœ… Set ${barangayName} to â‚±${numericFee}`);
                        } else {
                            currentFeeSpan.textContent = "â‚±0";
                            currentFeeSpan.style.color = "#c62828";
                            currentFeeSpan.style.fontWeight = "bold";
                            tr.style.background = "#ffebee";
                            tr.style.color = "#c62828";
                            console.log(
                                `â„¹ï¸ Set ${barangayName} to â‚±0 (fee: ${feeVal}, numeric: ${numericFee})`
                            );
                        }
                    } else {
                        console.log(`âŒ No current fee span found for ${barangayName}`);
                    }
                });
            }, 200);
        } catch (e) {
            console.error("Error processing delivery fees:", e);
            tbody.innerHTML =
                '<tr><td colspan="5" style="text-align:center; color:#c62828;">Failed to process fees</td></tr>';
        }
    }

    _renderBrgyRow(brgy, fee) {
        const safeBrgy = String(brgy || "").replace(/</g, "&lt;");
        const safeFee = Number(fee || 0);
        return `
            <tr data-brgy="${safeBrgy}">
                <td><input type="text" value="${safeBrgy}" class="brgy-name-input" placeholder="Barangay name" /></td>
                <td><input type="number" min="0" step="1" value="${safeFee}" class="brgy-fee-input" /></td>
                <td>
                    <button class="secondary-btn" onclick="window.staffManager && staffManager.duplicateBarangayRow(this)"><i class="fas fa-copy"></i> Duplicate</button>
                    <button class="danger-btn" onclick="window.staffManager && staffManager.removeBarangayRow(this)"><i class="fas fa-trash"></i> Remove</button>
                </td>
            </tr>
        `;
    }

    _renderEnhancedBrgyRow(barangay, currentFee) {
        // Ensure we have a valid barangay name
        const rawName = String(barangay.name || "").trim();
        if (!rawName || rawName.length > 100) {
            console.error(
                "Invalid barangay name in _renderEnhancedBrgyRow:",
                rawName
            );
            return ""; // Return empty string to skip this row
        }

        const safeName = rawName.replace(/</g, "&lt;");
        const safeFee = Number(currentFee || 0);
        const suggestedFee = barangay.suggestedFee || 50;
        const classification = barangay.classification || "unknown";
        const zoneDesc =
            classification.charAt(0).toUpperCase() + classification.slice(1);
        const distanceText =
            barangay.distance === 0 ? "Reference Point" : `${barangay.distance} km`;

        const isConfigured = safeFee > 0;
        const feeClass = isConfigured
            ? 'style="background:#e8f5e9; color:#2e7d32;"'
            : 'style="background:#ffebee; color:#c62828;"';
        const feeValue = safeFee > 0 ? safeFee : "";
        const currentFeeDisplay = safeFee > 0 ? `â‚±${safeFee}` : "â‚±0";

        console.log(
            `Rendering row for ${safeName}: currentFee=${currentFee}, safeFee=${safeFee}, currentFeeDisplay="${currentFeeDisplay}"`
        );

        return `
            <tr data-barangay="${safeName}" data-classification="${classification}" data-distance="${barangay.distance
            }" ${feeClass}>
                <td>
                    <input type="checkbox" class="barangay-checkbox" data-barangay="${safeName}" />
                </td>
                <td>
                    <strong>${safeName}</strong>
                    ${barangay.isReference
                ? '<span style="color:#28a745; font-size:11px; margin-left:8px;">(Reference)</span>'
                : ""
            }
                </td>
                <td style="text-align:center;">${distanceText}</td>
                <td style="text-align:center; font-weight:bold; color:#2e7d32;">
                    <span class="current-fee-text">${currentFeeDisplay}</span>
                </td>
                <td style="text-align:center;">
                    <input type="number" min="0" step="1" value="${feeValue}" 
                           class="brgy-fee-input" placeholder="0" 
                           style="width:80px; text-align:center; padding:4px 8px; border:1px solid #ddd; border-radius:4px;"
                           data-suggested="${suggestedFee}"
                           onchange="window.staffManager && staffManager._onFeeChange(this)" 
                           oninput="window.staffManager && staffManager._onFeeChange(this)" />
                    ${!barangay.isReference
                ? `
                    <button class="danger-btn" onclick="window.staffManager && staffManager.removeBarangayFee(this)" 
                            style="font-size:11px; padding:4px 8px; margin-left:4px;" title="Remove Fee">
                        <i class="fas fa-times"></i>
                    </button>
                    `
                : ""
            }
                </td>
            </tr>
        `;
    }

    addBarangayRow() {
        const tbody = document.getElementById("deliveryFeesTableBody");
        if (!tbody) return;
        const temp = document.createElement("tbody");
        temp.innerHTML = this._renderBrgyRow("", 0);
        tbody.appendChild(temp.firstElementChild);
    }

    duplicateBarangayRow(btn) {
        const tr = btn && btn.closest ? btn.closest("tr") : null;
        if (!tr) return;
        const name = tr.querySelector(".brgy-name-input")?.value || "";
        const fee = tr.querySelector(".brgy-fee-input")?.value || 0;
        const tbody = tr.parentElement;
        const temp = document.createElement("tbody");
        temp.innerHTML = this._renderBrgyRow(name, fee);
        tbody.insertBefore(temp.firstElementChild, tr.nextSibling);
    }

    removeBarangayRow(btn) {
        const tr = btn && btn.closest ? btn.closest("tr") : null;
        if (!tr) return;
        tr.remove();
    }

    async saveDeliveryFees() {
        try {
            const tbody = document.getElementById("deliveryFeesTableBody");
            if (!tbody) return;

            // Only get rows that have the data-barangay attribute (skip header rows and invalid rows)
            const rows = Array.from(tbody.querySelectorAll("tr[data-barangay]"));

            if (rows.length === 0) {
                this.showErrorMessage("No valid delivery fee rows found");
                return;
            }

            // Collect barangays explicitly selected for zeroing via checkbox
            const zeroSelected = new Set(
                Array.from(document.querySelectorAll(".barangay-checkbox:checked"))
                    .map((cb) => cb.getAttribute("data-barangay"))
                    .filter((name) => name && name.length > 0 && name.length < 100) // Filter out invalid names
            );
            // Get Supabase client
            const supabase = window.getSupabaseClient
                ? window.getSupabaseClient()
                : window.supabaseClient || null;
            if (!supabase) {
                this.showErrorMessage(
                    "Supabase client not available. Please refresh the page."
                );
                return;
            }

            // Get current fees from Supabase to preserve existing values
            const { data: currentData } = await supabase
                .from("delivery_fees")
                .select("*")
                .eq("id", 1)
                .single();

            const updateData = currentData ? { ...currentData } : { id: 1 };
            let savedCount = 0;

            for (const tr of rows) {
                // Skip if this is not a valid data row
                if (
                    !tr.hasAttribute("data-barangay") &&
                    !tr.querySelector(".brgy-fee-input")
                ) {
                    continue;
                }

                const barangayName = tr.getAttribute("data-barangay");
                const feeInput = tr.querySelector(".brgy-fee-input");
                if (!barangayName || !feeInput) {
                    console.warn("Skipping row - missing barangay name or fee input");
                    console.warn(
                        "Row data-barangay:",
                        barangayName,
                        "Fee input:",
                        feeInput
                    );
                    continue;
                }

                // Validate barangay name - it should not look like multiple names concatenated
                // Check for suspicious patterns like numbers separated by underscores or spaces
                const numberMatches = barangayName.match(/\d+/g);
                const numberCount = numberMatches ? numberMatches.length : 0;
                const underscoreParts = barangayName.split("_").length;

                if (
                    !barangayName ||
                    barangayName.length > 100 ||
                    barangayName.split(" ").length > 10 ||
                    /^\d+[\s_]+\d+/.test(barangayName) || // Multiple numbers at start
                    numberCount > 3 || // More than 3 number sequences (suggests concatenation)
                    (barangayName.includes("_") && underscoreParts > 8) || // Too many underscore-separated parts
                    /barangay.*\d+.*barangay/i.test(barangayName) || // Multiple "barangay" mentions
                    /poblacion.*\d+.*poblacion/i.test(barangayName)
                ) {
                    // Multiple "poblacion" mentions
                    console.error("âŒ Suspicious barangay name detected:", barangayName);
                    console.error(
                        "Length:",
                        barangayName.length,
                        "Words:",
                        barangayName.split(" ").length,
                        "Numbers:",
                        numberCount,
                        "Underscore parts:",
                        underscoreParts
                    );
                    console.error(
                        "Row data-barangay attribute:",
                        tr.getAttribute("data-barangay")
                    );
                    console.error("Row innerHTML:", tr.innerHTML.substring(0, 200));
                    continue;
                }

                // If staff selected this barangay via checkbox, force fee to 0
                const fee = zeroSelected.has(barangayName)
                    ? 0
                    : Math.max(0, parseFloat(feeInput.value || "0"));

                // Convert barangay name to column name
                console.log("Processing barangay:", barangayName);
                const columnName = barangayNameToColumnName(barangayName);
                if (columnName) {
                    // Validate column name - it should not be too long or contain suspicious patterns
                    const columnUnderscoreParts = columnName.split("_").length;
                    const columnNumberMatches = columnName.match(/\d+/g);
                    const columnNumberCount = columnNumberMatches
                        ? columnNumberMatches.length
                        : 0;

                    if (
                        columnName.length > 50 ||
                        columnUnderscoreParts > 10 ||
                        /barangay.*\d+.*barangay/i.test(columnName) ||
                        /poblacion.*\d+.*poblacion/i.test(columnName) ||
                        columnNumberCount > 2
                    ) {
                        console.error(
                            "âŒ Invalid column name detected:",
                            columnName,
                            "for barangay:",
                            barangayName
                        );
                        console.error(
                            "Column name parts:",
                            columnUnderscoreParts,
                            "Numbers:",
                            columnNumberCount
                        );
                        console.error(
                            "This suggests multiple barangay names were concatenated. Skipping this row."
                        );
                        continue;
                    }
                    console.log(
                        "âœ… Saving fee for",
                        barangayName,
                        "-> column:",
                        columnName,
                        "fee:",
                        fee
                    );
                    updateData[columnName] = fee;
                    if (fee > 0) savedCount++;
                } else {
                    console.warn(
                        "Could not convert barangay name to column:",
                        barangayName
                    );
                }
            }

            // Update the updated_at timestamp
            updateData.updated_at = new Date().toISOString();

            // Filter out any invalid column names before sending to Supabase
            const validUpdateData = { id: updateData.id || 1 };
            const validColumns = ["id", "updated_at"]; // Known valid columns

            // Get all valid barangay column names (they should match the pattern: lowercase with underscores, max 50 chars)
            Object.keys(updateData).forEach((key) => {
                if (key === "id" || key === "updated_at") {
                    validUpdateData[key] = updateData[key];
                } else if (
                    key.length <= 50 &&
                    /^[a-z0-9_]+$/.test(key) &&
                    key.split("_").length <= 10
                ) {
                    // Valid column name pattern
                    validUpdateData[key] = updateData[key];
                } else {
                    console.warn(
                        "Filtering out invalid column name from updateData:",
                        key
                    );
                }
            });

            console.log("Final updateData keys:", Object.keys(validUpdateData));

            // Upsert the row (insert if doesn't exist, update if it does)
            const { error } = await supabase
                .from("delivery_fees")
                .upsert(validUpdateData, { onConflict: "id" });

            if (error) {
                throw new Error("Failed to save delivery fees: " + error.message);
            }

            this.showSuccessMessage(
                `Delivery fees saved successfully! ${savedCount} barangays configured.`
            );

            // Uncheck all checkboxes after successful save
            const allCheckboxes = document.querySelectorAll(".barangay-checkbox");
            allCheckboxes.forEach((checkbox) => {
                checkbox.checked = false;
            });

            // Update Current Fee displays immediately
            const rowsAfterSave = Array.from(
                tbody.querySelectorAll("tr[data-barangay]")
            );
            rowsAfterSave.forEach((tr) => {
                const barangayName = tr.getAttribute("data-barangay");
                const feeInput = tr.querySelector(".brgy-fee-input");
                const brgyCheckbox = tr.querySelector(".barangay-checkbox");
                if (!barangayName || !feeInput) return;

                const forceZero = zeroSelected.has(barangayName);
                const fee = forceZero
                    ? 0
                    : Math.max(0, parseFloat(feeInput.value || "0"));
                const currentFeeSpan = tr.querySelector(".current-fee-text");
                if (currentFeeSpan) {
                    if (fee > 0) {
                        currentFeeSpan.textContent = `â‚±${fee}`;
                        currentFeeSpan.style.color = "#2e7d32";
                        currentFeeSpan.style.fontWeight = "bold";
                        tr.style.background = "#e8f5e9";
                        tr.style.color = "#2e7d32";
                    } else {
                        currentFeeSpan.textContent = "â‚±0";
                        currentFeeSpan.style.color = "#c62828";
                        currentFeeSpan.style.fontWeight = "bold";
                        tr.style.background = "#ffebee";
                        tr.style.color = "#c62828";
                    }
                    // If forced zero, also reflect in input and uncheck for next action
                    if (forceZero) {
                        feeInput.value = "0";
                        if (brgyCheckbox) brgyCheckbox.checked = false;
                    }
                }
            });

            // Reload the fees to ensure UI is in sync
            await this.loadDeliveryFees();
        } catch (e) {
            console.error("Error saving delivery fees:", e);
            alert("Error saving fees: " + (e && e.message ? e.message : e));
        }
    }

    // New methods for enhanced delivery fee management

    // =========================
    // Pickup Locations Manager
    // =========================
    async loadPickupArea() {
        try {
            const listEl = document.getElementById("pickupLocationsList");
            if (!listEl) {
                console.warn("pickupLocationsList element not found");
                return;
            }
            listEl.innerHTML =
                '<div style="padding:16px; color:#666; text-align:center; border:1px dashed #ddd; border-radius:8px;">Loading pickup locations...</div>';

            const dbRefsToUse = window.dbRefs || dbRefs;
            if (!dbRefsToUse || !dbRefsToUse.systemData) {
                console.error("Database references not available");
                listEl.innerHTML =
                    '<div style="padding:16px; color:#c62828; text-align:center; border:1px dashed #f4c7c7; border-radius:8px;">Database not available. Please refresh.</div>';
                return;
            }

            console.log("Loading pickup locations from systemData/pickupLocations");

            // Use the same database reference method as savePickupArea
            const snap = await dbRefsToUse.systemData
                .child("pickupLocations")
                .once("value");
            const raw = snap.val();

            console.log("Pickup locations data:", raw);

            // Normalize to id->record map
            let data = {};
            if (!raw) {
                data = {};
            } else if (Array.isArray(raw)) {
                data = raw.reduce((acc, item, idx) => {
                    if (item && typeof item === "object") {
                        const id = item.id || String(idx);
                        acc[id] = { id, ...item };
                    }
                    return acc;
                }, {});
            } else if (typeof raw === "object") {
                // Already an object with id keys
                data = raw;
            }

            console.log("Normalized pickup locations:", data);
            this._renderPickupLocationsList(data);

            // Attach realtime listener once to reflect future changes
            if (!this._pickupRealtimeBound) {
                const pickupRef = dbRefsToUse.systemData.child("pickupLocations");
                pickupRef.on("value", (snap) => {
                    const val = snap.val() || {};
                    let normalized = {};
                    if (Array.isArray(val)) {
                        normalized = val.reduce((acc, item, idx) => {
                            if (item && typeof item === "object") {
                                const id = item.id || String(idx);
                                acc[id] = { id, ...item };
                            }
                            return acc;
                        }, {});
                    } else if (typeof val === "object") {
                        normalized = val;
                    }
                    console.log("Realtime update - pickup locations:", normalized);
                    this._renderPickupLocationsList(normalized);
                });
                this._pickupRealtimeBound = true;
                console.log("Realtime listener attached for pickup locations");
            }
        } catch (e) {
            console.error("Error loading pickup locations:", e);
            const listEl = document.getElementById("pickupLocationsList");
            if (listEl) {
                listEl.innerHTML = `<div style="padding:16px; color:#c62828; text-align:center; border:1px dashed #f4c7c7; border-radius:8px;">
                    Failed to load pickup locations<br>
                    <small style="color:#666;">${e && e.message ? e.message : String(e)
                    }</small>
                </div>`;
            }
        }
    }
    _renderPickupLocationsList(locationsObj) {
        const listEl = document.getElementById("pickupLocationsList");
        if (!listEl) return;

        const entries = Object.entries(locationsObj)
            // show all saved locations regardless of active flag to make debugging clear
            .sort((a, b) => (b[1]?.updatedAt || 0) - (a[1]?.updatedAt || 0));

        if (entries.length === 0) {
            listEl.innerHTML = `
                <div style="padding:24px; border:2px dashed #e0e0e0; border-radius:10px; background:#fafafa; color:#666; text-align:center;">
                    No pickup locations configured yet.
                </div>
            `;
            return;
        }

        const html = entries
            .map(([id, loc], idx) => {
                const safe = (s) => (s == null ? "" : String(s).replace(/</g, "&lt;"));
                const name = safe(loc.name || "Unnamed Location");
                const address = safe(loc.address || "");
                const landmark = safe(loc.landmark || "");
                const instructions = safe(loc.instructions || "");
                const mapLink = safe(loc.mapLink || "");
                const updated = loc.updatedAt
                    ? new Date(loc.updatedAt).toLocaleString()
                    : "";

                return `
                <div style="border:2px dashed #dcdcdc; border-radius:8px; padding:12px; background:#fff; display:grid; gap:8px;">
                    <div style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
                        <div style="display:flex; gap:8px; align-items:center;">
                            <h4 style="margin:0;">${name}</h4>
                        </div>
                        <div style="display:flex; gap:6px;">
                            ${mapLink
                        ? `<a class=\"secondary-btn\" href=\"${mapLink}\" target=\"_blank\" rel=\"noopener\"><i class=\\"fas fa-map\\\"></i> Map</a>`
                        : ""
                    }
                            <button class="secondary-btn" onclick="window.staffManager && staffManager.editPickupArea('${id}')"><i class="fas fa-edit"></i> Edit</button>
                            <button class="danger-btn" onclick="window.staffManager && staffManager.deletePickupArea('${id}')"><i class="fas fa-trash"></i> Delete</button>
                        </div>
                    </div>
                    <div style="display:grid; grid-template-columns:160px 1fr; gap:4px 12px; color:#444;">
                        <div style="font-weight:600;">Address</div>
                        <div>${address || '<span style="color:#888;">â€”</span>'
                    }</div>
                        <div style="font-weight:600;">Landmark</div>
                        <div>${landmark || '<span style="color:#888;">â€”</span>'
                    }</div>
                        <div style="font-weight:600;">Instructions</div>
                        <div style="white-space:pre-wrap;">${instructions || '<span style="color:#888;">â€”</span>'
                    }</div>
                        ${updated
                        ? `<div style=\"font-weight:600;\">Updated</div><div>${updated}</div>`
                        : ""
                    }
                    </div>
                </div>
            `;
            })
            .join("");

        listEl.innerHTML = html;
    }

    async savePickupArea() {
        try {
            const nameEl = document.getElementById("pickupName");
            const mapEl = document.getElementById("pickupMapLink");
            const addrEl = document.getElementById("pickupAddress");
            const landmarkEl = document.getElementById("pickupLandmark");
            const instrEl = document.getElementById("pickupInstructions");
            const idEl = document.getElementById("currentLocationId");

            if (!nameEl) {
                alert("Form elements not found. Please refresh the page.");
                return;
            }

            const name = (nameEl.value || "").trim();
            if (!name) {
                alert("Please enter Location Name");
                nameEl.focus();
                return;
            }

            const address = (addrEl?.value || "").trim();
            if (!address) {
                alert("Please enter Address");
                if (addrEl) addrEl.focus();
                return;
            }

            const dbRefsToUse = window.dbRefs || dbRefs;
            if (!dbRefsToUse || !dbRefsToUse.systemData) {
                alert("Database connection not available. Please refresh the page.");
                console.error("Database references not available:", {
                    windowDbRefs: !!window.dbRefs,
                    dbRefs: !!dbRefs,
                });
                return;
            }

            const payload = {
                name,
                mapLink: (mapEl?.value || "").trim(),
                address,
                landmark: (landmarkEl?.value || "").trim(),
                instructions: (instrEl?.value || "").trim(),
                updatedAt: Date.now(),
                active: true,
            };

            const parent = dbRefsToUse.systemData.child("pickupLocations");
            const existingId = (idEl?.value || "").trim();

            console.log("Saving pickup area:", { existingId, payload });

            if (existingId) {
                await parent.child(existingId).update(payload);
                console.log("Updated existing pickup area:", existingId);
            } else {
                payload.createdAt = Date.now();
                const newRef = parent.push();
                await newRef.set({ id: newRef.key, ...payload });
                console.log("Created new pickup area:", newRef.key);
            }

            alert("Pick Up area saved successfully!");

            // Reset form for another input (keep visible)
            if (idEl) idEl.value = "";
            if (nameEl) nameEl.value = "";
            if (mapEl) mapEl.value = "";
            if (addrEl) addrEl.value = "";
            if (landmarkEl) landmarkEl.value = "";
            if (instrEl) instrEl.value = "";
            const title = document.getElementById("pickupSectionTitle");
            const form = document.getElementById("defaultPickupForm");
            if (title) title.style.display = "block";
            if (form) form.style.display = "block";

            // Reload the list to show the new/updated item
            await this.loadPickupArea();
        } catch (e) {
            console.error("Error saving pickup area:", e);
            alert(
                "Error saving pickup area: " + (e && e.message ? e.message : String(e))
            );
        }
    }

    async editPickupArea(id) {
        try {
            const dbRefsToUse = window.dbRefs || dbRefs;
            if (!dbRefsToUse || !dbRefsToUse.systemData) {
                alert("Database connection not available. Please refresh the page.");
                return;
            }

            const snap = await dbRefsToUse.systemData
                .child("pickupLocations")
                .child(id)
                .once("value");
            const loc = snap.val();
            if (!loc) {
                alert("Pickup location not found.");
                return;
            }

            // Show the form
            const formContainer = document.getElementById("pickupAreaForm");
            const title = document.getElementById("pickupSectionTitle");
            const form = document.getElementById("defaultPickupForm");

            if (formContainer) formContainer.style.display = "block";
            if (title) {
                title.textContent = "Edit Pickup Area";
                title.style.display = "block";
            }
            if (form) form.style.display = "block";

            const setVal = (id, v) => {
                const el = document.getElementById(id);
                if (el) el.value = v || "";
            };
            setVal("pickupName", loc.name);
            setVal("pickupMapLink", loc.mapLink);
            setVal("pickupAddress", loc.address);
            setVal("pickupLandmark", loc.landmark);
            setVal("pickupInstructions", loc.instructions);
            setVal("currentLocationId", id);

            // Scroll to form
            if (formContainer)
                formContainer.scrollIntoView({ behavior: "smooth", block: "nearest" });
        } catch (e) {
            console.error("Error editing pickup area:", e);
            alert(
                "Error loading pickup area for editing: " +
                (e && e.message ? e.message : String(e))
            );
        }
    }

    async deletePickupArea(id) {
        try {
            const confirmDel = window.confirm(
                "Delete this pickup location? This cannot be undone."
            );
            if (!confirmDel) return;

            const dbRefsToUse = window.dbRefs || dbRefs;
            if (!dbRefsToUse || !dbRefsToUse.systemData) {
                alert("Database connection not available. Please refresh the page.");
                return;
            }

            await dbRefsToUse.systemData.child("pickupLocations").child(id).remove();
            console.log("Deleted pickup area:", id);
            alert("Pick Up area deleted successfully!");
            await this.loadPickupArea();
        } catch (e) {
            console.error("Error deleting pickup area:", e);
            alert(
                "Error deleting pickup area: " +
                (e && e.message ? e.message : String(e))
            );
        }
    }

    // =========================
    // New Pickup Area Record (pickupArea table)
    // =========================
    openPickupAreaForm() {
        const f = document.getElementById("pickupAreaForm");
        const t = f ? f.querySelector("h4") : null;
        if (t) t.textContent = "Add Pickup Area";
        const ids = [
            "pa_currentId",
            "pa_name",
            "pa_mapLink",
            "pa_landmark",
            "pa_street",
            "pa_sitio",
            "pa_barangay",
            "pa_city",
            "pa_province",
            "pa_instructions",
        ];
        ids.forEach((id) => {
            const el = document.getElementById(id);
            if (el) el.value = "";
        });
        // Reset city and province to defaults
        const cityEl = document.getElementById("pa_city");
        const provinceEl = document.getElementById("pa_province");
        if (cityEl) cityEl.value = "Ormoc";
        if (provinceEl) provinceEl.value = "Leyte";
        if (f) f.style.display = "block";
    }
    cancelPickupAreaForm() {
        const f = document.getElementById("pickupAreaForm");
        if (f) f.style.display = "none";
        const ids = [
            "pa_currentId",
            "pa_name",
            "pa_mapLink",
            "pa_landmark",
            "pa_street",
            "pa_sitio",
            "pa_barangay",
            "pa_city",
            "pa_province",
            "pa_instructions",
        ];
        ids.forEach((id) => {
            const el = document.getElementById(id);
            if (el) el.value = "";
        });
        // Reset city and province to defaults
        const cityEl = document.getElementById("pa_city");
        const provinceEl = document.getElementById("pa_province");
        if (cityEl) cityEl.value = "Ormoc";
        if (provinceEl) provinceEl.value = "Leyte";
    }

    async loadPickupAreaRecords() {
        try {
            console.log("ðŸ” loadPickupAreaRecords called");
            const list = document.getElementById("pickupAreaList");
            if (!list) {
                console.error("âŒ pickupAreaList element not found");
                return;
            }
            list.innerHTML =
                '<div style="padding:12px; color:#666; text-align:center; border:1px dashed #ddd; border-radius:8px;">Loading records...</div>';

            // Get Supabase client
            const supabase = window.getSupabaseClient
                ? window.getSupabaseClient()
                : window.supabaseClient || null;
            if (!supabase) {
                list.innerHTML =
                    '<div style="padding:16px; color:#c62828; text-align:center; border:1px dashed #f4c7c7; border-radius:8px;">Supabase not available. Please refresh the page.</div>';
                return;
            }

            // Fetch all pickup areas from Supabase
            const { data: areas, error } = await supabase
                .from("pickup_area")
                .select("*")
                .order("updated_at", { ascending: false });

            if (error) {
                throw new Error("Failed to load pickup areas: " + error.message);
            }

            console.log("âœ… Data fetched successfully from Supabase:", areas);

            // Convert Supabase data to Firebase-compatible format for renderPickupAreaList
            const data = {};
            let selected = {};

            if (areas && areas.length > 0) {
                areas.forEach((area) => {
                    // Convert Supabase format to Firebase-compatible format
                    data[area.id] = {
                        name: area.name,
                        mapLink: area.map_link || "",
                        landmark: area.landmark || "",
                        address: area.address || "",
                        street: area.street || "",
                        sitio: area.sitio || "",
                        barangay: area.barangay || "",
                        city: area.city || "Ormoc",
                        province: area.province || "Leyte",
                        instructions: area.instructions || "",
                        updatedAt:
                            area.updated_at_timestamp ||
                            (area.updated_at
                                ? new Date(area.updated_at).getTime()
                                : Date.now()),
                        active: area.active || false,
                    };

                    // If this is the active pickup area, set it as selected
                    if (area.active) {
                        selected = {
                            id: area.id.toString(),
                            name: area.name,
                            mapLink: area.map_link || "",
                            address: area.address || "",
                            street: area.street || "",
                            sitio: area.sitio || "",
                            barangay: area.barangay || "",
                            city: area.city || "Ormoc",
                            province: area.province || "Leyte",
                            landmark: area.landmark || "",
                            instructions: area.instructions || "",
                            updatedAt:
                                area.updated_at_timestamp ||
                                (area.updated_at
                                    ? new Date(area.updated_at).getTime()
                                    : Date.now()),
                        };
                    }
                });
            }

            this.renderPickupAreaList(data, selected, list);
        } catch (e) {
            console.error("âŒ Error loading pickupArea records:", e);
            console.error("âŒ Error details:", {
                message: e.message,
                stack: e.stack,
                name: e.name,
            });

            const list = document.getElementById("pickupAreaList");
            if (list) {
                list.innerHTML = `
                    <div style="padding:16px; color:#c62828; text-align:center; border:1px dashed #f4c7c7; border-radius:8px;">
                        <div>Failed to load records</div>
                        <div style="font-size:12px; margin-top:8px; color:#666;">
                            Error: ${e.message || "Unknown error"}
                        </div>
                        <button onclick="window.staffManager && staffManager.loadPickupAreaRecords()" 
                                style="margin-top:8px; padding:4px 8px; background:#1976d2; color:white; border:none; border-radius:4px; cursor:pointer;">
                            Retry
                        </button>
                    </div>
                `;
            }
        }
    }

    // Utility function for escaping HTML
    esc(s) {
        return s == null ? "" : String(s).replace(/</g, "&lt;");
    }

    escAttr(s) {
        if (s == null) return "";
        return String(s)
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#39;");
    }

    getBarangayOptionsList() {
        if (
            Array.isArray(this._barangayOptionsCache) &&
            this._barangayOptionsCache.length > 0
        ) {
            return this._barangayOptionsCache;
        }

        let options = [];
        try {
            const utils = window.AccurateBarangayUtils;
            if (utils && typeof utils.getAllBarangays === "function") {
                const rawList = utils.getAllBarangays() || [];
                const normalized = rawList
                    .map((name) => (name == null ? "" : String(name).trim()))
                    .filter((name) => name.length > 0 && !/reference point/i.test(name));
                options = Array.from(new Set(normalized)).sort((a, b) =>
                    a.localeCompare(b)
                );
            }
        } catch (error) {
            console.warn("Failed to load barangay options:", error);
        }

        if (options.length > 0) {
            this._barangayOptionsCache = options;
        }
        return options;
    }

    renderBarangaySelect(fieldId, selectedValue = "", isRequired = false) {
        const options = this.getBarangayOptionsList();
        const fieldAttr = this.escAttr(fieldId);
        const requiredAttr = isRequired ? " required" : "";
        const selectedKey = (selectedValue || "").toString().trim().toLowerCase();

        if (!options || options.length === 0) {
            return `<input type="text" id="${fieldAttr}"${requiredAttr} value="${this.escAttr(
                selectedValue || ""
            )}">`;
        }

        const placeholderSelected = selectedKey ? "" : " selected";
        const placeholderOption = `<option value="" disabled${placeholderSelected}>Select Barangay</option>`;
        const optionsHtml = options
            .map((name) => {
                const isSelected = selectedKey && name.toLowerCase() === selectedKey;
                return `<option value="${this.escAttr(name)}"${isSelected ? " selected" : ""
                    }>${this.esc(name)}</option>`;
            })
            .join("");

        return `<select id="${fieldAttr}"${requiredAttr}>${placeholderOption}${optionsHtml}</select>`;
    }

    // Build address section for orders (delivery or pickup)
    // Filter out auto-generated rescheduled messages from order notes (for staff/admin view only)
    // Customers should see all notes including rescheduled messages
    filterCustomerNotes(notes) {
        if (!notes || typeof notes !== "string") return "";
        const trimmed = notes.trim();
        if (!trimmed) return "";
        
        // Filter out auto-generated rescheduled messages
        // Pattern: "Your order will be delivered next week for the one-day delivery. Estimate Delivery: 12/20/2025 - 12/21/2025"
        // Pattern: "You can pickup your order next week. Estimate Pickup Schedule: 12/20/2025 - 12/21/2025"
        // Check for common patterns in auto-generated messages
        const autoGeneratedPatterns = [
            /Estimate Delivery:\s*\d{1,2}\/\d{1,2}\/\d{4}\s*-\s*\d{1,2}\/\d{1,2}\/\d{4}/i,
            /Estimate Pickup Schedule:\s*\d{1,2}\/\d{1,2}\/\d{4}\s*-\s*\d{1,2}\/\d{1,2}\/\d{4}/i,
            /Your order will be delivered next week/i,
            /You can pickup your order next week/i,
            /delivered next week for the one-day delivery/i,
            /Estimate Delivery:/i,
            /Estimate Pickup Schedule:/i,
        ];
        
        // If the note matches any auto-generated pattern, return empty string
        for (const pattern of autoGeneratedPatterns) {
            if (pattern.test(trimmed)) {
                return "";
            }
        }
        
        return trimmed;
    }

    // Helper function to remove duplicate city and province from addresses
    removeDuplicateCityProvince(address) {
        if (!address || typeof address !== "string") return address;
        
        // Split address by comma
        const parts = address.split(",").map(p => p.trim()).filter(p => p);
        if (parts.length < 4) return address; // Need at least 4 parts to have duplication
        
        // Check if last two parts duplicate the previous two parts
        // Pattern: "X, Y, City, Province, City, Province"
        // For "Coob, Tambulilid, Ormoc, Leyte, Ormoc, Leyte":
        //   parts[2]="Ormoc", parts[3]="Leyte" (original)
        //   parts[4]="Ormoc", parts[5]="Leyte" (duplicate)
        const lastPart = parts[parts.length - 1];
        const secondLastPart = parts[parts.length - 2];
        const thirdLastPart = parts.length >= 3 ? parts[parts.length - 3] : "";
        const fourthLastPart = parts.length >= 4 ? parts[parts.length - 4] : "";
        
        // Normalize for comparison (case-insensitive)
        const lastLower = lastPart.toLowerCase();
        const secondLastLower = secondLastPart.toLowerCase();
        const thirdLastLower = thirdLastPart.toLowerCase();
        const fourthLastLower = fourthLastPart.toLowerCase();
        
        // Check if last two parts match fourth and third last parts (duplicate pattern)
        // secondLastPart should match fourthLastPart, lastPart should match thirdLastPart
        if (parts.length >= 4) {
            // Simple check: if secondLast matches fourthLast AND last matches thirdLast
            if (secondLastLower === fourthLastLower && lastLower === thirdLastLower) {
                // Remove duplicate (last two parts)
                return parts.slice(0, -2).join(", ");
            }
            
            // Also check for partial matches (e.g., "Ormoc" matches "Ormoc City")
            if ((secondLastLower === fourthLastLower || 
                 secondLastLower.includes(fourthLastLower) || 
                 fourthLastLower.includes(secondLastLower)) &&
                (lastLower === thirdLastLower || 
                 lastLower.includes(thirdLastLower) || 
                 thirdLastLower.includes(lastLower))) {
                // Remove duplicate (last two parts)
                return parts.slice(0, -2).join(", ");
            }
        }
        
        // Check for longer patterns: "X, Y, Z, City, Province, City, Province"
        if (parts.length >= 6) {
            const fifthLastPart = parts[parts.length - 5];
            const sixthLastPart = parts[parts.length - 6];
            const fifthLastLower = fifthLastPart.toLowerCase();
            const sixthLastLower = sixthLastPart.toLowerCase();
            
            // Check if last two match fifth and sixth (for pattern: X, Y, Z, City, Province, City, Province)
            if ((secondLastLower === fifthLastLower || 
                 secondLastLower.includes(fifthLastLower) || 
                 fifthLastLower.includes(secondLastLower)) &&
                (lastLower === sixthLastLower || 
                 lastLower.includes(sixthLastLower) || 
                 sixthLastLower.includes(lastLower))) {
                // Remove duplicate (last two parts)
                return parts.slice(0, -2).join(", ");
            }
        }
        
        return address;
    }

    buildAddressSection(order) {
        const deliveryOption = String(order.deliveryOption || "").toLowerCase();

        if (deliveryOption === "pickup") {
            // Build comprehensive pickup details
            let pickupHtml =
                '<div style="background: #ffffff; padding: 12px; border-radius: 8px; margin: 8px 0; border-left: 4px solid #2196F3;">';

            // Build structured address
            const addressParts = [];
            if (order.pickupStreet) addressParts.push(this.esc(order.pickupStreet));
            if (order.pickupSitio) addressParts.push(this.esc(order.pickupSitio));
            if (order.pickupBarangay)
                addressParts.push(this.esc(order.pickupBarangay));
            if (order.pickupCity) addressParts.push(this.esc(order.pickupCity));
            if (order.pickupProvince)
                addressParts.push(this.esc(order.pickupProvince));

            // Check if we have structured data
            const hasStructuredData =
                order.pickupName ||
                addressParts.length > 0 ||
                order.pickupLandmark ||
                order.pickupInstructions ||
                order.pickupMapLink;

            if (hasStructuredData) {
                // Show structured data
                if (order.pickupName) {
                    pickupHtml += `<p style="margin: 4px 0;"><strong>Location:</strong> ${this.esc(
                        order.pickupName
                    )}</p>`;
                }

                const fullAddress =
                    addressParts.length > 0
                        ? addressParts.join(", ")
                        : order.pickupAddress || "Address not available";

                pickupHtml += `<p style="margin: 4px 0;"><strong>Address:</strong> ${this.esc(
                    fullAddress
                )}</p>`;

                // Landmark
                if (order.pickupLandmark) {
                    pickupHtml += `<p style="margin: 4px 0;"><strong>Landmark:</strong> ${this.esc(
                        order.pickupLandmark
                    )}</p>`;
                }

                // Instructions
                if (order.pickupInstructions) {
                    pickupHtml += `<p style="margin: 4px 0;"><strong>Instructions:</strong> ${this.esc(
                        order.pickupInstructions
                    )}</p>`;
                }

                // Google Maps navigation button
                if (order.pickupMapLink) {
                    pickupHtml += `<div style="margin-top: 8px;">
                        <button onclick="window.open('${this.esc(
                        order.pickupMapLink
                    )}', '_blank')" 
                                style="background: #2196F3; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                            <i class="fas fa-map-marker-alt"></i> Navigate to Pickup
                        </button>
                    </div>`;
                }
            } else {
                // Show old format data (parse pickupAddress)
                if (order.pickupAddress && order.pickupAddress.includes(" - ")) {
                    const parts = order.pickupAddress.split(" - ");
                    if (parts.length > 1) {
                        const locationName = parts[0];
                        const address = parts.slice(1).join(" - ");

                        pickupHtml += `<p style="margin: 4px 0;"><strong>Location:</strong> ${this.esc(
                            locationName
                        )}</p>`;
                        pickupHtml += `<p style="margin: 4px 0;"><strong>Address:</strong> ${this.esc(
                            address
                        )}</p>`;
                    } else {
                        pickupHtml += `<p style="margin: 4px 0;"><strong>Address:</strong> ${this.esc(
                            order.pickupAddress
                        )}</p>`;
                    }
                } else {
                    pickupHtml += `<p style="margin: 4px 0;"><strong>Address:</strong> ${this.esc(
                        order.pickupAddress || "Address not available"
                    )}</p>`;
                }
            }

            // Only show fallback message if absolutely no pickup information is available
            if (
                !order.pickupName &&
                !order.pickupLandmark &&
                !order.pickupInstructions &&
                !order.pickupMapLink &&
                (!order.pickupAddress ||
                    order.pickupAddress === "Address not available")
            ) {
                pickupHtml += `<div style="margin-top: 8px; padding: 8px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px;">
                    <p style="margin: 0; color: #856404; font-size: 12px;">
                        <i class="fas fa-exclamation-triangle"></i> 
                        <strong>Complete pickup information not available.</strong> 
                        Please update the pickup area with landmark, instructions, and map link.
                    </p>
                </div>`;
            }

            pickupHtml += "</div>";
            return pickupHtml;
        } else {
            // Regular delivery address - remove duplicate city/province
            const rawAddress = order.deliveryAddress || order.customerAddress || "No address provided";
            const cleanedAddress = this.removeDuplicateCityProvince(rawAddress);
            return `<p>${this.esc(cleanedAddress)}</p>`;
        }
    }

    renderPickupAreaList(data, selected, list) {
        try {
            // Restore the active pickup ID from Firebase data first
            if (selected.id && selected.id !== this._activePickupId) {
                this._activePickupId = selected.id;
                console.log("Restored active pickup ID from Firebase:", selected.id);
            }

            // Use the restored active pickup ID or fallback to localStorage or memory
            const localStorageId = localStorage.getItem("activePickupAreaId");
            const selectedId =
                this._activePickupId || selected.id || localStorageId || "";

            // Debug logging
            console.log("Rendering pickup areas:", {
                selectedData: selected,
                selectedId: selectedId,
                areasCount: Object.keys(data).length,
                pickupAreaData: data,
                _activePickupId: this._activePickupId,
            });

            // Additional debugging: check if selected data exists
            if (!selected.id) {
                console.warn(
                    "No selected pickup area found in Firebase. Checking individual active flags..."
                );
                const activeAreas = Object.entries(data).filter(
                    ([id, area]) => area && area.active === true
                );
                console.log("Areas with active=true flag:", activeAreas);
            }

            const entries = Object.entries(data).sort(
                (a, b) => (b[1]?.updatedAt || 0) - (a[1]?.updatedAt || 0)
            );

            if (entries.length === 0) {
                list.innerHTML =
                    '<div style="padding:16px; border:2px dashed #e0e0e0; border-radius:10px; background:#fafafa; color:#666; text-align:center;">No pickup areas yet.</div>';
                return;
            }

            list.innerHTML = entries
                .map(([id, r], idx) => {
                    // Check if this is the active pickup area using multiple sources
                    // Priority: 1) pickupSelected data, 2) localStorage, 3) individual active flag, 4) memory
                    const localStorageId = localStorage.getItem("activePickupAreaId");
                    const isActive =
                        id === selectedId ||
                        id === localStorageId ||
                        id === this._activePickupId ||
                        (r && r.active === true);

                    // Debug logging for active state
                    if (isActive) {
                        console.log(`Pickup area ${id} is active:`, {
                            id: id,
                            selectedId: selectedId,
                            r_active: r?.active,
                            name: r?.name,
                        });
                    }
                    const cardStyle = isActive
                        ? "border:2px solid #1976d2; background:#e3f2fd;"
                        : "border:1px solid #e0e0e0; background:#fff;";

                    const checkedAttr = isActive ? "checked" : "";
                    const checkboxStyle = isActive ? "accent-color:#1976d2;" : "";

                    return `
                    <div style=\"${cardStyle} border-radius:8px; padding:12px; display:grid; gap:8px;\">
                        <div style=\"display:flex; justify-content:space-between; align-items:center;\">
                            <div style=\"display:flex; gap:10px; align-items:center;\">
                                <input type=\"checkbox\" style=\"${checkboxStyle}\" ${checkedAttr} onchange=\"this.checked && window.staffManager && staffManager.setActivePickupAreaRecord('${id}')\" title=\"Set as active pickup area\" />
                                <h4 style=\"margin:0;\">${this.esc(r.name) || "Unnamed Area"
                        }</h4>
                                ${isActive
                            ? '<span class=\\"status-badge active\\" style=\\"margin-left:8px; color:#1976d2; border:1px solid #1976d2; padding:2px 8px; border-radius:12px; font-size:12px;">Active</span>'
                            : ""
                        }
                            </div>
                            <div style=\"display:flex; gap:6px;\">
                                ${r.mapLink
                            ? `<a class='secondary-btn' href='${this.esc(
                                r.mapLink
                            )}' target='_blank' rel='noopener'><i class=\"fas fa-map\"></i> Map</a>`
                            : ""
                        }
                                <button class=\"secondary-btn\" onclick=\"window.staffManager && staffManager.editPickupAreaRecord('${id}')\"><i class=\"fas fa-edit\"></i> Edit</button>
                                <button class=\"danger-btn\" onclick=\"window.staffManager && staffManager.deletePickupAreaRecord('${id}')\"><i class=\"fas fa-trash\"></i> Remove</button>
                            </div>
                        </div>
                        <div style=\"display:grid; grid-template-columns:160px 1fr; gap:4px 12px; color:#444;\">\
                            <div style=\"font-weight:600;\">Landmark</div>
                            <div>${this.esc(r.landmark) ||
                        '<span style=\\"color:#888;\\">â€”</span>'
                        }</div>
                            <div style=\"font-weight:600;\">Address</div>
                            <div>${this.formatPickupAddress(r)}</div>
                            <div style=\"font-weight:600;\">Instructions</div>
                            <div style=\"white-space:pre-wrap;\">${this.esc(r.instructions) ||
                        '<span style=\\"color:#888;\\">â€”</span>'
                        }</div>
                        </div>
                    </div>`;
                })
                .join("");

            console.log("âœ… Pickup area list rendered successfully");
        } catch (e) {
            console.error("âŒ Error rendering pickup area list:", e);
            list.innerHTML = `
                <div style="padding:16px; color:#c62828; text-align:center; border:1px dashed #f4c7c7; border-radius:8px;">
                    <div>Error rendering pickup areas</div>
                    <div style="font-size:12px; margin-top:8px; color:#666;">
                        Error: ${e.message || "Unknown error"}
                    </div>
                </div>
            `;
        }
    }

    formatPickupAddress(record) {
        // If we have structured address components, use them
        if (record.street || record.sitio || record.barangay) {
            const parts = [];
            if (record.street) parts.push(record.street);
            if (record.sitio) parts.push(record.sitio);
            if (record.barangay) parts.push(record.barangay);
            if (record.city) parts.push(record.city);
            if (record.province) parts.push(record.province);
            return this.esc(parts.join(", "));
        }
        // Fallback to the old full address field
        return this.esc(record.address) || '<span style="color:#888;">â€”</span>';
    }

    async savePickupAreaRecord() {
        try {
            const name = document.getElementById("pa_name")?.value.trim() || "";
            const mapLink = document.getElementById("pa_mapLink")?.value.trim() || "";
            const landmark =
                document.getElementById("pa_landmark")?.value.trim() || "";
            const street = document.getElementById("pa_street")?.value.trim() || "";
            const sitio = document.getElementById("pa_sitio")?.value.trim() || "";
            const barangay =
                document.getElementById("pa_barangay")?.value.trim() || "";
            const city = document.getElementById("pa_city")?.value.trim() || "Ormoc";
            const province =
                document.getElementById("pa_province")?.value.trim() || "Leyte";
            const instructions =
                document.getElementById("pa_instructions")?.value.trim() || "";
            const currentId =
                document.getElementById("pa_currentId")?.value.trim() || "";

            if (!name) {
                alert("Please enter Area Name");
                return;
            }
            if (!barangay) {
                alert("Please enter Barangay");
                return;
            }

            // Build full address from components
            const addressParts = [];
            if (street) addressParts.push(street);
            if (sitio) addressParts.push(sitio);
            addressParts.push(barangay);
            addressParts.push(city);
            addressParts.push(province);
            const fullAddress = addressParts.join(", ");

            // Get Supabase client
            const supabase = window.getSupabaseClient
                ? window.getSupabaseClient()
                : window.supabaseClient || null;
            if (!supabase) {
                alert("Supabase not available. Please refresh the page and try again.");
                return;
            }

            // Prepare payload for Supabase (map field names)
            const payload = {
                name,
                map_link: mapLink,
                landmark,
                address: fullAddress, // Keep full address for backward compatibility
                street,
                sitio,
                barangay,
                city,
                province,
                instructions,
                updated_at_timestamp: Date.now(),
                updated_at: new Date().toISOString(),
            };

            if (currentId) {
                // Update existing record (ID is UUID string, not integer)
                const { error } = await supabase
                    .from("pickup_area")
                    .update(payload)
                    .eq("id", currentId);

                if (error) {
                    throw new Error("Failed to update pickup area: " + error.message);
                }
            } else {
                // Insert new record
                const { error } = await supabase.from("pickup_area").insert([payload]);

                if (error) {
                    throw new Error("Failed to create pickup area: " + error.message);
                }
            }

            alert("Pickup area saved successfully!");
            this.cancelPickupAreaForm();
            await this.loadPickupAreaRecords();
        } catch (e) {
            console.error("Error saving pickup area record:", e);
            alert("Error saving pickup area: " + (e && e.message ? e.message : e));
        }
    }

    async editPickupAreaRecord(id) {
        try {
            // Get Supabase client
            const supabase = window.getSupabaseClient
                ? window.getSupabaseClient()
                : window.supabaseClient || null;
            if (!supabase) {
                alert("Supabase not available. Please refresh the page and try again.");
                return;
            }

            // Fetch pickup area from Supabase (ID is UUID string, not integer)
            const { data: area, error } = await supabase
                .from("pickup_area")
                .select("*")
                .eq("id", id)
                .single();

            if (error || !area) {
                alert("Pickup area not found");
                return;
            }

            const f = document.getElementById("pickupAreaForm");
            const t = f ? f.querySelector("h4") : null;
            if (t) t.textContent = "Edit Pickup Area";

            const set = (k, v) => {
                const el = document.getElementById(k);
                if (el) el.value = v || "";
            };
            set("pa_currentId", id);
            set("pa_name", area.name);
            set("pa_mapLink", area.map_link); // Map Supabase field to form field
            set("pa_landmark", area.landmark);
            set("pa_address", area.address); // Keep for backward compatibility
            set("pa_street", area.street);
            set("pa_sitio", area.sitio);
            set("pa_barangay", area.barangay);
            set("pa_city", area.city || "Ormoc");
            set("pa_province", area.province || "Leyte");
            set("pa_instructions", area.instructions);
            if (f) {
                f.style.display = "block";
                // Scroll to form
                setTimeout(() => {
                    f.scrollIntoView({ behavior: "smooth", block: "nearest" });
                }, 100);
            }
        } catch (e) {
            console.error("Error editing pickup area record:", e);
            alert(
                "Error loading pickup area for editing: " +
                (e && e.message ? e.message : e)
            );
        }
    }

    async deletePickupAreaRecord(id) {
        try {
            if (!confirm("Remove this pickup area?")) return;

            // Get Supabase client
            const supabase = window.getSupabaseClient
                ? window.getSupabaseClient()
                : window.supabaseClient || null;
            if (!supabase) {
                alert("Supabase not available. Please refresh the page and try again.");
                return;
            }

            // Check if this is the active pickup area (ID is UUID string, not integer)
            const { data: area } = await supabase
                .from("pickup_area")
                .select("active")
                .eq("id", id)
                .single();

            if (area && area.active) {
                // Clear active flag and localStorage
                this._activePickupId = null;
                localStorage.removeItem("activePickupAreaId");
            }

            // Delete from Supabase (ID is UUID string, not integer)
            const { error } = await supabase
                .from("pickup_area")
                .delete()
                .eq("id", id);

            if (error) {
                throw new Error("Failed to delete pickup area: " + error.message);
            }

            this.showSuccessMessage("Pickup area removed");
            await this.loadPickupAreaRecords();
        } catch (e) {
            console.error("Error deleting pickup area record:", e);
            alert("Error deleting pickup area: " + (e && e.message ? e.message : e));
        }
    }
    async setActivePickupAreaRecord(id) {
        try {
            // Get Supabase client
            const supabase = window.getSupabaseClient
                ? window.getSupabaseClient()
                : window.supabaseClient || null;
            if (!supabase) {
                alert("Supabase not available. Please refresh the page and try again.");
                return;
            }

            // Fetch the pickup area to verify it exists (ID is UUID string, not integer)
            const { data: area, error: fetchError } = await supabase
                .from("pickup_area")
                .select("*")
                .eq("id", id)
                .single();

            if (fetchError || !area) {
                alert("Pickup area not found");
                return;
            }

            console.log("ðŸ”§ Setting active pickup area:", id);
            console.log("ðŸ“‹ Target area data:", area);

            // First, set all pickup areas to inactive
            // Fetch all pickup areas first, then update them
            const { data: allAreas } = await supabase
                .from("pickup_area")
                .select("id");

            if (allAreas && allAreas.length > 0) {
                // Update all areas to inactive
                const { error: updateAllError } = await supabase
                    .from("pickup_area")
                    .update({ active: false })
                    .in(
                        "id",
                        allAreas.map((a) => a.id)
                    );

                if (updateAllError) {
                    console.warn(
                        "Warning: Could not set all areas to inactive:",
                        updateAllError
                    );
                }
            }

            // Then, set the selected pickup area to active (ID is UUID string, not integer)
            const { error: updateActiveError } = await supabase
                .from("pickup_area")
                .update({
                    active: true,
                    updated_at: new Date().toISOString(),
                    updated_at_timestamp: Date.now(),
                })
                .eq("id", id);

            if (updateActiveError) {
                throw new Error(
                    "Failed to set pickup area as active: " + updateActiveError.message
                );
            }

            // Verify the data was saved (ID is UUID string, not integer)
            console.log("ðŸ” Verifying saved data...");
            const { data: verifyArea } = await supabase
                .from("pickup_area")
                .select("active")
                .eq("id", id)
                .single();

            console.log("ðŸ“‹ Verified active flag for", id, ":", verifyArea?.active);

            // Keep in-memory pointer so UI can reflect immediately even if DB lag
            this._activePickupId = id;

            // Also save to localStorage as backup for page refresh persistence
            localStorage.setItem("activePickupAreaId", id);

            this.showSuccessMessage("Pickup area activated successfully!");
            console.log("ðŸŽ‰ Pickup area activation complete!");

            // Reload immediately to show the active state
            await this.loadPickupAreaRecords();
        } catch (e) {
            console.error("âŒ Error setting active pickup area:", e);
            alert(
                "Error setting active pickup area: " + (e && e.message ? e.message : e)
            );
        }
    }

    // Restore active pickup area state from Supabase
    async restoreActivePickupAreaState() {
        try {
            // Check Supabase availability
            const supabase = window.getSupabaseClient
                ? window.getSupabaseClient()
                : window.supabaseClient || null;
            if (!supabase) {
                console.warn(
                    "Supabase not ready for restoreActivePickupAreaState. Will retry later."
                );
                // Fallback to localStorage only
                const localStorageId = localStorage.getItem("activePickupAreaId");
                if (localStorageId && localStorageId !== this._activePickupId) {
                    this._activePickupId = localStorageId;
                    console.log("Restored active pickup area state from localStorage:", {
                        id: localStorageId,
                    });
                    await this.loadPickupAreaRecords();
                }
                return;
            }

            // Try to get active pickup area from Supabase system_data table
            let selected = {};
            try {
                const { data: systemData, error } = await supabase
                    .from("system_data")
                    .select("*")
                    .eq("id", "pickupSelected")
                    .maybeSingle(); // Use maybeSingle() instead of single() to handle missing records gracefully

                if (!error && systemData && systemData.data) {
                    // Parse JSON data if stored as string
                    selected =
                        typeof systemData.data === "string"
                            ? JSON.parse(systemData.data)
                            : systemData.data;
                } else if (error) {
                    // Suppress all errors - record doesn't exist, use localStorage fallback
                    // PGRST116 is "not found" error, which is expected if record doesn't exist
                    // 406 errors are also expected when record doesn't exist or query format is wrong
                    // Don't log these expected errors - they're handled gracefully with fallback
                }
            } catch (e) {
                // Silently handle - record doesn't exist, use localStorage fallback
                // Suppress error logging
            }

            console.log("Restore active pickup area state - Supabase data:", {
                selected: selected,
                currentActiveId: this._activePickupId,
            });

            const localStorageId = localStorage.getItem("activePickupAreaId");

            if (selected.id && selected.id !== this._activePickupId) {
                this._activePickupId = selected.id;
                localStorage.setItem("activePickupAreaId", selected.id);
                console.log("Restored active pickup area state from Supabase:", {
                    id: selected.id,
                    name: selected.name,
                });

                // Force a re-render of the pickup area list to show the active state
                await this.loadPickupAreaRecords();
            } else if (localStorageId && localStorageId !== this._activePickupId) {
                this._activePickupId = localStorageId;
                console.log("Restored active pickup area state from localStorage:", {
                    id: localStorageId,
                });

                // Force a re-render of the pickup area list to show the active state
                await this.loadPickupAreaRecords();
            } else if (!selected.id && !localStorageId) {
                console.warn("No active pickup area found in Supabase or localStorage");
            } else {
                console.log("Active pickup area already matches stored data");
            }
        } catch (e) {
            console.error("Error restoring active pickup area state:", e);
            // Fallback to localStorage
            const localStorageId = localStorage.getItem("activePickupAreaId");
            if (localStorageId && localStorageId !== this._activePickupId) {
                this._activePickupId = localStorageId;
                await this.loadPickupAreaRecords();
            }
        }
    }

    _updateSummaryStats(barangays, currentFees) {
        const totalBarangays = barangays.length;
        const configuredCount = Object.values(currentFees).filter(
            (fee) => fee > 0
        ).length;
        const pendingCount = totalBarangays - configuredCount;

        const totalFees = Object.values(currentFees).reduce(
            (sum, fee) => sum + (fee || 0),
            0
        );
        const avgFee =
            configuredCount > 0 ? Math.round(totalFees / configuredCount) : 0;

        // Update summary display
        const elements = {
            totalBarangays: document.getElementById("totalBarangays"),
            configuredCount: document.getElementById("configuredCount"),
            pendingCount: document.getElementById("pendingCount"),
            avgFee: document.getElementById("avgFee"),
        };

        if (elements.totalBarangays)
            elements.totalBarangays.textContent = totalBarangays;
        if (elements.configuredCount)
            elements.configuredCount.textContent = configuredCount;
        if (elements.pendingCount) elements.pendingCount.textContent = pendingCount;
        if (elements.avgFee) elements.avgFee.textContent = `â‚±${avgFee}`;
    }

    _setupSearchAndFilter() {
        const searchInput = document.getElementById("barangaySearch");
        const zoneFilter = document.getElementById("zoneFilter");

        if (searchInput) {
            searchInput.addEventListener("input", () => this._filterBarangays());
        }

        if (zoneFilter) {
            zoneFilter.addEventListener("change", () => this._filterBarangays());
        }
    }

    _showReferencePointInfo(referencePoint) {
        const referenceInfo = document.getElementById("referencePointInfo");
        if (!referenceInfo || !referencePoint) return;

        // Update reference point info with coordinates if available
        let coordinatesText = "";
        if (referencePoint.coordinates && referencePoint.coordinates.length === 2) {
            coordinatesText = ` (${referencePoint.coordinates[0]}, ${referencePoint.coordinates[1]})`;
        }

        const infoText = referenceInfo.querySelector("p");
        if (infoText) {
            infoText.innerHTML = `All distances are calculated from Cabintan, Ormoc City using Geopy geographic coordinates.${coordinatesText}`;
        }

        referenceInfo.style.display = "block";
    }

    _filterBarangays() {
        const searchTerm = (
            document.getElementById("barangaySearch")?.value || ""
        ).toLowerCase();
        const selectedFilter = document.getElementById("zoneFilter")?.value || "";
        const rows = document.querySelectorAll(
            "#deliveryFeesTableBody tr[data-barangay]"
        );

        rows.forEach((row) => {
            const barangayName = row.getAttribute("data-barangay").toLowerCase();
            const classification = row.getAttribute("data-classification");

            const matchesSearch = !searchTerm || barangayName.includes(searchTerm);

            let matchesFilter = true;
            if (selectedFilter) {
                matchesFilter = classification === selectedFilter;
            }

            row.style.display = matchesSearch && matchesFilter ? "" : "none";
        });
    }

    _onFeeChange(input) {
        const tr = input.closest("tr");
        const fee = parseInt(input.value || "0", 10);

        // Update row styling based on fee (visual feedback only, no auto-save)
        if (fee > 0) {
            tr.style.background = "#e8f5e9";
            tr.style.color = "#2e7d32";
        } else {
            tr.style.background = "#ffebee";
            tr.style.color = "#c62828";
        }

        // Removed auto-save - fees will only save when "Save All Fees" button is clicked
    }
    async saveIndividualFee(tr) {
        try {
            const barangayName = tr.getAttribute("data-barangay");
            const feeInput = tr.querySelector(".brgy-fee-input");
            if (!barangayName || !feeInput) return;

            const fee = Math.max(0, parseInt(feeInput.value || "0", 10));

            // Get current fees to preserve other barangay fees
            // Get Supabase client
            const supabase = window.getSupabaseClient
                ? window.getSupabaseClient()
                : window.supabaseClient || null;
            if (!supabase) {
                console.error("Supabase client not available");
                return;
            }

            console.log("=== SAVING INDIVIDUAL FEE ===");
            console.log("Barangay:", barangayName);
            console.log("Fee:", fee);

            // Get current data from Supabase
            const { data: currentData } = await supabase
                .from("delivery_fees")
                .select("*")
                .eq("id", 1)
                .single();

            const updateData = currentData ? { ...currentData } : { id: 1 };

            // Convert barangay name to column name
            const columnName = barangayNameToColumnName(barangayName);
            if (columnName) {
                updateData[columnName] = fee;
                updateData.updated_at = new Date().toISOString();

                // Upsert the row
                const { error } = await supabase
                    .from("delivery_fees")
                    .upsert(updateData, { onConflict: "id" });

                if (error) {
                    console.error("âŒ Failed to save individual fee:", error);
                    return;
                }

                console.log(
                    `âœ… Successfully saved fee for ${barangayName} to Supabase`
                );

                // Update the stored fees cache
                if (fee > 0) {
                    window.__currentDeliveryFees = {
                        ...window.__currentDeliveryFees,
                        [barangayName]: fee,
                    };
                } else {
                    const newFees = { ...window.__currentDeliveryFees };
                    delete newFees[barangayName];
                    window.__currentDeliveryFees = newFees;
                }

                // Update the Current Fee display immediately
                const currentFeeSpan = tr.querySelector(".current-fee-text");
                if (currentFeeSpan) {
                    if (fee > 0) {
                        currentFeeSpan.textContent = `â‚±${fee}`;
                        currentFeeSpan.style.color = "#2e7d32";
                        currentFeeSpan.style.fontWeight = "bold";
                        tr.style.background = "#e8f5e9";
                        tr.style.color = "#2e7d32";
                    } else {
                        currentFeeSpan.textContent = "â‚±0";
                        currentFeeSpan.style.color = "#c62828";
                        currentFeeSpan.style.fontWeight = "bold";
                        tr.style.background = "#ffebee";
                        tr.style.color = "#c62828";
                    }
                }

                console.log(`Auto-saved fee for ${barangayName}: ${fee}`);
            }
        } catch (e) {
            console.error("Error saving individual fee:", e);
        }
    }

    setSuggestedFee(button) {
        const tr = button.closest("tr");
        const input = tr.querySelector(".brgy-fee-input");
        const suggestedFee = parseInt(input.getAttribute("data-suggested"), 10);

        input.value = suggestedFee;
        this._onFeeChange(input);

        // Visual feedback
        button.style.background = "#28a745";
        button.style.color = "white";
        setTimeout(() => {
            button.style.background = "";
            button.style.color = "";
        }, 500);
    }

    removeBarangayFee(button) {
        const tr = button.closest("tr");
        const input = tr.querySelector(".brgy-fee-input");

        input.value = "";
        this._onFeeChange(input);
    }

    addCustomBarangay() {
        const name = prompt("Enter custom barangay name:");
        if (!name || !name.trim()) return;

        const distance = parseFloat(
            prompt("Enter distance from Cabintan (km):") || "0"
        );
        const zone =
            prompt("Enter zone (core/near-urban/rural/remote):") || "rural";

        const customBarangay = {
            name: name.trim(),
            distance: distance,
            zone: zone,
            isReference: false,
        };

        const tbody = document.getElementById("deliveryFeesTableBody");
        const temp = document.createElement("tbody");
        temp.innerHTML = this._renderEnhancedBrgyRow(customBarangay, 0);
        tbody.appendChild(temp.firstElementChild);

        this.showSuccessMessage(`Custom barangay "${name}" added successfully!`);
    }

    autoSetSuggestedFees() {
        if (
            !confirm(
                "This will set all unconfigured barangays to their suggested fees. Continue?"
            )
        )
            return;

        const rows = document.querySelectorAll(
            "#deliveryFeesTableBody tr[data-barangay]"
        );
        let updatedCount = 0;

        rows.forEach((row) => {
            const input = row.querySelector(".brgy-fee-input");
            if (!input || input.value) return; // Skip if already has a value

            const suggestedFee = parseInt(input.getAttribute("data-suggested"), 10);
            input.value = suggestedFee;
            this._onFeeChange(input);
            updatedCount++;
        });

        this.showSuccessMessage(
            `Auto-set suggested fees for ${updatedCount} barangays!`
        );
    }

    async initializeBarangayData() {
        if (!window.AccurateBarangayUtils) {
            alert("Accurate barangay data not available. Please refresh the page.");
            return;
        }

        if (
            !confirm(
                "This will initialize all 110 Ormoc barangays with ACCURATE DISTANCES from Cabintan (0km to 88.30km) using Google Maps calculations. Continue?"
            )
        )
            return;

        try {
            // Get all barangay data from the accurate source
            const allBarangays = window.AccurateBarangayUtils.getAllBarangays();
            const barangayData = {};

            allBarangays.forEach((name) => {
                const data = window.AccurateBarangayUtils.getBarangayData(name);
                if (data) {
                    barangayData[name] = {
                        name: data.name,
                        distance: data.distance,
                        coordinates: data.coordinates,
                        classification: data.classification,
                        coastal: data.coastal,
                        suggestedFee: data.suggestedFee,
                        isReference: data.isReference,
                        calculatedAt: data.calculatedAt,
                    };
                }
            });
            const updates = {};

            Object.entries(barangayData).forEach(([key, data]) => {
                updates[`systemData/barangayData/${key}`] = data;
            });

            updates["systemData/barangayDataUpdatedAt"] =
                FirebaseUtils.getTimestamp();
            updates["systemData/barangayDataSource"] = "simplified_urban_rural_only";
            const stats = window.AccurateBarangayUtils.getStatistics();
            updates["systemData/barangayCount"] = stats.total;
            updates["systemData/urbanCount"] = stats.urban;
            updates["systemData/ruralCount"] = stats.rural;
            updates["systemData/distanceRange"] = `${stats.minDistance.toFixed(
                2
            )}km to ${stats.maxDistance.toFixed(
                2
            )}km accurate distance from Cabintan`;
            updates["systemData/averageDistance"] = stats.averageDistance;
            updates["systemData/distanceMethod"] = "google_maps_accurate_calculation";

            const rootRef =
                typeof database !== "undefined"
                    ? database.ref()
                    : firebase.database().ref();
            await rootRef.update(updates);

            this.showSuccessMessage(
                `All 110 Ormoc barangays with ACCURATE DISTANCES (${stats.urban} Urban, ${stats.rural} Rural, ${stats.coastal} Coastal) initialized successfully!`
            );
            setTimeout(() => this.reloadDeliverySettings(), 1000);
        } catch (e) {
            console.error("Error initializing barangay data:", e);
            alert("Error initializing data: " + (e && e.message ? e.message : e));
        }
    }

    async loadPickupArea() {
        try {
            const [nameSnap, addrSnap, linkSnap, instructionsSnap] =
                await Promise.all([
                    dbRefs.systemData.child("pickup/name").once("value"),
                    dbRefs.systemData.child("pickup/address").once("value"),
                    dbRefs.systemData.child("pickup/mapLink").once("value"),
                    dbRefs.systemData.child("pickup/instructions").once("value"),
                ]);

            const nameEl = document.getElementById("pickupName");
            const addrEl = document.getElementById("pickupAddress");
            const mapEl = document.getElementById("pickupMapLink");
            const instructionsEl = document.getElementById("pickupInstructions");

            if (nameEl) nameEl.value = nameSnap.val() || "";
            if (addrEl) addrEl.value = addrSnap.val() || "";
            if (mapEl) mapEl.value = linkSnap.val() || "";
            if (instructionsEl) instructionsEl.value = instructionsSnap.val() || "";

            // Load pickup locations list
            await this.loadPickupLocations();
        } catch (e) {
            console.error("Error loading pickup area:", e);
        }
    }

    async savePickupArea() {
        try {
            const name = (document.getElementById("pickupName")?.value || "").trim();
            const addr = (
                document.getElementById("pickupAddress")?.value || ""
            ).trim();
            const map = (
                document.getElementById("pickupMapLink")?.value || ""
            ).trim();
            const instructions = (
                document.getElementById("pickupInstructions")?.value || ""
            ).trim();

            const updates = {
                "systemData/pickup/name": name,
                "systemData/pickup/address": addr,
                "systemData/pickup/mapLink": map,
                "systemData/pickup/instructions": instructions,
                "systemData/pickup/updatedAt": FirebaseUtils.getTimestamp(),
            };

            const rootRef =
                typeof database !== "undefined"
                    ? database.ref()
                    : firebase.database().ref();
            await rootRef.update(updates);
            this.showSuccessMessage("Pick up area saved successfully!");
        } catch (e) {
            console.error("Error saving pickup area:", e);
            alert("Error saving pickup area: " + (e && e.message ? e.message : e));
        }
    }

    // Pickup Locations Management
    async loadPickupLocations() {
        try {
            const locationsList = document.getElementById("pickupLocationsList");
            if (!locationsList) return;

            const snap = await dbRefs.systemData
                .child("pickupLocations")
                .once("value");
            const locations = snap.val() || {};

            const locationCards = Object.entries(locations).map(([id, location]) =>
                this._renderPickupLocationCard(id, location)
            );

            locationsList.innerHTML = locationCards.length
                ? locationCards.join("")
                : '<div style="text-align:center; color:#666; padding:20px; border:2px dashed #ddd; border-radius:8px;">No pickup locations configured yet.</div>';
        } catch (e) {
            console.error("Error loading pickup locations:", e);
        }
    }

    _renderPickupLocationCard(id, location) {
        const safeName = String(location.name || "").replace(/</g, "&lt;");
        const safeAddress = String(location.address || "").replace(/</g, "&lt;");
        const safeInstructions = String(location.instructions || "").replace(
            /</g,
            "&lt;"
        );
        const safeMapLink = String(location.mapLink || "").replace(/</g, "&lt;");
        const isSelected = location.isSelected || false;

        return `
            <div class="pickup-location-card" data-id="${id}" style="border:1px solid ${isSelected ? "#28a745" : "#e0e0e0"
            }; border-radius:8px; padding:16px; background:${isSelected ? "#f8fff8" : "#fff"
            };">
                <div style="display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:12px;">
                    <div style="display:flex; align-items:center; gap:8px;">
                        <input type="radio" name="selectedPickupLocation" value="${id}" ${isSelected ? "checked" : ""
            } 
                               onchange="window.staffManager && staffManager.selectPickupLocation('${id}')"
                               style="margin:0;" />
                        <div>
                            <h4 style="margin:0 0 4px 0; color:#333;">${safeName}</h4>
                            <p style="margin:0; color:#666; font-size:14px;">${safeAddress}</p>
                        </div>
                    </div>
                    <div style="display:flex; gap:4px;">
                        <button class="secondary-btn" onclick="window.staffManager && staffManager.editPickupLocation('${id}')" 
                                style="font-size:11px; padding:4px 8px;" title="Edit">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="danger-btn" onclick="window.staffManager && staffManager.deletePickupLocation('${id}')" 
                                style="font-size:11px; padding:4px 8px;" title="Delete">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
                ${safeInstructions
                ? `<p style="margin:0 0 8px 0; color:#555; font-size:13px;"><strong>Instructions:</strong> ${safeInstructions}</p>`
                : ""
            }
                ${safeMapLink
                ? `<a href="${safeMapLink}" target="_blank" style="color:#1976d2; text-decoration:none; font-size:13px;"><i class="fas fa-map-marker-alt"></i> View on Map</a>`
                : ""
            }
                ${isSelected
                ? `<div style="margin-top:8px; padding:4px 8px; background:#28a745; color:white; border-radius:4px; font-size:12px; text-align:center;"><i class="fas fa-check"></i> Selected</div>`
                : ""
            }
            </div>
        `;
    }

    addPickupLocation() {
        const name = prompt("Enter pickup location name:");
        if (!name || !name.trim()) return;

        const address = prompt("Enter address/directions:");
        const mapLink = prompt("Enter map link (optional):");
        const instructions = prompt("Enter pickup instructions (optional):");

        const locationData = {
            name: name.trim(),
            address: address ? address.trim() : "",
            mapLink: mapLink ? mapLink.trim() : "",
            instructions: instructions ? instructions.trim() : "",
            createdAt: FirebaseUtils.getTimestamp(),
            updatedAt: FirebaseUtils.getTimestamp(),
        };

        this.savePickupLocation(null, locationData);
    }

    async savePickupLocation(id, locationData) {
        try {
            const updates = {};
            const locationId = id || `location_${Date.now()}`;

            updates[`systemData/pickupLocations/${locationId}`] = {
                ...locationData,
                updatedAt: FirebaseUtils.getTimestamp(),
            };

            const rootRef =
                typeof database !== "undefined"
                    ? database.ref()
                    : firebase.database().ref();
            await rootRef.update(updates);

            this.showSuccessMessage(
                id ? "Pickup location updated!" : "Pickup location added!"
            );
            setTimeout(() => this.loadPickupLocations(), 1000);
        } catch (e) {
            console.error("Error saving pickup location:", e);
            alert(
                "Error saving pickup location: " + (e && e.message ? e.message : e)
            );
        }
    }
    editPickupLocation(id) {
        // This would open a modal or form for editing
        // For now, we'll use prompts
        const name = prompt("Edit location name:");
        if (!name || !name.trim()) return;

        const address = prompt("Edit address/directions:");
        const mapLink = prompt("Edit map link (optional):");
        const instructions = prompt("Edit pickup instructions (optional):");

        const locationData = {
            name: name.trim(),
            address: address ? address.trim() : "",
            mapLink: mapLink ? mapLink.trim() : "",
            instructions: instructions ? instructions.trim() : "",
            updatedAt: FirebaseUtils.getTimestamp(),
        };

        this.savePickupLocation(id, locationData);
    }

    async deletePickupLocation(id) {
        if (!confirm("Are you sure you want to delete this pickup location?"))
            return;

        try {
            const updates = {};
            updates[`systemData/pickupLocations/${id}`] = null;

            const rootRef =
                typeof database !== "undefined"
                    ? database.ref()
                    : firebase.database().ref();
            await rootRef.update(updates);

            this.showSuccessMessage("Pickup location deleted!");
            setTimeout(() => this.loadPickupLocations(), 1000);
        } catch (e) {
            console.error("Error deleting pickup location:", e);
            alert(
                "Error deleting pickup location: " + (e && e.message ? e.message : e)
            );
        }
    }
    async selectPickupLocation(selectedId) {
        try {
            // First, get all pickup locations to unselect others
            const snap = await dbRefs.systemData
                .child("pickupLocations")
                .once("value");
            const locations = snap.val() || {};

            const updates = {};

            // Unselect all locations first
            Object.keys(locations).forEach((id) => {
                updates[`systemData/pickupLocations/${id}/isSelected`] = false;
            });

            // Select the chosen location
            updates[`systemData/pickupLocations/${selectedId}/isSelected`] = true;

            const rootRef =
                typeof database !== "undefined"
                    ? database.ref()
                    : firebase.database().ref();
            await rootRef.update(updates);

            this.showSuccessMessage("Pickup location selected!");
            setTimeout(() => this.loadPickupLocations(), 500);
        } catch (e) {
            console.error("Error selecting pickup location:", e);
            alert(
                "Error selecting pickup location: " + (e && e.message ? e.message : e)
            );
        }
    }
    _setupProductsRealtimeListeners() {
        // Note: Realtime listeners removed - Supabase doesn't support Firebase-style realtime listeners
        // Products will be refreshed on manual actions (create, update, delete)
        // This function is kept for compatibility but does nothing
        console.log("âš ï¸ Products realtime listeners disabled - using Supabase");
    }

    _debounce(fn, wait) {
        let t;
        return (...args) => {
            clearTimeout(t);
            t = setTimeout(() => fn.apply(this, args), wait);
        };
    }

    // Human-friendly status label for UI badges
    formatStatus(status, order = null) {
        if (!status || typeof status !== "string") return "";
        const s = status.toLowerCase();

        // Check if pickup order is ready for pickup - show "Pickup Ready" instead of "To Receive"
        if (s === "to_receive" && order) {
            const isPickup = String(order.deliveryOption || "").toLowerCase() === "pickup";
            const readyForPickup = order.readyForPickup === true || order.ready_for_pickup === true;
            if (isPickup && readyForPickup) {
                return "Pickup Ready";
            }
        }

        if (s === "out_for_delivery") {
            return "Out for delivery";
        }
        if (s === "to_receive") {
            return "To Receive";
        }
        if (s === "pickup_ready") {
            return "Pickup Ready";
        }
        if (s === "delivered") {
            return "Delivered";
        }
        if (s === "picked_up") {
            return "Picked Up";
        }
        if (s === "failed" || s === "delivery_failed") {
            return "Failed Delivery";
        }
        if (s === "failed_pickup") {
            return "Failed Pickup";
        }
        // Title-case other statuses and replace underscores
        return s
            .split("_")
            .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
            .join(" ");
    }
    async initialize() {
        // Show loading screen immediately
        this.showLoadingScreen("Initializing dashboard...");

        // Check authentication FIRST before loading anything else (no delay)
        await this.checkAuthentication();

        // Only proceed if authentication was successful
        if (this.userName && this.userUid) {
            // Update UI immediately after auth
            this.updateUIForRole();

            // Setup critical event listeners first (non-blocking)
            this.setupEventListeners();
            this.initializeMenuListeners();

            // Load dashboard data BEFORE hiding loading screen
            // This ensures data is ready when loading screen disappears
            this.updateLoadingText("Loading dashboard data...");
            const dataLoadStartTime = Date.now();

            try {
                // Load the dashboard (staff-overview) data and wait for it to complete
                // This ensures the dashboard shows data immediately when loading screen disappears
                await this.loadSectionData("staff-overview");
                console.log("Dashboard data loaded successfully");
            } catch (error) {
                console.error("Error loading dashboard data:", error);
                // Continue even if there's an error, but log it
            }

            // Ensure minimum 2 seconds display time for loading screen (for smooth UX)
            const dataLoadElapsed = Date.now() - dataLoadStartTime;
            const minLoadingTime = 2000; // 2 seconds minimum
            const remainingTime = Math.max(0, minLoadingTime - dataLoadElapsed);

            if (remainingTime > 0) {
                this.updateLoadingText("Preparing dashboard...");
                await new Promise((resolve) => setTimeout(resolve, remainingTime));
            }

            // Hide loading screen only after dashboard data is loaded and minimum time elapsed
            this.hideLoadingScreen();

            // Setup realtime listeners in background (non-blocking)
            this.setupRealtimeListeners();

            // Initialize other features in background (non-blocking)
            setTimeout(() => {
                this.cleanupRejectedCustomers(); // Run Monday cleanup check
                setupOrderAutoRefresh(); // Initialize order auto-refresh
                this.attachPendingOrdersListener(); // reliable realtime pending-orders refresh
                this.initFarmerSearch(); // ensure farmer search X toggles properly
                this.initCustomerSearch(); // ensure customer search X toggles properly
                this.testFirebaseFunctions(); // Test Firebase Functions availability
                this.startCutoffWatcher(); // Start cutoff watcher
            }, 0);

            // Load pickup areas in background (non-critical, can load later)
            setTimeout(async () => {
                console.log("ðŸ” Initializing pickup area loading...");
                await this.testFirebaseConnection();
                this.loadPickupAreaRecords();
                this.restoreActivePickupAreaState();
            }, 100);
        }
    }

    // Test Firebase connection
    async testFirebaseConnection() {
        try {
            console.log("ðŸ” Testing Firebase connection...");

            // Check if Firebase is available
            if (typeof firebase === "undefined") {
                console.error("âŒ Firebase not available");
                return false;
            }

            // Check if database is available
            if (!firebase.database) {
                console.error("âŒ Firebase Database not available");
                return false;
            }

            // Check if dbRefs is available
            const dbRefsToUse = window.dbRefs || dbRefs;
            if (!dbRefsToUse) {
                console.error("âŒ dbRefs not available");
                return false;
            }

            // Test a simple read operation
            console.log("ðŸ” Testing database read...");
            const testRef = dbRefsToUse.systemData.child("test");
            await testRef.set({ timestamp: Date.now() });
            await testRef.remove();

            console.log("âœ… Firebase connection test successful");
            return true;
        } catch (e) {
            console.error("âŒ Firebase connection test failed:", e);
            return false;
        }
    }

    // Test Firebase Functions availability
    async testFirebaseFunctions() {
        try {
            console.log("ðŸ” Testing Firebase Functions availability...");

            if (!firebase.functions) {
                console.error("âŒ Firebase Functions not initialized!");
                console.error("Please check:");
                console.error("1. Firebase Functions script is loaded");
                console.error(
                    "2. Firebase Functions are initialized in firebase-config.js"
                );
                return false;
            }

            console.log("âœ… Firebase Functions initialized successfully");

            // Test if the deleteUserAccount function exists
            const testFunction = firebase
                .functions()
                .httpsCallable("deleteUserAccount");
            console.log("âœ… deleteUserAccount function is callable");

            return true;
        } catch (error) {
            console.error("âŒ Firebase Functions test failed:", error);
            console.error("This means email reuse will not work properly!");
            return false;
        }
    }

    async checkAuthentication() {
        try {
            // Show loading screen if not already hidden
            this.showLoadingScreen("Authenticating...");

            const uid = this.userUid;
            let name = this.userName;
            const role = this.userRole;
            const authMethod = sessionStorage.getItem("authMethod");

            console.log("Authentication check:", { uid, name, role, authMethod });

            if (uid) {
                // Check sessionStorage first (fastest) before making network requests
                const cachedName =
                    sessionStorage.getItem("adminName") ||
                    sessionStorage.getItem("staffName") ||
                    sessionStorage.getItem("username");
                if (cachedName) {
                    this.userName = cachedName;
                    name = cachedName;
                    console.log(`${role} name loaded from cache:`, cachedName);
                } else {
                    // Only fetch from database if not in cache
                    // For admin users, fetch the actual name from Supabase
                    if (this.isAdmin() && uid) {
                        try {
                            this.updateLoadingText("Loading admin profile...");
                            const supabase = window.getSupabaseClient
                                ? window.getSupabaseClient()
                                : window.supabaseClient || null;
                            if (supabase) {
                                // Only select name fields for faster query
                                const { data: admins, error: queryError } = await supabase
                                    .from("admins")
                                    .select("fullname, username, fullName, name")
                                    .eq("uuid", uid)
                                    .limit(1)
                                    .single();

                                if (!queryError && admins) {
                                    const adminName =
                                        admins.fullname ||
                                        admins.username ||
                                        admins.fullName ||
                                        admins.name ||
                                        "Administrator";
                                    this.userName = adminName;
                                    name = adminName;
                                    sessionStorage.setItem("adminName", adminName);
                                    sessionStorage.setItem("staffName", adminName);
                                    sessionStorage.setItem("username", adminName);
                                    console.log("Admin name loaded from Supabase:", adminName);
                                }
                            }
                        } catch (error) {
                            console.error("Error loading admin name from Supabase:", error);
                            // Fallback to default if query fails
                            this.userName = "Administrator";
                            name = "Administrator";
                        }
                    } else if (!this.isAdmin() && uid) {
                        // For staff users, try Firebase (faster than Supabase for staff)
                        try {
                            this.updateLoadingText("Loading staff profile...");
                            if (window.dbRefs && window.dbRefs.staff) {
                                const staffSnapshot = await window.dbRefs.staff
                                    .child(uid)
                                    .once("value");
                                const staffData = staffSnapshot.val();
                                if (staffData) {
                                    const staffName =
                                        staffData.fullName ||
                                        staffData.name ||
                                        staffData.username ||
                                        "Staff Member";
                                    this.userName = staffName;
                                    name = staffName;
                                    sessionStorage.setItem("staffName", staffName);
                                    sessionStorage.setItem("username", staffName);
                                    console.log("Staff name loaded from Firebase:", staffName);
                                } else {
                                    this.userName = "Staff Member";
                                    name = "Staff Member";
                                }
                            } else {
                                this.userName = "Staff Member";
                                name = "Staff Member";
                            }
                        } catch (error) {
                            console.error("Error loading staff name:", error);
                            this.userName = "Staff Member";
                            name = "Staff Member";
                        }
                    }
                }

                if (this.userName) {
                    console.log(`${role} authenticated via session storage`);

                    // Store role in session storage for consistency
                    sessionStorage.setItem("userRole", role);

                    // UI will be updated in initialize() after this returns
                } else {
                    console.error("No user name found");
                    this.updateLoadingText("Authentication failed. Redirecting...");
                    setTimeout(() => {
                        alert("Authentication required. Please log in again.");
                        window.location.href = "admin-login.html";
                    }, 1000);
                }
            } else {
                console.error("No authentication found");
                this.updateLoadingText("No authentication found. Redirecting...");
                setTimeout(() => {
                    alert("Authentication required. Please log in again.");
                    window.location.href = "admin-login.html";
                }, 1000);
            }
        } catch (error) {
            console.error("Error checking authentication:", error);
            this.updateLoadingText("Error during authentication. Redirecting...");
            setTimeout(() => {
                alert("Authentication error. Please log in again.");
                window.location.href = "admin-login.html";
            }, 1000);
        }
    }

    // Loading screen management
    showLoadingScreen(message = "Loading Dashboard...") {
        const loadingScreen = document.getElementById("loadingScreen");
        const loadingText = loadingScreen?.querySelector(".loading-text");
        const loadingSubtext = loadingScreen?.querySelector(".loading-subtext");

        // Ensure body has loading class and prevent scrolling
        document.body.classList.add("loading");
        document.body.style.overflow = "hidden";
        document.documentElement.style.overflow = "hidden";

        if (loadingScreen) {
            loadingScreen.style.display = "flex";
            loadingScreen.classList.remove("hidden");
        }
        if (loadingText) {
            loadingText.textContent = message;
        }
        if (loadingSubtext) {
            loadingSubtext.textContent = "Please wait...";
        }

        // Hide dashboard content
        const dashboardContent = document.getElementById("staffDashboard");
        if (dashboardContent) {
            dashboardContent.classList.remove("loaded");
        }
    }

    updateLoadingText(message, subtext = null) {
        const loadingText = document
            .getElementById("loadingScreen")
            ?.querySelector(".loading-text");
        const loadingSubtext = document
            .getElementById("loadingScreen")
            ?.querySelector(".loading-subtext");

        // Update text directly but ensure no layout shifts
        // The CSS already has fixed min-heights to prevent reflows
        if (loadingText) {
            loadingText.textContent = message || "";
        }
        if (loadingSubtext && subtext !== null) {
            loadingSubtext.textContent = subtext;
        }
    }

    hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        const dashboardContent = document.getElementById("staffDashboard");

        // Remove loading class from body and restore scrolling
        document.body.classList.remove("loading");
        document.body.style.overflow = "";
        document.documentElement.style.overflow = "";

        if (loadingScreen) {
            loadingScreen.classList.add("hidden");
            loadingScreen.style.display = "none";
        }

        // Show dashboard content with fade-in
        if (dashboardContent) {
            setTimeout(() => {
                dashboardContent.classList.add("loaded");
                dashboardContent.style.opacity = "1";
            }, 100);
        }
    }

    updateUIForRole() {
        // Update sidebar brand
        const brandEl = document.getElementById("dashboard-brand");
        if (brandEl) {
            brandEl.textContent = this.isAdmin() ? "Admin" : "Staff";
        }

        // Update profile role - use "System Administrator" for admin users
        const profileRoleEl = document.getElementById("profileRole");
        if (profileRoleEl) {
            profileRoleEl.textContent = this.isAdmin()
                ? "System Administrator"
                : "Staff";
        }
        const dropdownRoleEl = document.getElementById("dropdownStaffRole");
        if (dropdownRoleEl) {
            dropdownRoleEl.textContent = this.isAdmin()
                ? "System Administrator"
                : "Staff";
        }

        // Update profile name
        const profileNameEl = document.getElementById("profileName");
        if (profileNameEl) {
            profileNameEl.textContent = this.userName;
        }
        const dropdownNameEl = document.getElementById("dropdownStaffName");
        if (dropdownNameEl) {
            dropdownNameEl.textContent =
                this.userName || (this.isAdmin() ? "Administrator" : "Staff Member");
        }

        // Update page title
        document.title = `AgriCart - ${this.isAdmin() ? "Admin" : "Staff"
            } Dashboard`;

        // Show/hide admin-specific features
        this.toggleAdminFeatures();
    }

    toggleAdminFeatures() {
        // Show/hide admin-specific features based on role
        const adminOnlyElements = document.querySelectorAll(".admin-only");

        if (this.isAdmin()) {
            // Show admin-only elements
            adminOnlyElements.forEach((el) => {
                el.style.display = "";
            });
            console.log("Admin features enabled");
        } else {
            // Hide admin-only elements
            adminOnlyElements.forEach((el) => {
                el.style.display = "none";
            });
            console.log("Staff mode - admin features hidden");
        }
    }
    setupEventListeners() {
        console.log("Setting up event listeners...");

        // Wait for DOM to be fully ready
        setTimeout(() => {
            // Sidebar navigation
            const menuItems = document.querySelectorAll(".menu-item");
            console.log("Found menu items:", menuItems.length);

            if (menuItems.length === 0) {
                console.error("No menu items found!");
                return;
            }

            menuItems.forEach((item, index) => {
                console.log(
                    `Setting up listener for menu item ${index}:`,
                    item.dataset.section
                );
                item.addEventListener("click", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log("Menu item clicked:", item.dataset.section);
                    const section = item.dataset.section;
                    this.switchSection(section);
                });
            });
        }, 100);

        // Fallback: Use event delegation for menu items
        document.addEventListener("click", (e) => {
            if (e.target.closest(".menu-item")) {
                const menuItem = e.target.closest(".menu-item");
                const section = menuItem.dataset.section;
                if (section) {
                    console.log("Event delegation: Menu item clicked:", section);
                    e.preventDefault();
                    e.stopPropagation();
                    this.switchSection(section);
                }
            }

            // Event delegation for customer management tabs - REMOVED to allow direct event handlers to work
        });

        // Add product button
        document.getElementById("addProductBtn").addEventListener("click", () => {
            this.showAddProductModal();
        });

        // Product search functionality
        const searchInput = document.getElementById("productSearchInput");
        const clearSearchBtn = document.getElementById("clearSearchBtn");

        if (searchInput) {
            // Search on input
            searchInput.addEventListener("input", (e) => {
                const searchTerm = e.target.value;
                this.handleProductSearch(searchTerm);
            });

            // Search on Enter key
            searchInput.addEventListener("keypress", (e) => {
                if (e.key === "Enter") {
                    const searchTerm = e.target.value;
                    this.handleProductSearch(searchTerm);
                }
            });
        }

        if (clearSearchBtn) {
            clearSearchBtn.addEventListener("click", () => {
                this.clearProductSearch();
            });
        }


        // Time period selector for reports
        document.querySelectorAll(".time-btn").forEach((btn) => {
            btn.addEventListener("click", (e) => {
                this.switchTimePeriod(btn.dataset.period);
            });
        });

        // User management tabs
        document
            .querySelectorAll(".user-management-tabs .tab-btn")
            .forEach((btn) => {
                btn.addEventListener("click", (e) => {
                    const tab = btn.dataset.tab;
                    this.switchUserManagementTab(tab);
                });
            });

        // Customer management tabs - REMOVED conflicting event listeners to allow direct event handlers to work

        // Order management tabs - REMOVED conflicting event listeners to allow onclick attributes to work

        // Verification tabs
        document.querySelectorAll(".verification-tabs .tab-btn").forEach((btn) => {
            btn.addEventListener("click", (e) => {
                const tab = btn.dataset.tab;
                this.switchVerificationTab(tab);
            });
        });

        // Verification status tabs
        document
            .querySelectorAll(".verification-status-tabs .status-tab-btn")
            .forEach((btn) => {
                btn.addEventListener("click", (e) => {
                    const status = btn.dataset.status;
                    this.switchVerificationStatusTab(status);
                });
            });

        // Modal close
        document.addEventListener("click", (e) => {
            if (
                e.target.classList.contains("close-modal") ||
                e.target.classList.contains("modal-overlay")
            ) {
                this.closeModal();
            }
        });

        // Profile dropdown functionality
        this.setupProfileDropdown();
    }

    setupProfileDropdown() {
        // Simple and reliable dropdown setup
        const profileBtn = document.getElementById("staffProfileBtn");
        const dropdownMenu = document.getElementById("profileDropdownMenu");

        if (!profileBtn || !dropdownMenu) {
            console.error("Profile dropdown elements not found!");
            return;
        }

        // Toggle dropdown on profile button click
        profileBtn.onclick = (e) => {
            e.stopPropagation();
            this.toggleProfileDropdown();
        };

        // Profile menu item click
        const profileMenuItem = document.getElementById("profileMenuItem");
        if (profileMenuItem) {
            profileMenuItem.onclick = (e) => {
                e.preventDefault();
                this.closeProfileDropdown();
                this.showProfileSection();
            };
        }

        // Settings menu item click
        const settingsMenuItem = document.getElementById("settingsMenuItem");
        if (settingsMenuItem) {
            settingsMenuItem.onclick = (e) => {
                e.preventDefault();
                this.closeProfileDropdown();
                this.showSettingsSection();
            };
        }

        // Logout menu item click
        const logoutMenuItem = document.getElementById("logoutMenuItem");
        if (logoutMenuItem) {
            logoutMenuItem.onclick = (e) => {
                e.preventDefault();
                this.closeProfileDropdown();
                this.logout();
            };
        }

        // Close dropdown when clicking outside
        document.onclick = (e) => {
            if (!profileBtn.contains(e.target) && !dropdownMenu.contains(e.target)) {
                this.closeProfileDropdown();
            }
        };

        // Update staff name in dropdown
        this.updateStaffName();
    }

    toggleProfileDropdown() {
        const profileBtn = document.getElementById("staffProfileBtn");
        const dropdownMenu = document.getElementById("profileDropdownMenu");

        if (!profileBtn || !dropdownMenu) {
            return;
        }

        const isOpen = dropdownMenu.classList.contains("show");

        if (isOpen) {
            this.closeProfileDropdown();
        } else {
            this.openProfileDropdown();
        }
    }

    openProfileDropdown() {
        const profileBtn = document.getElementById("staffProfileBtn");
        const dropdownMenu = document.getElementById("profileDropdownMenu");

        profileBtn.classList.add("active");
        dropdownMenu.classList.add("show");
    }

    closeProfileDropdown() {
        const profileBtn = document.getElementById("staffProfileBtn");
        const dropdownMenu = document.getElementById("profileDropdownMenu");

        profileBtn.classList.remove("active");
        dropdownMenu.classList.remove("show");
    }

    async updateStaffName() {
        let staffName = sessionStorage.getItem("staffName") || "Staff Member";

        // Try to fetch the latest staff name from database
        try {
            const staffUid = sessionStorage.getItem("staffUid");
            if (staffUid && window.dbRefs && window.dbRefs.staff) {
                const staffSnapshot = await window.dbRefs.staff
                    .child(staffUid)
                    .once("value");
                const staffData = staffSnapshot.val();

                if (staffData) {
                    staffName = staffData.fullName || staffData.name || "Staff Member";
                    // Update session storage with the latest name
                    sessionStorage.setItem("staffName", staffName);
                    sessionStorage.setItem("username", staffName);
                }
            }
        } catch (error) {
            console.error("Error fetching staff name:", error);
        }

        const dropdownNameSpan = document.getElementById("dropdownStaffName");

        if (dropdownNameSpan) {
            dropdownNameSpan.textContent = staffName;
        }
    }

    async showProfileSection() {
        console.log("=== SHOW PROFILE SECTION CALLED ===");

        // If user is admin, require password verification
        if (this.isAdmin()) {
            const passwordVerified = await this.verifyAdminPassword();
            if (!passwordVerified) {
                console.log("Password verification failed or cancelled");
                return;
            }
        }

        // Populate profile section with current user data
        await this.populateProfileSection();
        this.switchSection("staff-profile");
        console.log("=== SHOW PROFILE SECTION COMPLETED ===");
    }

    async verifyAdminPassword() {
        return new Promise((resolve) => {
            const modalContent = `
                <div class="modal-header">
                    <h3>Security Verification</h3>
                    <button class="close-modal" onclick="staffManager.closePasswordModal();">&times;</button>
                </div>
                <div style="padding: 20px;">
                    <p style="margin-bottom: 20px; color: #666;">
                        <i class="fas fa-shield-alt" style="color: #ff9800; margin-right: 8px;"></i>
                        Please enter your admin password to access your profile for security purposes.
                    </p>
                    <div class="form-field">
                        <label for="adminPasswordVerify" class="required">Admin Password</label>
                        <div style="position: relative;">
                            <input type="password" id="adminPasswordVerify" placeholder="Enter your password" required autofocus style="padding-right: 45px; width: 100%; box-sizing: border-box;">
                            <button type="button" id="toggleAdminPasswordVerify" style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); background: transparent; border: none; color: #666; cursor: pointer; padding: 5px; display: flex; align-items: center; justify-content: center; width: 30px; height: 30px; transition: color 0.2s;" onmouseover="this.style.color='#333'" onmouseout="this.style.color='#666'" onclick="staffManager.togglePasswordVisibility('adminPasswordVerify', 'toggleAdminPasswordVerify');">
                                <i class="fas fa-eye" id="toggleAdminPasswordVerifyIcon"></i>
                            </button>
                        </div>
                    </div>
                    <div class="modal-actions" style="margin-top: 20px;">
                        <button type="button" class="secondary-btn" id="cancelPasswordVerifyBtn">Cancel</button>
                        <button type="button" class="primary-btn" id="confirmPasswordVerifyBtn">
                            <i class="fas fa-check"></i> Verify
                        </button>
                    </div>
                </div>
            `;

            // Create temporary modal for password verification
            const tempModalId = "adminPasswordVerifyModal";
            let modalOverlay = document.getElementById(tempModalId);

            if (!modalOverlay) {
                modalOverlay = document.createElement("div");
                modalOverlay.id = tempModalId;
                modalOverlay.className = "modal-overlay";
                modalOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                `;
                document.body.appendChild(modalOverlay);
            }

            const modalContentDiv = document.createElement("div");
            modalContentDiv.className = "modal-content";
            modalContentDiv.style.cssText = `
                background: white;
                border-radius: 15px;
                padding: 0;
                max-width: 500px;
                width: 90%;
            `;
            modalContentDiv.innerHTML = modalContent;

            modalOverlay.innerHTML = "";
            modalOverlay.appendChild(modalContentDiv);
            modalOverlay.classList.add("show");
            modalOverlay.style.display = "flex";

            // Store resolve function for later use
            modalOverlay._resolvePassword = resolve;

            // Handle Enter key and button clicks
            const passwordInput = document.getElementById("adminPasswordVerify");
            const confirmBtn = document.getElementById("confirmPasswordVerifyBtn");
            const cancelBtn = document.getElementById("cancelPasswordVerifyBtn");
            
            if (passwordInput) {
                passwordInput.addEventListener("keypress", (e) => {
                    if (e.key === "Enter") {
                        staffManager.confirmAdminPassword();
                    }
                });
            }
            
            if (confirmBtn) {
                confirmBtn.addEventListener("click", () => {
                    staffManager.confirmAdminPassword();
                });
            }
            
            if (cancelBtn) {
                cancelBtn.addEventListener("click", () => {
                    staffManager.closePasswordModal();
                });
            }

            // Close on overlay click
            modalOverlay.addEventListener("click", (e) => {
                if (e.target === modalOverlay) {
                    resolve(false);
                    modalOverlay.remove();
                }
            });
        });
    }

    async confirmAdminPassword() {
        const passwordInput = document.getElementById("adminPasswordVerify");
        const password = passwordInput ? passwordInput.value : "";

        if (!password) {
            alert("Please enter your password");
            return;
        }

        try {
            // Get admin email from session
            const adminEmail =
                sessionStorage.getItem("userEmail") ||
                sessionStorage.getItem("adminEmail") ||
                "admin@agricart.com";

            // Use Supabase Auth verification (same as login logic)
            let verified = false;
            try {
                // Get Supabase client
                const supabase = window.getSupabaseClient
                    ? window.getSupabaseClient()
                    : window.supabaseClient || null;
                if (!supabase) {
                    throw new Error(
                        "Supabase client not initialized. Please refresh the page."
                    );
                }

                // Use Supabase Auth to verify password (same as login)
                // This ensures we verify against the hashed password in Auth, not plain text in admins table
                const lowerEmail = adminEmail.toLowerCase();
                const signInResult = await supabase.auth.signInWithPassword({
                    email: lowerEmail,
                    password: password,
                });

                if (signInResult.error) {
                    console.error("Password verification error:", signInResult.error);
                    verified = false;
                } else if (signInResult.data && signInResult.data.user) {
                    // Password is correct - verified via Supabase Auth
                    verified = true;
                    // Sign out immediately since we just needed to verify
                    await supabase.auth.signOut();
                } else {
                    verified = false;
                }
            } catch (authError) {
                console.error("Error verifying admin password via Supabase Auth:", authError);
                verified = false;
            }

            const modalOverlay = document.getElementById("adminPasswordVerifyModal");
            if (modalOverlay && modalOverlay._resolvePassword) {
                if (verified) {
                    modalOverlay.remove();
                    modalOverlay._resolvePassword(true);
                } else {
                    alert("Incorrect password. Please try again.");
                    if (passwordInput) {
                        passwordInput.value = "";
                        passwordInput.focus();
                    }
                }
            }
        } catch (error) {
            console.error("Error verifying password:", error);
            alert("Error verifying password: " + error.message);
            const modalOverlay = document.getElementById("adminPasswordVerifyModal");
            if (modalOverlay && modalOverlay._resolvePassword) {
                const passwordInput = document.getElementById("adminPasswordVerify");
                if (passwordInput) {
                    passwordInput.value = "";
                    passwordInput.focus();
                }
            }
        }
    }

    togglePasswordVisibility(inputId, toggleId) {
        const passwordInput = document.getElementById(inputId);
        const toggleIcon = document.getElementById(toggleId + 'Icon');
        
        if (passwordInput && toggleIcon) {
            if (passwordInput.type === 'password') {
                passwordInput.type = 'text';
                toggleIcon.classList.remove('fa-eye');
                toggleIcon.classList.add('fa-eye-slash');
            } else {
                passwordInput.type = 'password';
                toggleIcon.classList.remove('fa-eye-slash');
                toggleIcon.classList.add('fa-eye');
            }
        }
    }

    closePasswordModal() {
        const modalOverlay = document.getElementById("adminPasswordVerifyModal");
        if (modalOverlay && modalOverlay._resolvePassword) {
            modalOverlay._resolvePassword(false);
            modalOverlay.remove();
        }
    }

    showSettingsSection() {
        // Populate settings section
        this.populateSettingsSection();
        this.switchSection("staff-settings");
    }
    async populateProfileSection() {
        console.log("=== POPULATE PROFILE SECTION START ===");

        // Check if user is admin
        const isAdmin = this.isAdmin();

        let staffName =
            sessionStorage.getItem("staffName") ||
            (isAdmin ? "Rodel Morales" : "Staff Member");
        let staffEmail =
            sessionStorage.getItem("userEmail") ||
            (isAdmin ? "admin@agricart.com" : "staff@example.com");
        let staffRole = isAdmin ? "System Administrator" : "Staff Member";
        let staffPhone = "";
        let staffAddress = "";
        let staffIdType = "";
        let accountUid = null;
        // Initialize employee ID for staff
        if (!isAdmin) {
            this.staffEmployeeId = "N/A";
        }

        console.log("Initial values from session storage:", {
            staffName,
            staffEmail,
            isAdmin,
        });

        // Try to fetch the latest admin/staff data from database
        try {
            const adminUid =
                sessionStorage.getItem("adminUid") || sessionStorage.getItem("userUid");
            const staffUid = sessionStorage.getItem("staffUid");
            accountUid = isAdmin ? adminUid : staffUid;
            const uid = accountUid;

            console.log("User UID:", uid, "Is Admin:", isAdmin);
            console.log("DB Refs available:", !!window.dbRefs);

            if (uid) {
                console.log("Fetching user data from database...");

                let userData = null;

                // Fetch from Supabase for both admin and staff
                try {
                    const supabase = window.getSupabaseClient
                        ? window.getSupabaseClient()
                        : window.supabaseClient || null;
                    if (supabase) {
                        if (isAdmin) {
                            // Admin profiles are stored in the admins table keyed by uuid (adminUid)
                            const { data: users, error: queryError } = await supabase
                                .from("admins")
                                .select("*")
                                .eq("uuid", uid)
                                .limit(1);

                            if (queryError) {
                                console.error("Supabase query error (admins):", queryError);
                            } else if (users && users.length > 0) {
                                userData = users[0];
                                console.log("Admin data from Supabase:", userData);
                            } else {
                                console.log("No admin found in Supabase with uid:", uid);
                            }
                        } else {
                            // Staff profiles are in the staff table, keyed by uuid (staffUid)
                            // First try by UUID (primary method, same as admin side)
                            if (uid) {
                                const { data: staffRowsByUuid, error: staffErrByUuid } = await supabase
                                    .from("staff")
                                    .select("*")
                                    .eq("uuid", uid)
                                    .limit(1);

                                if (staffErrByUuid) {
                                    console.error("Supabase query error (staff by uuid):", staffErrByUuid);
                                } else if (staffRowsByUuid && staffRowsByUuid.length > 0) {
                                    userData = staffRowsByUuid[0];
                                    console.log("Staff data from Supabase (staff table by uuid):", userData);
                                    console.log("Address-related fields in userData:", {
                                        street: userData.street,
                                        sitio: userData.sitio,
                                        barangay: userData.barangay,
                                        address: userData.address,
                                        allAddressKeys: Object.keys(userData).filter(k => 
                                            k.toLowerCase().includes('street') || 
                                            k.toLowerCase().includes('sitio') || 
                                            k.toLowerCase().includes('barangay') || 
                                            k.toLowerCase().includes('address')
                                        )
                                    });
                                }
                            }
                            
                            // Fallback: try by email if UUID query didn't find anything
                            if (!userData) {
                                const email =
                                    (this.userEmail || staffEmail || "").toLowerCase().trim();
                                if (email) {
                                    const { data: staffRows, error: staffErr } = await supabase
                                        .from("staff")
                                        .select("*")
                                        .eq("email", email)
                                        .limit(1);

                                    if (staffErr) {
                                        console.error("Supabase query error (staff by email):", staffErr);
                                    } else if (staffRows && staffRows.length > 0) {
                                        userData = staffRows[0];
                                        console.log("Staff data from Supabase (staff table by email):", userData);
                                    } else {
                                        console.log(
                                            "No staff found in Supabase staff table with email:",
                                            email
                                        );
                                        // Fallback: try customers table to get phone/address if they exist there
                                        const { data: customerRows, error: custErr } = await supabase
                                            .from("customers")
                                            .select("*")
                                            .eq("email", email)
                                            .limit(1);
                                        if (custErr) {
                                            console.error(
                                                "Supabase query error (customers by email):",
                                                custErr
                                            );
                                        } else if (customerRows && customerRows.length > 0) {
                                            userData = customerRows[0];
                                            console.log(
                                                "Customer data from Supabase used for staff profile:",
                                                userData
                                            );
                                        }
                                    }
                                } else {
                                    console.log(
                                        "No email available to fetch staff profile from Supabase."
                                    );
                                }
                            }
                        }
                    } else {
                        console.error("Supabase client not available");
                    }
                } catch (supabaseError) {
                    console.error(
                        `Error fetching ${isAdmin ? "admin" : "staff"} from Supabase:`,
                        supabaseError
                    );
                }

                console.log("User data from database:", userData);

                if (userData) {
                    // For admin from Supabase, use fullname or username
                    if (isAdmin) {
                        staffName =
                            userData.fullname ||
                            userData.username ||
                            userData.full_name ||
                            userData.name ||
                            staffName;
                        // Always set role to "System Administrator" for admin users
                        staffRole = "System Administrator";
                    } else {
                        staffName = userData.full_name || userData.name || staffName;
                        staffRole = "Staff Member";
                    }
                    staffEmail = userData.email || staffEmail;
                    // Prefer customer phone_number if available (for staff accounts backed by customers table)
                    staffPhone =
                        userData.phone_number ||
                        userData.phone ||
                        (isAdmin ? "09525818621" : "");
                    // Don't set address or ID type for admin users
                    if (!isAdmin) {
                        // Store employee ID for staff
                        this.staffEmployeeId = userData.employee_id || userData.employeeId || "N/A";
                        staffAddress = userData.address || "";
                        staffIdType = userData.valid_id_type || "";
                        // Store last updated information for staff
                        this.staffLastUpdatedAt = userData.updated_at || null;
                        this.staffLastUpdatedByName = userData.last_updated_by_name || null;
                        this.staffLastUpdatedByRole = userData.last_updated_by_role || null;
                        // Store individual name and address fields for staff
                        // If individual fields don't exist, try to parse from full_name
                        if (userData.first_name || userData.last_name) {
                            this.staffFirstName = userData.first_name || "";
                            this.staffMiddleName = userData.middle_name || "";
                            this.staffLastName = userData.last_name || "";
                            this.staffSuffix = userData.suffix || "";
                        } else if (userData.full_name) {
                            // Parse full_name into individual parts as fallback
                            // Use the same parsing logic as admin for consistency
                            const parsedName = this.parseFullName(userData.full_name);
                            console.log('Staff profile - Parsed name from full_name:', userData.full_name, '->', parsedName);
                            this.staffFirstName = parsedName.firstName;
                            this.staffMiddleName = parsedName.middleName;
                            this.staffLastName = parsedName.lastName;
                            this.staffSuffix = parsedName.suffix;
                        } else {
                            this.staffFirstName = "";
                            this.staffMiddleName = "";
                            this.staffLastName = "";
                            this.staffSuffix = "";
                        }
                        
                        // Store address fields - check both snake_case and camelCase
                        // Explicitly check for null/undefined and convert to empty string
                        this.staffStreet = (userData.street !== null && userData.street !== undefined) ? String(userData.street).trim() : 
                                         ((userData.street_address !== null && userData.street_address !== undefined) ? String(userData.street_address).trim() : "");
                        this.staffSitio = (userData.sitio !== null && userData.sitio !== undefined) ? String(userData.sitio).trim() : "";
                        this.staffBarangay = (userData.barangay !== null && userData.barangay !== undefined) ? String(userData.barangay).trim() : "";
                        this.staffPostalCode = (userData.postal_code !== null && userData.postal_code !== undefined) ? String(userData.postal_code).trim() : 
                                             ((userData.postalCode !== null && userData.postalCode !== undefined) ? String(userData.postalCode).trim() : "6541");
                        this.staffCity = (userData.city !== null && userData.city !== undefined) ? String(userData.city).trim() : "Ormoc";
                        this.staffProvince = (userData.province !== null && userData.province !== undefined) ? String(userData.province).trim() : "Leyte";
                        
                        // If individual fields are empty but address exists, try to parse it
                        if ((!this.staffStreet && !this.staffSitio && !this.staffBarangay) && userData.address) {
                            console.log("Individual address fields empty, attempting to parse from address:", userData.address);
                            const addressStr = userData.address;
                            
                            // Split address by comma
                            const addressParts = addressStr.split(',').map(part => part.trim()).filter(part => part);
                            
                            // Try to identify components
                            // Pattern: Street, Sitio X, Barangay, City, Province, Postal Code
                            // Or: Street, Barangay, City, Province, Postal Code
                            
                            let foundBarangay = false;
                            let foundCity = false;
                            let foundProvince = false;
                            
                            for (let i = 0; i < addressParts.length; i++) {
                                const part = addressParts[i];
                                const partLower = part.toLowerCase();
                                
                                // Check for sitio (usually contains "sitio" or is a short name)
                                if (partLower.includes('sitio') && !this.staffSitio) {
                                    this.staffSitio = part.replace(/sitio\s*/i, '').trim();
                                    continue;
                                }
                                
                                // Check for barangay (usually contains "barangay", "brgy", "br", or matches known barangay list)
                                if ((partLower.includes('barangay') || partLower.includes('brgy') || partLower.includes('br.')) && !foundBarangay) {
                                    this.staffBarangay = part.replace(/\b(barangay|brgy\.?|br\.?)\s*/i, '').trim();
                                    foundBarangay = true;
                                    continue;
                                }
                                
                                // Check for city (usually "Ormoc" or comes before province)
                                if ((partLower === 'ormoc' || partLower.includes('city')) && !foundCity) {
                                    this.staffCity = part;
                                    foundCity = true;
                                    continue;
                                }
                                
                                // Check for province (usually "Leyte")
                                if (partLower === 'leyte' && !foundProvince) {
                                    this.staffProvince = part;
                                    foundProvince = true;
                                    continue;
                                }
                                
                                // Check for postal code (usually 4 digits)
                                if (/^\d{4}$/.test(part) && !this.staffPostalCode) {
                                    this.staffPostalCode = part;
                                    continue;
                                }
                            }
                            
                            // If barangay not found by keyword, try to match against known barangays
                            if (!this.staffBarangay && window.staffManager && typeof window.staffManager.getBarangayOptionsList === 'function') {
                                const barangayList = window.staffManager.getBarangayOptionsList();
                                for (const part of addressParts) {
                                    if (barangayList.some(b => b.toLowerCase() === part.toLowerCase())) {
                                        this.staffBarangay = part;
                                        break;
                                    }
                                }
                            }
                            
                            // Remaining parts before barangay are likely street/sitio
                            if (!this.staffStreet && addressParts.length > 0) {
                                const barangayIndex = addressParts.findIndex(p => 
                                    p.toLowerCase() === this.staffBarangay?.toLowerCase() ||
                                    p.toLowerCase().includes('barangay') ||
                                    p.toLowerCase().includes('brgy')
                                );
                                if (barangayIndex > 0) {
                                    const streetParts = addressParts.slice(0, barangayIndex);
                                    // Filter out sitio if already found
                                    this.staffStreet = streetParts
                                        .filter(p => !p.toLowerCase().includes('sitio') || p.toLowerCase() === this.staffSitio?.toLowerCase())
                                        .join(', ')
                                        .trim();
                                } else if (addressParts.length > 0 && !this.staffBarangay) {
                                    // If no barangay found, first part might be street
                                    this.staffStreet = addressParts[0];
                                }
                            }
                            
                            console.log("Parsed address fields:", {
                                street: this.staffStreet,
                                sitio: this.staffSitio,
                                barangay: this.staffBarangay,
                                city: this.staffCity,
                                province: this.staffProvince,
                                postalCode: this.staffPostalCode
                            });
                        }
                        
                        console.log("Staff individual fields loaded from userData:", {
                            userDataKeys: Object.keys(userData),
                            userDataStreet: userData.street,
                            userDataSitio: userData.sitio,
                            userDataBarangay: userData.barangay,
                            userDataAddress: userData.address,
                            firstName: this.staffFirstName,
                            middleName: this.staffMiddleName,
                            lastName: this.staffLastName,
                            suffix: this.staffSuffix,
                            street: this.staffStreet,
                            sitio: this.staffSitio,
                            barangay: this.staffBarangay,
                            postalCode: this.staffPostalCode,
                            city: this.staffCity,
                            province: this.staffProvince
                        });
                    }

                    // Load profile picture if available (for admin, check Supabase field names)
                    const profilePicture =
                        userData.profilePicture ||
                        userData.profile_picture ||
                        userData.photoURL ||
                        userData.photo_url ||
                        userData.profilePictureUrl ||
                        userData.profile_picture_url;
                    if (profilePicture) {
                        const profileImg = document.getElementById("profileAvatarImg");
                        const profileIcon = document.getElementById("profileAvatarIcon");
                        if (profileImg && profileIcon) {
                            profileImg.src = profilePicture;
                            profileImg.style.display = "block";
                            profileIcon.style.display = "none";
                        }
                    }

                    console.log("Updated values from database:", {
                        staffName,
                        staffEmail,
                        staffPhone,
                        staffRole,
                    });

                    // Update session storage with the latest data
                    sessionStorage.setItem("staffName", staffName);
                    sessionStorage.setItem("userEmail", staffEmail);
                    sessionStorage.setItem("username", staffName);

                    // Update this.userName for sidebar profile display
                    if (isAdmin) {
                        this.userName = staffName;
                    }
                } else {
                    console.log("No user data found in database, using defaults");
                    // For admin, set default values if not found
                    if (isAdmin) {
                        staffName = "Rodel Morales";
                        staffEmail = "admin@agricart.com";
                        staffPhone = "09525818621";
                        staffRole = "System Administrator";
                        this.userName = staffName;
                    }
                }
            } else {
                console.log("Cannot fetch from database - missing UID");
                // For admin, set default values
                if (isAdmin) {
                    staffName = "Rodel Morales";
                    staffEmail = "admin@agricart.com";
                    staffPhone = "09525818621";
                    staffRole = "System Administrator";
                }
            }
        } catch (error) {
            console.error("Error fetching profile data:", error);
            // For admin, set default values on error
            if (isAdmin) {
                staffName = "Rodel Morales";
                staffEmail = "admin@agricart.com";
                staffPhone = "09525818621";
                staffRole = "System Administrator";
            }
        }

        // Update profile header
        console.log("Updating profile elements with:", { staffName, staffEmail });

        const profileStaffNameEl = document.getElementById("profileStaffName");
        const profileStaffEmailEl = document.getElementById("profileStaffEmail");
        const profileFullNameEl = document.getElementById("profileFullName");
        const profileEmailEl = document.getElementById("profileEmail");
        const profilePhoneEl = document.getElementById("profilePhone");
        const profileRoleEl = document.getElementById("profileRole");
        const profileRoleDisplayEl = document.getElementById("profileRoleDisplay");
        const profileMemberSinceEl = document.getElementById("profileMemberSince");
        const profileAddressEl = document.getElementById("profileAddress");
        const profileIdTypeEl = document.getElementById("profileIdType");
        const editProfileBtn = document.getElementById("editProfileBtn");
        const changeProfilePictureBtn = document.getElementById(
            "changeProfilePictureBtn"
        );

        // Hide profile info note for all users (removed per user request)
        const profileInfoNote = document.getElementById("profileInfoNote");
        if (profileInfoNote) {
            profileInfoNote.style.display = "none";
        }
        this.toggleProfileIdSection(!isAdmin);

        // Show/hide admin-specific elements
        if (isAdmin) {
            if (editProfileBtn) {
                editProfileBtn.style.display = "block";
                editProfileBtn.innerHTML = '<i class="fas fa-edit"></i> Edit';
            }
            if (changeProfilePictureBtn)
                changeProfilePictureBtn.style.display = "block";
        } else {
            if (editProfileBtn) {
                editProfileBtn.style.display = "block";
                editProfileBtn.innerHTML =
                    '<i class="fas fa-edit"></i> Update Account';
            }
            if (changeProfilePictureBtn)
                changeProfilePictureBtn.style.display = "none";
        }

        console.log("Profile elements found:", {
            profileStaffNameEl: !!profileStaffNameEl,
            profileStaffEmailEl: !!profileStaffEmailEl,
            profileFullNameEl: !!profileFullNameEl,
            profileEmailEl: !!profileEmailEl,
            profilePhoneEl: !!profilePhoneEl,
            profileRoleEl: !!profileRoleEl,
            profileRoleDisplayEl: !!profileRoleDisplayEl,
            profileMemberSinceEl: !!profileMemberSinceEl,
        });

        if (profileStaffNameEl) {
            profileStaffNameEl.textContent = staffName;
            console.log("Updated profileStaffName to:", staffName);
        }
        if (profileStaffEmailEl) {
            profileStaffEmailEl.textContent = staffEmail;
            console.log("Updated profileStaffEmail to:", staffEmail);
        }
        // Show/hide fields based on user type
        const profileFullNameField = document.getElementById("profileFullNameField");
        const profileIndividualNameFields = document.getElementById("profileIndividualNameFields");
        const profileAddressFields = document.getElementById("profileAddressFields");
        const profileEmployeeIdField = document.getElementById("profileEmployeeIdField");
        const profileRoleField = document.getElementById("profileRoleField");
        const profileUpdateInfoFields = document.getElementById("profileUpdateInfoFields");
        
        if (isAdmin) {
            // Admin: Show only Full Name, Email, Phone
            if (profileFullNameField) profileFullNameField.style.display = "flex";
            if (profileIndividualNameFields) profileIndividualNameFields.style.display = "none";
            if (profileAddressFields) profileAddressFields.style.display = "none";
            if (profileEmployeeIdField) profileEmployeeIdField.style.display = "none";
            if (profileRoleField) profileRoleField.style.display = "none";
            if (profileUpdateInfoFields) profileUpdateInfoFields.style.display = "none";
        } else {
            // Staff: Show individual name fields, address fields, role, employee ID, and update info
            if (profileFullNameField) profileFullNameField.style.display = "none";
            if (profileIndividualNameFields) profileIndividualNameFields.style.display = "grid";
            if (profileAddressFields) profileAddressFields.style.display = "block";
            if (profileEmployeeIdField) profileEmployeeIdField.style.display = "flex";
            if (profileRoleField) profileRoleField.style.display = "flex";
            // Show update info fields only if account has been updated
            if (profileUpdateInfoFields) {
                if (this.staffLastUpdatedAt) {
                    profileUpdateInfoFields.style.display = "block";
                } else {
                    profileUpdateInfoFields.style.display = "none";
                }
            }
            
            // Update individual name fields for staff
            const profileFirstNameEl = document.getElementById("profileFirstName");
            const profileMiddleNameEl = document.getElementById("profileMiddleName");
            const profileLastNameEl = document.getElementById("profileLastName");
            const profileSuffixEl = document.getElementById("profileSuffix");
            
            if (profileFirstNameEl) profileFirstNameEl.textContent = this.staffFirstName || "-";
            if (profileMiddleNameEl) profileMiddleNameEl.textContent = this.staffMiddleName || "-";
            if (profileLastNameEl) profileLastNameEl.textContent = this.staffLastName || "-";
            if (profileSuffixEl) profileSuffixEl.textContent = this.staffSuffix || "-";
            
            // Update employee ID for staff
            const profileEmployeeIdEl = document.getElementById("profileEmployeeId");
            if (profileEmployeeIdEl) {
                profileEmployeeIdEl.textContent = this.staffEmployeeId || "N/A";
                console.log("Updated profileEmployeeId to:", this.staffEmployeeId);
            }
            
            // Update individual address fields for staff
            const profileStreetEl = document.getElementById("profileStreet");
            const profileSitioEl = document.getElementById("profileSitio");
            const profileBarangayEl = document.getElementById("profileBarangay");
            const profilePostalCodeEl = document.getElementById("profilePostalCode");
            const profileCityEl = document.getElementById("profileCity");
            const profileProvinceEl = document.getElementById("profileProvince");
            
            if (profileStreetEl) {
                const streetValue = (this.staffStreet && this.staffStreet.trim()) || "";
                profileStreetEl.textContent = streetValue || "-";
                console.log("Updated profileStreet - raw value:", this.staffStreet, "displayed:", streetValue);
            } else {
                console.warn("profileStreetEl not found!");
            }
            if (profileSitioEl) {
                const sitioValue = (this.staffSitio && this.staffSitio.trim()) || "";
                profileSitioEl.textContent = sitioValue || "-";
                console.log("Updated profileSitio - raw value:", this.staffSitio, "displayed:", sitioValue);
            } else {
                console.warn("profileSitioEl not found!");
            }
            if (profileBarangayEl) {
                const barangayValue = (this.staffBarangay && this.staffBarangay.trim()) || "";
                profileBarangayEl.textContent = barangayValue || "-";
                console.log("Updated profileBarangay - raw value:", this.staffBarangay, "displayed:", barangayValue);
            } else {
                console.warn("profileBarangayEl not found!");
            }
            if (profilePostalCodeEl) profilePostalCodeEl.textContent = this.staffPostalCode || "6541";
            if (profileCityEl) profileCityEl.textContent = this.staffCity || "Ormoc";
            if (profileProvinceEl) profileProvinceEl.textContent = this.staffProvince || "Leyte";
            
            // Update last updated information for staff
            const profileLastUpdatedAtEl = document.getElementById("profileLastUpdatedAt");
            const profileLastUpdatedByEl = document.getElementById("profileLastUpdatedBy");
            
            if (profileLastUpdatedAtEl) {
                if (this.staffLastUpdatedAt) {
                    let updatedDate;
                    if (typeof this.staffLastUpdatedAt === 'number') {
                        updatedDate = new Date(this.staffLastUpdatedAt);
                    } else {
                        updatedDate = new Date(this.staffLastUpdatedAt);
                    }
                    if (!isNaN(updatedDate.getTime())) {
                        profileLastUpdatedAtEl.textContent = updatedDate.toLocaleString();
                    } else {
                        profileLastUpdatedAtEl.textContent = "-";
                    }
                } else {
                    profileLastUpdatedAtEl.textContent = "-";
                }
            }
            
            if (profileLastUpdatedByEl) {
                if (this.staffLastUpdatedByName) {
                    const updatedByDisplay = this.staffLastUpdatedByRole 
                        ? `${this.staffLastUpdatedByName} Â· ${this.staffLastUpdatedByRole}`
                        : this.staffLastUpdatedByName;
                    profileLastUpdatedByEl.textContent = updatedByDisplay;
                } else {
                    profileLastUpdatedByEl.textContent = "-";
                }
            }
        }
        
        // Update full name field (for admin only - staff uses individual fields)
        if (isAdmin && profileFullNameEl) {
            profileFullNameEl.textContent = staffName;
            console.log("Updated profileFullName to:", staffName);
        }
        if (profileEmailEl) {
            profileEmailEl.textContent = staffEmail;
            console.log("Updated profileEmail to:", staffEmail);
        }
        if (profilePhoneEl) {
            profilePhoneEl.textContent = staffPhone || "N/A";
            console.log("Updated profilePhone to:", staffPhone);
        }
        // Role field is now conditionally shown/hidden above
        if (profileRoleEl) {
            // Always show "System Administrator" for admin users
            profileRoleEl.textContent = isAdmin ? "System Administrator" : staffRole;
            console.log("Updated profileRole to:", profileRoleEl.textContent);
        }
        if (profileRoleDisplayEl) {
            // Always show "System Administrator" for admin users
            profileRoleDisplayEl.textContent = isAdmin
                ? "System Administrator"
                : staffRole;
            console.log(
                "Updated profileRoleDisplay to:",
                profileRoleDisplayEl.textContent
            );
        }

        // Hide Complete Address field for admin users
        if (profileAddressEl) {
            const addressField = profileAddressEl.closest(".profile-field");
            if (addressField) {
                addressField.style.display = isAdmin ? "none" : "flex";
                // Always update the displayed address text for staff users
                if (!isAdmin) {
                    profileAddressEl.textContent = staffAddress || "No address on file";
                }
            } else {
                profileAddressEl.textContent = staffAddress || "No address on file";
            }
        }

        // Valid ID Type field has been removed from the UI; keep this block as a no-op

        // Hide Role field for admin users in personal information section
        // Find the Role field specifically in the profile-content container (not the sidebar)
        const profileContentContainer = document.getElementById(
            "profileContentContainer"
        );
        if (profileContentContainer && isAdmin) {
            // Find the Role field by looking for the label "Role:" within profile-content
            const roleLabels = profileContentContainer.querySelectorAll("label");
            roleLabels.forEach((label) => {
                if (label.textContent.trim() === "Role:") {
                    const roleField = label.closest(".profile-field");
                    if (roleField) {
                        roleField.style.display = "none";
                    }
                }
            });
        }

        // Set edit input values
        const profileFullNameEdit = document.getElementById("profileFullNameEdit");
        const profileEmailEdit = document.getElementById("profileEmailEdit");
        const profilePhoneEdit = document.getElementById("profilePhoneEdit");
        const profileRoleEdit = document.getElementById("profileRoleEdit");

        if (profileFullNameEdit) profileFullNameEdit.value = staffName;
        if (profileEmailEdit) profileEmailEdit.value = staffEmail;
        if (profilePhoneEdit) profilePhoneEdit.value = staffPhone || "";
        if (profileRoleEdit) profileRoleEdit.value = staffRole;
        
        // Set individual name and address edit values for staff
        if (!isAdmin) {
            const profileFirstNameEdit = document.getElementById("profileFirstNameEdit");
            const profileMiddleNameEdit = document.getElementById("profileMiddleNameEdit");
            const profileLastNameEdit = document.getElementById("profileLastNameEdit");
            const profileSuffixEdit = document.getElementById("profileSuffixEdit");
            const profileStreetEdit = document.getElementById("profileStreetEdit");
            const profileSitioEdit = document.getElementById("profileSitioEdit");
            const profilePostalCodeEdit = document.getElementById("profilePostalCodeEdit");
            const profileCityEdit = document.getElementById("profileCityEdit");
            const profileProvinceEdit = document.getElementById("profileProvinceEdit");
            
            if (profileFirstNameEdit) profileFirstNameEdit.value = this.staffFirstName || "";
            if (profileMiddleNameEdit) profileMiddleNameEdit.value = this.staffMiddleName || "";
            if (profileLastNameEdit) profileLastNameEdit.value = this.staffLastName || "";
            if (profileSuffixEdit) profileSuffixEdit.value = this.staffSuffix || "";
            if (profileStreetEdit) profileStreetEdit.value = this.staffStreet || "";
            if (profileSitioEdit) profileSitioEdit.value = this.staffSitio || "";
            // Initialize barangay select dropdown
            const profileBarangayEditContainer = document.getElementById("profileBarangayEditContainer");
            if (profileBarangayEditContainer) {
                if (window.staffManager && typeof window.staffManager.renderBarangaySelect === 'function') {
                    const barangaySelectHtml = window.staffManager.renderBarangaySelect('profileBarangayEdit', this.staffBarangay || '', true);
                    profileBarangayEditContainer.innerHTML = barangaySelectHtml;
                    // Set value after creating the select
                    setTimeout(() => {
                        const barangaySelect = document.getElementById("profileBarangayEdit");
                        if (barangaySelect && barangaySelect.tagName === "SELECT") {
                            barangaySelect.value = this.staffBarangay || "";
                        }
                    }, 0);
                } else {
                    profileBarangayEditContainer.innerHTML = `<input type="text" id="profileBarangayEdit" class="profile-edit-input" value="${this.staffBarangay || ''}" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-top: 4px;">`;
                }
            }
            if (profilePostalCodeEdit) profilePostalCodeEdit.value = this.staffPostalCode || "6541";
            if (profileCityEdit) profileCityEdit.value = this.staffCity || "Ormoc";
            if (profileProvinceEdit) profileProvinceEdit.value = this.staffProvince || "Leyte";
        }

        // Set member since date from database
        if (profileMemberSinceEl) {
            let memberSinceDate = "January 2024"; // Default fallback

            // Try to get the creation date from admin/staff data
            try {
                const adminUid =
                    sessionStorage.getItem("adminUid") ||
                    sessionStorage.getItem("userUid");
                const staffUid = sessionStorage.getItem("staffUid");
                const uid = isAdmin ? adminUid : staffUid;

                if (uid) {
                    let userData = null;

                    // For admin, fetch from Supabase ONLY (no Firebase)
                    if (isAdmin) {
                        try {
                            const supabase = window.getSupabaseClient
                                ? window.getSupabaseClient()
                                : window.supabaseClient || null;
                            if (supabase) {
                                const { data: admins, error: queryError } = await supabase
                                    .from("admins")
                                    .select("created_at, created_at_timestamp")
                                    .eq("uuid", uid)
                                    .limit(1);

                                if (!queryError && admins && admins.length > 0) {
                                    userData = admins[0];
                                }
                            }
                        } catch (supabaseError) {
                            console.error(
                                "Error fetching admin date from Supabase:",
                                supabaseError
                            );
                        }
                    } else {
                        // For staff, use Firebase
                        let userSnapshot = null;
                        if (window.dbRefs && window.dbRefs.staff) {
                            userSnapshot = await window.dbRefs.staff.child(uid).once("value");
                        }
                        userData = userSnapshot ? userSnapshot.val() : null;
                    }

                    if (userData) {
                        // Check for various date fields that might exist
                        // For Supabase admins, check created_at (timestamp or ISO string)
                        // For Firebase staff, check createdAt or created_at
                        const createdAt =
                            userData.created_at ||
                            userData.createdAt ||
                            userData.created_at_timestamp ||
                            userData.registrationDate ||
                            userData.memberSince;

                        if (createdAt) {
                            // Handle both timestamp and date string formats
                            let date;
                            if (typeof createdAt === "number") {
                                // Timestamp (Unix timestamp in milliseconds or seconds)
                                date = new Date(
                                    createdAt > 1000000000000 ? createdAt : createdAt * 1000
                                );
                            } else if (typeof createdAt === "string") {
                                // Date string (ISO format or other)
                                date = new Date(createdAt);
                            } else {
                                // Try to parse as timestamp
                                date = new Date(createdAt);
                            }

                            // Format the date nicely
                            if (!isNaN(date.getTime())) {
                                memberSinceDate = date.toLocaleDateString("en-US", {
                                    year: "numeric",
                                    month: "long",
                                });
                            }
                        }
                    }
                }
            } catch (error) {
                console.error("Error getting member since date:", error);
            }

            profileMemberSinceEl.textContent = memberSinceDate;
            console.log("Updated member since date to:", memberSinceDate);
        }

        if (!isAdmin) {
            await this.loadStaffIdPhotos(accountUid);
        } else {
            this.renderStaffIdPhotos([], {
                message: "Valid ID photos are displayed within staff accounts.",
            });
        }

        console.log("=== POPULATE PROFILE SECTION END ===");
    }

    updateProfileInfoNoteVisibility(showNote = false) {
        try {
            const noteEl = document.getElementById("profileInfoNote");
            if (!noteEl) return;
            noteEl.style.display = showNote ? "flex" : "none";
        } catch (error) {
            console.warn("Unable to toggle profile note visibility:", error);
        }
    }

    toggleProfileIdSection(visible = true) {
        const section = document.getElementById("profileIdPhotosSection");
        if (!section) return;
        section.style.display = visible ? "block" : "none";
    }

    getEditableProfileFields() {
        return this.isAdmin()
            ? ["profileFullName", "profileEmail", "profilePhone", "profileRole"]
            : ["profileFirstName", "profileMiddleName", "profileLastName", "profileSuffix", "profileEmail", "profilePhone", "profileStreet", "profileSitio", "profileBarangay", "profilePostalCode", "profileCity", "profileProvince"];
    }

    renderStaffIdPhotos(photos = [], options = {}) {
        const container = document.getElementById("profileIdPhotosContainer");
        const placeholder = document.getElementById("profileIdPhotosPlaceholder");
        const placeholderText = document.getElementById(
            "profileIdPhotosPlaceholderText"
        );
        const placeholderIcon = placeholder ? placeholder.querySelector("i") : null;
        if (!container) return;

        const { message = null, loading = false } = options;

        if (placeholder) {
            if (loading) {
                placeholder.style.display = "flex";
                if (placeholderIcon)
                    placeholderIcon.className = "fas fa-spinner fa-spin";
                if (placeholderText)
                    placeholderText.textContent = "Loading ID photos...";
            } else if (!photos.length) {
                placeholder.style.display = "flex";
                if (placeholderIcon) placeholderIcon.className = "fas fa-id-card";
                if (placeholderText) {
                    placeholderText.textContent =
                        message ||
                        "Valid ID photos will appear here once provided by the System Administrator.";
                }
            } else {
                placeholder.style.display = "none";
            }
        }

        if (!photos.length) {
            container.innerHTML = "";
            return;
        }

        container.innerHTML = "";
        photos.forEach((photo) => {
            const card = document.createElement("div");
            card.className = "profile-id-card";
            const uploadedText = photo.createdAt
                ? `Uploaded ${new Date(photo.createdAt).toLocaleDateString("en-US", {
                    month: "short",
                    day: "numeric",
                    year: "numeric",
                })}`
                : "";
            const imageUrl = photo.url;
            const imageLabel = photo.label || "Valid ID";

            // Create label div
            const labelDiv = document.createElement("div");
            labelDiv.className = "profile-id-label";
            labelDiv.textContent = imageLabel;

            // Create meta div if needed
            let metaDiv = null;
            if (uploadedText) {
                metaDiv = document.createElement("div");
                metaDiv.className = "profile-id-meta";
                metaDiv.textContent = uploadedText;
            }

            // Create image wrapper div to handle clicks
            const imgWrapper = document.createElement("div");
            imgWrapper.style.cssText =
                "position: relative; width: 100%; cursor: pointer; overflow: hidden;";
            imgWrapper.className = "profile-id-image-wrapper";

            // Create image element
            const img = document.createElement("img");
            img.src = imageUrl;
            img.alt = imageLabel;
            img.loading = "lazy";
            img.draggable = false;
            img.style.cssText =
                "width: 100%; max-height: 250px; height: auto; object-fit: contain; display: block; border-radius: 0; pointer-events: none; -webkit-user-select: none; user-select: none; -webkit-user-drag: none;";

            // Prevent context menu on wrapper
            imgWrapper.addEventListener(
                "contextmenu",
                function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                },
                true
            );

            // Hover effects on wrapper
            imgWrapper.addEventListener("mouseenter", function () {
                if (img) {
                    img.style.transform = "scale(1.02)";
                    img.style.boxShadow = "0 4px 12px rgba(0, 0, 0, 0.15)";
                }
            });

            imgWrapper.addEventListener("mouseleave", function () {
                if (img) {
                    img.style.transform = "scale(1)";
                    img.style.boxShadow = "none";
                }
            });

            // Click handler on wrapper - this is the key to prevent new tab opening
            // Use multiple approaches to ensure it works
            const clickHandler = function (e) {
                console.log("Staff ID photo clicked, preventing default...");
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                e.cancelBubble = true;
                if (
                    window.staffManager &&
                    typeof window.staffManager.showEnlargedImage === "function"
                ) {
                    console.log("Opening enlarged image for:", imageLabel);
                    window.staffManager.showEnlargedImage(imageUrl, imageLabel);
                } else {
                    console.error("showEnlargedImage function not available");
                }
                return false;
            };

            // Add click handler with highest priority
            imgWrapper.addEventListener("click", clickHandler, {
                capture: true,
                passive: false,
            });

            // Also add as direct property as backup
            imgWrapper.onclick = clickHandler;

            // Also prevent mousedown on wrapper
            imgWrapper.addEventListener(
                "mousedown",
                function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                },
                true
            );

            // Prevent any default link behavior on wrapper
            imgWrapper.addEventListener(
                "auxclick",
                function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                },
                true
            );

            // Prevent image from being clickable directly
            img.addEventListener(
                "click",
                function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                },
                true
            );

            // Assemble: wrapper contains image
            imgWrapper.appendChild(img);

            // Assemble card
            card.appendChild(labelDiv);
            if (metaDiv) {
                card.appendChild(metaDiv);
            }
            card.appendChild(imgWrapper);

            // Prevent card from being clickable (except wrapper)
            card.addEventListener(
                "click",
                function (e) {
                    if (
                        e.target === card ||
                        e.target === labelDiv ||
                        e.target === metaDiv
                    ) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                },
                true
            );

            // Final safety check - prevent any navigation on the card
            card.addEventListener(
                "click",
                function (e) {
                    // If click somehow reaches the card and it's not the wrapper, prevent it
                    if (e.target !== imgWrapper && !imgWrapper.contains(e.target)) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                },
                { capture: true, passive: false }
            );

            // Also add a click handler directly on the image that ALWAYS prevents default
            img.addEventListener(
                "click",
                function (e) {
                    console.log("Image direct click prevented");
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    // Trigger wrapper click instead
                    imgWrapper.dispatchEvent(
                        new MouseEvent("click", { bubbles: true, cancelable: true })
                    );
                    return false;
                },
                { capture: true, passive: false }
            );

            // Prevent any URL navigation from the image
            img.addEventListener("load", function () {
                // Once image loads, ensure it can't be clicked as a link
                this.style.pointerEvents = "none";
                this.style.cursor = "default";
            });

            container.appendChild(card);
        });

        // Global click interceptor on the container to catch any image clicks
        // This is a safety net in case event handlers somehow don't fire
        container.addEventListener(
            "click",
            function (e) {
                // Check if click is on a profile-id-card image or wrapper
                const clickedCard = e.target.closest(".profile-id-card");
                if (clickedCard) {
                    const imgWrapper = clickedCard.querySelector(
                        ".profile-id-image-wrapper"
                    );
                    const img = clickedCard.querySelector("img");

                    // If click is on image wrapper or image itself, prevent navigation
                    if (
                        e.target === imgWrapper ||
                        e.target === img ||
                        imgWrapper?.contains(e.target)
                    ) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();

                        // Get image URL from the img element
                        if (img && img.src) {
                            const imageUrl = img.src;
                            const imageLabel = img.alt || "Valid ID";

                            // Open in lightbox
                            if (
                                window.staffManager &&
                                typeof window.staffManager.showEnlargedImage === "function"
                            ) {
                                window.staffManager.showEnlargedImage(imageUrl, imageLabel);
                            }
                        }
                    }
                }
            },
            { capture: true, passive: false }
        );
    }

    async loadStaffIdPhotos(staffUid) {
        if (!staffUid) {
            this.renderStaffIdPhotos([], {
                message: "Staff ID not available. Please refresh the page.",
            });
            return;
        }

        this.renderStaffIdPhotos([], { loading: true });

        try {
            const client =
                (typeof initSupabaseClient === "function"
                    ? initSupabaseClient()
                    : null) ||
                window.supabaseClient ||
                null;
            if (!client) {
                throw new Error("Supabase client is not initialized.");
            }

            const { data: files, error } = await client.storage
                .from("staffid_image")
                .list(staffUid, { limit: 20, offset: 0 });

            if (error) {
                throw error;
            }

            const photos = [];
            if (Array.isArray(files)) {
                for (const file of files) {
                    if (!file || !file.name) continue;
                    const { data: urlData, error: urlError } = client.storage
                        .from("staffid_image")
                        .getPublicUrl(`${staffUid}/${file.name}`);

                    if (urlError || !urlData || !urlData.publicUrl) {
                        console.warn(
                            "Unable to get public URL for staff ID photo:",
                            file?.name,
                            urlError
                        );
                        continue;
                    }

                    photos.push({
                        url: urlData.publicUrl,
                        label: this._deriveIdPhotoLabel(file.name),
                        createdAt: file.created_at || file.updated_at || null,
                    });
                }
            }

            if (!photos.length) {
                this.renderStaffIdPhotos([], {
                    message: "No ID photos have been uploaded for your account yet.",
                });
                return;
            }

            this.renderStaffIdPhotos(photos);
        } catch (error) {
            console.error("Error loading staff ID photos:", error);
            this.renderStaffIdPhotos([], {
                message: "Unable to load ID photos right now. Please try again later.",
            });
        }
    }

    _deriveIdPhotoLabel(fileName = "") {
        const lower = (fileName || "").toLowerCase();
        if (lower.includes("front")) return "ID Front";
        if (lower.includes("back")) return "ID Back";
        if (lower.includes("selfie")) return "ID Selfie";
        return "Valid ID";
    }

    toggleEditProfileMode() {
        const saveBtn = document.getElementById("saveProfileBtn");
        const editBtn = document.getElementById("editProfileBtn");
        const cancelBtn = document.getElementById("cancelEditBtn");
        const isEditMode = saveBtn && saveBtn.style.display !== "none";
        const editableFields = this.getEditableProfileFields();

        if (!isEditMode) {
            if (editBtn) editBtn.style.display = "none";
            if (saveBtn) saveBtn.style.display = "inline-flex";
            if (cancelBtn) cancelBtn.style.display = "inline-flex";

            // Ensure email input is populated with current value before showing it
            const profileEmailDisplay = document.getElementById("profileEmail");
            const profileEmailEdit = document.getElementById("profileEmailEdit");
            if (profileEmailDisplay && profileEmailEdit) {
                const currentEmail = profileEmailDisplay.textContent.trim();
                if (currentEmail && !profileEmailEdit.value.trim()) {
                    profileEmailEdit.value = currentEmail;
                }
            }

            editableFields.forEach((field) => {
                const spanEl = document.getElementById(field);
                let inputEl = document.getElementById(field + "Edit");
                
                // Special handling for barangay field
                if (field === "profileBarangay") {
                    const container = document.getElementById("profileBarangayEditContainer");
                    if (spanEl && container) {
                        spanEl.style.display = "none";
                        container.style.display = "block";
                        // Get the select from container if it exists
                        inputEl = container.querySelector("select") || container.querySelector("input");
                    }
                } else {
                    if (!spanEl || !inputEl) return;
                    spanEl.style.display = "none";
                    // Ensure input field has current value from display span
                    if (inputEl.tagName !== "SELECT" && spanEl.textContent) {
                        const currentValue = spanEl.textContent.trim();
                        if (currentValue && currentValue !== "-" && !inputEl.value.trim()) {
                            inputEl.value = currentValue;
                        }
                    }
                }
                
                if (inputEl) {
                    if (inputEl.tagName === "SELECT") {
                        inputEl.style.display = "block";
                        inputEl.style.width = "100%";
                        inputEl.style.padding = "8px";
                        inputEl.style.border = "1px solid #ddd";
                        inputEl.style.borderRadius = "4px";
                        inputEl.style.marginTop = "4px";
                    } else {
                        inputEl.style.display = "block";
                        inputEl.style.width = "100%";
                        inputEl.style.padding = "8px";
                        inputEl.style.border = "1px solid #ddd";
                        inputEl.style.borderRadius = "4px";
                        inputEl.style.marginTop = "4px";
                    }
                }
            });
        } else {
            this.cancelEditProfile();
        }
    }

    cancelEditProfile() {
        const editBtn = document.getElementById("editProfileBtn");
        const saveBtn = document.getElementById("saveProfileBtn");
        const cancelBtn = document.getElementById("cancelEditBtn");
        if (editBtn) editBtn.style.display = "inline-flex";
        if (saveBtn) saveBtn.style.display = "none";
        if (cancelBtn) cancelBtn.style.display = "none";

        const fields = [
            "profileFullName",
            "profileFirstName",
            "profileMiddleName",
            "profileLastName",
            "profileSuffix",
            "profileEmail",
            "profilePhone",
            "profileRole",
            "profileStreet",
            "profileSitio",
            "profileBarangay",
            "profilePostalCode",
            "profileCity",
            "profileProvince",
        ];
        fields.forEach((field) => {
            const spanEl = document.getElementById(field);
            const inputEl = document.getElementById(field + "Edit");
            if (spanEl) spanEl.style.display = "inline";
            if (inputEl) {
                if (inputEl.tagName === "SELECT") {
                    inputEl.style.display = "none";
                } else {
                    inputEl.style.display = "none";
                }
            }
        });
        
        // Hide barangay edit container
        const profileBarangayEditContainer = document.getElementById("profileBarangayEditContainer");
        if (profileBarangayEditContainer) {
            profileBarangayEditContainer.style.display = "none";
        }

        this.populateProfileSection();
    }

    async saveProfileChanges() {
        if (this.isAdmin()) {
            await this.saveAdminProfile();
        } else {
            await this.saveStaffContactInfo();
        }
    }

    async saveStaffContactInfo() {
        try {
            // Get all input fields
            const firstNameInput = document.getElementById("profileFirstNameEdit");
            const middleNameInput = document.getElementById("profileMiddleNameEdit");
            const lastNameInput = document.getElementById("profileLastNameEdit");
            const suffixInput = document.getElementById("profileSuffixEdit");
            const emailInput = document.getElementById("profileEmailEdit");
            const phoneInput = document.getElementById("profilePhoneEdit");
            const streetInput = document.getElementById("profileStreetEdit");
            const sitioInput = document.getElementById("profileSitioEdit");
            const barangayInput = document.getElementById("profileBarangayEdit");
            const postalCodeInput = document.getElementById("profilePostalCodeEdit");
            const cityInput = document.getElementById("profileCityEdit");
            const provinceInput = document.getElementById("profileProvinceEdit");

            if (!emailInput || !phoneInput || !firstNameInput || !lastNameInput) {
                alert("Unable to find required fields. Please refresh the page.");
                return;
            }

            // Get values
            const firstName = firstNameInput.value.trim();
            const middleName = middleNameInput ? middleNameInput.value.trim() : "";
            const lastName = lastNameInput.value.trim();
            const suffix = suffixInput ? suffixInput.value.trim() : "";
            let newEmail = emailInput ? emailInput.value.trim() : "";
            const newPhone = phoneInput.value.trim();
            const street = streetInput ? streetInput.value.trim() : "";
            const sitio = sitioInput ? sitioInput.value.trim() : "";
            const barangay = barangayInput ? (barangayInput.tagName === "SELECT" ? barangayInput.value : barangayInput.value.trim()) : "";
            const postalCode = postalCodeInput ? postalCodeInput.value.trim() : "6541";
            const city = cityInput ? cityInput.value.trim() : "Ormoc";
            const province = provinceInput ? provinceInput.value.trim() : "Leyte";

            // Validation
            if (!firstName || !lastName) {
                alert("Please provide both First Name and Last Name.");
                return;
            }

            // If email input is empty or not found, try to get from the display span as fallback
            if (!newEmail) {
                const profileEmailDisplay = document.getElementById("profileEmail");
                if (profileEmailDisplay) {
                    newEmail = profileEmailDisplay.textContent.trim();
                }
            }

            if (!newEmail || !newPhone) {
                alert("Please provide both your email address and phone number.");
                return;
            }

            // Normalize email to lowercase for validation
            const normalizedEmail = newEmail.toLowerCase().trim();
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(normalizedEmail)) {
                alert("Please enter a valid email address (example@domain.com).");
                console.error("Email validation failed. Email value:", newEmail, "Normalized:", normalizedEmail);
                return;
            }
            
            // Use normalized email for saving
            newEmail = normalizedEmail;

            const phoneDigits = newPhone.replace(/[^\d]/g, "");
            if (phoneDigits.length < 10 || phoneDigits.length > 11) {
                alert("Please enter a valid phone number (10-11 digits).");
                return;
            }
            const normalizedPhone = phoneDigits;

            if (!barangay) {
                alert("Please select a Barangay.");
                return;
            }

            const staffUid = sessionStorage.getItem("staffUid");
            if (!staffUid) {
                alert("Staff UID not found. Please log in again.");
                return;
            }

            // Fetch staff data from Supabase
            const supabase = window.getSupabaseClient
                ? window.getSupabaseClient()
                : window.supabaseClient || null;
            if (!supabase) {
                alert("Supabase client not available. Please refresh the page.");
                return;
            }

            const { data: staffList, error: fetchError } = await supabase
                .from("staff")
                .select("*")
                .eq("uuid", staffUid)
                .limit(1);

            if (fetchError || !staffList || staffList.length === 0) {
                alert("Staff account not found. Please contact the administrator.");
                return;
            }

            const staffData = staffList[0];

            const password = await this.promptStaffPassword();
            if (!password) {
                console.log("Staff password confirmation cancelled.");
                return;
            }

            // Verify password using Supabase Auth (same as login)
            // This ensures we verify against the hashed password in Auth, not plain text in staff table
            const staffEmail = staffData.email || sessionStorage.getItem("staffEmail") || sessionStorage.getItem("userEmail");
            if (!staffEmail) {
                alert("Unable to verify password. Email not found.");
                return;
            }

            try {
                const lowerEmail = staffEmail.toLowerCase();
                const signInResult = await supabase.auth.signInWithPassword({
                    email: lowerEmail,
                    password: password,
                });

                if (signInResult.error) {
                    console.error("Password verification error:", signInResult.error);
                    alert("Incorrect password. Please try again.");
                    return;
                }

                if (signInResult.data && signInResult.data.user) {
                    // Password is correct - verified via Supabase Auth
                    // Sign out immediately since we just needed to verify
                    await supabase.auth.signOut();
                } else {
                    alert("Incorrect password. Please try again.");
                    return;
                }
            } catch (authError) {
                console.error("Error verifying staff password via Supabase Auth:", authError);
                alert("Error verifying password. Please try again.");
                return;
            }

            // Construct full name
            let fullName = `${firstName} ${lastName}`;
            if (middleName) {
                fullName = `${firstName} ${middleName} ${lastName}`;
            }
            if (suffix) {
                fullName = `${fullName} ${suffix}`;
            }
            fullName = fullName.trim();

            // Construct full address
            const addressParts = [];
            if (street) addressParts.push(street);
            if (sitio) addressParts.push(`Sitio ${sitio}`);
            if (barangay) addressParts.push(barangay);
            if (postalCode) addressParts.push(postalCode);
            if (city) addressParts.push(city);
            if (province) addressParts.push(province);
            const fullAddress = addressParts.join(", ");

            // Get staff name and role for tracking who updated
            const updaterName = sessionStorage.getItem('staffName') || 
                                sessionStorage.getItem('username') || 
                                'Staff';
            const updaterRole = 'Staff';

            // Update staff data in Supabase
            // Note: Name is saved in a single 'full_name' column, and address is saved in a single 'address' column
            // Individual name and address fields (first_name, middle_name, street, barangay, etc.) do not exist in the schema
            const updateData = {
                full_name: fullName,
                email: newEmail.toLowerCase(),
                phone: normalizedPhone,
                address: fullAddress,
                updated_at: Date.now(),
                last_updated_by_name: updaterName,
                last_updated_by_role: updaterRole
            };

            const { error: updateError } = await supabase
                .from("staff")
                .update(updateData)
                .eq("uuid", staffUid);

            if (updateError) {
                throw new Error(
                    "Failed to update profile information: " + updateError.message
                );
            }

            // Update session storage
            sessionStorage.setItem("userEmail", newEmail.toLowerCase());
            sessionStorage.setItem("staffEmail", newEmail.toLowerCase());
            sessionStorage.setItem("staffName", fullName);
            sessionStorage.setItem("username", fullName);

            this.showSuccessMessage("Profile information updated successfully");
            this.cancelEditProfile();
            
            // Refresh the profile section to show updated data
            await this.populateProfileSection();
        } catch (error) {
            console.error("Error updating staff profile info:", error);
            alert(
                "Failed to update profile information: " + (error?.message || error)
            );
        }
    }

    promptStaffPassword() {
        return new Promise((resolve) => {
            let resolved = false;
            const finish = (value) => {
                if (resolved) return;
                resolved = true;
                resolve(value);
            };

            const modalContent = `
                <div class="modal-header">
                    <h3>Verify Your Password</h3>
                    <button class="close-modal">&times;</button>
                </div>
                <div style="padding: 20px;">
                    <p style="margin-bottom: 16px; color: #555;">
                        For security reasons, please enter your password before saving changes to your email or phone number.
                    </p>
                    <div class="form-field">
                        <label for="staffPasswordConfirmInput" class="required">Password</label>
                        <input type="password" id="staffPasswordConfirmInput" placeholder="Enter your password" required>
                    </div>
                    <div class="modal-actions" style="margin-top: 20px;">
                        <button type="button" class="secondary-btn" id="cancelStaffPasswordBtn">Cancel</button>
                        <button type="button" class="primary-btn" id="confirmStaffPasswordBtn">
                            <i class="fas fa-check"></i> Confirm
                        </button>
                    </div>
                </div>
            `;

            this.showModal(modalContent);

            const confirmBtn = document.getElementById("confirmStaffPasswordBtn");
            const cancelBtn = document.getElementById("cancelStaffPasswordBtn");
            const passwordInput = document.getElementById(
                "staffPasswordConfirmInput"
            );
            const overlay = document.getElementById("modalOverlay");
            const closeBtn = document.querySelector("#modalContent .close-modal");

            const handleCancel = () => {
                this.closeModal();
                finish(null);
            };

            if (confirmBtn) {
                confirmBtn.addEventListener("click", () => {
                    const password = passwordInput ? passwordInput.value.trim() : "";
                    if (!password) {
                        alert("Please enter your password.");
                        return;
                    }
                    this.closeModal();
                    finish(password);
                });
            }

            if (cancelBtn) {
                cancelBtn.addEventListener("click", handleCancel);
            }

            if (closeBtn) {
                closeBtn.addEventListener("click", () => finish(null), { once: true });
            }

            if (overlay) {
                overlay.addEventListener(
                    "click",
                    (e) => {
                        if (e.target === overlay) {
                            finish(null);
                        }
                    },
                    { once: true }
                );
            }
        });
    }

    async saveAdminProfile() {
        if (!this.isAdmin()) {
            alert("Only admins can edit their profile");
            return;
        }

        try {
            const fullName = document
                .getElementById("profileFullNameEdit")
                .value.trim();
            const email = document.getElementById("profileEmailEdit").value.trim();
            const phone = document.getElementById("profilePhoneEdit").value.trim();

            // Validation - role is not editable, always "System Administrator" for admins
            if (!fullName || !email) {
                alert("Please fill in all required fields (Full Name, Email)");
                return;
            }

            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(email)) {
                alert("Please enter a valid email address");
                return;
            }

            const adminUid =
                sessionStorage.getItem("adminUid") || sessionStorage.getItem("userUid");
            if (!adminUid) {
                alert("Admin UID not found. Please log in again.");
                return;
            }

            // Update admin data in Supabase ONLY (no Firebase)
            const supabase = window.getSupabaseClient
                ? window.getSupabaseClient()
                : window.supabaseClient || null;
            if (!supabase) {
                throw new Error(
                    "Supabase client not initialized. Please refresh the page."
                );
            }

            // Get current admin data to preserve other fields
            const { data: currentAdmin, error: fetchError } = await supabase
                .from("admins")
                .select("*")
                .eq("uuid", adminUid)
                .single();

            if (fetchError) {
                console.error("Error fetching current admin data:", fetchError);
                // Continue anyway - might be creating new record
            }

            // Prepare update data for Supabase
            const now = new Date().toISOString();
            const updateData = {
                fullname: fullName, // Use fullname column name for Supabase
                username: fullName, // Also update username as fallback
                email: email.toLowerCase(),
                phone: phone || null, // Include phone - column should exist (run add_admins_phone_column.sql if needed)
                updated_at: now,
            };

            // Update in Supabase
            const { error: updateError } = await supabase
                .from("admins")
                .update(updateData)
                .eq("uuid", adminUid);

            if (updateError) {
                throw new Error(
                    "Failed to update admin profile: " + updateError.message
                );
            }

            // Update session storage
            sessionStorage.setItem("adminName", fullName);
            sessionStorage.setItem("staffName", fullName);
            sessionStorage.setItem("userEmail", email.toLowerCase());
            sessionStorage.setItem("adminEmail", email.toLowerCase());
            sessionStorage.setItem("username", fullName);

            // Update this.userName for sidebar
            this.userName = fullName;

            // Exit edit mode and reload profile
            this.cancelEditProfile();
            await this.populateProfileSection();

            // Update sidebar after profile is reloaded
            this.updateUIForRole();

            this.showSuccessMessage("Profile updated successfully");
        } catch (error) {
            console.error("Error saving admin profile:", error);
            alert("Error saving profile: " + error.message);
        }
    }

    showChangeProfilePictureModal() {
        if (!this.isAdmin()) {
            alert("Only admins can change their profile picture");
            return;
        }

        const modalContent = `
            <div class="modal-header">
                <h3>Change Profile Picture</h3>
                <button class="close-modal" onclick="staffManager.closeModal()">&times;</button>
            </div>
            <div style="padding: 20px;">
                <div class="form-field">
                    <label for="profilePictureUpload" class="required">Profile Picture</label>
                    <input type="file" id="profilePictureUpload" accept="image/*" style="display: none;" onchange="staffManager.handleProfilePictureChange(event)">
                    <div class="photo-upload-area" onclick="document.getElementById('profilePictureUpload').click()" style="border: 2px dashed #ddd; border-radius: 8px; padding: 40px; text-align: center; cursor: pointer; background: #f9f9f9;">
                        <i class="fas fa-camera" style="font-size: 2em; color: #666; margin-bottom: 10px;"></i>
                        <p style="color: #666; margin: 10px 0;">Click to upload profile picture</p>
                        <small style="color: #999;">JPG, PNG up to 5MB</small>
                    </div>
                    <div id="profilePicturePreview" class="image-preview" style="margin-top: 15px; display: none;">
                        <img id="profilePicturePreviewImg" src="" alt="Profile Preview" style="max-width: 200px; border-radius: 8px; border: 2px solid #4CAF50;">
                    </div>
                </div>
                <div class="modal-actions" style="margin-top: 20px;">
                    <button type="button" class="secondary-btn" onclick="staffManager.closeModal()">Cancel</button>
                    <button type="button" class="primary-btn" onclick="staffManager.saveProfilePicture()">
                        <i class="fas fa-save"></i> Save Profile Picture
                    </button>
                </div>
            </div>
        `;

        this.showModal(modalContent);
        this.currentProfilePictureFile = null;
    }

    handleProfilePictureChange(event) {
        const file = event.target.files[0];
        if (!file) return;

        // Validate file type
        if (!file.type.startsWith("image/")) {
            alert("Please select a valid image file");
            return;
        }

        // Validate file size (5MB limit)
        if (file.size > 5 * 1024 * 1024) {
            alert("File size must be less than 5MB");
            return;
        }

        // Show preview
        const reader = new FileReader();
        reader.onload = (e) => {
            const preview = document.getElementById("profilePicturePreview");
            const previewImg = document.getElementById("profilePicturePreviewImg");
            if (preview && previewImg) {
                previewImg.src = e.target.result;
                preview.style.display = "block";
            }
        };
        reader.readAsDataURL(file);
        this.currentProfilePictureFile = file;
    }

    async saveProfilePicture() {
        if (!this.isAdmin()) {
            alert("Only admins can change their profile picture");
            return;
        }

        if (!this.currentProfilePictureFile) {
            alert("Please select a profile picture to upload");
            return;
        }

        try {
            const adminUid =
                sessionStorage.getItem("adminUid") || sessionStorage.getItem("userUid");
            if (!adminUid) {
                alert("Admin UID not found. Please log in again.");
                return;
            }

            // Upload to Supabase Storage (or convert to base64 for small images)
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const profilePictureUrl = e.target.result;

                    // Update admin profile picture in Supabase only (no Firebase)
                    const supabase = window.getSupabaseClient
                        ? window.getSupabaseClient()
                        : window.supabaseClient || null;
                    if (!supabase) {
                        throw new Error(
                            "Supabase client not initialized. Please refresh the page."
                        );
                    }

                    // Determine which column name to use for profile picture in Supabase
                    // Try common column names: profile_picture, profile_picture_url, photo_url
                    const now = new Date().toISOString();
                    const updateData = {
                        profile_picture: profilePictureUrl, // Primary column name
                        profile_picture_url: profilePictureUrl, // Alternative column name
                        photo_url: profilePictureUrl, // Another alternative
                        updated_at: now,
                    };

                    const { error: updateError } = await supabase
                        .from("admins")
                        .update(updateData)
                        .eq("uuid", adminUid);

                    if (updateError) {
                        throw new Error(
                            "Failed to update profile picture: " + updateError.message
                        );
                    }

                    // Update profile display
                    const profileImg = document.getElementById("profileAvatarImg");
                    const profileIcon = document.getElementById("profileAvatarIcon");
                    if (profileImg && profileIcon) {
                        profileImg.src = profilePictureUrl;
                        profileImg.style.display = "block";
                        profileIcon.style.display = "none";
                    }

                    this.closeModal();
                    this.showSuccessMessage("Profile picture updated successfully");

                    // Reload profile section to show updated picture
                    await this.populateProfileSection();
                } catch (error) {
                    console.error("Error saving profile picture:", error);
                    alert("Error saving profile picture: " + error.message);
                }
            };
            reader.readAsDataURL(this.currentProfilePictureFile);
        } catch (error) {
            console.error("Error processing profile picture:", error);
            alert("Error processing profile picture: " + error.message);
        }
    }


    populateSettingsSection() {
        // Load current settings from localStorage or sessionStorage
        const currentTheme = localStorage.getItem("theme") || "light";
        const currentLanguage = localStorage.getItem("language") || "en";

        // Set current values in selects
        const themeSelect = document.querySelector(".setting-select");
        const languageSelect = document.querySelectorAll(".setting-select")[1];

        if (themeSelect) {
            themeSelect.value = currentTheme;
            themeSelect.addEventListener("change", (e) => {
                localStorage.setItem("theme", e.target.value);
                this.applyTheme(e.target.value);
            });
        }

        if (languageSelect) {
            languageSelect.value = currentLanguage;
            languageSelect.addEventListener("change", (e) => {
                localStorage.setItem("language", e.target.value);
                // You can implement language switching here
            });
        }
    }

    applyTheme(theme) {
        // Apply theme changes
        document.body.className = theme;
        console.log("Theme changed to:", theme);
    }

    logout() {
        // Clear session storage
        sessionStorage.clear();

        // Redirect to login page (no Firebase Auth sign out needed with Supabase)
        window.location.href = "index.html";
    }

    shouldRefreshCustomersList(customers) {
        try {
            console.log(
                "shouldRefreshCustomersList called with customers:",
                customers
            );

            // Store previous customer data for comparison
            if (!this.previousCustomerData) {
                console.log("First load, always refresh");
                this.previousCustomerData = {};
                return true; // First load, always refresh
            }

            if (!customers || typeof customers !== "object") {
                console.log("Invalid customers data, refreshing");
                this.previousCustomerData = {};
                return true;
            }

            const currentCustomerIds = Object.keys(customers);
            const previousCustomerIds = Object.keys(this.previousCustomerData);

            console.log("Current customer IDs:", currentCustomerIds.length);
            console.log("Previous customer IDs:", previousCustomerIds.length);

            // Check if customer count changed (new customer added or removed)
            if (currentCustomerIds.length !== previousCustomerIds.length) {
                console.log("Customer count changed, refresh needed");
                this.previousCustomerData = JSON.parse(JSON.stringify(customers));
                return true;
            }

            // Check for meaningful changes in each customer
            for (const customerId of currentCustomerIds) {
                const currentCustomer = customers[customerId];
                const previousCustomer = this.previousCustomerData[customerId];

                if (!currentCustomer || typeof currentCustomer !== "object") {
                    console.log("Invalid customer data for ID:", customerId);
                    continue;
                }

                if (!previousCustomer) {
                    console.log("New customer detected, refresh needed");
                    this.previousCustomerData = JSON.parse(JSON.stringify(customers));
                    return true;
                }

                // Check for meaningful field changes (ignore lastLogin)
                const meaningfulFields = [
                    "verificationStatus",
                    "accountStatus",
                    "fullName",
                    "email",
                    "phoneNumber",
                    "address",
                    "validIdType",
                    "createdAt",
                    "approvedAt",
                ];

                for (const field of meaningfulFields) {
                    if (currentCustomer[field] !== previousCustomer[field]) {
                        console.log(
                            `Meaningful change detected in ${field} for customer ${customerId}, refresh needed`
                        );
                        this.previousCustomerData = JSON.parse(JSON.stringify(customers));
                        return true;
                    }
                }
            }

            // No meaningful changes detected
            console.log("No meaningful changes detected, skipping refresh");
            return false;
        } catch (error) {
            console.error("Error in shouldRefreshCustomersList:", error);
            // If there's an error in the comparison logic, always refresh to be safe
            this.previousCustomerData = {};
            return true;
        }
    }

    switchSection(sectionId) {
        console.log("Switching to section:", sectionId);

        // Update sidebar
        document.querySelectorAll(".menu-item").forEach((item) => {
            item.classList.remove("active");
        });
        const menuItem = document.querySelector(
            `.menu-item[data-section="${sectionId}"]`
        );
        if (menuItem) {
            menuItem.classList.add("active");
            console.log("Updated menu item to active");
        } else {
            console.error("Menu item not found for section:", sectionId);
        }

        // Update content
        document.querySelectorAll(".content-section").forEach((section) => {
            section.classList.remove("active");
        });
        const contentSection = document.getElementById(sectionId);
        if (contentSection) {
            contentSection.classList.add("active");
            console.log("Updated content section to active");
        } else {
            console.error("Content section not found for ID:", sectionId);
        }

        this.currentSection = sectionId;
        console.log("Updated current section to:", this.currentSection);

        // Note: Auto-refresh is now handled by real-time listeners
        // No need to start interval-based refresh

        // Clear all search bars when switching sections
        this.clearAllSearchBars();

        // Load section-specific data
        this.loadSectionData(sectionId);

        // Load pickup area records when entering Delivery Settings
        if (sectionId === "delivery-settings") {
            setTimeout(() => {
                // Load pickup areas using the pickupArea system (like backup)
                this.loadPickupAreaRecords();
                // Also try loadPickupArea as fallback
                this.loadPickupArea();
                // Additional safeguard: restore active pickup area state
                if (typeof this.restoreActivePickupAreaState === "function") {
                    this.restoreActivePickupAreaState();
                }
            }, 100);
        }

        // Reset user management tabs to default when switching to user-management
        if (sectionId === "user-management") {
            this.resetUserManagementTabs();
        }

        // Ensure farmer search clear-X is wired when entering User Management
        if (sectionId === "user-management") {
            setTimeout(() => this.initFarmerSearch(), 0);
        }
    }

    resetUserManagementTabs() {
        // Reset to farmer management as default
        this.switchUserManagementTab("farmer-users");
    }

    switchUserManagementTab(tabId) {
        console.log("switchUserManagementTab called with:", tabId);

        // Loading message removed for user-management module

        // Update tab buttons
        const tabButtons = document.querySelectorAll(
            ".user-management-tabs .tab-btn"
        );
        console.log("Found user management tab buttons:", tabButtons.length);
        tabButtons.forEach((btn) => {
            btn.classList.remove("active");
        });
        const activeTab = document.querySelector(
            `.user-management-tabs .tab-btn[data-tab="${tabId}"]`
        );
        if (activeTab) {
            activeTab.classList.add("active");
            console.log("Updated user management tab button to active");
        } else {
            console.error("User management tab button not found for:", tabId);
        }

        // Update tab content
        const tabContents = document.querySelectorAll(
            ".user-management-content .tab-content"
        );
        console.log("Found user management tab contents:", tabContents.length);
        tabContents.forEach((content) => {
            content.classList.remove("active");
            // Clear inline style to let CSS handle it
            content.style.display = "";
        });
        const activeContent = document.getElementById(`${tabId}-tab`);
        if (activeContent) {
            activeContent.classList.add("active");
            // Force display to ensure visibility
            activeContent.style.display = "block";
            console.log("Updated user management tab content to active");
        } else {
            console.error(
                "User management tab content not found for:",
                `${tabId}-tab`
            );
        }

        this.currentTab = tabId;
        console.log("Updated current tab to:", this.currentTab);

        // Reset customer management sub-tab states when switching to customer-users
        if (tabId === "customer-users") {
            // Reset all customer management sub-tab buttons
            const subTabButtons = document.querySelectorAll(
                ".customer-management-tabs .sub-tab-btn"
            );
            subTabButtons.forEach((btn) => {
                btn.classList.remove("active");
            });

            // Set pending-verifications as the default active sub-tab
            const pendingTab = document.querySelector(
                '.customer-management-tabs .sub-tab-btn[data-tab="pending-verifications"]'
            );
            if (pendingTab) {
                pendingTab.classList.add("active");
            }

            // Reset all customer management sub-tab content
            const subTabContents = document.querySelectorAll(
                ".customer-management-content .sub-tab-content"
            );
            subTabContents.forEach((content) => {
                content.classList.remove("active");
            });

            // Set pending-verifications content as active
            const pendingContent = document.getElementById(
                "pending-verifications-tab"
            );
            if (pendingContent) {
                pendingContent.classList.add("active");
            }

            // Update current customer management tab tracking
            this.currentCustomerManagementTab = "pending-verifications";
        }

        // Clear search bars when switching user management tabs
        this.clearUserManagementSearchBars();

        // Load tab-specific data (loading message removed for user-management)
        this.loadUserManagementData(tabId);

        // Rebind clear-X toggle for farmer search when switching to farmer-users
        if (tabId === "farmer-users") {
            setTimeout(() => this.initFarmerSearch(), 0);
        }
    }

    switchCustomerManagementTab(tabId) {
        console.log("switchCustomerManagementTab called with:", tabId);

        // Ensure the parent customer-users tab is visible first
        const parentTab = document.getElementById("customer-users-tab");
        if (parentTab) {
            parentTab.classList.add("active");
            parentTab.style.display = "block";
            console.log("Ensured parent customer-users-tab is visible");
        }

        // Clear customer management search bars when switching tabs
        this.clearCustomerManagementSearchBars();

        // Update current tab tracking
        this.currentCustomerManagementTab = tabId;

        // Update tab buttons
        const tabButtons = document.querySelectorAll(
            ".customer-management-tabs .sub-tab-btn"
        );
        console.log("Found customer management tab buttons:", tabButtons.length);
        tabButtons.forEach((btn) => {
            btn.classList.remove("active");
        });
        const activeTab = document.querySelector(
            `.customer-management-tabs .sub-tab-btn[data-tab="${tabId}"]`
        );
        if (activeTab) {
            activeTab.classList.add("active");
            console.log("Updated tab button to active");
        } else {
            console.error("Tab button not found for:", tabId);
        }

        // Update tab content
        const tabContents = document.querySelectorAll(
            ".customer-management-content .sub-tab-content"
        );
        console.log("Found customer management tab contents:", tabContents.length);
        tabContents.forEach((content) => {
            content.classList.remove("active");
            // Clear inline style to let CSS rules handle display
            content.style.display = "";
        });
        const activeContent = document.getElementById(`${tabId}-tab`);
        if (activeContent) {
            activeContent.classList.add("active");
            // Force display to be visible using inline style as fallback
            activeContent.style.display = "block";
            console.log("Updated tab content to active");
            console.log("Active content element:", activeContent);
            console.log(
                "Active content computed style display:",
                window.getComputedStyle(activeContent).display
            );
        } else {
            console.error("Tab content not found for:", `${tabId}-tab`);
            console.log("Available tab contents:");
            document.querySelectorAll(".sub-tab-content").forEach((content) => {
                console.log("- Tab content ID:", content.id);
            });
        }

        // Load tab-specific data
        if (tabId === "pending-verifications") {
            console.log(
                "ðŸ”„ Switching to pending verifications tab - loading data..."
            );
            this.loadCustomerManagementVerificationData();
            // Reinitialize search for pending verifications
            setTimeout(() => {
                console.log("ðŸ” Reinitializing search after tab switch...");
                const input = document.getElementById("pendingCustomerSearchInput");
                if (input && input.value) {
                    console.log("ðŸ” Found existing search value, applying:", input.value);
                    this.searchPendingVerifications(input.value);
                } else {
                    console.log(
                        "ðŸ” No existing search value, clearing any search results"
                    );
                    this.searchPendingVerifications("");
                }
            }, 100);
        } else if (tabId === "approved-customers") {
            console.log("ðŸ”„ Switching to approved customers tab - loading data...");
            this.loadCustomersManagementData();

            // Event handlers are managed by initCustomerSearch() - no need to duplicate here
        }

        // Rebind clear-X toggle for customer searches when switching sub-tabs
        setTimeout(() => this.initCustomerSearch(), 0);
    }

    switchOrderManagementTab(tabId) {
        // Track current section and tab for other features (e.g., cutoff watcher)
        this.currentSection = "order-management";
        this.currentOrderManagementTab = tabId;
        // Update tab buttons
        document
            .querySelectorAll(".order-management-tabs .tab-btn")
            .forEach((btn) => {
                btn.classList.remove("active");
            });
        document
            .querySelector(`.order-management-tabs .tab-btn[data-tab="${tabId}"]`)
            .classList.add("active");

        // Update tab content
        document
            .querySelectorAll(".order-management-content .tab-content")
            .forEach((content) => {
                content.classList.remove("active");
            });
        document.getElementById(`${tabId}-tab`).classList.add("active");

        // Load tab-specific data
        if (tabId === "pending-orders") {
            this.loadPendingOrders();
            this.attachPendingOrdersListener();
        } else if (tabId === "rejected-orders") {
            this.loadRejectedProducts();
        } else if (tabId === "cancelled-orders") {
            this.loadCancelledOrders();
        }
    }
    async loadCancelledOrders() {
        try {
            // Load from Supabase instead of Firebase
            if (!window.OrderSupabaseAdapter) {
                console.error(
                    "OrderSupabaseAdapter not available; cannot load cancelled orders"
                );
                const container = document.getElementById("cancelledProductsContainer");
                if (container) {
                    container.innerHTML =
                        '<p class="no-data">Supabase orders adapter not available. Please refresh the page.</p>';
                }
                return;
            }

            const orders = await OrderSupabaseAdapter.fetchOrders();
            if (orders === null) {
                console.error("Failed to load orders from Supabase");
                const container = document.getElementById("cancelledProductsContainer");
                if (container) {
                    container.innerHTML =
                        '<p class="no-data">Unable to load cancelled orders from Supabase.</p>';
                }
                return;
            }

            const container = document.getElementById("cancelledProductsContainer");
            const countElement = document.getElementById("cancelledCount");
            const statsContainer = countElement
                ? countElement.closest(".rejected-stats")
                : null;
            if (!container) {
                console.warn("Cancelled container not found");
                return;
            }

            // Center the stats container
            if (statsContainer) {
                statsContainer.style.cssText =
                    "display:flex; justify-content:center; align-items:center; width:100%;";
            }
            const statItem = countElement ? countElement.closest(".stat-item") : null;
            if (statItem) {
                statItem.style.cssText =
                    "display:flex; justify-content:center; align-items:center; width:100%;";
            }

            // Normalize list - Include ALL cancelled orders (both GCash and Cash)
            // Include:
            //  - Cancelled with confirmed refund (GCash)
            //  - Cancelled with confirmed no-refund (GCash)
            //  - Cash (COD) orders cancelled by the customer immediately (no refund required)
            //  - Any order with status === 'cancelled'
            //  - GCash orders with cancellationConfirmed = true (even if status is still 'pending' or 'confirmed')
            //  - Orders with refundConfirmedAt timestamp
            //  - Orders with refundDenied flag
            //  - Orders with refundReceiptUrl (indicates refund was processed)
            const items = Object.entries(orders).filter(([id, order]) => {
                if (!order) return false;
                const s = String(order.status || "").toLowerCase();
                const isCancelled = s === "cancelled";

                // Check cancellation flags (same logic as confirmed tab filter)
                const isCancellationConfirmed =
                    order.cancellationConfirmed === true ||
                    order.cancellation_confirmed === true ||
                    order.cancellation_confirmed === 1 ||
                    order.cancellation_confirmed === "true";
                const hasRefundConfirmed =
                    order.refundConfirmedAt ||
                    order.refund_confirmed_at ||
                    order.refundConfirmedAt > 0 ||
                    order.refund_confirmed_at > 0;
                const hasRefundDenied =
                    order.refundDenied === true ||
                    order.refund_denied === true ||
                    order.refundDenied === 1 ||
                    order.refund_denied === 1 ||
                    order.refundDenied === "true" ||
                    order.refund_denied === "true";
                const hasRefundReceipt =
                    order.refundReceiptUrl || order.refund_receipt_url;

                // Include all orders with status === 'cancelled'
                if (isCancelled) {
                    return true;
                }

                // Include orders with any cancellation indicator (even if status is still 'pending' or 'confirmed')
                // This catches orders that were cancelled but status wasn't updated properly
                if (
                    isCancellationConfirmed ||
                    hasRefundConfirmed ||
                    hasRefundDenied ||
                    hasRefundReceipt
                ) {
                    console.log(`âœ… INCLUDING cancelled order ${id} in cancelled tab:`, {
                        status: order.status,
                        cancellationConfirmed: isCancellationConfirmed,
                        refundConfirmedAt: hasRefundConfirmed,
                        refundDenied: hasRefundDenied,
                        refundReceiptUrl: hasRefundReceipt,
                    });
                    return true;
                }

                return false;
            });

            // Calculate refund statistics
            let refundedCount = 0;
            let nonRefundedCount = 0;
            items.forEach(([id, order]) => {
                if (order.refundConfirmedAt) {
                    refundedCount++;
                } else {
                    nonRefundedCount++;
                }
            });

            // Update stats display - simple count only
            if (countElement) {
                countElement.textContent = items.length;
            }

            // State for Orders module cancelled grouping
            if (!this._ordersCancelledSortMode)
                this._ordersCancelledSortMode = "weekly"; // 'weekly' | 'monthly'
            if (!this._ordersCancelledExpanded) this._ordersCancelledExpanded = {}; // key -> bool

            // Toolbar (sort)
            const toolbarId = "orders-cancelled-records-toolbar";
            let toolbar = document.getElementById(toolbarId);
            if (!toolbar) {
                toolbar = document.createElement("div");
                toolbar.id = toolbarId;
                toolbar.style.cssText =
                    "display:flex; align-items:center; justify-content:flex-end; gap:8px; margin:6px 0 10px;";
                toolbar.innerHTML = `
                    <label style="font-size:12px; color:#666;">Group by</label>
                    <select id="orders-cancelled-sort-select" style="padding:6px 8px; border:1px solid #ddd; border-radius:6px; font-size:12px;">
                        <option value="weekly">Weekly</option>
                        <option value="monthly">Monthly</option>
                    </select>
                `;
                // Insert before container
                container.parentElement?.insertBefore(toolbar, container);
                const selectEl = toolbar.querySelector("select");
                if (selectEl) {
                    selectEl.value = this._ordersCancelledSortMode;
                    selectEl.addEventListener("change", (e) => {
                        this._ordersCancelledSortMode = e.target.value;
                        this.loadCancelledOrders(); // re-render
                    });
                }
            } else {
                const selectEl = toolbar.querySelector("select");
                if (selectEl) selectEl.value = this._ordersCancelledSortMode;
            }

            // Helpers - Use same week calculation logic as successful/failed tabs
            // Calculate which Monday-Sunday week a date belongs to
            const getWeekKey = (ts) => {
                const d = new Date(Number(ts || 0));
                const year = d.getFullYear();

                // Create a copy of the date to avoid mutating the original
                const date = new Date(d);
                date.setHours(0, 0, 0, 0);

                // Get the date's day of week (0=Sunday, 1=Monday, ..., 6=Saturday)
                const dayOfWeek = date.getDay();

                // Calculate days to subtract to get to Monday (start of week)
                // If Sunday (0), go back 6 days; otherwise go back (dayOfWeek - 1) days
                const daysToMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;

                // Get the Monday of the week containing this date
                const monday = new Date(date);
                monday.setDate(date.getDate() - daysToMonday);

                // Get January 1st of the same year
                const jan1 = new Date(year, 0, 1);
                jan1.setHours(0, 0, 0, 0);
                const jan1DayOfWeek = jan1.getDay();

                // Find the first Monday of the year
                const firstMonday = new Date(jan1);
                if (jan1DayOfWeek === 0) {
                    // Jan 1 is Sunday, first Monday is Jan 2
                    firstMonday.setDate(2);
                } else if (jan1DayOfWeek === 1) {
                    // Jan 1 is Monday, use it
                    // firstMonday is already Jan 1
                } else {
                    // Jan 1 is Tuesday-Saturday, find the first Monday
                    const daysToFirstMonday = 8 - jan1DayOfWeek;
                    firstMonday.setDate(1 + daysToFirstMonday);
                }

                // Calculate days difference between this Monday and first Monday
                const daysDiff = Math.floor(
                    (monday.getTime() - firstMonday.getTime()) / (1000 * 60 * 60 * 24)
                );

                // Week number (1-indexed)
                const weekNumber = Math.floor(daysDiff / 7) + 1;

                // Handle edge case: if the date is before the first Monday, it belongs to week 1
                if (daysDiff < 0) {
                    return `${year}-W1`;
                }

                return `${year}-W${weekNumber}`;
            };

            const getGroupKey = (ts) => {
                const d = new Date(Number(ts || 0));
                if (this._ordersCancelledSortMode === "monthly") {
                    const mm = String(d.getMonth() + 1).padStart(2, "0");
                    return `${d.getFullYear()}-${mm}`;
                }
                return getWeekKey(ts);
            };

            const getGroupTitle = (key) => {
                if (this._ordersCancelledSortMode === "monthly") {
                    const [year, mm] = key.split("-");
                    const monthNames = [
                        "",
                        "January",
                        "February",
                        "March",
                        "April",
                        "May",
                        "June",
                        "July",
                        "August",
                        "September",
                        "October",
                        "November",
                        "December",
                    ];
                    return `${monthNames[Number(mm)]} ${year}`;
                }
                return getWeekTitle(key);
            };

            const getWeekTitle = (wKey) => {
                const [year, wStr] = String(wKey || "").split("-W");
                const week = Number(wStr);

                // Get January 1st of the year
                const jan1 = new Date(Number(year), 0, 1);
                jan1.setHours(0, 0, 0, 0);
                const jan1DayOfWeek = jan1.getDay();

                // Find the first Monday of the year
                const firstMonday = new Date(jan1);
                if (jan1DayOfWeek === 0) {
                    // Jan 1 is Sunday, first Monday is Jan 2
                    firstMonday.setDate(2);
                } else if (jan1DayOfWeek === 1) {
                    // Jan 1 is Monday, use it
                    // firstMonday is already Jan 1
                } else {
                    // Jan 1 is Tuesday-Saturday, find the first Monday
                    const daysToFirstMonday = 8 - jan1DayOfWeek;
                    firstMonday.setDate(1 + daysToFirstMonday);
                }

                // Calculate the Monday of the requested week
                const weekStart = new Date(firstMonday);
                weekStart.setDate(firstMonday.getDate() + (week - 1) * 7);

                // Calculate the Sunday (end of week)
                const weekEnd = new Date(weekStart);
                weekEnd.setDate(weekStart.getDate() + 6);

                const fmt = (d) => {
                    const day = String(d.getDate()).padStart(2, "0");
                    const month = String(d.getMonth() + 1).padStart(2, "0");
                    return `${day}/${month}/${d.getFullYear()}`;
                };
                return `Week of ${fmt(weekStart)} - ${fmt(weekEnd)}`;
            };

            const buildGroupHeader = (key, count) => {
                const isExpanded = !!this._ordersCancelledExpanded[key];
                const header = document.createElement("div");
                header.style.cssText =
                    "display:flex; align-items:center; gap:10px; padding:10px 12px; background:#f5f9ff; border:1px solid #e3f2fd; border-radius:8px; cursor:pointer;";
                header.innerHTML = `
                    <i class="fas ${this._ordersCancelledSortMode === "monthly"
                        ? "fa-calendar-alt"
                        : "fa-calendar-week"
                    }" style="color:#1976d2;"></i>
                    <div style="flex:1;">
                        <div style="font-weight:600; color:#1976d2;">${getGroupTitle(
                        key
                    )}</div>
                        <div style="font-size:12px; color:#5c6bc0;">${this._ordersCancelledSortMode === "monthly"
                        ? "Monthly View"
                        : "Weekly View"
                    }</div>
                    </div>
                    <div style="display:flex; align-items:center; gap:10px;">
                        <span style="font-size:12px; color:#555;">${count} orders</span>
                        <i class="fas ${isExpanded ? "fa-chevron-up" : "fa-chevron-down"
                    }" style="color:#1976d2;"></i>
                    </div>
                `;
                header.addEventListener("click", () => {
                    this._ordersCancelledExpanded[key] = !isExpanded;
                    this.loadCancelledOrders();
                });
                return header;
            };

            // Build groups
            container.innerHTML = "";
            if (items.length === 0) {
                container.innerHTML = `
                    <div class="empty-rejected">
                        <i class="fas fa-undo"></i>
                        <h3>No Cancelled Orders</h3>
                        <p>Cancelled orders with confirmed refunds will appear here.</p>
                    </div>
                `;
                return;
            }

            const map = new Map();
            items.forEach(([id, o]) => {
                // Group by ORDER DATE (when order was placed), not cancellation date
                // Use createdAt (order date) for grouping, not refundConfirmedAt or cancellationConfirmedAt
                const ts =
                    o.createdAt ||
                    o.created_at ||
                    o.orderDate ||
                    o.order_date ||
                    Date.now();
                const key = getGroupKey(ts);
                if (!map.has(key)) map.set(key, []);
                map.get(key).push([id, o]);
            });

            const keys = Array.from(map.keys()).sort((a, b) => b.localeCompare(a));
            keys.forEach((key) => {
                const groupDiv = document.createElement("div");
                groupDiv.style.cssText = "margin:8px 0;";
                const groupItems = map.get(key) || [];
                groupDiv.appendChild(buildGroupHeader(key, groupItems.length));
                if (this._ordersCancelledExpanded[key]) {
                    if (this._ordersCancelledSortMode === "monthly") {
                        const weekMap = new Map();
                        groupItems.forEach(([id, o]) => {
                            // Group by ORDER DATE (when order was placed), not cancellation date
                            // Use createdAt (order date) for grouping, not refundConfirmedAt or cancellationConfirmedAt
                            const ts =
                                o.createdAt ||
                                o.created_at ||
                                o.orderDate ||
                                o.order_date ||
                                Date.now();
                            const wKey = getWeekKey(ts);
                            if (!weekMap.has(wKey)) weekMap.set(wKey, []);
                            weekMap.get(wKey).push([id, o]);
                        });
                        const weekKeys = Array.from(weekMap.keys()).sort((a, b) =>
                            b.localeCompare(a)
                        );
                        weekKeys.forEach((wKey) => {
                            const composite = `${key}::${wKey}`;
                            const wkHeader = document.createElement("div");
                            const isWExpanded = !!this._ordersCancelledExpanded[composite];
                            wkHeader.style.cssText =
                                "margin:8px 0 4px; padding:8px 10px; background:#eef4ff; border:1px dashed #c5d7fe; border-radius:6px; cursor:pointer; display:flex; align-items:center; gap:8px;";
                            wkHeader.innerHTML = `
                                <i class=\"fas fa-calendar-week\" style=\"color:#3f51b5;\"></i>
                                <div style=\"flex:1; color:#3f51b5; font-weight:600;\">${getWeekTitle(
                                wKey
                            )}</div>
                                <i class=\"fas ${isWExpanded
                                    ? "fa-chevron-up"
                                    : "fa-chevron-down"
                                }\" style=\"color:#3f51b5;\"></i>
                            `;
                            wkHeader.addEventListener("click", () => {
                                this._ordersCancelledExpanded[composite] = !isWExpanded;
                                this.loadCancelledOrders();
                            });
                            groupDiv.appendChild(wkHeader);
                            if (isWExpanded) {
                                const listDiv = document.createElement("div");
                                listDiv.style.cssText =
                                    "margin-top:4px; display:flex; flex-direction:column; gap:8px;";
                                const weekItems = weekMap.get(wKey) || [];
                                // Sort by createdAt (when order was placed) - descending
                                weekItems.sort((a, b) => {
                                    const at =
                                        a[1].createdAt ||
                                        a[1].created_at ||
                                        a[1].orderDate ||
                                        a[1].order_date ||
                                        0;
                                    const bt =
                                        b[1].createdAt ||
                                        b[1].created_at ||
                                        b[1].orderDate ||
                                        b[1].order_date ||
                                        0;
                                    return bt - at;
                                });
                                weekItems.forEach(([id, order]) => {
                                    const card = this.createRejectedProductCard(id, order);
                                    listDiv.appendChild(card);
                                    // Load staff notes after card is created
                                    setTimeout(() => this.loadStaffNotesIntoCard(id), 100);
                                });
                                groupDiv.appendChild(listDiv);
                            }
                        });
                    } else {
                        const listDiv = document.createElement("div");
                        listDiv.style.cssText =
                            "margin-top:8px; display:flex; flex-direction:column; gap:8px;";
                        // Sort by createdAt (when order was placed) - descending
                        groupItems.sort((a, b) => {
                            const at =
                                a[1].createdAt ||
                                a[1].created_at ||
                                a[1].orderDate ||
                                a[1].order_date ||
                                0;
                            const bt =
                                b[1].createdAt ||
                                b[1].created_at ||
                                b[1].orderDate ||
                                b[1].order_date ||
                                0;
                            return bt - at;
                        });
                        groupItems.forEach(([id, order]) => {
                            const card = this.createRejectedProductCard(id, order);
                            listDiv.appendChild(card);
                            // Load staff notes after card is created
                            setTimeout(() => this.loadStaffNotesIntoCard(id), 100);
                        });
                        groupDiv.appendChild(listDiv);
                    }
                }
                container.appendChild(groupDiv);
            });
        } catch (error) {
            console.error("Error loading cancelled orders:", error);
        }
    }

    switchVerificationTab(tabId) {
        // Update tab buttons
        document.querySelectorAll(".verification-tabs .tab-btn").forEach((btn) => {
            btn.classList.remove("active");
        });
        document
            .querySelector(`.verification-tabs .tab-btn[data-tab="${tabId}"]`)
            .classList.add("active");

        // Update tab content
        document
            .querySelectorAll(".verification-content .tab-content")
            .forEach((content) => {
                content.classList.remove("active");
            });
        document.getElementById(`${tabId}-tab`).classList.add("active");

        // Load verification data for the selected tab
        this.loadVerificationData(tabId);
    }

    switchVerificationStatusTab(status) {
        // Update status tab buttons
        document
            .querySelectorAll(".verification-status-tabs .status-tab-btn")
            .forEach((btn) => {
                btn.classList.remove("active");
            });
        document
            .querySelector(
                `.verification-status-tabs .status-tab-btn[data-status="${status}"]`
            )
            .classList.add("active");

        // Update status content
        document
            .querySelectorAll(".verification-status-content .status-content")
            .forEach((content) => {
                content.classList.remove("active");
            });
        document.getElementById(`customers-${status}`).classList.add("active");
    }

    async loadDashboardData() {
        try {
            await this.loadStats();
            await this.loadProducts();
            await this.loadPendingOrders();
            await this.loadUserManagementData();
        } catch (error) {
            console.error("Error loading dashboard data:", error);
        }
    }

    async loadStats() {
        try {
            // Get Supabase client for farmers
            let supabase = null;
            if (typeof window.getSupabaseClient === "function") {
                supabase = window.getSupabaseClient();
            } else if (window.supabaseClient) {
                supabase = window.supabaseClient;
            } else if (typeof window.supabase !== "undefined") {
                const SUPABASE_URL = "https://afkwexvvuxwbpioqnelp.supabase.co";
                const SUPABASE_ANON_KEY =
                    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFma3dleHZ2dXh3YnBpb3FuZWxwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI5MzA3MjcsImV4cCI6MjA3ODUwNjcyN30.7r5j1xfWdJwiRZZm8AcOIaBp9VaXoD2QWE3WrGYZNyM";
                supabase = window.supabase.createClient(
                    SUPABASE_URL,
                    SUPABASE_ANON_KEY
                );
                window.supabaseClient = supabase;
            }

            // Get customers from Supabase instead of Firebase
            let customers = {};
            try {
                customers = await CustomerHelpers.getAllCustomers();
                console.log(
                    "ðŸ“Š loadStats: Loaded customers:",
                    Object.keys(customers).length,
                    "customers"
                );
            } catch (error) {
                console.error("âŒ loadStats: Error loading customers:", error);
                customers = {};
            }

            // Get farmers count - count all farmers from Supabase (matches user management)
            let farmersResult = { count: 0, error: null };
            if (supabase) {
                try {
                    farmersResult = await supabase
                        .from("farmers")
                        .select("*", { count: "exact", head: true });
                    console.log("ðŸ“Š loadStats: Farmers count result:", farmersResult);
                } catch (error) {
                    console.error("âŒ loadStats: Error loading farmers count:", error);
                    farmersResult = { count: 0, error: error };
                }
            }

            // Get staff count - count all staff from Supabase (admin-only, matches user management)
            let staffResult = { count: 0, error: null };
            if (supabase) {
                try {
                    staffResult = await supabase
                        .from("staff")
                        .select("*", { count: "exact", head: true });
                    console.log("ðŸ“Š loadStats: Staff count result:", staffResult);
                } catch (error) {
                    console.error("âŒ loadStats: Error loading staff count:", error);
                    staffResult = { count: 0, error: error };
                }
            }

            // Get riders count - count all riders from Supabase (admin-only, matches user management)
            let ridersResult = { count: 0, error: null };
            if (supabase) {
                try {
                    ridersResult = await supabase
                        .from("riders")
                        .select("*", { count: "exact", head: true });
                    console.log("ðŸ“Š loadStats: Riders count result:", ridersResult);
                } catch (error) {
                    console.error("âŒ loadStats: Error loading riders count:", error);
                    ridersResult = { count: 0, error: error };
                }
            }

            // Get orders from Supabase instead of Firebase
            let orders = {};
            if (window.OrderSupabaseAdapter) {
                try {
                    orders = await OrderSupabaseAdapter.fetchOrders();
                    if (orders === null) {
                        orders = {};
                    }
                } catch (error) {
                    console.error(
                        "âŒ loadStats: Error loading orders from Supabase:",
                        error
                    );
                    orders = {};
                }
            } else {
                // Fallback to Firebase if Supabase adapter not available
                const ordersSnapshot = await dbRefs.orders.once("value");
                orders = ordersSnapshot.val() || {};
            }

            // Farmer count: Count all farmers from Supabase (matches what's shown in user management)
            const farmerCount =
                farmersResult && !farmersResult.error ? farmersResult.count || 0 : 0;
            console.log("ðŸ“Š loadStats: Farmer count:", farmerCount);

            // Staff count: Count all staff from Supabase (admin-only, matches what's shown in user management)
            const staffCount =
                staffResult && !staffResult.error ? staffResult.count || 0 : 0;
            console.log("ðŸ“Š loadStats: Staff count:", staffCount);

            // Riders count: Count all riders from Supabase (admin-only, matches what's shown in user management)
            const riderCount =
                ridersResult && !ridersResult.error ? ridersResult.count || 0 : 0;
            console.log("ðŸ“Š loadStats: Rider count:", riderCount);

            // Calculate Total Order (Weekly): orders from confirmed to to_receive tabs within current week
            // Helper function to get current week key (Monday-Sunday)
            const getCurrentWeekKey = () => {
                const now = new Date();
                const year = now.getFullYear();
                const date = new Date(now);
                date.setHours(0, 0, 0, 0);
                const dayOfWeek = date.getDay();
                const daysToMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
                const monday = new Date(date);
                monday.setDate(date.getDate() - daysToMonday);
                const jan1 = new Date(year, 0, 1);
                jan1.setHours(0, 0, 0, 0);
                const jan1DayOfWeek = jan1.getDay();
                const firstMonday = new Date(jan1);
                if (jan1DayOfWeek === 0) {
                    firstMonday.setDate(2);
                } else if (jan1DayOfWeek === 1) {
                    // firstMonday is already Jan 1
                } else {
                    const daysToFirstMonday = 8 - jan1DayOfWeek;
                    firstMonday.setDate(1 + daysToFirstMonday);
                }
                const daysDiff = Math.floor(
                    (monday.getTime() - firstMonday.getTime()) / (1000 * 60 * 60 * 24)
                );
                const weekNumber = Math.floor(daysDiff / 7) + 1;
                if (daysDiff < 0) {
                    return `${year}-W1`;
                }
                return `${year}-W${weekNumber}`;
            };

            const getOrderWeekKey = (ts) => {
                const d = new Date(Number(ts || 0));
                const year = d.getFullYear();
                const date = new Date(d);
                date.setHours(0, 0, 0, 0);
                const dayOfWeek = date.getDay();
                const daysToMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
                const monday = new Date(date);
                monday.setDate(date.getDate() - daysToMonday);
                const jan1 = new Date(year, 0, 1);
                jan1.setHours(0, 0, 0, 0);
                const jan1DayOfWeek = jan1.getDay();
                const firstMonday = new Date(jan1);
                if (jan1DayOfWeek === 0) {
                    firstMonday.setDate(2);
                } else if (jan1DayOfWeek === 1) {
                    // firstMonday is already Jan 1
                } else {
                    const daysToFirstMonday = 8 - jan1DayOfWeek;
                    firstMonday.setDate(1 + daysToFirstMonday);
                }
                const daysDiff = Math.floor(
                    (monday.getTime() - firstMonday.getTime()) / (1000 * 60 * 60 * 24)
                );
                const weekNumber = Math.floor(daysDiff / 7) + 1;
                if (daysDiff < 0) {
                    return `${year}-W1`;
                }
                return `${year}-W${weekNumber}`;
            };

            const currentWeekKey = getCurrentWeekKey();
            const ordersArray = Object.entries(orders);

            // Filter orders: exclude cancelled orders (same logic as Order Management)
            const nonCancelledOrders = ordersArray.filter(([id, order]) => {
                if (!order) return false;
                // Check cancellation flags
                const isCancellationConfirmed =
                    order.cancellationConfirmed === true ||
                    order.cancellation_confirmed === true ||
                    order.cancellation_confirmed === 1 ||
                    order.cancellation_confirmed === "true";
                const hasRefundConfirmed =
                    order.refundConfirmedAt ||
                    order.refund_confirmed_at ||
                    order.refundConfirmedAt > 0 ||
                    order.refund_confirmed_at > 0;
                const hasRefundDenied =
                    order.refundDenied === true ||
                    order.refund_denied === true ||
                    order.refundDenied === 1 ||
                    order.refundDenied === "true" ||
                    order.refund_denied === "true";
                const hasRefundReceipt =
                    order.refundReceiptUrl || order.refund_receipt_url;
                const s = (order.status || "").toLowerCase();
                if (
                    s === "cancelled" ||
                    isCancellationConfirmed ||
                    hasRefundConfirmed ||
                    hasRefundDenied ||
                    hasRefundReceipt
                ) {
                    return false;
                }
                return true;
            });

            // Calculate Total Order (Weekly): orders from confirmed to to_receive tabs within current week
            const totalOrdersWeekly = nonCancelledOrders.filter(([id, order]) => {
                const s = (order.status || "").toLowerCase();
                // Only count orders from confirmed to to_receive tabs
                if (
                    s === "confirmed" ||
                    s === "to_receive" ||
                    s === "out_for_delivery"
                ) {
                    // Check if order is within current week based on createdAt
                    const orderWeekKey = getOrderWeekKey(
                        order.createdAt ||
                        order.created_at ||
                        order.orderDate ||
                        order.order_date ||
                        Date.now()
                    );
                    return orderWeekKey === currentWeekKey;
                }
                return false;
            }).length;

            // Calculate pending GCash orders only
            const pendingGCashOrders = ordersArray.filter(([id, order]) => {
                if (!order) return false;
                const s = (order.status || "").toLowerCase();
                if (s !== "pending") return false;
                // Check if payment method is GCash
                const paymentMethod = String(
                    order.paymentMethod || order.payment_method || ""
                ).toLowerCase();
                return paymentMethod === "gcash";
            }).length;

            // Calculate today's sales from orders (delivered orders)
            const today = new Date().toDateString();
            const todaysSales = Object.values(orders)
                .filter((order) => {
                    if (!order || order.status !== "delivered") return false;
                    const orderDate = new Date(
                        order.createdAt || order.deliveredAt || Date.now()
                    ).toDateString();
                    return orderDate === today;
                })
                .reduce(
                    (total, order) => total + (order.totalAmount || order.total || 0),
                    0
                );

            // Customer count: Count only approved customers (matches Customer Records tab in user management)
            // This matches the filter in loadCustomersManagementData: verificationStatus === 'approved'
            const allCustomersArray = Object.values(customers);
            console.log(
                "ðŸ“Š loadStats: Total customers loaded:",
                allCustomersArray.length
            );
            if (allCustomersArray.length > 0) {
                console.log("ðŸ“Š loadStats: Sample customer:", {
                    uid: allCustomersArray[0]?.uid,
                    verificationStatus: allCustomersArray[0]?.verificationStatus,
                    verification_status: allCustomersArray[0]?.verification_status,
                    fullName: allCustomersArray[0]?.fullName,
                });
            }

            // Normalize verification status check (handle both camelCase and snake_case, case-insensitive)
            const approvedCustomers = allCustomersArray.filter((customer) => {
                if (!customer) return false;
                const status = (
                    customer.verificationStatus ||
                    customer.verification_status ||
                    ""
                ).toLowerCase();
                return status === "approved";
            }).length;
            console.log("ðŸ“Š loadStats: Approved customers count:", approvedCustomers);

            // Pending verifications count: Count customers with verificationStatus === 'pending'
            // This matches what's shown in Pending Verifications tab
            const pendingCustomerCount = allCustomersArray.filter((customer) => {
                if (!customer) return false;
                const status = (
                    customer.verificationStatus ||
                    customer.verification_status ||
                    ""
                ).toLowerCase();
                return status === "pending";
            }).length;
            console.log(
                "ðŸ“Š loadStats: Pending verifications count:",
                pendingCustomerCount
            );

            // Update stats display
            const allOrdersCountEl = document.getElementById("allOrdersCount");
            if (allOrdersCountEl) {
                allOrdersCountEl.textContent = totalOrdersWeekly;
                console.log(
                    "âœ… Updated allOrdersCount element (Total Order Weekly):",
                    totalOrdersWeekly
                );
            } else {
                console.warn("âš ï¸ allOrdersCount element not found");
            }

            const pendingOrdersEl = document.getElementById("pendingOrdersCount");
            if (pendingOrdersEl) {
                pendingOrdersEl.textContent = pendingGCashOrders;
                console.log(
                    "âœ… Updated pendingOrdersCount element (Pending GCash Orders):",
                    pendingGCashOrders
                );
            } else {
                console.warn("âš ï¸ pendingOrdersCount element not found");
            }

            const todaysSalesEl = document.getElementById("todaysSales");
            if (todaysSalesEl)
                todaysSalesEl.textContent = `â‚±${todaysSales.toLocaleString()}`;

            // Update farmer count if element exists
            const farmerCountEl = document.getElementById("farmerCount");
            if (farmerCountEl) {
                farmerCountEl.textContent = farmerCount;
                console.log("âœ… Updated farmerCount element:", farmerCount);
            } else {
                console.warn("âš ï¸ farmerCount element not found");
            }

            // Update customer stats if elements exist
            const customerCountEl = document.getElementById("customerCount");
            if (customerCountEl) {
                customerCountEl.textContent = approvedCustomers;
                console.log("âœ… Updated customerCount element:", approvedCustomers);
            } else {
                console.warn("âš ï¸ customerCount element not found");
            }

            const pendingCustomerVerificationsEl = document.getElementById(
                "pendingCustomerVerificationsSummary"
            );
            if (pendingCustomerVerificationsEl) {
                pendingCustomerVerificationsEl.textContent = pendingCustomerCount;
                console.log(
                    "âœ… Updated pendingCustomerVerificationsSummary element:",
                    pendingCustomerCount
                );
            } else {
                console.warn(
                    "âš ï¸ pendingCustomerVerificationsSummary element not found"
                );
            }

            // Update staff count if element exists (admin-only)
            const staffCountEl = document.getElementById("staffCount");
            if (staffCountEl) {
                staffCountEl.textContent = staffCount;
                console.log("âœ… Updated staffCount element:", staffCount);
            } else {
                console.warn("âš ï¸ staffCount element not found");
            }

            // Update riders count if element exists (admin-only)
            const riderCountEl = document.getElementById("riderCount");
            if (riderCountEl) {
                riderCountEl.textContent = riderCount;
                console.log("âœ… Updated riderCount element:", riderCount);
            } else {
                console.warn("âš ï¸ riderCount element not found");
            }

            // Calculate and update weekly sales total using the same logic as analytics
            const weeklySalesTotalEl = document.getElementById("weeklySalesTotal");
            if (weeklySalesTotalEl) {
                // Calculate current week date range (Monday to Sunday) - same as analytics
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const dayOfWeek = today.getDay(); // 0 = Sunday, 1 = Monday, etc.
                const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1; // If Sunday, go back 6 days; otherwise go back to Monday

                const weekStart = new Date(today);
                weekStart.setDate(today.getDate() - daysFromMonday);
                weekStart.setHours(0, 0, 0, 0);

                const weekEnd = new Date(weekStart);
                weekEnd.setDate(weekStart.getDate() + 6);
                weekEnd.setHours(23, 59, 59, 999);

                // Convert orders object to format expected by getAnalyticsSalesInPeriod
                const ordersObj = {};
                Object.entries(orders).forEach(([id, order]) => {
                    if (order) {
                        ordersObj[id] = order;
                    }
                });

                // Use the same calculation logic as analytics (getAnalyticsSalesInPeriod)
                const weekSales = this.getAnalyticsSalesInPeriod(
                    {},
                    ordersObj,
                    weekStart,
                    weekEnd
                );

                const weeklySalesTotal = weekSales.total || 0;

                weeklySalesTotalEl.textContent =
                    "â‚±" +
                    weeklySalesTotal.toLocaleString(undefined, {
                        minimumFractionDigits: 2,
                        maximumFractionDigits: 2,
                    });
                console.log("âœ… Updated weeklySalesTotal element:", weeklySalesTotal);
            } else {
                console.warn("âš ï¸ weeklySalesTotal element not found");
            }
        } catch (error) {
            console.error("Error loading stats:", error);
        }
    }
    async loadUserManagementData(tab) {
        this.currentTab = tab;

        if (tab === "staff-users") {
            await this.loadStaffData();
        } else if (tab === "farmer-users") {
            await this.loadFarmersManagementData();
        } else if (tab === "customer-users") {
            // Always default to pending verifications when switching to customer-users
            this.currentCustomerManagementTab = "pending-verifications";

            // Update tab buttons to show pending verifications as active
            document
                .querySelectorAll(".customer-management-tabs .sub-tab-btn")
                .forEach((tabBtn) => {
                    tabBtn.classList.remove("active");
                });
            const defaultTab = document.querySelector(
                '.customer-management-tabs .sub-tab-btn[data-tab="pending-verifications"]'
            );
            if (defaultTab) {
                defaultTab.classList.add("active");
            }

            // Update tab content to show pending verifications as active
            document
                .querySelectorAll(".customer-management-content .sub-tab-content")
                .forEach((content) => {
                    content.classList.remove("active");
                });
            const defaultContent = document.getElementById(
                "pending-verifications-tab"
            );
            if (defaultContent) {
                defaultContent.classList.add("active");
            }

            // Load the pending verifications data
            await this.loadCustomerManagementVerificationData();
        } else if (tab === "rider-users") {
            await this.loadRidersManagementData();
        }
    }

    async loadFarmersManagementData() {
        try {
            const container = document.getElementById("farmerList");
            if (!container) {
                console.error("Farmer list container not found");
                return;
            }

            // Show loading state
            container.innerHTML = '<p class="loading">Loading farmers...</p>';

            // Get Supabase client
            let supabase = null;
            if (typeof window.getSupabaseClient === "function") {
                supabase = window.getSupabaseClient();
            } else if (window.supabaseClient) {
                supabase = window.supabaseClient;
            } else if (typeof window.supabase !== "undefined") {
                const SUPABASE_URL = "https://afkwexvvuxwbpioqnelp.supabase.co";
                const SUPABASE_ANON_KEY =
                    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFma3dleHZ2dXh3YnBpb3FuZWxwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI5MzA3MjcsImV4cCI6MjA3ODUwNjcyN30.7r5j1xfWdJwiRZZm8AcOIaBp9VaXoD2QWE3WrGYZNyM";
                supabase = window.supabase.createClient(
                    SUPABASE_URL,
                    SUPABASE_ANON_KEY
                );
                window.supabaseClient = supabase;
            }

            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            // Load farmers from Supabase
            const { data: farmers, error } = await supabase
                .from("farmers")
                .select("*")
                .order("created_at", { ascending: false });

            if (error) {
                throw new Error("Failed to load farmers: " + error.message);
            }

            container.innerHTML = "";

            // Ensure the Add Farmer button works even when list is empty
            const addFarmerBtn = document.getElementById("addFarmerBtn");
            if (addFarmerBtn && !addFarmerBtn._bound) {
                addFarmerBtn.onclick = () => this.showAddFarmerModal();
                addFarmerBtn._bound = true;
            }

            if (!farmers || farmers.length === 0) {
                container.innerHTML = '<p class="no-data">No farmer records found</p>';
                await this.loadStats();
                return;
            }

            // Convert Supabase data to format expected by createFarmerManagementItem
            farmers.forEach((farmer) => {
                // Map Supabase column names to expected format for backward compatibility
                const farmerData = {
                    uid: farmer.uid,
                    fullName: farmer.full_name,
                    phoneNumber: farmer.phone_number,
                    homeLocation: farmer.home_location,
                    age: farmer.age,
                    gender: farmer.gender,
                    birthDate: farmer.birth_date,
                    farmLocation: farmer.farm_location,
                    farmSize: farmer.farm_size,
                    idType: farmer.id_type, idNumber: farmer.id_number, lastUpdated: farmer.last_updated_at, updatedByName: farmer.updated_by_name, updatedByRole: farmer.updated_by_role,
                    idFrontPhoto: farmer.id_front_photo,
                    idBackPhoto: farmer.id_back_photo,
                    createdAt: farmer.created_at, // Map to camelCase for display
                    registrationDate: farmer.created_at, // Also provide as registrationDate for compatibility
                    created_at: farmer.created_at,
                    updatedAt: farmer.updated_at, // Map to camelCase for display
                    updated_at: farmer.updated_at,
                    created_by: farmer.created_by,
                    createdByName: farmer.created_by_name,
                    created_by_name: farmer.created_by_name,
                    createdByRole: farmer.created_by_role,
                    created_by_role: farmer.created_by_role,
                    updated_by: farmer.updated_by,
                    updatedBy: farmer.updated_by,
                    updatedByName: farmer.updated_by_name,
                    updated_by_name: farmer.updated_by_name,
                    updatedByRole: farmer.updated_by_role,
                    updated_by_role: farmer.updated_by_role,
                    verified_by: farmer.verified_by,
                    verifiedBy: farmer.verified_by,
                    verified_by_name: farmer.verified_by_name,
                    verifiedByName: farmer.verified_by_name,
                    verified_by_role: farmer.verified_by_role,
                    verifiedByRole: farmer.verified_by_role,
                };
                const item = this.createFarmerManagementItem(farmer.uid, farmerData);
                container.appendChild(item);
            });

            // Update dashboard stats after loading farmer data
            await this.loadStats();
        } catch (error) {
            console.error("Error loading farmers data:", error);
            const container = document.getElementById("farmerList");
            if (container) {
                container.innerHTML =
                    '<p class="error">Error loading farmers: ' + error.message + "</p>";
            }
        }
    }

    createFarmerManagementItem(id, farmer) {
        const div = document.createElement("div");
        div.className = "staff-member fade-in";
        div.setAttribute(
            "data-searchable",
            `${farmer.fullName || ""} ${farmer.phoneNumber || farmer.phone || ""} ${farmer.homeLocation || farmer.location || ""
                }`.toLowerCase()
        );

        div.innerHTML = `
            <div class="staff-info">
                <h4>${farmer.fullName || "Unknown"}</h4>
                <p><small>Phone Number: ${farmer.phoneNumber || farmer.phone || "N/A"
            }</small></p>
                <p><small>Home Location: ${farmer.homeLocation || farmer.location || "N/A"
            }</small></p>
            </div>
            <div class="staff-actions">
                <button class="edit-btn" onclick="staffManager.editFarmer('${id}')">
                    <i class="fas fa-edit"></i> Edit
                </button>
                <button class="secondary-btn" onclick="staffManager.viewFarmerDetails('${id}')">
                    <i class="fas fa-eye"></i> View Details
                </button>
                <button class="reject-btn" onclick="staffManager.removeFarmer('${id}')">
                    <i class="fas fa-trash"></i> Remove
                </button>
            </div>
        `;

        return div;
    }

    async loadStaffData() {
        try {
            const container = document.getElementById("staffList");
            if (!container) {
                console.error("Staff list container not found");
                return;
            }

            // Show loading state
            container.innerHTML = '<p class="loading">Loading staff...</p>';

            // Load staff from Supabase
            let supabase = null;

            // Try to get Supabase client from window.getSupabaseClient
            if (typeof window.getSupabaseClient === "function") {
                supabase = window.getSupabaseClient();
            }
            // Fallback: use window.supabaseClient directly
            else if (window.supabaseClient) {
                supabase = window.supabaseClient;
            }
            // Last resort: try to initialize it
            else if (typeof window.supabase !== "undefined") {
                const SUPABASE_URL = "https://afkwexvvuxwbpioqnelp.supabase.co";
                const SUPABASE_ANON_KEY =
                    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFma3dleHZ2dXh3YnBpb3FuZWxwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI5MzA3MjcsImV4cCI6MjA3ODUwNjcyN30.7r5j1xfWdJwiRZZm8AcOIaBp9VaXoD2QWE3WrGYZNyM";
                supabase = window.supabase.createClient(
                    SUPABASE_URL,
                    SUPABASE_ANON_KEY
                );
                window.supabaseClient = supabase;
            }

            if (!supabase) {
                container.innerHTML =
                    '<p class="no-data">Supabase client not initialized. Please refresh the page.</p>';
                console.error(
                    "Supabase client is not available. Check if supabase-config.js loaded correctly."
                );
                return;
            }

            const { data: staff, error: queryError } = await supabase
                .from("staff")
                .select("*")
                .order("created_at", { ascending: false });

            container.innerHTML = "";

            if (queryError) {
                console.error("Error loading staff:", queryError);
                container.innerHTML =
                    '<p class="no-data">Error loading staff data: ' +
                    queryError.message +
                    "</p>";
                return;
            }

            // Set up button click handler (do this even if no staff found)
            const addStaffBtn = document.getElementById("addStaffBtn");
            if (addStaffBtn && !addStaffBtn._bound) {
                if (
                    window.adminManager &&
                    typeof window.adminManager.showAddStaffModal === "function"
                ) {
                    addStaffBtn.onclick = () => window.adminManager.showAddStaffModal();
                } else {
                    addStaffBtn.onclick = () => this.showAddStaffModal();
                }
                addStaffBtn._bound = true;
            }

            if (!staff || staff.length === 0) {
                container.innerHTML = '<p class="no-data">No staff members found</p>';
                return;
            }

            // Convert staff array to object format for createStaffItem compatibility
            staff.forEach((member) => {
                const id = member.uuid;
                const item = this.createStaffItem(id, member);
                container.appendChild(item);
            });
        } catch (error) {
            console.error("Error loading staff data:", error);
            const container = document.getElementById("staffList");
            if (container) {
                container.innerHTML =
                    '<p class="no-data">Error loading staff data. Please refresh the page.</p>';
            }
        }
    }

    createStaffItem(id, member) {
        const div = document.createElement("div");
        const status = member.status || "active";
        const isActive = status === "active";
        div.className = `staff-member fade-in${isActive ? "" : " staff-inactive"}`;
        const fullName = member.full_name || member.fullName || "Unknown";
        const email = member.email || "N/A";
        const employeeId = member.employee_id || member.employeeId || "N/A";
        div.setAttribute(
            "data-searchable",
            `${fullName} ${email} ${employeeId}`.toLowerCase()
        );

        div.innerHTML = `
            <div class="staff-info">
                <h4>${fullName}</h4>
                <p><small>Employee ID: ${employeeId}</small></p>
                <p><small>Email: ${email}</small></p>
            </div>
            <div class="staff-actions">
                <button class="edit-btn" onclick="staffManager.editStaff('${id}')">
                    <i class="fas fa-edit"></i> Edit
                </button>
                <button class="deactivate-btn" onclick="staffManager.toggleStaffStatus('${id}', '${status}')">
                    <i class="fas fa-${status === "active" ? "ban" : "check"
            }"></i> 
                    ${status === "active" ? "Deactivate" : "Activate"}
                </button>
                <button class="secondary-btn" onclick="staffManager.viewStaffDetails('${id}')">
                    <i class="fas fa-eye"></i> View Details
                </button>
                <button class="reject-btn" onclick="staffManager.removeStaff('${id}')">
                    <i class="fas fa-trash"></i> Remove
                </button>
            </div>
        `;

        return div;
    }

    // Delegate staff management functions to adminManager if available, otherwise use local implementations
    async editStaff(id) {
        if (
            window.adminManager &&
            typeof window.adminManager.editStaff === "function"
        ) {
            await window.adminManager.editStaff(id);
            // Keep cancel button using adminManager since it opened the modal
            setTimeout(() => {
                const cancelBtn = document.querySelector(
                    '#editStaffForm button[onclick*="closeModal"]'
                );
                if (cancelBtn) {
                    cancelBtn.setAttribute("onclick", "adminManager.closeModal()");
                }
            }, 100);
            return;
        }
        alert(
            "Edit staff function is not available. Please ensure admin functions are loaded."
        );
    }

    async toggleStaffStatus(id, currentStatus) {
        if (
            window.adminManager &&
            typeof window.adminManager.toggleStaffStatus === "function"
        ) {
            await window.adminManager.toggleStaffStatus(id, currentStatus);
            // Refresh staff list after status change
            if (typeof this.loadStaffData === "function") {
                this.loadStaffData();
            }
            return;
        }
        // Fallback implementation using Supabase
        try {
            const newStatus = currentStatus === "active" ? "inactive" : "active";
            const confirmMsg = `Are you sure you want to ${newStatus === "active" ? "activate" : "deactivate"
                } this staff member?`;
            if (!confirm(confirmMsg)) return;

            // Get Supabase client with fallback
            let supabase = null;
            if (typeof window.getSupabaseClient === "function") {
                supabase = window.getSupabaseClient();
            } else if (window.supabaseClient) {
                supabase = window.supabaseClient;
            }

            if (!supabase) {
                alert("Supabase client not initialized. Please refresh the page.");
                return;
            }

            // Use Unix timestamp in milliseconds for bigint column
            const now = Date.now();
            const { error: updateError } = await supabase
                .from("staff")
                .update({
                    status: newStatus,
                    updated_at: now,
                })
                .eq("uuid", id);

            if (updateError) {
                throw new Error(updateError.message);
            }

            this.showSuccessMessage(
                `Staff member ${newStatus === "active" ? "activated" : "deactivated"
                } successfully`
            );
            this.loadStaffData();
        } catch (error) {
            console.error("Error toggling staff status:", error);
            alert("Error updating staff status: " + error.message);
        }
    }

    async viewStaffDetails(id) {
        if (
            window.adminManager &&
            typeof window.adminManager.viewStaffDetails === "function"
        ) {
            await window.adminManager.viewStaffDetails(id);
            // Update close button to use staffManager
            setTimeout(() => {
                const closeBtn = document.querySelector(
                    '.modal-header button[onclick*="closeModal"]'
                );
                if (closeBtn) {
                    closeBtn.setAttribute("onclick", "staffManager.closeModal()");
                }
            }, 100);
            return;
        }
        // Fallback implementation using Supabase
        try {
            // Get Supabase client with fallback
            let supabase = null;
            if (typeof window.getSupabaseClient === "function") {
                supabase = window.getSupabaseClient();
            } else if (window.supabaseClient) {
                supabase = window.supabaseClient;
            }

            if (!supabase) {
                alert("Supabase client not initialized. Please refresh the page.");
                return;
            }

            const { data: member, error: queryError } = await supabase
                .from("staff")
                .select("*")
                .eq("uuid", id)
                .single();

            if (queryError || !member) {
                alert("Staff member not found");
                return;
            }

            const fullName = member.full_name || member.fullName || "Unknown";
            const email = member.email || "N/A";
            const phone = member.phone || "N/A";
            const employeeId = member.employee_id || member.employeeId || "N/A";

            alert(
                `Staff: ${fullName}\nEmail: ${email}\nPhone: ${phone}\nEmployee ID: ${employeeId}`
            );
        } catch (error) {
            console.error("Error viewing staff details:", error);
            alert("Error loading staff details: " + error.message);
        }
    }

    async removeStaff(id) {
        if (
            window.adminManager &&
            typeof window.adminManager.removeStaff === "function"
        ) {
            await window.adminManager.removeStaff(id);
            // Refresh staff list after removal
            if (typeof this.loadStaffData === "function") {
                this.loadStaffData();
            }
            return;
        }
        // Fallback implementation using Supabase
        try {
            if (
                !confirm(
                    "Are you sure you want to permanently delete this staff member? This action cannot be undone."
                )
            ) {
                return;
            }

            // Get Supabase client with fallback
            let supabase = null;
            if (typeof window.getSupabaseClient === "function") {
                supabase = window.getSupabaseClient();
            } else if (window.supabaseClient) {
                supabase = window.supabaseClient;
            }

            if (!supabase) {
                alert("Supabase client not initialized. Please refresh the page.");
                return;
            }

            const { error: deleteError } = await supabase
                .from("staff")
                .delete()
                .eq("uuid", id);

            if (deleteError) {
                throw new Error(deleteError.message);
            }

            this.showSuccessMessage("Staff member removed successfully");
            this.loadStaffData();
            if (typeof this.loadStats === "function") {
                this.loadStats();
            }
        } catch (error) {
            console.error("Error removing staff:", error);
            alert("Error removing staff: " + error.message);
        }
    }

    showAddStaffModal() {
        if (
            window.adminManager &&
            typeof window.adminManager.showAddStaffModal === "function"
        ) {
            window.adminManager.showAddStaffModal();
            // Update cancel button to use staffManager
            setTimeout(() => {
                const cancelBtn = document.querySelector(
                    '#addStaffForm button[onclick*="closeModal"]'
                );
                if (cancelBtn) {
                    cancelBtn.setAttribute("onclick", "staffManager.closeModal()");
                }
            }, 100);
            return;
        }
        alert(
            "Add staff function is not available. Please ensure admin functions are loaded."
        );
    }

    async loadRidersManagementData() {
        try {
            console.log("Loading riders management data...");

            const container = document.getElementById("riderList");
            if (!container) {
                console.error("Rider list container not found");
                return;
            }

            // Show loading state
            container.innerHTML = '<p class="loading">Loading riders...</p>';

            // Set up button click handler
            const addRiderBtn = document.getElementById("addRiderBtn");
            if (addRiderBtn && !addRiderBtn._bound) {
                addRiderBtn.onclick = () => this.showAddRiderModal();
                addRiderBtn._bound = true;
            }

            // Get Supabase client
            let supabase = null;
            if (typeof window.getSupabaseClient === "function") {
                supabase = window.getSupabaseClient();
            } else if (window.supabaseClient) {
                supabase = window.supabaseClient;
            }

            if (!supabase) {
                container.innerHTML =
                    '<p class="no-data">Supabase client not initialized. Please refresh the page.</p>';
                return;
            }

            // Load riders from Supabase
            const { data: riders, error: ridersError } = await supabase
                .from("riders")
                .select("*")
                .order("created_at", { ascending: false });

            if (ridersError) {
                throw new Error("Failed to load riders: " + ridersError.message);
            }

            // Convert array to object format for compatibility
            const ridersObj = {};
            if (riders) {
                riders.forEach((rider) => {
                    ridersObj[rider.uid] = rider;
                });
            }

            this.updateRidersList(ridersObj);
        } catch (error) {
            console.error("Error loading riders data:", error);
            const container = document.getElementById("riderList");
            if (container) {
                container.innerHTML =
                    '<p class="no-data">Error loading riders data: ' +
                    error.message +
                    "</p>";
            }
        }
    }

    updateRidersList(riders) {
        const container = document.getElementById("riderList");
        if (!container) return;

        container.innerHTML = "";

        // If no riders data provided, reload from Supabase
        if (!riders || Object.keys(riders).length === 0) {
            const noDataDiv = document.createElement("div");
            noDataDiv.innerHTML = '<p class="no-data">No rider records found</p>';
            container.appendChild(noDataDiv);
            return;
        }

        // Get all riders (show both active and inactive)
        const riderEntries = Object.entries(riders).filter(([id, rider]) => {
            return rider && rider.full_name; // Check if rider exists and has a name
        });

        if (riderEntries.length === 0) {
            const noDataDiv = document.createElement("div");
            noDataDiv.innerHTML = '<p class="no-data">No rider records found</p>';
            container.appendChild(noDataDiv);
            return;
        }

        riderEntries.forEach(([id, rider]) => {
            const item = this.createRiderManagementItem(id, rider);
            container.appendChild(item);
        });
    }

    createRiderManagementItem(id, rider) {
        const div = document.createElement("div");
        const isActive = rider.is_active !== false;
        div.className = `staff-member fade-in${isActive ? "" : " rider-inactive"}`;
        // Use Supabase column names
        const fullName = rider.full_name || "Unknown Rider";
        const phoneNumber = rider.phone_number || "";
        const vehicleNumber = rider.vehicle_number || "";
        const vehicleType = rider.vehicle_type || "";
        div.setAttribute(
            "data-searchable",
            `${fullName} ${phoneNumber} ${vehicleNumber} ${vehicleType}`.toLowerCase()
        );

        div.innerHTML = `
            <div class="staff-info">
                <div class="staff-details">
                    <h4>${fullName}</h4>
                    <p><i class="fas fa-envelope"></i> ${rider.email || "No email"
            }</p>
                    <p><i class="fas fa-phone"></i> ${phoneNumber || "No phone"
            }</p>
                    <p><i class="fas fa-motorcycle"></i> ${vehicleType || "Unknown"
            } - ${vehicleNumber || "No number"}</p>
                </div>
                <div class="staff-actions">
                    <button class="secondary-btn" onclick="staffManager.viewRiderDetails('${id}')">
                        <i class="fas fa-eye"></i> View Details
                    </button>
                    <button class="edit-btn" onclick="staffManager.editRider('${id}')">
                        <i class="fas fa-edit"></i> Edit
                    </button>
                    <button class="deactivate-btn" onclick="staffManager.toggleRiderStatus('${id}', ${rider.is_active})">
                        <i class="fas fa-${rider.is_active ? "ban" : "check"
            }"></i> ${rider.is_active ? "Deactivate" : "Activate"}
                    </button>
                    <button class="reject-btn" onclick="staffManager.removeRider('${id}')">
                        <i class="fas fa-trash"></i> Remove
                    </button>
                </div>
            </div>
        `;

        return div;
    }

    showAddRiderModal() {
        // Use adminManager if available (should be loaded via admin.js in HTML)
        if (
            window.adminManager &&
            typeof window.adminManager.showAddRiderModal === "function"
        ) {
            window.adminManager.showAddRiderModal();
            // Update cancel button to use staffManager
            setTimeout(() => {
                const cancelBtn = document.querySelector(
                    '#addRiderForm button[onclick*="closeModal"]'
                );
                if (cancelBtn) {
                    cancelBtn.setAttribute("onclick", "staffManager.closeModal()");
                }
                // Ensure removePhoto is accessible
                if (
                    !window.removePhoto &&
                    window.adminManager &&
                    typeof window.adminManager.removePhoto === "function"
                ) {
                    window.removePhoto = function (inputId) {
                        if (window.adminManager) {
                            window.adminManager.removePhoto(inputId);
                        }
                    };
                }
            }, 100);
            return;
        }
        // Fallback: Try to wait for adminManager to load
        setTimeout(() => {
            if (
                window.adminManager &&
                typeof window.adminManager.showAddRiderModal === "function"
            ) {
                this.showAddRiderModal();
            } else {
                alert(
                    "Rider management functions are loading. Please try again in a moment or refresh the page."
                );
            }
        }, 500);
    }

    async editRider(riderId) {
        if (
            window.adminManager &&
            typeof window.adminManager.editRider === "function"
        ) {
            await window.adminManager.editRider(riderId);
            return;
        }
        alert("Edit rider function is not available.");
    }

    async viewRiderDetails(riderId) {
        if (
            window.adminManager &&
            typeof window.adminManager.viewRiderDetails === "function"
        ) {
            await window.adminManager.viewRiderDetails(riderId);
            return;
        }
        // Fallback: show basic rider details
        try {
            // Get Supabase client
            let supabase = null;
            if (typeof window.getSupabaseClient === "function") {
                supabase = window.getSupabaseClient();
            } else if (window.supabaseClient) {
                supabase = window.supabaseClient;
            }

            if (!supabase) {
                alert("Supabase client not initialized. Please refresh the page.");
                return;
            }

            const { data: rider, error: riderError } = await supabase
                .from("riders")
                .select("*")
                .eq("uid", riderId)
                .single();

            if (riderError || !rider) {
                alert("Rider not found");
                return;
            }

            alert(
                `Rider: ${rider.full_name || "Unknown"}\nEmail: ${rider.email || "N/A"
                }\nPhone: ${rider.phone_number || "N/A"}`
            );
        } catch (error) {
            console.error("Error viewing rider details:", error);
            alert("Error loading rider details: " + error.message);
        }
    }

    async toggleRiderStatus(riderId, currentStatus) {
        if (
            window.adminManager &&
            typeof window.adminManager.toggleRiderStatus === "function"
        ) {
            await window.adminManager.toggleRiderStatus(riderId, currentStatus);
            return;
        }
        // Fallback implementation
        try {
            const newStatus = !currentStatus;
            const confirmMsg = `Are you sure you want to ${newStatus ? "activate" : "deactivate"
                } this rider?`;
            if (!confirm(confirmMsg)) return;

            // Get Supabase client
            let supabase = null;
            if (typeof window.getSupabaseClient === "function") {
                supabase = window.getSupabaseClient();
            } else if (window.supabaseClient) {
                supabase = window.supabaseClient;
            }

            if (!supabase) {
                alert("Supabase client not initialized. Please refresh the page.");
                return;
            }

            const { error: updateError } = await supabase
                .from("riders")
                .update({
                    is_active: newStatus,
                })
                .eq("uid", riderId);

            if (updateError) {
                throw new Error(updateError.message);
            }

            this.showSuccessMessage(
                `Rider ${newStatus ? "activated" : "deactivated"} successfully`
            );
            this.loadRidersManagementData();
        } catch (error) {
            console.error("Error toggling rider status:", error);
            alert("Error updating rider status: " + error.message);
        }
    }

    async removeRider(riderId) {
        if (
            window.adminManager &&
            typeof window.adminManager.removeRider === "function"
        ) {
            await window.adminManager.removeRider(riderId);
            return;
        }
        // Fallback implementation
        try {
            if (
                !confirm(
                    "Are you sure you want to permanently delete this rider? This action cannot be undone."
                )
            ) {
                return;
            }

            // Get Supabase client
            let supabase = null;
            if (typeof window.getSupabaseClient === "function") {
                supabase = window.getSupabaseClient();
            } else if (window.supabaseClient) {
                supabase = window.supabaseClient;
            }

            if (!supabase) {
                alert("Supabase client not initialized. Please refresh the page.");
                return;
            }

            const { error: deleteError } = await supabase
                .from("riders")
                .delete()
                .eq("uid", riderId);

            if (deleteError) {
                throw new Error(deleteError.message);
            }

            this.showSuccessMessage("Rider removed successfully");
            this.loadRidersManagementData();
        } catch (error) {
            console.error("Error removing rider:", error);
            alert("Error removing rider: " + error.message);
        }
    }

    // Search functionality for user management
    searchUsers(type, searchTerm) {
        const searchTermLower = (searchTerm || "").toString().toLowerCase().trim();
        let containerId;

        switch (type) {
            case "staff":
                containerId = "staffList";
                break;
            case "farmer":
                containerId = "farmerList";
                break;
            case "customer":
                containerId = "customerList";
                break;
            case "rider":
                containerId = "riderList";
                break;
            default:
                return;
        }

        const container = document.getElementById(containerId);
        if (!container) return;

        // For customer records, filter using data-searchable first, then name/full text
        if (type === "customer") {
            let items = Array.from(container.querySelectorAll(".staff-member"));
            if (items.length === 0) {
                items = Array.from(container.children);
            }
            let anyMatch = false;
            const norm = (s) =>
                (s || "").toString().toLowerCase().trim().normalize("NFKD");
            items.forEach((item) => {
                const attr = norm(item.getAttribute?.("data-searchable"));
                const nameText = norm(item.querySelector?.("h5")?.textContent);
                const fullText = norm(item.textContent);
                const haystack = attr || nameText || fullText;
                const match =
                    searchTermLower === "" || haystack.includes(searchTermLower);

                // Force visibility change with !important to override CSS
                if (match) {
                    item.style.setProperty("display", "flex", "important");
                    item.style.visibility = "visible";
                } else {
                    item.style.setProperty("display", "none", "important");
                    item.style.visibility = "hidden";
                }

                if (match) anyMatch = true;
            });

            // If no items matched, show a friendly message
            const existing = container.querySelector(".no-data.search, .no-data");
            if (!anyMatch) {
                if (!existing) {
                    const msg = document.createElement("p");
                    msg.className = "no-data search";
                    msg.textContent = "No matching customers";
                    container.appendChild(msg);
                }
            } else if (existing) {
                existing.remove();
            }
            return;
        }

        // Default generic filtering for other user types
        let items = Array.from(container.querySelectorAll("[data-searchable]"));
        if (items.length === 0) {
            items = Array.from(container.children);
        }
        items.forEach((item) => {
            const attrText = (
                item.getAttribute?.("data-searchable") || ""
            ).toLowerCase();
            const fullText = (item.textContent || "").toLowerCase();
            const haystack = `${attrText} ${fullText}`;
            const match =
                searchTermLower === "" || haystack.includes(searchTermLower);
            item.style.display = match ? "" : "none";
        });
    }

    // Search functionality for verifications
    searchVerifications(type, searchTerm) {
        const q = (searchTerm || "").toString().toLowerCase().trim();
        let containerId;

        switch (type) {
            case "pending":
                containerId = "customerVerificationsManagement";
                break;
            case "rejected":
                containerId = "customerRejectedManagement";
                break;
            default:
                return;
        }

        const container = document.getElementById(containerId);
        if (!container) {
            console.warn("Search container not found:", containerId);
            return;
        }

        // Find all verification items
        let items = container.querySelectorAll(".verification-item");
        if (!items || items.length === 0) {
            // Fallback: look for any child elements that might be verification items
            items = Array.from(container.children).filter(
                (child) =>
                    child.classList.contains("verification-item") ||
                    child.querySelector("h4") || // Has a name element
                    child.querySelector(".verification-info") // Has verification info
            );
        }

        console.log(
            `Searching ${type} verifications: query="${q}", items found: ${items.length}`
        );

        let anyMatch = false;

        // If there are no items to search through, show appropriate message
        if (items.length === 0) {
            if (q === "") {
                // Don't show "no results" for empty search when there are no items
                this.hideSearchNoResults(container);
            } else {
                console.log(
                    "ðŸ” Search query with no items - showing no results message"
                );
                this.showSearchNoResults(container, q);
            }
            return;
        }

        Array.from(items).forEach((item) => {
            const norm = (s) =>
                (s || "").toString().toLowerCase().trim().normalize("NFKD");
            const attr = norm(item.getAttribute?.("data-searchable"));
            const nameText = norm(item.querySelector?.("h4")?.textContent);
            const fullText = norm(item.textContent);
            const haystack = attr || nameText || fullText;
            const match = q === "" || haystack.includes(q);

            // Force visibility change with !important to override CSS (same as customer records)
            if (match) {
                item.style.setProperty("display", "flex", "important");
                item.style.visibility = "visible";
            } else {
                item.style.setProperty("display", "none", "important");
                item.style.visibility = "hidden";
            }

            if (match) {
                anyMatch = true;
                console.log(`Match found: ${haystack}`);
            }
        });

        console.log(
            `Search complete: ${anyMatch ? "matches found" : "no matches"}`
        );

        // Show/hide "no results" message
        if (!anyMatch && q !== "") {
            this.showSearchNoResults(container, q);
        } else {
            this.hideSearchNoResults(container);
        }
    }

    // Helper function to show "no results" message
    showSearchNoResults(container, query) {
        const existingMsg = container.querySelector(".no-data.search, .no-data");
        if (!existingMsg) {
            const msg = document.createElement("p");
            msg.className = "no-data search";
            msg.textContent = "No matching verifications";
            msg.style.cssText =
                "text-align: center; padding: 20px; color: #666; font-style: italic;";
            container.appendChild(msg);
            console.log('Showing "no results" message');
        }
    }

    // Helper function to hide "no results" message
    hideSearchNoResults(container) {
        const existingMsg = container.querySelector(".no-data.search, .no-data");
        if (existingMsg) {
            existingMsg.remove();
            console.log('Hiding "no results" message');
        }
    }
    showAddFarmerModal() {
        const barangaySelectHtml = this.renderBarangaySelect(
            "farmerHomeBarangay",
            "",
            true
        );
        const modalContent = `
            <div class="modal-header">
                <h3>Add New Farmer</h3>
                <button class="close-modal">&times;</button>
            </div>
            <form id="addFarmerForm" style="padding: 24px; overflow-y: auto;">
                <div style="display: flex; flex-direction: column; gap: 24px; max-width: 1200px; margin: 0 auto;">
                    <!-- Personal Information Section -->
                    <div class="form-section">
                        <h4 style="margin: 0 0 16px 0; font-size: 16px; font-weight: 600; color: #333; border-bottom: 2px solid #e2e8f0; padding-bottom: 8px;">
                            <i class="fas fa-user"></i> Personal Information
                        </h4>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px;">
                            <div class="form-field">
                                <label for="farmerFirstName" class="required">First Name</label>
                                <input type="text" id="farmerFirstName" required>
                            </div>
                            <div class="form-field">
                                <label for="farmerMiddleName">Middle Name</label>
                                <input type="text" id="farmerMiddleName">
                            </div>
                            <div class="form-field">
                                <label for="farmerLastName" class="required">Last Name</label>
                                <input type="text" id="farmerLastName" required>
                            </div>
                            <div class="form-field">
                                <label for="farmerSuffix">Suffix</label>
                                <input type="text" id="farmerSuffix" placeholder="Jr., Sr., III, etc.">
                            </div>
                            <div class="form-field">
                                <label for="farmerPhone" class="required">Phone Number</label>
                                <input type="tel" id="farmerPhone" required>
                            </div>
                            <div class="form-field">
                                <label for="farmerBirthDate" class="required">Birth Date</label>
                                <input type="date" id="farmerBirthDate" required onchange="staffManager.calculateAge()">
                            </div>
                            <div class="form-field">
                                <label for="farmerAge">Age</label>
                                <input type="number" id="farmerAge" min="18" max="100" readonly>
                            </div>
                            <div class="form-field">
                                <label for="farmerGender">Gender</label>
                                <select id="farmerGender">
                                    <option value="">Select Gender</option>
                                    <option value="Male">Male</option>
                                    <option value="Female">Female</option>
                                    <option value="Other">Other</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Home Location Section -->
                    <div class="form-section">
                        <h4 style="margin: 0 0 16px 0; font-size: 16px; font-weight: 600; color: #333; border-bottom: 2px solid #e2e8f0; padding-bottom: 8px;">
                            <i class="fas fa-map-marker-alt"></i> Home Location
                        </h4>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px;">
                            <div class="form-field">
                                <label for="farmerHomeStreet">Street</label>
                                <input type="text" id="farmerHomeStreet">
                            </div>
                            <div class="form-field">
                                <label for="farmerHomeSitio">Sitio</label>
                                <input type="text" id="farmerHomeSitio">
                            </div>
                            <div class="form-field">
                                <label for="farmerHomeBarangay" class="required">Barangay</label>
                                ${barangaySelectHtml}
                            </div>
                            <div class="form-field">
                                <label for="farmerHomePostalCode">Postal Code</label>
                                <input type="text" id="farmerHomePostalCode" value="6541" readonly>
                            </div>
                            <div class="form-field">
                                <label for="farmerHomeCity" class="required">City</label>
                                <input type="text" id="farmerHomeCity" value="Ormoc" required readonly>
                            </div>
                            <div class="form-field">
                                <label for="farmerHomeProvince" class="required">Province</label>
                                <input type="text" id="farmerHomeProvince" value="Leyte" required readonly>
                            </div>
                        </div>
                    </div>

                    <!-- Farm Information Section -->
                    <div class="form-section">
                        <h4 style="margin: 0 0 16px 0; font-size: 16px; font-weight: 600; color: #333; border-bottom: 2px solid #e2e8f0; padding-bottom: 8px;">
                            <i class="fas fa-tractor"></i> Farm Information
                        </h4>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px;">
                            <div class="form-field">
                                <label for="farmerFarmLocation">Farm Location</label>
                                <textarea id="farmerFarmLocation" rows="3"></textarea>
                            </div>
                            <div class="form-field">
                                <label for="farmerFarmSize">Farm Size (hectares)</label>
                                <input type="number" id="farmerFarmSize" min="0" step="0.1">
                            </div>
                        </div>
                    </div>

                    <!-- Valid ID Information Section -->
                    <div class="form-section">
                        <h4 style="margin: 0 0 16px 0; font-size: 16px; font-weight: 600; color: #333; border-bottom: 2px solid #e2e8f0; padding-bottom: 8px;">
                            <i class="fas fa-id-card"></i> Valid ID Information
                        </h4>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; margin-bottom: 20px;">
                            <div class="form-field">
                                <label for="farmerIdType" class="required">Valid ID Type</label>
                                <select id="farmerIdType" required>
                                    <option value="">Select ID Type</option>
                                    <option value="Philippine National ID">Philippine National ID</option>
                                    <option value="Driver's License">Driver's License</option>
                                    <option value="Philippine Passport">Philippine Passport</option><option value="BIR">BIR</option>
                                    <option value="SSS">SSS</option>
                                    <option value="GSIS">GSIS</option>
                                    <option value="Other">Other</option>
                                </select>
                            </div>
                            <div class="form-field">
                                <label for="farmerIdNumber" style="white-space: nowrap">Valid ID/Paper Reference Number</label>
                                <input type="text" id="farmerIdNumber">
                            </div>
                        </div>
                        
                        <div class="id-photos-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                            <div class="form-field">
                                <label for="farmerIdFront">Valid ID/Paper Images</label>
                                <input type="file" id="farmerIdFront" accept="image/*">
                                <div id="farmerIdFrontPreview" class="image-preview"></div>
                            </div>
                            <div class="form-field">
                                <label for="farmerIdBack">Valid ID/Paper Images</label>
                                <input type="file" id="farmerIdBack" accept="image/*">
                                <div id="farmerIdBackPreview" class="image-preview"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="form-actions" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e2e8f0; display: flex; gap: 12px; justify-content: flex-end;">
                    <button type="button" class="secondary-btn" onclick="staffManager.closeModal()">Cancel</button>
                    <button type="submit" class="primary-btn"><i class="fas fa-plus"></i> Register Farmer</button>
                </div>
            </form>
        `;

        this.showModal(modalContent);
        // Ensure product modal shows its action buttons (clear compact farmer classes)
        (function () {
            const modalEl = document.getElementById("modalContent");
            const overlayEl = document.getElementById("modalOverlay");
            if (modalEl) {
                modalEl.classList.remove("compact-farmer-edit");
                // Add scrollable classes for farmer form
                modalEl.classList.add("scrollable-modal");
                if (overlayEl) {
                    overlayEl.classList.add("scrollable-overlay");
                }
                // keep uniform width but allow default product spacing
            }
        })();
        // Match Edit Farmer modal sizing and overlay behavior
        (function () {
            const modalEl = document.getElementById("modalContent");
            if (modalEl && modalEl.classList.contains("farmer-modal")) {
                modalEl.classList.remove("farmer-modal");
            }
            if (modalEl && !modalEl.classList.contains("uniform-farmer-modal")) {
                modalEl.classList.add("uniform-farmer-modal");
            }
            if (modalEl && !modalEl.classList.contains("compact-farmer-edit")) {
                modalEl.classList.add("compact-farmer-edit");
            }
            const overlayEl = document.getElementById("modalOverlay");
            if (overlayEl && !overlayEl.classList.contains("farmer-modal-open")) {
                overlayEl.classList.add("farmer-modal-open");
            }
        })();

        const form = document.getElementById("addFarmerForm");
        form.addEventListener("submit", async (e) => {
            e.preventDefault();
            await this.createFarmer();
        });

        // Image preview like admin
        this.setupImagePreviews();
    }

    async createFarmer() {
        try {
            const formData = {
                firstName: document.getElementById("farmerFirstName")?.value.trim(),
                middleName:
                    document.getElementById("farmerMiddleName")?.value.trim() || null,
                lastName: document.getElementById("farmerLastName")?.value.trim(),
                suffix: document.getElementById("farmerSuffix")?.value.trim() || null,
                phoneNumber: document.getElementById("farmerPhone").value.trim(),
                age: document.getElementById("farmerAge").value
                    ? parseInt(document.getElementById("farmerAge").value)
                    : null,
                gender: document.getElementById("farmerGender").value,
                birthDate: document.getElementById("farmerBirthDate").value,
                idType: document.getElementById("farmerIdType").value,
                idNumber: document.getElementById("farmerIdNumber")?.value.trim() || null,
                farmLocation: document
                    .getElementById("farmerFarmLocation")
                    .value.trim() || null,
                homeStreet:
                    document.getElementById("farmerHomeStreet")?.value.trim() || null,
                homeSitio:
                    document.getElementById("farmerHomeSitio")?.value.trim() || null,
                homeBarangay: document
                    .getElementById("farmerHomeBarangay")
                    .value.trim(),
                homeCity: document.getElementById("farmerHomeCity").value.trim(),
                homeProvince: document
                    .getElementById("farmerHomeProvince")
                    .value.trim(),
                homePostalCode:
                    document.getElementById("farmerHomePostalCode")?.value.trim() || null,
                farmSize: document.getElementById("farmerFarmSize").value
                    ? parseFloat(document.getElementById("farmerFarmSize").value)
                    : null,
            };

            const idFrontFile = document.getElementById("farmerIdFront").files[0];
            const idBackFile = document.getElementById("farmerIdBack").files[0];

            // Build full name from components
            let fullName = formData.firstName;
            if (formData.middleName) {
                fullName += " " + formData.middleName;
            }
            fullName += " " + formData.lastName;
            if (formData.suffix) {
                fullName += " " + formData.suffix;
            }

            // Build full home location from components
            let fullHomeLocationParts = [];
            if (formData.homeStreet) fullHomeLocationParts.push(formData.homeStreet);
            if (formData.homeSitio)
                fullHomeLocationParts.push(`Sitio ${formData.homeSitio}`);
            if (formData.homeBarangay)
                fullHomeLocationParts.push(formData.homeBarangay);
            if (formData.homeCity) fullHomeLocationParts.push(formData.homeCity);
            if (formData.homeProvince)
                fullHomeLocationParts.push(formData.homeProvince);
            if (formData.homePostalCode)
                fullHomeLocationParts.push(formData.homePostalCode);
            const fullHomeLocation =
                fullHomeLocationParts.length > 0
                    ? fullHomeLocationParts.join(", ")
                    : "N/A";

            // Validation (align with admin)
            if (
                !formData.firstName ||
                !formData.lastName ||
                !formData.phoneNumber ||
                !formData.idType ||
                !formData.homeBarangay ||
                !formData.birthDate
            ) {
                alert("Please fill in all required fields");
                return;
            }
            // ID photos are optional - no validation needed

            // Generate UUID for farmer
            const farmerUuid =
                "farmer_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9);

            // Show loading state
            const submitBtn = document.querySelector(
                '#addFarmerForm button[type="submit"]'
            );
            const originalBtnText = submitBtn ? submitBtn.innerHTML : "";
            if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.innerHTML =
                    '<i class="fas fa-spinner fa-spin"></i> Uploading ID photos...';
            }

            // Upload ID photos to Supabase (optional)
            let idFrontUrl = "";
            let idBackUrl = "";

            try {
                // Upload front ID photo if provided
                if (idFrontFile) {
                    if (submitBtn) {
                        submitBtn.innerHTML =
                            '<i class="fas fa-spinner fa-spin"></i> Uploading front ID photo...';
                    }
                    idFrontUrl = await FirebaseUtils.uploadFarmerIdPhoto(
                        idFrontFile,
                        farmerUuid,
                        "front",
                        (pct) => {
                            console.log(`Front ID photo upload: ${Math.round(pct)}%`);
                        }
                    );
                }

                // Upload back ID photo if provided
                if (idBackFile) {
                    if (submitBtn) {
                        submitBtn.innerHTML =
                            '<i class="fas fa-spinner fa-spin"></i> Uploading back ID photo...';
                    }
                    idBackUrl = await FirebaseUtils.uploadFarmerIdPhoto(
                        idBackFile,
                        farmerUuid,
                        "back",
                        (pct) => {
                            console.log(`Back ID photo upload: ${Math.round(pct)}%`);
                        }
                    );
                }
            } catch (uploadError) {
                console.error("Error uploading ID photos:", uploadError);
                if (submitBtn) {
                    submitBtn.disabled = false;
                    submitBtn.innerHTML = originalBtnText;
                }
                alert("Error uploading ID photos: " + uploadError.message);
                return;
            }

            // Get Supabase client
            let supabase = null;
            if (typeof window.getSupabaseClient === "function") {
                supabase = window.getSupabaseClient();
            } else if (window.supabaseClient) {
                supabase = window.supabaseClient;
            } else if (typeof window.supabase !== "undefined") {
                const SUPABASE_URL = "https://afkwexvvuxwbpioqnelp.supabase.co";
                const SUPABASE_ANON_KEY =
                    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFma3dleHZ2dXh3YnBpb3FuZWxwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI5MzA3MjcsImV4cCI6MjA3ODUwNjcyN30.7r5j1xfWdJwiRZZm8AcOIaBp9VaXoD2QWE3WrGYZNyM";
                supabase = window.supabase.createClient(
                    SUPABASE_URL,
                    SUPABASE_ANON_KEY
                );
                window.supabaseClient = supabase;
            }

            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            // Use Unix timestamp in milliseconds for bigint columns
            const now = Date.now(); // Unix timestamp in milliseconds
            const birthDateTimestamp = formData.birthDate
                ? new Date(formData.birthDate).getTime()
                : null;

            const staffUid =
                sessionStorage.getItem("staffUid") ||
                sessionStorage.getItem("adminUid") ||
                "staff";
            const staffName =
                sessionStorage.getItem("staffName") ||
                sessionStorage.getItem("adminName") ||
                "Staff";
            const staffRole =
                sessionStorage.getItem("staffRole") ||
                (this.isAdmin() ? "Administrator" : "Staff");

            // Create farmer data matching Supabase table columns
            const farmerData = {
                uid: farmerUuid,
                age: formData.age,
                birth_date: formData.birthDate || null, // Store as DATE type
                created_at: now,
                created_by: staffUid,
                created_by_name: staffName,
                created_by_role: staffRole,
                farm_location: formData.farmLocation || null,
                farm_size: formData.farmSize || null,
                full_name: fullName,
                gender: formData.gender || null,
                home_location: fullHomeLocation,
                id_back_photo: idBackUrl || null,
                id_front_photo: idFrontUrl || null,
                id_type: formData.idType || null,
                id_number: formData.idNumber || null,
                phone_number: formData.phoneNumber,
                updated_at: null,
                updated_by: null,
                updated_by_name: null,
                updated_by_role: null,
            };

            // Save farmer data to Supabase
            const { error: insertError } = await supabase
                .from("farmers")
                .insert([farmerData]);

            if (insertError) {
                throw new Error(
                    "Failed to create farmer account: " + insertError.message
                );
            }

            // Restore button state
            if (submitBtn) {
                submitBtn.disabled = false;
                submitBtn.innerHTML = originalBtnText;
            }

            this.closeModal();
            this.showSuccessMessage("Farmer registered successfully");
            this.loadFarmersManagementData();
            this.loadStats();
        } catch (error) {
            console.error("Error creating farmer:", error);
            const submitBtn = document.querySelector(
                '#addFarmerForm button[type="submit"]'
            );
            if (submitBtn) {
                submitBtn.disabled = false;
                submitBtn.innerHTML = '<i class="fas fa-plus"></i> Register Farmer';
            }
            alert("Error creating farmer: " + error.message);
        }
    }

    calculateAge() {
        const birthDateInput = document.getElementById("farmerBirthDate");
        const ageInput = document.getElementById("farmerAge");
        if (birthDateInput && ageInput && birthDateInput.value) {
            const birthDate = new Date(birthDateInput.value);
            const today = new Date();
            let age = today.getFullYear() - birthDate.getFullYear();
            const monthDiff = today.getMonth() - birthDate.getMonth();
            if (
                monthDiff < 0 ||
                (monthDiff === 0 && today.getDate() < birthDate.getDate())
            ) {
                age--;
            }
            ageInput.value = age;
        } else if (ageInput) {
            ageInput.value = "";
        }
    }

    setupImagePreviews() {
        const frontInput = document.getElementById("farmerIdFront");
        const backInput = document.getElementById("farmerIdBack");
        const frontPreview = document.getElementById("farmerIdFrontPreview");
        const backPreview = document.getElementById("farmerIdBackPreview");
        if (frontInput && frontPreview) {
            frontInput.addEventListener("change", (e) => {
                this.displayImagePreview(e.target.files[0], frontPreview);
            });
        }
        if (backInput && backPreview) {
            backInput.addEventListener("change", (e) => {
                this.displayImagePreview(e.target.files[0], backPreview);
            });
        }
    }

    displayImagePreview(file, previewElement) {
        if (file && previewElement) {
            const reader = new FileReader();
            reader.onload = (e) => {
                previewElement.innerHTML = `
                    <img src="${e.target.result}" alt="ID Preview" style="max-width: 200px; max-height: 150px; border-radius: 8px; margin-top: 10px;">
                `;
            };
            reader.readAsDataURL(file);
        } else if (previewElement) {
            previewElement.innerHTML = "";
        }
    }

    async editFarmer(farmerId) {
        try {
            // Get Supabase client
            let supabase = null;
            if (typeof window.getSupabaseClient === "function") {
                supabase = window.getSupabaseClient();
            } else if (window.supabaseClient) {
                supabase = window.supabaseClient;
            } else if (typeof window.supabase !== "undefined") {
                const SUPABASE_URL = "https://afkwexvvuxwbpioqnelp.supabase.co";
                const SUPABASE_ANON_KEY =
                    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFma3dleHZ2dXh3YnBpb3FuZWxwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI5MzA3MjcsImV4cCI6MjA3ODUwNjcyN30.7r5j1xfWdJwiRZZm8AcOIaBp9VaXoD2QWE3WrGYZNyM";
                supabase = window.supabase.createClient(
                    SUPABASE_URL,
                    SUPABASE_ANON_KEY
                );
                window.supabaseClient = supabase;
            }

            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            // Load farmer from Supabase
            const { data: farmer, error } = await supabase
                .from("farmers")
                .select("*")
                .eq("uid", farmerId)
                .single();

            if (error || !farmer) {
                alert("Farmer not found");
                return;
            }

            // Map Supabase column names to expected format for backward compatibility
            const farmerData = {
                uid: farmer.uid,
                fullName: farmer.full_name,
                phoneNumber: farmer.phone_number,
                homeLocation: farmer.home_location,
                age: farmer.age,
                gender: farmer.gender,
                birthDate: farmer.birth_date,
                farmLocation: farmer.farm_location,
                farmSize: farmer.farm_size,
                idType: farmer.id_type, idNumber: farmer.id_number, lastUpdated: farmer.last_updated_at, updatedByName: farmer.updated_by_name, updatedByRole: farmer.updated_by_role,
                idFrontPhoto: farmer.id_front_photo,
                idBackPhoto: farmer.id_back_photo,
                address: farmer.home_location,
                email: null, // Farmers table doesn't have email column
            };

            this.showEditFarmerModal(farmerId, farmerData);
        } catch (error) {
            console.error("Error loading farmer data:", error);
            alert("Error loading farmer data: " + error.message);
        }
    }

    showEditFarmerModal(farmerId, farmer) {
        const modalContent = `
            <div class="modal-header">
                <div><h3>Edit Farmer</h3>${farmer.lastUpdated ? `<div style="font-size: 12px; color: #666; font-weight: normal; margin-top: 4px;">Last Updated: ${new Date(farmer.lastUpdated).toLocaleString()} by ${farmer.updatedByName} (${farmer.updatedByRole})</div>` : ""}</div>
                <button class="close-modal">&times;</button>
            </div>
            <form id="editFarmerForm">
                <div class="user-registration-grid">
                    <div class="user-form-left">
                    <h4 style="margin: 16px 0 12px 0; font-size: 14px; font-weight: 600; color: #333;">Personal Information</h4>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 16px;">
                        <div class="form-field">
                            <label for="editFarmerFirstName" class="required">First Name</label>
                            <input type="text" id="editFarmerFirstName" value="${farmer.fullName ? farmer.fullName.split(' ')[0] : ''}" required>
                        </div>
                        <div class="form-field">
                            <label for="editFarmerMiddleName">Middle Name</label>
                            <input type="text" id="editFarmerMiddleName" value="${farmer.fullName && farmer.fullName.split(' ').length > 2 ? farmer.fullName.split(' ').slice(1, -1).join(' ') : ''}">
                        </div>
                        <div class="form-field">
                            <label for="editFarmerLastName" class="required">Last Name</label>
                            <input type="text" id="editFarmerLastName" value="${farmer.fullName ? farmer.fullName.split(' ').slice(-1)[0] : ''}" required>
                        </div>
                        <div class="form-field">
                            <label for="editFarmerSuffix">Suffix</label>
                            <input type="text" id="editFarmerSuffix" placeholder="Jr., Sr., III" value="">
                        </div>
                    </div>
                    <div class="form-field">
                        <label for="editFarmerEmail" class="required">Email</label>
                        <input type="email" id="editFarmerEmail" value="${farmer.email || ""
            }" required>
                    </div>
                    <div class="form-field">
                        <label for="editFarmerPhone" class="required">Phone</label>
                        <input type="tel" id="editFarmerPhone" value="${farmer.phoneNumber || farmer.phone || ""
            }" required>
                    </div>
                    <div class="form-field">
                        <label for="editFarmerAge">Age</label>
                        <input type="number" id="editFarmerAge" min="18" max="100" value="${farmer.age || ""
            }">
                    </div>
                    <div class="form-field">
                        <label for="editFarmerGender">Gender</label>
                        <select id="editFarmerGender">
                            <option value="">Select Gender</option>
                            <option value="male" ${farmer.gender === "male" ? "selected" : ""
            }>Male</option>
                            <option value="female" ${farmer.gender === "female" ? "selected" : ""
            }>Female</option>
                            <option value="other" ${farmer.gender === "other" ? "selected" : ""
            }>Other</option>
                        </select>
                    </div>
                    <div class="form-field">
                        <label for="editFarmerBirthDate">Birth Date</label>
                        <input type="date" id="editFarmerBirthDate" value="${farmer.birthDate || ""
            }">
                    </div>
                    <h4 style="margin: 16px 0 12px 0; font-size: 14px; font-weight: 600; color: #333;">Home Location</h4>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 16px;">
                        <div class="form-field">
                            <label for="editFarmerStreet">Street</label>
                            <input type="text" id="editFarmerStreet" value="">
                        </div>
                        <div class="form-field">
                            <label for="editFarmerPurok">Purok</label>
                            <input type="text" id="editFarmerPurok" value="">
                        </div>
                        <div class="form-field">
                            <label for="editFarmerBarangay" class="required">Barangay</label>
                            <input type="text" id="editFarmerBarangay" value="${farmer.address || ''}" required>
                        </div>
                        <div class="form-field">
                            <label for="editFarmerCity" class="required">City</label>
                            <input type="text" id="editFarmerCity" value="Ormoc" required readonly>
                        </div>
                        <div class="form-field">
                            <label for="editFarmerProvince" class="required">Province</label>
                            <input type="text" id="editFarmerProvince" value="Leyte" required readonly>
                        </div>
                        <div class="form-field">
                            <label for="editFarmerZipCode">Zip Code</label>
                            <input type="text" id="editFarmerZipCode" value="6541" readonly>
                        </div>
                    </div>
                    <h4 style="margin: 16px 0 12px 0; font-size: 14px; font-weight: 600; color: #333;">Farm Information</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
                        <div class="form-field">
                            <label for="editFarmerFarmLocation">Farm Location</label>
                            <textarea id="editFarmerFarmLocation" rows="2">${farmer.farmLocation || ""
            }</textarea>
                        </div>
                        <div class="form-field">
                            <label for="editFarmerFarmSize">Farm Size (hectares)</label>
                            <input type="number" id="editFarmerFarmSize" min="0" step="0.1" value="${farmer.farmSize || ''}">
                        </div>
                    </div>
                    <div class="form-field">
                        <label for="editFarmerBusinessName">Business Name</label>
                        <input type="text" id="editFarmerBusinessName" value="${farmer.businessName || ""
            }">
                    </div>
                    
                    </div>
                    <div class="user-form-right">
                        <div class="form-section">
                            <h4>Valid ID Photos</h4>
                            <p class="form-description">Upload new photos only if you want to replace the current ones</p>
                            <div class="id-photos-grid">
                                <div class="form-field">
                                    <label for="editFarmerIdFront">ID Front Photo</label>
                                    <input type="file" id="editFarmerIdFront" accept="image/*">
                                    <div id="editFarmerIdFrontPreview" class="image-preview"></div>
                                </div>
                                <div class="form-field">
                                    <label for="editFarmerIdBack">ID Back Photo</label>
                                    <input type="file" id="editFarmerIdBack" accept="image/*">
                                    <div id="editFarmerIdBackPreview" class="image-preview"></div>
                                </div>
                            </div>
                            <div class="edit-actions-right">
                                <button type="button" class="secondary-btn" onclick="staffManager.closeModal()">Cancel</button>
                                <button type="submit" class="primary-btn"><i class="fas fa-save"></i> Update Farmer</button>
                            </div>
                        </div>
                    </div>
                </div>
            </form>
        `;

        this.showModal(modalContent);
        // Apply compact styling to reduce height and prevent scrolling
        (function () {
            const modalEl = document.getElementById("modalContent");
            if (modalEl) {
                modalEl.classList.add("uniform-farmer-modal");
                modalEl.classList.add("compact-farmer-edit");
            }
            const overlayEl = document.getElementById("modalOverlay");
            if (overlayEl && !overlayEl.classList.contains("farmer-modal-open")) {
                overlayEl.classList.add("farmer-modal-open");
            }
        })();

        const form = document.getElementById("editFarmerForm");
        form.addEventListener("submit", async (e) => {
            e.preventDefault();
            await this.updateFarmer(farmerId);
        });
    }
    async updateFarmer(farmerId) {
        try {
            // Get Supabase client
            let supabase = null;
            if (typeof window.getSupabaseClient === "function") {
                supabase = window.getSupabaseClient();
            } else if (window.supabaseClient) {
                supabase = window.supabaseClient;
            } else if (typeof window.supabase !== "undefined") {
                const SUPABASE_URL = "https://afkwexvvuxwbpioqnelp.supabase.co";
                const SUPABASE_ANON_KEY =
                    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFma3dleHZ2dXh3YnBpb3FuZWxwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI5MzA3MjcsImV4cCI6MjA3ODUwNjcyN30.7r5j1xfWdJwiRZZm8AcOIaBp9VaXoD2QWE3WrGYZNyM";
                supabase = window.supabase.createClient(
                    SUPABASE_URL,
                    SUPABASE_ANON_KEY
                );
                window.supabaseClient = supabase;
            }

            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            // Get existing farmer data from Supabase to preserve existing ID photos if not updated
            const { data: existingFarmers, error: fetchError } = await supabase
                .from("farmers")
                .select("*")
                .eq("uid", farmerId)
                .single();

            if (fetchError || !existingFarmers) {
                throw new Error(
                    "Farmer not found: " + (fetchError?.message || "Unknown error")
                );
            }

            const existingFarmer = existingFarmers;

            const staffUid =
                sessionStorage.getItem("staffUid") ||
                sessionStorage.getItem("adminUid") ||
                "staff";
            const staffName =
                sessionStorage.getItem("staffName") ||
                sessionStorage.getItem("adminName") ||
                "Staff";
            const staffRole =
                sessionStorage.getItem("staffRole") ||
                (this.isAdmin() ? "Administrator" : "Staff");

            // Read individual name fields and combine
            const firstName = document.getElementById("editFarmerFirstName").value.trim();
            const middleName = document.getElementById("editFarmerMiddleName")?.value?.trim() || "";
            const lastName = document.getElementById("editFarmerLastName").value.trim();
            const suffix = document.getElementById("editFarmerSuffix")?.value?.trim() || "";
            const fullName = [firstName, middleName, lastName, suffix].filter(Boolean).join(" ");

            // Read individual location fields and combine
            const street = document.getElementById("editFarmerStreet")?.value?.trim() || "";
            const purok = document.getElementById("editFarmerPurok")?.value?.trim() || "";
            const barangay = document.getElementById("editFarmerBarangay").value.trim();
            const city = document.getElementById("editFarmerCity").value.trim();
            const province = document.getElementById("editFarmerProvince").value.trim();
            const zipCode = document.getElementById("editFarmerZipCode")?.value?.trim() || "";
            const address = [street, purok, barangay, city, province, zipCode].filter(Boolean).join(", ");

            const formData = {
                fullName: fullName,
                email:
                    document.getElementById("editFarmerEmail")?.value?.trim() || null,
                phoneNumber: document.getElementById("editFarmerPhone").value.trim(),
                age: document.getElementById("editFarmerAge").value
                    ? parseInt(document.getElementById("editFarmerAge").value)
                    : null,
                gender: document.getElementById("editFarmerGender").value || null,
                birthDate: document.getElementById("editFarmerBirthDate").value || null,
                address: address,
                farmLocation:
                    document.getElementById("editFarmerFarmLocation").value.trim() ||
                    null,
                businessName:
                    document.getElementById("editFarmerBusinessName")?.value?.trim() ||
                    null,
                farmSize: document.getElementById("editFarmerFarmSize")?.value
                    ? parseFloat(document.getElementById("editFarmerFarmSize").value)
                    : null,
                updatedAt: Date.now(),
                updatedBy: staffUid,
                updatedByName: staffName,
                updatedByRole: staffRole,
            };

            // Check if new ID photos were uploaded
            const editIdFrontFile = document.getElementById("editFarmerIdFront");
            const editIdBackFile = document.getElementById("editFarmerIdBack");
            const newIdFrontFile = editIdFrontFile ? editIdFrontFile.files[0] : null;
            const newIdBackFile = editIdBackFile ? editIdBackFile.files[0] : null;

            const submitBtn = document.querySelector(
                '#editFarmerForm button[type="submit"]'
            );
            const originalBtnText = submitBtn ? submitBtn.innerHTML : "";

            let idFrontPhoto = existingFarmer.id_front_photo || null;
            let idBackPhoto = existingFarmer.id_back_photo || null;

            // Upload new ID photos if provided
            if (newIdFrontFile) {
                if (submitBtn) {
                    submitBtn.disabled = true;
                    submitBtn.innerHTML =
                        '<i class="fas fa-spinner fa-spin"></i> Uploading front ID photo...';
                }
                try {
                    // Delete all old front photos before uploading new one
                    await FirebaseUtils.deleteOldFarmerIdPhotos(farmerId, "front");
                    idFrontPhoto = await FirebaseUtils.uploadFarmerIdPhoto(
                        newIdFrontFile,
                        farmerId,
                        "front",
                        (pct) => {
                            console.log(`Front ID photo upload: ${Math.round(pct)}%`);
                        }
                    );
                } catch (error) {
                    console.error("Error uploading front ID photo:", error);
                    if (submitBtn) {
                        submitBtn.disabled = false;
                        submitBtn.innerHTML = originalBtnText;
                    }
                    alert("Error uploading front ID photo: " + error.message);
                    return;
                }
            }

            if (newIdBackFile) {
                if (submitBtn) {
                    submitBtn.innerHTML =
                        '<i class="fas fa-spinner fa-spin"></i> Uploading back ID photo...';
                }
                try {
                    // Delete all old back photos before uploading new one
                    await FirebaseUtils.deleteOldFarmerIdPhotos(farmerId, "back");
                    idBackPhoto = await FirebaseUtils.uploadFarmerIdPhoto(
                        newIdBackFile,
                        farmerId,
                        "back",
                        (pct) => {
                            console.log(`Back ID photo upload: ${Math.round(pct)}%`);
                        }
                    );
                } catch (error) {
                    console.error("Error uploading back ID photo:", error);
                    if (submitBtn) {
                        submitBtn.disabled = false;
                        submitBtn.innerHTML = originalBtnText;
                    }
                    alert("Error uploading back ID photo: " + error.message);
                    return;
                }
            }

            // Map form data to Supabase column names
            const updateData = {
                full_name: formData.fullName,
                phone_number: formData.phoneNumber,
                age: formData.age,
                gender: formData.gender,
                birth_date: formData.birthDate || null,
                home_location: formData.address || existingFarmer.home_location,
                farm_location: formData.farmLocation,
                farm_size: formData.farmSize,
                id_front_photo: idFrontPhoto,
                id_back_photo: idBackPhoto,
                id_type: existingFarmer.id_type, // Preserve existing id_type
                updated_at: formData.updatedAt,
                updated_by: formData.updatedBy,
                updated_by_name: formData.updatedByName,
                updated_by_role: formData.updatedByRole,
            };

            // Update farmer in Supabase
            const { error: updateError } = await supabase
                .from("farmers")
                .update(updateData)
                .eq("uid", farmerId);

            if (updateError) {
                throw new Error("Failed to update farmer: " + updateError.message);
            }

            // Restore button state
            if (submitBtn) {
                submitBtn.disabled = false;
                submitBtn.innerHTML = originalBtnText;
            }

            this.closeModal();
            this.showSuccessMessage("Farmer updated successfully");
            this.loadFarmersManagementData();
        } catch (error) {
            console.error("Error updating farmer:", error);
            const submitBtn = document.querySelector(
                '#editFarmerForm button[type="submit"]'
            );
            if (submitBtn) {
                submitBtn.disabled = false;
                submitBtn.innerHTML = '<i class="fas fa-save"></i> Update Farmer';
            }
            alert("Error updating farmer: " + error.message);
        }
    }

    async removeFarmer(farmerId) {
        try {
            if (
                !confirm(
                    "Are you sure you want to permanently delete this farmer? This action cannot be undone and the farmer record will be completely removed from the database."
                )
            ) {
                return;
            }

            console.log("Attempting to permanently delete farmer:", farmerId);
            console.log("Staff UID:", sessionStorage.getItem("staffUid"));
            console.log("Auth method:", sessionStorage.getItem("authMethod"));

            // Get Supabase client
            let supabase = null;
            if (typeof window.getSupabaseClient === "function") {
                supabase = window.getSupabaseClient();
            } else if (window.supabaseClient) {
                supabase = window.supabaseClient;
            } else if (typeof window.supabase !== "undefined") {
                const SUPABASE_URL = "https://afkwexvvuxwbpioqnelp.supabase.co";
                const SUPABASE_ANON_KEY =
                    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFma3dleHZ2dXh3YnBpb3FuZWxwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI5MzA3MjcsImV4cCI6MjA3ODUwNjcyN30.7r5j1xfWdJwiRZZm8AcOIaBp9VaXoD2QWE3WrGYZNyM";
                supabase = window.supabase.createClient(
                    SUPABASE_URL,
                    SUPABASE_ANON_KEY
                );
                window.supabaseClient = supabase;
            }

            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            // Get the farmer data first from Supabase
            const { data: farmer, error: fetchError } = await supabase
                .from("farmers")
                .select("*")
                .eq("uid", farmerId)
                .single();

            if (fetchError || !farmer) {
                alert("Farmer not found!");
                return;
            }

            console.log("Farmer data to delete:", farmer);

            // Delete all ID photos from Supabase storage before removing the farmer record
            try {
                await FirebaseUtils.deleteAllFarmerIdPhotos(farmerId);
                console.log(
                    `Deleted all ID photos from Supabase storage for farmer ${farmerId}`
                );
            } catch (photoError) {
                console.warn("Error deleting farmer photos from Supabase:", photoError);
                // Continue with farmer removal even if photo deletion fails
            }

            // Perform actual deletion from Supabase database
            console.log("Performing actual deletion from database...");

            // Delete from farmers table in Supabase
            const { error: deleteError } = await supabase
                .from("farmers")
                .delete()
                .eq("uid", farmerId);

            if (deleteError) {
                throw new Error("Failed to delete farmer: " + deleteError.message);
            }

            console.log("Farmer record deleted from Supabase farmers table");

            console.log("Farmer deletion completed successfully");
            this.showSuccessMessage("Farmer permanently deleted from database!");

            // Refresh both the farmer list and stats
            await this.loadFarmersManagementData();
            await this.loadStats();
        } catch (error) {
            console.error("Error deleting farmer:", error);
            console.error("Error details:", {
                code: error.code,
                message: error.message,
                stack: error.stack,
            });

            // Provide more specific error messages
            if (error.code === "PERMISSION_DENIED") {
                alert(
                    "Permission denied. Please ensure you are properly authenticated as staff. Try logging out and logging back in."
                );
            } else {
                alert("Error deleting farmer: " + error.message);
            }
        }
    }
    async viewFarmerDetails(farmerId) {
        try {
            // Get Supabase client
            let supabase = null;
            if (typeof window.getSupabaseClient === "function") {
                supabase = window.getSupabaseClient();
            } else if (window.supabaseClient) {
                supabase = window.supabaseClient;
            } else if (typeof window.supabase !== "undefined") {
                const SUPABASE_URL = "https://afkwexvvuxwbpioqnelp.supabase.co";
                const SUPABASE_ANON_KEY =
                    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFma3dleHZ2dXh3YnBpb3FuZWxwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI5MzA3MjcsImV4cCI6MjA3ODUwNjcyN30.7r5j1xfWdJwiRZZm8AcOIaBp9VaXoD2QWE3WrGYZNyM";
                supabase = window.supabase.createClient(
                    SUPABASE_URL,
                    SUPABASE_ANON_KEY
                );
                window.supabaseClient = supabase;
            }

            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            // Load farmer from Supabase
            const { data: farmerData, error } = await supabase
                .from("farmers")
                .select("*")
                .eq("uid", farmerId)
                .single();

            if (error || !farmerData) {
                alert("Farmer not found");
                return;
            }

            // Map Supabase column names to expected format for backward compatibility
            const farmer = {
                uid: farmerData.uid,
                fullName: farmerData.full_name,
                phoneNumber: farmerData.phone_number,
                homeLocation: farmerData.home_location,
                age: farmerData.age,
                gender: farmerData.gender,
                birthDate: farmerData.birth_date,
                farmLocation: farmerData.farm_location,
                farmSize: farmerData.farm_size,
                idType: farmerData.id_type,
                idNumber: farmerData.id_number,
                idFrontPhoto: farmerData.id_front_photo,
                idBackPhoto: farmerData.id_back_photo,
                createdAt: farmerData.created_at, // Map to camelCase for display
                registrationDate: farmerData.created_at, // Also provide as registrationDate for compatibility
                created_at: farmerData.created_at,
                updatedAt: farmerData.updated_at, // Map to camelCase for display
                updated_at: farmerData.updated_at,
                created_by: farmerData.created_by,
                createdByName: farmerData.created_by_name,
                created_by_name: farmerData.created_by_name,
                createdByRole: farmerData.created_by_role,
                created_by_role: farmerData.created_by_role,
                updated_by: farmerData.updated_by,
                updatedBy: farmerData.updated_by,
                updatedByName: farmerData.updated_by_name,
                updated_by_name: farmerData.updated_by_name,
                updatedByRole: farmerData.updated_by_role,
                updated_by_role: farmerData.updated_by_role,
                verified_by: farmerData.verified_by,
                verifiedBy: farmerData.verified_by,
                verifiedByName: farmerData.verified_by_name,
                verified_by_name: farmerData.verified_by_name,
                verifiedByRole: farmerData.verified_by_role,
                verified_by_role: farmerData.verified_by_role,
            };

            // Resolve staff metadata displays
            const registeredByDisplay = formatStaffActionDisplay(
                farmer.created_by_name || farmer.createdByName,
                farmer.created_by_role || farmer.createdByRole,
                farmer.created_by || farmer.createdBy || "Unknown staff"
            );

            let verifiedByDisplay = "";
            if (
                farmer.verified_by_name ||
                farmer.verifiedByName ||
                farmer.verified_by ||
                farmer.verifiedBy ||
                farmer.verified_by_role ||
                farmer.verifiedByRole
            ) {
                verifiedByDisplay = formatStaffActionDisplay(
                    farmer.verified_by_name || farmer.verifiedByName,
                    farmer.verified_by_role || farmer.verifiedByRole,
                    farmer.verified_by || farmer.verifiedBy || "Unknown staff"
                );
            }

            const updatedByNameMeta =
                farmer.updated_by_name || farmer.updatedByName || null;
            const updatedByRoleMeta =
                farmer.updated_by_role || farmer.updatedByRole || null;
            let updatedByDisplay = "";

            if (updatedByNameMeta || updatedByRoleMeta) {
                updatedByDisplay = formatStaffActionDisplay(
                    updatedByNameMeta,
                    updatedByRoleMeta,
                    ""
                );
            }

            if (!updatedByDisplay && farmer.updatedBy) {
                // Fall back to legacy lookup for old records
                try {
                    const staffSnapshot = await dbRefs.staff
                        .child(farmer.updatedBy)
                        .once("value");
                    const staffMember = staffSnapshot.val();
                    if (staffMember && staffMember.fullName) {
                        updatedByDisplay = staffMember.fullName;
                    } else {
                        updatedByDisplay = farmer.updatedBy;
                    }
                } catch (staffError) {
                    console.warn("Could not fetch staff name for updatedBy:", staffError);
                    updatedByDisplay = farmer.updatedBy || "";
                }
            }

            if (!updatedByDisplay && (updatedByNameMeta || updatedByRoleMeta)) {
                updatedByDisplay = formatStaffActionDisplay(
                    updatedByNameMeta,
                    updatedByRoleMeta,
                    "Unknown staff"
                );
            }

            const registrationDateValue =
                farmer.createdAt || farmer.registrationDate || farmer.created_at;
            let registrationDateDisplay = "Not recorded";
            if (registrationDateValue) {
                const regDate =
                    typeof registrationDateValue === "number"
                        ? new Date(registrationDateValue)
                        : new Date(registrationDateValue);
                if (!Number.isNaN(regDate.getTime())) {
                    registrationDateDisplay = regDate.toLocaleString();
                }
            }

            const updatedTimestampRaw = farmer.updatedAt || farmer.updated_at;
            const createdTimestampRaw = farmer.createdAt || farmer.created_at;
            const updatedTimestamp = updatedTimestampRaw
                ? typeof updatedTimestampRaw === "number"
                    ? updatedTimestampRaw
                    : Date.parse(updatedTimestampRaw)
                : null;
            const createdTimestamp = createdTimestampRaw
                ? typeof createdTimestampRaw === "number"
                    ? createdTimestampRaw
                    : Date.parse(createdTimestampRaw)
                : null;
            const hasUpdatedTimestamp = Boolean(
                updatedTimestamp &&
                (!createdTimestamp ||
                    Math.abs(updatedTimestamp - createdTimestamp) > 1000)
            );
            const updatedDateDisplay =
                hasUpdatedTimestamp &&
                    !Number.isNaN(new Date(updatedTimestamp).getTime())
                    ? new Date(updatedTimestamp).toLocaleString()
                    : "";
            const shouldShowUpdatedDate = Boolean(updatedDateDisplay);
            const shouldShowUpdatedBy = Boolean(
                hasUpdatedTimestamp && updatedByDisplay
            );
            const shouldShowVerifiedBy = Boolean(verifiedByDisplay);

            const modalContent = `
                <div class="modal-content scrollable-modal">
                    <div class="modal-header">
                        <h3>Farmer Details</h3>
                        <button class="close-modal" onclick="staffManager.closeModal()">&times;</button>
                    </div>
                    <div style="padding: 24px; overflow-y: auto;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px;">
                            <!-- Left Column - Personal & Location Information -->
                            <div>
                                <!-- Personal Information -->
                                <div style="margin-bottom: 24px;">
                                    <h4 style="margin: 0 0 16px 0; font-size: 16px; font-weight: 600; color: #333; border-bottom: 2px solid #e2e8f0; padding-bottom: 8px;">
                                        <i class="fas fa-user"></i> Personal Information
                                    </h4>
                                    <div style="display: flex; flex-direction: column; gap: 16px;">
                                        <div style="display: flex; flex-direction: column; gap: 4px;">
                                            <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Full Name</label>
                                            <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0; font-weight: 600;">${farmer.fullName || "N/A"
                }</div>
                                        </div>
                                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                                            <div style="display: flex; flex-direction: column; gap: 4px;">
                                                <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Phone Number</label>
                                                <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0;">${farmer.phoneNumber || "N/A"
                }</div>
                                            </div>
                                            <div style="display: flex; flex-direction: column; gap: 4px;">
                                                <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Gender</label>
                                                <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0;">${farmer.gender || "N/A"
                }</div>
                                            </div>
                                        </div>
                                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                                            <div style="display: flex; flex-direction: column; gap: 4px;">
                                                <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Birth Date</label>
                                                <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0;">${farmer.birthDate
                    ? new Date(
                        farmer.birthDate
                    ).toLocaleDateString()
                    : "N/A"
                }</div>
                                            </div>
                                            <div style="display: flex; flex-direction: column; gap: 4px;">
                                                <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Age</label>
                                                <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0;">${farmer.age || "N/A"
                }</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Home Location -->
                                <div style="margin-bottom: 24px;">
                                    <h4 style="margin: 0 0 16px 0; font-size: 16px; font-weight: 600; color: #333; border-bottom: 2px solid #e2e8f0; padding-bottom: 8px;">
                                        <i class="fas fa-map-marker-alt"></i> Home Location
                                    </h4>
                                    <div style="display: flex; flex-direction: column; gap: 16px;">
                                        <div style="display: flex; flex-direction: column; gap: 4px;">
                                            <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Full Address</label>
                                            <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0; min-height: 60px; white-space: pre-wrap;">${farmer.homeLocation || "N/A"
                }</div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Farm Information -->
                                <div style="margin-bottom: 24px;">
                                    <h4 style="margin: 0 0 16px 0; font-size: 16px; font-weight: 600; color: #333; border-bottom: 2px solid #e2e8f0; padding-bottom: 8px;">
                                        <i class="fas fa-tractor"></i> Farm Information
                                    </h4>
                                    <div style="display: flex; flex-direction: column; gap: 16px;">
                                        <div style="display: flex; flex-direction: column; gap: 4px;">
                                            <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Farm Location</label>
                                            <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0; min-height: 60px; white-space: pre-wrap;">${farmer.farmLocation || "N/A"
                }</div>
                                        </div>
                                        ${farmer.farmSize
                    ? `
                                        <div style="display: flex; flex-direction: column; gap: 4px;">
                                            <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Farm Size</label>
                                            <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0; font-weight: 600;">${farmer.farmSize} hectares</div>
                                        </div>
                                        `
                    : ""
                }
                                    </div>
                                </div>

                                <!-- Account Information -->
                                <div>
                                    <h4 style="margin: 0 0 16px 0; font-size: 16px; font-weight: 600; color: #333; border-bottom: 2px solid #e2e8f0; padding-bottom: 8px;">
                                        <i class="fas fa-info-circle"></i> Account Information
                                    </h4>
                                    <div style="display: flex; flex-direction: column; gap: 16px;">
                                        <div style="display: flex; flex-direction: column; gap: 4px;">
                                            <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Registration Date</label>
                                            <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0;">${registrationDateDisplay}</div>
                                        </div>
                                        ${registeredByDisplay
                    ? `
                                        <div style="display: flex; flex-direction: column; gap: 4px;">
                                            <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Registered By</label>
                                            <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0;">${registeredByDisplay}</div>
                                        </div>
                                        `
                    : ""
                }
                                        ${shouldShowVerifiedBy
                    ? `
                                        <div style="display: flex; flex-direction: column; gap: 4px;">
                                            
                                        </div>
                                        `
                    : ""
                }
                                        ${shouldShowUpdatedDate
                    ? `
                                        <div style="display: flex; flex-direction: column; gap: 4px;">
                                            <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Last Updated</label>
                                            <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0;">${updatedDateDisplay}</div>
                                        </div>
                                        `
                    : ""
                }
                                        ${shouldShowUpdatedBy
                    ? `
                                        <div style="display: flex; flex-direction: column; gap: 4px;">
                                            <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Last Updated By</label>
                                            <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0;">${updatedByDisplay}</div>
                                        </div>
                                        `
                    : ""
                }
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Right Column - Valid ID Information -->
                            <div>
                                <div style="margin-bottom: 24px;">
                                    <h4 style="margin: 0 0 16px 0; font-size: 16px; font-weight: 600; color: #333; border-bottom: 2px solid #e2e8f0; padding-bottom: 8px;">
                                        <i class="fas fa-id-card"></i> Valid ID Information
                                    </h4>
                                    <div style="display: flex; flex-direction: column; gap: 16px;">
                                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                                            <div style="display: flex; flex-direction: column; gap: 4px;">
                                                <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Valid ID Type</label>
                                                <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0;">${farmer.idType || "N/A"
                }</div>
                                            </div>
                                        </div>
                                        <div style="display: flex; flex-direction: column; gap: 4px;">
                                            <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Valid ID/Paper Reference Number</label>
                                            ${farmer.idNumber && farmer.idNumber.trim() 
                ? `<div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0;">${farmer.idNumber}</div>`
                : ''
                }
                                        </div>
                                        <div>
                                            <label style="display: block; font-size: 12px; font-weight: 600; color: #666; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">Valid ID/Paper Images</label>
                                            ${farmer.idFrontPhoto
                    ? farmer.idFrontPhoto.startsWith(
                        "placeholder_"
                    )
                        ? '<div style="padding: 40px; text-align: center; background: #f8fafc; border: 2px dashed #e2e8f0; border-radius: 8px; color: #999;"><i class="fas fa-image" style="font-size: 32px; margin-bottom: 8px; display: block;"></i>Photo uploaded (pending activation)</div>'
                        : `<img src="${farmer.idFrontPhoto}" alt="ID Front" class="farmer-id-photo" data-image-src="${farmer.idFrontPhoto}" style="width: 100%; max-width: 100%; border-radius: 8px; border: 2px solid #e2e8f0; cursor: pointer; transition: transform 0.2s ease;" onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">`
                    : '<div style="padding: 40px; text-align: center; background: #f8fafc; border: 2px dashed #e2e8f0; border-radius: 8px; color: #999;"><i class="fas fa-image" style="font-size: 32px; margin-bottom: 8px; display: block;"></i>No photo available</div>'
                }
                                        </div>
                                        <div>
                                            <label style="display: block; font-size: 12px; font-weight: 600; color: #666; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">Valid ID/Paper Images</label>
                                            ${farmer.idBackPhoto
                    ? farmer.idBackPhoto.startsWith(
                        "placeholder_"
                    )
                        ? '<div style="padding: 40px; text-align: center; background: #f8fafc; border: 2px dashed #e2e8f0; border-radius: 8px; color: #999;"><i class="fas fa-image" style="font-size: 32px; margin-bottom: 8px; display: block;"></i>Photo uploaded (pending activation)</div>'
                        : `<img src="${farmer.idBackPhoto}" alt="ID Back" class="farmer-id-photo" data-image-src="${farmer.idBackPhoto}" style="width: 100%; max-width: 100%; border-radius: 8px; border: 2px solid #e2e8f0; cursor: pointer; transition: transform 0.2s ease;" onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">`
                    : '<div style="padding: 40px; text-align: center; background: #f8fafc; border: 2px dashed #e2e8f0; border-radius: 8px; color: #999;"><i class="fas fa-image" style="font-size: 32px; margin-bottom: 8px; display: block;"></i>No photo available</div>'
                }
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Action Buttons -->
                        <div style="margin-top: 24px; padding-top: 20px; border-top: 1px solid #e2e8f0; display: flex; gap: 12px; justify-content: flex-end;">
                            <button type="button" class="primary-btn" onclick="staffManager.editFarmer('${farmerId}')">
                                <i class="fas fa-edit"></i> Edit Farmer
                            </button>
                            <button type="button" class="secondary-btn" onclick="staffManager.closeModal()">Close</button>
                        </div>
                    </div>
                </div>
            `;

            this.showModal(modalContent);
            // Add scrollable classes for farmer details view
            (function () {
                const modalEl = document.getElementById("modalContent");
                const overlayEl = document.getElementById("modalOverlay");
                if (modalEl) {
                    modalEl.classList.add("scrollable-modal");
                    if (overlayEl) {
                        overlayEl.classList.add("scrollable-overlay");
                    }
                }
            })();

            // Set up image lightbox handlers for ID photos
            setTimeout(() => {
                const idPhotos = document.querySelectorAll(".farmer-id-photo");
                idPhotos.forEach((img) => {
                    img.addEventListener("click", (e) => {
                        e.stopPropagation();
                        const imageSrc = img.getAttribute("data-image-src");
                        if (imageSrc) {
                            // Create a simple lightbox
                            const lightbox = document.createElement("div");
                            lightbox.style.cssText =
                                "position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 20000; display: flex; align-items: center; justify-content: center; cursor: pointer;";

                            // Create close button
                            const closeBtn = document.createElement("button");
                            closeBtn.innerHTML = "&times;";
                            closeBtn.style.cssText =
                                "position: absolute; top: 20px; right: 30px; font-size: 40px; font-weight: bold; color: white; background: rgba(0,0,0,0.5); border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; z-index: 20001;";
                            closeBtn.onmouseover = () => {
                                closeBtn.style.background = "rgba(255,255,255,0.2)";
                                closeBtn.style.transform = "scale(1.1)";
                            };
                            closeBtn.onmouseout = () => {
                                closeBtn.style.background = "rgba(0,0,0,0.5)";
                                closeBtn.style.transform = "scale(1)";
                            };
                            closeBtn.onclick = (e) => {
                                e.stopPropagation();
                                lightbox.remove();
                            };

                            // Create image container
                            const imageContainer = document.createElement("div");
                            imageContainer.style.cssText =
                                "position: relative; max-width: 90%; max-height: 90%;";
                            const image = document.createElement("img");
                            image.src = imageSrc;
                            image.alt = "ID Photo";
                            image.style.cssText =
                                "max-width: 100%; max-height: 90vh; border-radius: 8px; display: block;";
                            image.onclick = (e) => e.stopPropagation(); // Prevent closing when clicking on image

                            imageContainer.appendChild(image);
                            lightbox.appendChild(closeBtn);
                            lightbox.appendChild(imageContainer);
                            lightbox.onclick = () => lightbox.remove(); // Close when clicking on background
                            document.body.appendChild(lightbox);
                        }
                    });
                });
            }, 100);
        } catch (error) {
            console.error("Error loading farmer details:", error);
            alert("Error loading farmer details: " + error.message);
        }
    }

    async editFarmer(farmerId) {
        try {
            // Get Supabase client
            let supabase = null;
            if (typeof window.getSupabaseClient === "function") {
                supabase = window.getSupabaseClient();
            } else if (window.supabaseClient) {
                supabase = window.supabaseClient;
            } else if (typeof window.supabase !== "undefined") {
                const SUPABASE_URL = "https://afkwexvvuxwbpioqnelp.supabase.co";
                const SUPABASE_ANON_KEY =
                    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFma3dleHZ2dXh3YnBpb3FuZWxwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI5MzA3MjcsImV4cCI6MjA3ODUwNjcyN30.7r5j1xfWdJwiRZZm8AcOIaBp9VaXoD2QWE3WrGYZNyM";
                supabase = window.supabase.createClient(
                    SUPABASE_URL,
                    SUPABASE_ANON_KEY
                );
                window.supabaseClient = supabase;
            }

            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            // Load farmer from Supabase
            const { data: farmerData, error } = await supabase
                .from("farmers")
                .select("*")
                .eq("uid", farmerId)
                .single();

            if (error || !farmerData) {
                alert("Farmer not found");
                return;
            }

            // Helper function to parse full name into components
            const parseFullName = (fullName) => {
                if (!fullName) return { firstName: "", middleName: "", lastName: "", suffix: "" };
                const parts = fullName.trim().split(/\s+/);
                const suffixPattern = /^(Jr\.?|Sr\.?|III|II|IV|I|IIII)$/i;
                
                let firstName = parts[0] || "";
                let middleName = "";
                let lastName = "";
                let suffix = "";
                
                if (parts.length === 1) {
                    lastName = parts[0];
                    firstName = "";
                } else if (parts.length === 2) {
                    firstName = parts[0];
                    lastName = parts[1];
                } else {
                    firstName = parts[0];
                    // Check if last part is a suffix
                    if (suffixPattern.test(parts[parts.length - 1])) {
                        suffix = parts[parts.length - 1];
                        lastName = parts[parts.length - 2];
                        middleName = parts.slice(1, parts.length - 2).join(" ");
                    } else {
                        lastName = parts[parts.length - 1];
                        middleName = parts.slice(1, parts.length - 1).join(" ");
                    }
                }
                
                return { firstName, middleName, lastName, suffix };
            };

            // Helper function to parse home location
            const parseHomeLocation = (homeLocation) => {
                if (!homeLocation) return { street: "", sitio: "", barangay: "", postalCode: "6541", city: "Ormoc", province: "Leyte" };
                
                const parts = homeLocation.split(",").map(p => p.trim());
                let street = "";
                let sitio = "";
                let barangay = "";
                let postalCode = "6541";
                let city = "Ormoc";
                let province = "Leyte";
                
                // Try to extract components
                parts.forEach((part, index) => {
                    const lowerPart = part.toLowerCase();
                    if (lowerPart.includes("sitio")) {
                        sitio = part.replace(/sitio\s*/i, "").trim();
                    } else if (lowerPart === "ormoc" || lowerPart.includes("ormoc")) {
                        city = "Ormoc";
                    } else if (lowerPart === "leyte" || lowerPart.includes("leyte")) {
                        province = "Leyte";
                    } else if (/^\d{4}$/.test(part)) {
                        postalCode = part;
                    } else if (index === 0) {
                        street = part;
                    } else if (!sitio && !barangay && index < parts.length - 3) {
                        barangay = part;
                    }
                });
                
                return { street, sitio, barangay, postalCode, city, province };
            };

            // Parse name and location
            const nameParts = parseFullName(farmerData.full_name);
            const locationParts = parseHomeLocation(farmerData.home_location);

            // Get barangay select HTML
            const barangaySelectHtml = this.renderBarangaySelect(
                "editFarmerHomeBarangay",
                locationParts.barangay || "",
                true
            );

            // Map Supabase column names to expected format
            const farmer = {
                ...nameParts,
                phoneNumber: farmerData.phone_number,
                phone: farmerData.phone_number,
                birthDate: farmerData.birth_date,
                age: farmerData.age,
                gender: farmerData.gender,
                idType: farmerData.id_type,
                idNumber: farmerData.id_number || "",
                farmLocation: farmerData.farm_location,
                ...locationParts,
                idFrontPhoto: farmerData.id_front_photo,
                idBackPhoto: farmerData.id_back_photo,
                farmSize: farmerData.farm_size,
            };

            const modalContent = `
                <div class="modal-content scrollable-modal">
                    <div class="modal-header">
                        <div><h3>Edit Farmer</h3>${farmer.lastUpdated ? `<div style="font-size: 12px; color: #666; font-weight: normal; margin-top: 4px;">Last Updated: ${new Date(farmer.lastUpdated).toLocaleString()} by ${farmer.updatedByName} (${farmer.updatedByRole})</div>` : ""}</div>
                        <button class="close-modal">&times;</button>
                    </div>
                    <form id="editFarmerForm" style="padding: 24px; overflow-y: auto;">
                        <div style="display: flex; flex-direction: column; gap: 24px; max-width: 1200px; margin: 0 auto;">
                            
                            <div class="form-section">
                                <h4 style="margin: 0 0 16px 0; font-size: 16px; font-weight: 600; color: #333; border-bottom: 2px solid #e2e8f0; padding-bottom: 8px;">
                                    <i class="fas fa-user"></i> Personal Information
                                </h4>
                                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px;">
                                    <div class="form-field">
                                        <label for="editFarmerFirstName" class="required">First Name</label>
                                        <input type="text" id="editFarmerFirstName" value="${farmer.firstName || ""}" required>
                                    </div>
                                    <div class="form-field">
                                        <label for="editFarmerMiddleName">Middle Name</label>
                                        <input type="text" id="editFarmerMiddleName" value="${farmer.middleName || ""}">
                                    </div>
                                    <div class="form-field">
                                        <label for="editFarmerLastName" class="required">Last Name</label>
                                        <input type="text" id="editFarmerLastName" value="${farmer.lastName || ""}" required>
                                    </div>
                                    <div class="form-field">
                                        <label for="editFarmerSuffix">Suffix</label>
                                        <input type="text" id="editFarmerSuffix" value="${farmer.suffix || ""}" placeholder="Jr., Sr., III, etc.">
                                    </div>
                                    <div class="form-field">
                                        <label for="editFarmerPhone" class="required">Phone Number</label>
                                        <input type="tel" id="editFarmerPhone" value="${farmer.phoneNumber ||
                farmer.phone ||
                ""
                }" required>
                                    </div>
                                    <div class="form-field">
                                        <label for="editFarmerBirthDate" class="required">Birth Date</label>
                                        <input type="date" id="editFarmerBirthDate" value="${farmer.birthDate || ""
                }" required onchange="staffManager.calculateEditAge()">
                                    </div>
                                    <div class="form-field">
                                        <label for="editFarmerAge">Age</label>
                                        <input type="number" id="editFarmerAge" value="${farmer.age || ""
                }" min="18" max="100" readonly>
                                    </div>
                                    <div class="form-field">
                                        <label for="editFarmerGender">Gender</label>
                                        <select id="editFarmerGender">
                                            <option value="">Select Gender</option>
                                            <option value="Male" ${farmer.gender === "Male"
                    ? "selected"
                    : ""
                }>Male</option>
                                            <option value="Female" ${farmer.gender === "Female"
                    ? "selected"
                    : ""
                }>Female</option>
                                            <option value="Other" ${farmer.gender === "Other" ? "selected" : ""}>Other</option>
                                        </select>
                                    </div>
                                </div>
                            </div>

                            <!-- Home Location Section -->
                            <div class="form-section">
                                <h4 style="margin: 0 0 16px 0; font-size: 16px; font-weight: 600; color: #333; border-bottom: 2px solid #e2e8f0; padding-bottom: 8px;">
                                    <i class="fas fa-map-marker-alt"></i> Home Location
                                </h4>
                                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px;">
                                    <div class="form-field">
                                        <label for="editFarmerHomeStreet">Street</label>
                                        <input type="text" id="editFarmerHomeStreet" value="${farmer.street || ""}">
                                    </div>
                                    <div class="form-field">
                                        <label for="editFarmerHomeSitio">Sitio</label>
                                        <input type="text" id="editFarmerHomeSitio" value="${farmer.sitio || ""}">
                                    </div>
                                    <div class="form-field">
                                        <label for="editFarmerHomeBarangay" class="required">Barangay</label>
                                        ${barangaySelectHtml}
                                    </div>
                                    <div class="form-field">
                                        <label for="editFarmerHomePostalCode">Postal Code</label>
                                        <input type="text" id="editFarmerHomePostalCode" value="${farmer.postalCode || "6541"}" readonly>
                                    </div>
                                    <div class="form-field">
                                        <label for="editFarmerHomeCity" class="required">City</label>
                                        <input type="text" id="editFarmerHomeCity" value="${farmer.city || "Ormoc"}" required readonly>
                                    </div>
                                    <div class="form-field">
                                        <label for="editFarmerHomeProvince" class="required">Province</label>
                                        <input type="text" id="editFarmerHomeProvince" value="${farmer.province || "Leyte"}" required readonly>
                                    </div>
                                </div>
                            </div>

                            <!-- Farm Information Section -->
                            <div class="form-section">
                                <h4 style="margin: 0 0 16px 0; font-size: 16px; font-weight: 600; color: #333; border-bottom: 2px solid #e2e8f0; padding-bottom: 8px;">
                                    <i class="fas fa-tractor"></i> Farm Information
                                </h4>
                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px;">
                                    <div class="form-field">
                                        <label for="editFarmerFarmLocation">Farm Location</label>
                                        <textarea id="editFarmerFarmLocation" rows="3">${farmer.farmLocation || ""}</textarea>
                                    </div>
                                    <div class="form-field">
                                        <label for="editFarmerFarmSize">Farm Size (hectares)</label>
                                        <input type="number" id="editFarmerFarmSize" value="${farmer.farmSize || ""}" min="0" step="0.1">
                                    </div>
                                </div>
                            </div>

                            <!-- Valid ID Information Section -->
                            <div class="form-section">
                                <h4 style="margin: 0 0 16px 0; font-size: 16px; font-weight: 600; color: #333; border-bottom: 2px solid #e2e8f0; padding-bottom: 8px;">
                                    <i class="fas fa-id-card"></i> Valid ID Information
                                </h4>
                                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; margin-bottom: 20px;">
                                    <div class="form-field">
                                        <label for="editFarmerIdType" class="required">Valid ID Type</label>
                                        <select id="editFarmerIdType" required>
                                            <option value="">Select ID Type</option>
                                            <option value="Philippine National ID" ${farmer.idType === "Philippine National ID" ? "selected" : ""}>Philippine National ID</option>
                                            <option value="Driver's License" ${farmer.idType === "Driver's License" ? "selected" : ""}>Driver's License</option>
                                            <option value="Philippine Passport" ${farmer.idType === "Philippine Passport" ? "selected" : ""}>Philippine Passport</option>
                                            <option value="BIR" ${farmer.idType === "BIR" ? "selected" : ""}>BIR</option>
                                            <option value="SSS" ${farmer.idType === "SSS" ? "selected" : ""}>SSS</option>
                                            <option value="GSIS" ${farmer.idType === "GSIS" ? "selected" : ""}>GSIS</option>
                                            <option value="Other" ${farmer.idType === "Other" ? "selected" : ""}>Other</option>
                                        </select>
                                    </div>
                                    <div class="form-field">
                                        <label for="editFarmerIdNumber" style="white-space: nowrap">Valid ID/Paper Reference Number</label>
                                        <input type="text" id="editFarmerIdNumber" value="${farmer.idNumber || ""}">
                                    </div>
                                </div>
                                
                                <p class="form-description" style="margin-bottom: 16px; color: #666; font-size: 14px;">Upload new photos only if you want to replace the current ones</p>
                                <div class="id-photos-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                                    <div class="form-field">
                                        <label for="editFarmerIdFront">Valid ID/Paper Images</label>
                                        <input type="file" id="editFarmerIdFront" accept="image/*">
                                        <div id="editFarmerIdFrontPreview" class="image-preview">
                                            ${farmer.idFrontPhoto && !farmer.idFrontPhoto.startsWith("placeholder_")
                    ? `<img src="${farmer.idFrontPhoto}" alt="Current Front ID" style="max-width: 100%; border-radius: 8px; border: 1px solid #e2e8f0; margin-top: 8px;">`
                    : '<div style="padding: 16px; border: 1px dashed #e2e8f0; border-radius: 8px; color: #888; margin-top: 8px;">Current photo uploaded</div>'
                }
                                        </div>
                                    </div>
                                    <div class="form-field">
                                        <label for="editFarmerIdBack">Valid ID/Paper Images</label>
                                        <input type="file" id="editFarmerIdBack" accept="image/*">
                                        <div id="editFarmerIdBackPreview" class="image-preview">
                                            ${farmer.idBackPhoto && !farmer.idBackPhoto.startsWith("placeholder_")
                    ? `<img src="${farmer.idBackPhoto}" alt="Current Back ID" style="max-width: 100%; border-radius: 8px; border: 1px solid #e2e8f0; margin-top: 8px;">`
                    : '<div style="padding: 16px; border: 1px dashed #e2e8f0; border-radius: 8px; color: #888; margin-top: 8px;">Current photo uploaded</div>'
                }
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="form-actions" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e2e8f0; display: flex; gap: 12px; justify-content: flex-end;">
                            <button type="button" class="secondary-btn" onclick="staffManager.closeModal()">Cancel</button>
                            <button type="submit" class="primary-btn">
                                <i class="fas fa-save"></i> Update Farmer
                            </button>
                        </div>
                    </form>
                </div>
            `;

            this.showModal(modalContent);
            // Use default larger modal styling (no compact farmer-modal class)
            this.setupEditFarmerForm(farmerId);
        } catch (error) {
            console.error("Error loading farmer for editing:", error);
            alert("Error loading farmer for editing: " + error.message);
        }
    }

    calculateEditAge() {
        const birthDate = document.getElementById("editFarmerBirthDate").value;
        const ageInput = document.getElementById("editFarmerAge");

        if (birthDate) {
            const today = new Date();
            const birth = new Date(birthDate);
            let age = today.getFullYear() - birth.getFullYear();
            const monthDiff = today.getMonth() - birth.getMonth();

            if (
                monthDiff < 0 ||
                (monthDiff === 0 && today.getDate() < birth.getDate())
            ) {
                age--;
            }

            ageInput.value = age;
        } else {
            ageInput.value = "";
        }
    }

    setupEditFarmerForm(farmerId) {
        const form = document.getElementById("editFarmerForm");
        const idFrontInput = document.getElementById("editFarmerIdFront");
        const idBackInput = document.getElementById("editFarmerIdBack");
        const frontPreview = document.getElementById("editFarmerIdFrontPreview");
        const backPreview = document.getElementById("editFarmerIdBackPreview");

        // Handle ID photo previews
        idFrontInput.addEventListener("change", (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    frontPreview.innerHTML = `<img src="${e.target.result}" alt="Front ID Preview" style="max-width: 100%; border-radius: 8px; border: 1px solid #e2e8f0; margin-top: 8px;">`;
                };
                reader.readAsDataURL(file);
            }
        });

        idBackInput.addEventListener("change", (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    backPreview.innerHTML = `<img src="${e.target.result}" alt="Back ID Preview" style="max-width: 100%; border-radius: 8px; border: 1px solid #e2e8f0; margin-top: 8px;">`;
                };
                reader.readAsDataURL(file);
            }
        });

        form.addEventListener("submit", async (e) => {
            e.preventDefault();
            await this.updateFarmer(farmerId);
        });
    }

    async updateFarmer(farmerId) {
        try {
            // Get name components
            const firstName = document.getElementById("editFarmerFirstName")?.value?.trim() || "";
            const middleName = document.getElementById("editFarmerMiddleName")?.value?.trim() || "";
            const lastName = document.getElementById("editFarmerLastName")?.value?.trim() || "";
            const suffix = document.getElementById("editFarmerSuffix")?.value?.trim() || "";
            
            // Build full name from components
            let fullName = firstName;
            if (middleName) {
                fullName += " " + middleName;
            }
            fullName += " " + lastName;
            if (suffix) {
                fullName += " " + suffix;
            }
            
            // Get home location components
            const homeStreet = document.getElementById("editFarmerHomeStreet")?.value?.trim() || "";
            const homeSitio = document.getElementById("editFarmerHomeSitio")?.value?.trim() || "";
            const homeBarangay = document.getElementById("editFarmerHomeBarangay")?.value?.trim() || "";
            const homePostalCode = document.getElementById("editFarmerHomePostalCode")?.value?.trim() || "";
            const homeCity = document.getElementById("editFarmerHomeCity")?.value?.trim() || "";
            const homeProvince = document.getElementById("editFarmerHomeProvince")?.value?.trim() || "";
            
            // Build full home location from components
            let fullHomeLocationParts = [];
            if (homeStreet) fullHomeLocationParts.push(homeStreet);
            if (homeSitio) fullHomeLocationParts.push(`Sitio ${homeSitio}`);
            if (homeBarangay) fullHomeLocationParts.push(homeBarangay);
            if (homeCity) fullHomeLocationParts.push(homeCity);
            if (homeProvince) fullHomeLocationParts.push(homeProvince);
            if (homePostalCode) fullHomeLocationParts.push(homePostalCode);
            const fullHomeLocation = fullHomeLocationParts.length > 0 ? fullHomeLocationParts.join(", ") : "";
            
            const formData = {
                fullName: fullName.trim(),
                firstName,
                middleName: middleName || null,
                lastName,
                suffix: suffix || null,
                phoneNumber: document.getElementById("editFarmerPhone")?.value?.trim() || "",
                birthDate: document.getElementById("editFarmerBirthDate")?.value || "",
                age: parseInt(document.getElementById("editFarmerAge")?.value) || 0,
                gender: document.getElementById("editFarmerGender")?.value || "",
                idType: document.getElementById("editFarmerIdType")?.value || "",
                idNumber: document.getElementById("editFarmerIdNumber")?.value?.trim() || null,
                farmLocation: document.getElementById("editFarmerFarmLocation")?.value?.trim() || "",
                homeLocation: fullHomeLocation,
                homeStreet: homeStreet || null,
                homeSitio: homeSitio || null,
                homeBarangay: homeBarangay || null,
                homePostalCode: homePostalCode || null,
                homeCity: homeCity || null,
                homeProvince: homeProvince || null,
                farmSize: parseFloat(document.getElementById("editFarmerFarmSize")?.value) || null,
            };

            // Validate required fields
            if (
                !formData.firstName ||
                !formData.lastName ||
                !formData.phoneNumber ||
                !formData.birthDate ||
                !formData.idType ||
                !formData.homeBarangay
            ) {
                alert("Please fill in all required fields");
                return;
            }

            // Handle ID photos
            const idFrontFile = document.getElementById("editFarmerIdFront").files[0];
            const idBackFile = document.getElementById("editFarmerIdBack").files[0];

            // Get Supabase client
            let supabase = null;
            if (typeof window.getSupabaseClient === "function") {
                supabase = window.getSupabaseClient();
            } else if (window.supabaseClient) {
                supabase = window.supabaseClient;
            } else if (typeof window.supabase !== "undefined") {
                const SUPABASE_URL = "https://afkwexvvuxwbpioqnelp.supabase.co";
                const SUPABASE_ANON_KEY =
                    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFma3dleHZ2dXh3YnBpb3FuZWxwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI5MzA3MjcsImV4cCI6MjA3ODUwNjcyN30.7r5j1xfWdJwiRZZm8AcOIaBp9VaXoD2QWE3WrGYZNyM";
                supabase = window.supabase.createClient(
                    SUPABASE_URL,
                    SUPABASE_ANON_KEY
                );
                window.supabaseClient = supabase;
            }

            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            // Get current farmer data from Supabase to preserve existing photos if not changed
            const { data: currentData, error: fetchError } = await supabase
                .from("farmers")
                .select("*")
                .eq("uid", farmerId)
                .single();

            if (fetchError || !currentData) {
                alert("Farmer record not found");
                return;
            }

            let idFrontPhoto = currentData.id_front_photo || "";
            let idBackPhoto = currentData.id_back_photo || "";

            // Upload new photos to Supabase if provided
            const submitBtn = document.querySelector(
                '#editFarmerForm button[type="submit"]'
            );
            const originalBtnText = submitBtn ? submitBtn.innerHTML : "";

            if (idFrontFile) {
                if (submitBtn) {
                    submitBtn.disabled = true;
                    submitBtn.innerHTML =
                        '<i class="fas fa-spinner fa-spin"></i> Uploading front ID photo...';
                }
                try {
                    // Delete all old front photos before uploading new one
                    await FirebaseUtils.deleteOldFarmerIdPhotos(farmerId, "front");
                    idFrontPhoto = await FirebaseUtils.uploadFarmerIdPhoto(
                        idFrontFile,
                        farmerId,
                        "front",
                        (pct) => {
                            console.log(`Front ID photo upload: ${Math.round(pct)}%`);
                        }
                    );
                } catch (error) {
                    console.error("Error uploading front ID photo:", error);
                    if (submitBtn) {
                        submitBtn.disabled = false;
                        submitBtn.innerHTML = originalBtnText;
                    }
                    alert("Error uploading front ID photo: " + error.message);
                    return;
                }
            }

            if (idBackFile) {
                if (submitBtn) {
                    submitBtn.innerHTML =
                        '<i class="fas fa-spinner fa-spin"></i> Uploading back ID photo...';
                }
                try {
                    // Delete all old back photos before uploading new one
                    await FirebaseUtils.deleteOldFarmerIdPhotos(farmerId, "back");
                    idBackPhoto = await FirebaseUtils.uploadFarmerIdPhoto(
                        idBackFile,
                        farmerId,
                        "back",
                        (pct) => {
                            console.log(`Back ID photo upload: ${Math.round(pct)}%`);
                        }
                    );
                } catch (error) {
                    console.error("Error uploading back ID photo:", error);
                    if (submitBtn) {
                        submitBtn.disabled = false;
                        submitBtn.innerHTML = originalBtnText;
                    }
                    alert("Error uploading back ID photo: " + error.message);
                    return;
                }
            }

            // Restore button state
            if (submitBtn) {
                submitBtn.disabled = false;
                submitBtn.innerHTML = originalBtnText;
            }

            // Map form data to Supabase column names
            const updateData = {
                full_name: formData.fullName,
                phone_number: formData.phoneNumber,
                age: formData.age,
                gender: formData.gender,
                birth_date: formData.birthDate || null,
                home_location: formData.homeLocation,
                farm_location: formData.farmLocation,
                farm_size: formData.farmSize,
                id_front_photo: idFrontPhoto || null,
                id_back_photo: idBackPhoto || null,
                id_type: formData.idType,
                id_number: formData.idNumber,
                updated_at: Date.now(),
                updated_by:
                    sessionStorage.getItem("staffUid") ||
                    sessionStorage.getItem("adminUid") ||
                    "staff",
                updated_by_name: sessionStorage.getItem("username") || "Unknown",
                updated_by_role: sessionStorage.getItem("userRole") || "Staff",
            };

            // Update farmer in Supabase
            const { error: updateError } = await supabase
                .from("farmers")
                .update(updateData)
                .eq("uid", farmerId);

            if (updateError) {
                throw new Error("Failed to update farmer: " + updateError.message);
            }

            this.showSuccessMessage("Farmer updated successfully");
            this.closeModal();
            this.loadFarmersManagementData();
        } catch (error) {
            console.error("Error updating farmer:", error);
            alert("Error updating farmer: " + error.message);
        }
    }
    // Note: uploadFarmerIdPhoto is now handled by FirebaseUtils.uploadFarmerIdPhoto() which uses Supabase
    // This method is kept for backward compatibility but should not be used
    async uploadFarmerIdPhoto(file, path) {
        console.warn(
            "uploadFarmerIdPhoto is deprecated. Use FirebaseUtils.uploadFarmerIdPhoto() instead."
        );
        // Extract farmerId and side from path if needed, or use FirebaseUtils directly
        throw new Error("Please use FirebaseUtils.uploadFarmerIdPhoto() instead");
    }
    showFarmerDetailsModal(farmerId, farmer) {
        const registrationDate = farmer.createdAt
            ? new Date(farmer.createdAt).toLocaleDateString()
            : "N/A";
        const updateDate = farmer.updatedAt
            ? new Date(farmer.updatedAt).toLocaleDateString()
            : "N/A";
        const removalDate = farmer.removedAt
            ? new Date(farmer.removedAt).toLocaleDateString()
            : "N/A";

        const modalContent = `
            <div class="modal-header">
                <h3>Farmer Details</h3>
                <button class="close-modal">&times;</button>
            </div>
            <div class="farmer-details-modal">
                <div class="form-grid">
                    <div class="form-field">
                        <label>Full Name:</label>
                        <p>${farmer.fullName || "N/A"}</p>
                    </div>
                    <div class="form-field">
                        <label>Email:</label>
                        <p>${farmer.email || "N/A"}</p>
                    </div>
                    <div class="form-field">
                        <label>Phone:</label>
                        <p>${farmer.phoneNumber || farmer.phone || "N/A"}</p>
                    </div>
                    <div class="form-field">
                        <label>Age:</label>
                        <p>${farmer.age || "N/A"}</p>
                    </div>
                    <div class="form-field">
                        <label>Gender:</label>
                        <p>${farmer.gender || "N/A"}</p>
                    </div>
                    <div class="form-field">
                        <label>Birth Date:</label>
                        <p>${farmer.birthDate
                ? new Date(farmer.birthDate).toLocaleDateString()
                : "N/A"
            }</p>
                    </div>
                    <div class="form-field full-width">
                        <label>Address:</label>
                        <p>${farmer.address || "N/A"}</p>
                    </div>
                    <div class="form-field full-width">
                        <label>Farm Location:</label>
                        <p>${farmer.farmLocation || "N/A"}</p>
                    </div>
                    <div class="form-field">
                        <label>Business Name:</label>
                        <p>${farmer.businessName || "N/A"}</p>
                    </div>
                    <div class="form-field">
                        <label>Farm Size:</label>
                        <p>${farmer.farmSize
                ? `${farmer.farmSize} hectares`
                : "N/A"
            }</p>
                    </div>
                    <div class="form-field">
                        <label>Verification Status:</label>
                        <p class="status-badge ${farmer.verificationStatus || "pending"
            }">${farmer.verificationStatus || "pending"}</p>
                    </div>
                    <div class="form-field">
                        <label>Account Status:</label>
                        <p class="status-badge ${farmer.status || "active"}">${farmer.status || "active"
            }</p>
                    </div>
                    <div class="form-field">
                        <label>Registration Date:</label>
                        <p>${registrationDate}</p>
                    </div>
                    ${farmer.updatedAt &&
                farmer.createdAt &&
                farmer.updatedAt !== farmer.createdAt
                ? `
                        <div class="form-field">
                            <label>Last Updated:</label>
                            <p>${updateDate}</p>
                        </div>
                    `
                : ""
            }
                    ${farmer.removedAt
                ? `
                        <div class="form-field">
                            <label>Removal Date:</label>
                            <p>${removalDate}</p>
                        </div>
                        <div class="form-field">
                            <label>Removal Reason:</label>
                            <p>${farmer.removalReason || "N/A"}</p>
                        </div>
                    `
                : ""
            }
                </div>
            </div>
            <div class="modal-actions">
                <button class="secondary-btn" onclick="staffManager.closeModal()">Close</button>
            </div>
        `;

        this.showModal(modalContent);
    }

    // Calculate next Friday-Saturday harvest dates
    getNextHarvestDates() {
        const today = new Date();
        const currentDay = today.getDay(); // 0 = Sunday, 5 = Friday, 6 = Saturday

        // Calculate days until next Friday
        let daysUntilFriday = (5 - currentDay + 7) % 7;
        if (daysUntilFriday === 0 && currentDay !== 5) {
            daysUntilFriday = 7; // If it's not Friday, go to next Friday
        }

        const nextFriday = new Date(today);
        nextFriday.setDate(today.getDate() + daysUntilFriday);
        nextFriday.setHours(0, 0, 0, 0);

        const nextSaturday = new Date(nextFriday);
        nextSaturday.setDate(nextFriday.getDate() + 1);

        // Format as YYYY-MM-DD
        const formatDate = (date) => {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, "0");
            const day = String(date.getDate()).padStart(2, "0");
            return `${year}-${month}-${day}`;
        };

        return {
            friday: formatDate(nextFriday),
            saturday: formatDate(nextSaturday),
            fridayDate: nextFriday,
            saturdayDate: nextSaturday,
        };
    }

    // Automatically update product harvest dates to next Friday-Saturday
    async updateProductHarvestDates() {
        try {
            const harvestDates = this.getNextHarvestDates();
            const products = await ProductHelpers.getAllProducts();

            const updates = [];
            let productIndex = 0;

            for (const [id, product] of Object.entries(products)) {
                // Only update active products
                if (product.status === "active" && product.isAvailable !== false) {
                    // Alternate between Friday and Saturday based on product index
                    // This ensures consistent assignment (same product always gets same day of week)
                    const useFriday = productIndex % 2 === 0;
                    const newHarvestDate = useFriday
                        ? harvestDates.friday
                        : harvestDates.saturday;

                    // Only update if harvest date is different or missing
                    const currentHarvestDate =
                        product.harvest_date || product.harvestDate || "";
                    if (currentHarvestDate !== newHarvestDate) {
                        updates.push({
                            id,
                            updates: {
                                harvest_date: newHarvestDate,
                                updated_at: Date.now(),
                            },
                        });
                    }
                    productIndex++;
                }
            }

            // Batch update products
            if (updates.length > 0) {
                const fridayCount = updates.filter(
                    (u) => u.updates.harvest_date === harvestDates.friday
                ).length;
                const saturdayCount = updates.filter(
                    (u) => u.updates.harvest_date === harvestDates.saturday
                ).length;
                console.log(
                    `Updating harvest dates: ${fridayCount} products to Friday (${harvestDates.friday}), ${saturdayCount} products to Saturday (${harvestDates.saturday})`
                );

                for (const { id, updates: updateData } of updates) {
                    try {
                        await ProductHelpers.updateProduct(id, updateData);
                    } catch (error) {
                        console.error(
                            `Error updating harvest date for product ${id}:`,
                            error
                        );
                    }
                }
            }
        } catch (error) {
            console.error("Error updating product harvest dates:", error);
        }
    }

    // Set up periodic harvest date updates (runs every Monday at 12:00 AM)
    setupHarvestDateAutoUpdate() {
        // Update immediately on load
        this.updateProductHarvestDates();

        // Calculate milliseconds until next Monday 12:00 AM
        const now = new Date();
        const currentDay = now.getDay(); // 0 = Sunday, 1 = Monday, etc.

        // Calculate days until next Monday
        let daysUntilMonday = (1 - currentDay + 7) % 7;
        if (daysUntilMonday === 0) {
            // If it's already Monday, check if it's before or after midnight
            const isMondayBeforeMidnight =
                now.getHours() === 0 &&
                now.getMinutes() === 0 &&
                now.getSeconds() === 0;
            if (!isMondayBeforeMidnight) {
                // It's Monday but past midnight, go to next Monday
                daysUntilMonday = 7;
            }
        }

        const nextMonday = new Date(now);
        nextMonday.setDate(now.getDate() + daysUntilMonday);
        nextMonday.setHours(0, 0, 0, 0); // Set to 12:00 AM

        const msUntilMonday = nextMonday.getTime() - now.getTime();

        // Set timeout for first update on next Monday at 12:00 AM, then interval for weekly updates
        setTimeout(() => {
            this.updateProductHarvestDates();
            // Then update every 7 days (weekly on Monday)
            setInterval(() => {
                this.updateProductHarvestDates();
            }, 7 * 24 * 60 * 60 * 1000); // 7 days in milliseconds
        }, msUntilMonday);

        const nextMondayStr = nextMonday.toLocaleString("en-US", {
            weekday: "long",
            year: "numeric",
            month: "long",
            day: "numeric",
            hour: "2-digit",
            minute: "2-digit",
        });
        console.log(
            `Harvest date auto-update scheduled (updates every Monday at 12:00 AM). Next update: ${nextMondayStr}`
        );
    }

    // Calculate cumulative kg sold per product from all orders (cumulative, never resets)
    // Counts orders with status: pending, confirmed, to_receive, out_for_delivery, 
    // pickup_ready, delivered, picked_up, and failed GCash orders
    // Excludes: cancelled orders, confirmed cancellations, and rejected orders
    async calculateCumulativeKgSold() {
        try {
            const orders = await OrderSupabaseAdapter.fetchOrders();
            const kgSoldMap = {};

            // Iterate through all orders
            for (const [orderId, order] of Object.entries(orders)) {
                const status = String(order.status || "").toLowerCase();
                const paymentMethod = String(order.paymentMethod || order.payment_method || "").toLowerCase();

                // Exclude ALL cancelled orders (GCash/Cash) - regardless of refund status
                if (status === "cancelled") {
                    continue;
                }

                // Exclude ALL rejected orders (GCash/Cash)
                if (status === "rejected") {
                    continue;
                }

                // Exclude orders with any cancellation flags (cancellation requested, confirmed, or refunded)
                // This catches orders that might be cancelled but status hasn't been updated yet
                const hasCancellationRequested = order.cancellationRequested === true ||
                    order.cancellation_requested === true;
                const hasCancellationConfirmed = order.cancellationConfirmed === true ||
                    order.cancellation_confirmed === true;
                const hasRefundConfirmed = order.refundConfirmedAt != null ||
                    order.refund_confirmed_at != null;

                if (hasCancellationRequested || hasCancellationConfirmed || hasRefundConfirmed) {
                    continue;
                }

                // Exclude failed cash orders (only failed GCash orders are included)
                if (status === "failed" && paymentMethod !== "gcash") {
                    continue;
                }

                // Count orders with these statuses:
                // - pending, confirmed, to_receive, out_for_delivery, pickup_ready
                // - delivered, picked_up
                // - failed (but only if it's a GCash order - failed cash orders are excluded)
                const validStatuses = [
                    "pending",
                    "confirmed",
                    "to_receive",
                    "out_for_delivery",
                    "pickup_ready",
                    "ready_to_pickup", // Alternative naming
                    "delivered",
                    "picked_up"
                ];

                const isFailedGcash = status === "failed" && paymentMethod === "gcash";
                const isValidStatus = validStatuses.includes(status);

                // Skip if not a valid status and not a failed GCash order
                if (!isValidStatus && !isFailedGcash) {
                    continue;
                }

                // Process order items
                const items = order.items || [];
                if (!Array.isArray(items)) continue;

                for (const item of items) {
                    const productId = item.productId || item.product_id;
                    const quantity = Number(item.quantity || 0);
                    const unit = String(item.unit || "").toLowerCase();

                    // Only count items with unit "kg"
                    if (productId && quantity > 0 && unit === "kg") {
                        if (!kgSoldMap[productId]) {
                            kgSoldMap[productId] = 0;
                        }
                        kgSoldMap[productId] += quantity;
                    }
                }
            }

            return kgSoldMap;
        } catch (error) {
            console.error("Error calculating cumulative kg sold:", error);
            return {};
        }
    }

    async loadProducts(searchTerm = "") {
        try {
            console.log("Loading products...");
            // Update harvest dates automatically before loading
            await this.updateProductHarvestDates();

            // Load all products from Supabase
            const products = await ProductHelpers.getAllProducts();

            // Calculate cumulative kg sold for all products
            const kgSoldMap = await this.calculateCumulativeKgSold();

            const productsGrid = document.getElementById("productsGrid");
            if (!productsGrid) {
                console.error("Products grid container not found");
                return;
            }

            // Check if modal is currently open
            const modalOverlay = document.getElementById("modalOverlay");
            if (modalOverlay && modalOverlay.classList.contains("show")) {
                console.log(
                    "Modal is open, skipping product reload to avoid interference"
                );
                return;
            }

            console.log("Clearing products grid and loading products...");
            productsGrid.innerHTML = "";

            if (Object.keys(products).length === 0) {
                productsGrid.innerHTML =
                    '<p class="no-data">No products found. Add your first product!</p>';
                return;
            }

            // Filter products based on search term
            let filteredProducts = Object.entries(products);
            if (searchTerm.trim()) {
                const searchLower = searchTerm.toLowerCase();
                filteredProducts = filteredProducts.filter(([id, product]) => {
                    return (
                        product.name.toLowerCase().includes(searchLower) ||
                        product.category.toLowerCase().includes(searchLower) ||
                        (product.description &&
                            product.description.toLowerCase().includes(searchLower))
                    );
                });
            }

            if (filteredProducts.length === 0) {
                productsGrid.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #666;">
                        <i class="fas fa-search" style="font-size: 3rem; color: #ddd; margin-bottom: 20px;"></i>
                        <h3>No products found</h3>
                        <p>No products match your search criteria.</p>
                    </div>
                `;
                return;
            }

            // Add bulk delete controls
            const bulkDeleteContainer = document.createElement("div");
            bulkDeleteContainer.className = "bulk-delete-container";
            bulkDeleteContainer.style.cssText = `
                margin-bottom: 20px;
                padding: 15px;
                background: white;
                border-radius: 12px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                display: none;
            `;
            bulkDeleteContainer.innerHTML = `
                <div style="display: flex; align-items: center; gap: 15px;">
                    <span class="selected-count">0 products selected</span>
                    <button class="delete-selected-btn" onclick="staffManager.deleteSelectedProducts()">
                        <i class="fas fa-trash"></i> Delete Selected
                    </button>
                    <button class="select-all-btn" onclick="staffManager.toggleSelectAll()">
                        <i class="fas fa-check-square"></i> Select All
                    </button>
                </div>
            `;
            productsGrid.appendChild(bulkDeleteContainer);

            // Add filtered products directly to the products grid
            filteredProducts.forEach(([id, product]) => {
                const kgSold = kgSoldMap[id] || 0;
                const item = this.createProductCard(id, product, kgSold);
                productsGrid.appendChild(item);
            });

            // Note: Realtime listeners removed - Supabase doesn't support Firebase-style realtime listeners
            // Products will be refreshed on manual actions (create, update, delete)
        } catch (error) {
            console.error("Error loading products:", error);
        }
    }

    handleProductSearch(searchTerm) {
        // Show/hide clear button based on search term
        const clearSearchBtn = document.getElementById("clearSearchBtn");
        if (clearSearchBtn) {
            clearSearchBtn.style.display = searchTerm.trim() ? "block" : "none";
        }

        // Debounce the search to avoid too many API calls
        clearTimeout(this.searchTimeout);
        this.searchTimeout = setTimeout(() => {
            this.loadProducts(searchTerm);
        }, 300);
    }

    clearProductSearch() {
        const searchInput = document.getElementById("productSearchInput");
        const clearSearchBtn = document.getElementById("clearSearchBtn");

        if (searchInput) {
            searchInput.value = "";
        }

        if (clearSearchBtn) {
            clearSearchBtn.style.display = "none";
        }

        // Reload products without search term
        this.loadProducts("");
    }

    createProductCard(id, product, kgSold = 0) {
        const div = document.createElement("div");
        const isActive = (product.status || "active") === "active";
        const isAvailable = product.isAvailable !== false; // Check isAvailable field
        const baseQty = Number(product.availableQuantity ?? product.quantity ?? 0) || 0;
        const isSoldOut = baseQty <= 0 && isAvailable && isActive; // Sold out if quantity is 0 but product is still available and active

        // Apply classes: inactive takes priority over sold out
        let cardClasses = "product-card fade-in";
        if (!isActive) {
            cardClasses += " product-inactive";
        } else if (isSoldOut) {
            cardClasses += " product-sold-out";
        }
        div.className = cardClasses;

        const description = product.description
            ? product.description.length > 60
                ? product.description.substring(0, 60) + "..."
                : product.description
            : "No description available";
        const reservedQty = Number(product.currentReserved ?? 0) || 0;
        // Display availableQuantity directly (it's already decreased when orders are placed)
        // Don't subtract currentReserved as it's already accounted for in availableQuantity
        const shownQty = baseQty;
        const productImageSection = this._buildProductImageSection(id, product, {
            variant: "card",
        });

        div.innerHTML = `
            <div class="product-selection">
                <input type="checkbox" class="product-checkbox" data-product-id="${id}" onchange="staffManager.updateDeleteSelection()">
                <label class="checkbox-label"></label>
            </div>
            <div class="product-status ${isActive ? "status-active" : "status-inactive"
            }">
                ${isActive ? "Active" : "Inactive"}
            </div>
            ${isSoldOut ? '<div class="product-status status-sold-out" style="top: 10px; right: 10px;">Sold Out</div>' : ''}
            <div class="product-menu">
                <button class="product-menu-btn" onclick="staffManager.toggleProductMenu('${id}')" title="More options">
                    <i class="fas fa-ellipsis-v"></i>
                </button>
                <div class="product-menu-dropdown" id="menu-${id}">
                    <div class="menu-item" onclick="staffManager.viewProductDetails('${id}')">
                        <i class="fas fa-eye"></i>
                        <span>View</span>
                    </div>
                    <div class="menu-item" onclick="staffManager.editProduct('${id}')">
                        <i class="fas fa-edit"></i>
                        <span>Edit</span>
                    </div>
                    <div class="menu-item" onclick="staffManager.toggleProductAvailability('${id}', ${isActive})">
                        <i class="fas ${isActive ? "fa-ban" : "fa-check"}"></i>
                        <span>${isActive ? "Unavailable" : "Available"}</span>
                    </div>
                    <div class="menu-item delete-item" onclick="staffManager.deleteProduct('${id}')">
                        <i class="fas fa-trash"></i>
                        <span>Remove</span>
                    </div>
                </div>
            </div>
            ${productImageSection}
            <div class="product-info">
                <h4>${product.name}</h4>
                <div class="product-details">
                    <p><i class="fas fa-tag" style="color: #3498db; margin-right: 6px;"></i><strong>Category:</strong> ${product.category
            }</p>
                    <p><i class="fas fa-boxes" style="color: #e67e22; margin-right: 6px;"></i><strong>Qty:</strong> ${shownQty} ${product.unit || ""
            }${reservedQty > 0
                ? ' <span style="color:#e67e22;font-size:0.85rem;">(reserved ' +
                reservedQty +
                ")</span>"
                : ""
            }</p>
                    <p><i class="fas fa-chart-line" style="color: #27ae60; margin-right: 6px;"></i><strong>Sold:</strong> ${kgSold.toFixed(1)} kg</p>
                    <p><i class="fas fa-calendar-alt" style="color: #9b59b6; margin-right: 6px;"></i><strong>Harvest:</strong> ${new Date(
                product.harvestDate
            ).toLocaleDateString()}</p>
                    <p style="margin-top: 8px; font-style: italic; color: #95a5a6; font-size: 0.85rem;">${description}</p>
                </div>
                <div class="product-price">â‚±${product.price.toLocaleString()}</div>
            </div>
        `;

        this._initializeCarouselsWithin(div);

        return div;
    }

    _buildProductImageSection(id, product, options = {}) {
        const images = this._collectProductImages(product);
        const videos = this._collectProductVideos(product);
        const allMedia = [...images, ...videos];
        const wrapperClasses = ["product-image"];
        if (options.wrapperClass) {
            wrapperClasses.push(options.wrapperClass);
        }
        if (allMedia.length) {
            wrapperClasses.push("has-image");
        }

        if (!allMedia.length) {
            return `
                <div class="${wrapperClasses.join(" ")}">
                    <div class="product-image-placeholder">
                        <i class="fas fa-image"></i>
                        <span>No Image</span>
                    </div>
                </div>
            `;
        }

        const variant = options.variant || "card";
        const showControls = allMedia.length > 1;

        // Create slides for images and videos
        const slides = [];
        let slideIndex = 0;

        // Add image slides
        images.forEach((url, index) => {
            slides.push(`
                <div class="product-image-slide ${slideIndex === 0 ? "active" : ""
                }" data-index="${slideIndex}" data-type="image" aria-hidden="${slideIndex === 0 ? "false" : "true"
                }">
                    <img src="${url}" alt="${product.name} image ${index + 1}">
                </div>
            `);
            slideIndex++;
        });

        // Add video slides
        videos.forEach((url, index) => {
            slides.push(`
                <div class="product-image-slide ${slideIndex === 0 ? "active" : ""
                }" data-index="${slideIndex}" data-type="video" aria-hidden="${slideIndex === 0 ? "false" : "true"
                }">
                    <video src="${url}" controls muted playsinline style="width: 100%; height: 100%; object-fit: cover;">
                        Your browser does not support the video tag.
                    </video>
                </div>
            `);
            slideIndex++;
        });

        const dots = showControls
            ? `
            <div class="product-carousel-dots">
                ${allMedia
                .map(
                    (_, index) => `
                    <button type="button" class="product-carousel-dot ${index === 0 ? "active" : ""
                        }" data-index="${index}" aria-label="View media ${index + 1
                        }"></button>
                `
                )
                .join("")}
            </div>
        `
            : "";

        const controls = showControls
            ? `
            <button type="button" class="product-carousel-btn prev" aria-label="Previous media">
                <i class="fas fa-chevron-left"></i>
            </button>
            <button type="button" class="product-carousel-btn next" aria-label="Next media">
                <i class="fas fa-chevron-right"></i>
            </button>
        `
            : "";

        return `
            <div class="${wrapperClasses.join(" ")}">
                <div class="product-image-carousel ${variant === "modal" ? "product-image-carousel--modal" : ""
            }" data-product-id="${id}" data-variant="${variant}">
                    <div class="product-image-track">
                        ${slides.join("")}
                    </div>
                    ${controls}
                    ${dots}
                </div>
            </div>
        `;
    }

    _collectProductImages(product) {
        const collected = [];
        const add = (value) => {
            if (!value) return;
            if (Array.isArray(value)) {
                value.forEach(add);
                return;
            }
            if (typeof value === "object") {
                Object.values(value).forEach(add);
                return;
            }
            if (typeof value === "string") {
                const trimmed = value.trim();
                if (trimmed) {
                    collected.push(trimmed);
                }
            }
        };

        add(product.imageUrls);
        add(product.images);
        add(product.photos);
        add(product.imageUrl);
        add(product.image_url);

        return [...new Set(collected)].slice(0, 5);
    }

    _collectProductVideos(product) {
        const collected = [];
        const add = (value) => {
            if (!value) return;
            if (Array.isArray(value)) {
                value.forEach(add);
                return;
            }
            if (typeof value === "object") {
                Object.values(value).forEach(add);
                return;
            }
            if (typeof value === "string") {
                const trimmed = value.trim();
                if (trimmed) {
                    collected.push(trimmed);
                }
            }
        };

        add(product.videoUrls);
        add(product.videos);
        add(product.videoUrl);
        add(product.video_url);

        return [...new Set(collected)].slice(0, 2);
    }

    _initializeCarouselsWithin(root) {
        if (!root) return;
        const carousels = root.querySelectorAll(".product-image-carousel");
        carousels.forEach((carousel) => {
            if (carousel.dataset.carouselBound === "true") {
                return;
            }
            carousel.dataset.carouselBound = "true";
            const slides = carousel.querySelectorAll(".product-image-slide");
            if (slides.length <= 1) {
                return;
            }

            const prevBtn = carousel.querySelector(".product-carousel-btn.prev");
            const nextBtn = carousel.querySelector(".product-carousel-btn.next");
            const dots = carousel.querySelectorAll(".product-carousel-dot");

            if (prevBtn) {
                prevBtn.addEventListener("click", () =>
                    this._shiftProductCarousel(carousel, -1)
                );
            }
            if (nextBtn) {
                nextBtn.addEventListener("click", () =>
                    this._shiftProductCarousel(carousel, 1)
                );
            }
            dots.forEach((dot) => {
                dot.addEventListener("click", () => {
                    const index = Number(dot.dataset.index) || 0;
                    this._setProductCarouselSlide(carousel, index);
                });
            });
        });
    }

    _shiftProductCarousel(carousel, direction = 1) {
        const slides = carousel.querySelectorAll(".product-image-slide");
        if (!slides.length) {
            return;
        }
        const currentIndex = Array.from(slides).findIndex((slide) =>
            slide.classList.contains("active")
        );
        const nextIndex =
            (currentIndex + direction + slides.length) % slides.length;
        this._setProductCarouselSlide(carousel, nextIndex);
    }

    _setProductCarouselSlide(carousel, targetIndex) {
        const slides = carousel.querySelectorAll(".product-image-slide");
        if (!slides.length) return;

        const dots = carousel.querySelectorAll(".product-carousel-dot");
        const safeIndex = Math.max(0, Math.min(targetIndex, slides.length - 1));

        slides.forEach((slide, index) => {
            const isActive = index === safeIndex;
            slide.classList.toggle("active", isActive);
            slide.setAttribute("aria-hidden", isActive ? "false" : "true");

            // Pause videos when they're not active
            if (slide.dataset.type === "video") {
                const video = slide.querySelector("video");
                if (video) {
                    if (isActive) {
                        // Video is now active - user can play it manually via controls
                    } else {
                        video.pause();
                    }
                }
            }
        });

        dots.forEach((dot, index) => {
            dot.classList.toggle("active", index === safeIndex);
        });

        carousel.dataset.activeIndex = safeIndex;
    }
    toggleProductMenu(id) {
        // Close all other menus first
        document.querySelectorAll(".product-menu-dropdown").forEach((menu) => {
            if (menu.id !== `menu-${id}`) {
                menu.classList.remove("show");
            }
        });

        // Toggle the current menu
        const menu = document.getElementById(`menu-${id}`);
        if (menu) {
            menu.classList.toggle("show");
        }
    }

    // Close menus when clicking outside
    closeAllMenus() {
        document.querySelectorAll(".product-menu-dropdown").forEach((menu) => {
            menu.classList.remove("show");
        });
    }

    // Initialize event listeners for menu functionality
    initializeMenuListeners() {
        // Close menus when clicking outside
        document.addEventListener("click", (e) => {
            if (!e.target.closest(".product-menu")) {
                this.closeAllMenus();
            }
        });
    }

    async toggleProductAvailability(id, isActive) {
        try {
            this.closeAllMenus(); // Close menu before action
            await ProductHelpers.updateProduct(id, {
                status: isActive ? "inactive" : "active",
            });
            this.showSuccessMessage(
                `Product ${isActive ? "marked unavailable" : "marked available"}`
            );
            this.loadProducts();
        } catch (error) {
            console.error("Error toggling availability:", error);
            alert("Error updating product: " + error.message);
        }
    }

    async deleteProduct(id) {
        this.closeAllMenus(); // Close menu before action
        if (
            confirm(
                "Are you sure you want to delete this product? This action cannot be undone."
            )
        ) {
            try {
                await ProductHelpers.deleteProduct(id);
                this.showSuccessMessage("Product deleted successfully");
                this.loadProducts();
            } catch (error) {
                console.error("Error deleting product:", error);
                alert("Error deleting product: " + error.message);
            }
        }
    }

    async editProduct(id) {
        try {
            this.closeAllMenus(); // Close menu before action
            const product = await ProductHelpers.getProduct(id);

            if (!product) {
                alert("Product not found");
                return;
            }

            this.showEditProductModal(id, product);
        } catch (error) {
            console.error("Error loading product for editing:", error);
            alert("Error loading product: " + error.message);
        }
    }

    async viewProductDetails(id) {
        try {
            this.closeAllMenus(); // Close menu before action
            const product = await ProductHelpers.getProduct(id);

            if (!product) {
                alert("Product not found");
                return;
            }

            this.showProductDetailsModal(id, product);
        } catch (error) {
            console.error("Error loading product details:", error);
            alert("Error loading product details: " + error.message);
        }
    }
    showEditProductModal(id, product) {
        const modalContent = `
                <div class="modal-header">
                    <h3>Edit Product</h3>
                <button class="close-modal" onclick="window.staffManager.closeModal()">&times;</button>
                </div>
                <form id="editProductForm">
                    <div class="form-grid">
                        <div class="form-field">
                        <label for="editProductName" class="required">Product Name</label>
                            <input type="text" id="editProductName" value="${product.name
            }" required>
                        </div>
                        <div class="form-field">
                        <label for="editProductCategory" class="required">Category</label>
                            <select id="editProductCategory" required>
                                <option value="Vegetables" ${product.category === "Vegetables"
                ? "selected"
                : ""
            }>Vegetables</option>
                                <option value="Fruits" ${product.category === "Fruits"
                ? "selected"
                : ""
            }>Fruits</option>
                                <option value="Grains" ${product.category === "Grains"
                ? "selected"
                : ""
            }>Grains</option>
                                <option value="Dairy" ${product.category === "Dairy" ? "selected" : ""
            }>Dairy</option>
                                <option value="Meat" ${product.category === "Meat" ? "selected" : ""
            }>Meat</option>
                                <option value="Other" ${product.category === "Other" ? "selected" : ""
            }>Other</option>
                            </select>
                        </div>
                        <div class="form-field">
                        <label for="editProductQuantity" class="required">Available Quantity</label>
                        <input type="number" id="editProductQuantity" value="${product.availableQuantity || product.quantity
            }" min="0" required>
                        </div>
                        <div class="form-field">
                        <label for="editProductUnit" class="required">Unit</label>
                            <select id="editProductUnit" required>
                                <option value="kg" ${product.unit === "kg" ? "selected" : ""
            }>Kilograms (kg)</option>
                                <option value="pcs" ${product.unit === "pcs" ? "selected" : ""
            }>Pieces (pcs)</option>
                                <option value="bundle" ${product.unit === "bundle" ? "selected" : ""
            }>Bundle</option>
                                <option value="dozen" ${product.unit === "dozen" ? "selected" : ""
            }>Dozen</option>
                            </select>
                        </div>
                        <div class="form-field">
                        <label for="editProductPrice" class="required">Price per Unit (â‚±)</label>
                        <input type="number" id="editProductPrice" value="${product.price
            }" min="0" step="0.01" required>
                    </div>
                    <div class="form-field">
                        <label for="editProductHarvestDate" class="required">Harvest Date</label>
                            <input type="date" id="editProductHarvestDate" value="${product.harvestDate
            }" required>
                        </div>
                        <div class="form-field full-width">
                        <label for="editProductDescription" class="required">Description</label>
                        <textarea id="editProductDescription" rows="3" required>${product.description || ""
            }</textarea>
                        </div>
                        <div class="form-field">
                        <label for="editProductStatus" class="required">Status</label>
                            <select id="editProductStatus" required>
                                <option value="active" ${(product.status || "active") === "active"
                ? "selected"
                : ""
            }>Active</option>
                                <option value="inactive" ${(product.status || "active") === "inactive"
                ? "selected"
                : ""
            }>Inactive</option>
                            </select>
                        </div>
                    <div class="form-field full-width product-images-action-row" style="display: block !important;">
                        <div class="product-images-left" style="width: 100% !important; max-width: 100% !important;">
                            ${(() => {
                const existingImages =
                    product.imageUrls || product.image_urls || [];
                const existingVideos =
                    product.videoUrls || product.video_urls || [];
                const hasExistingImages =
                    existingImages.length > 0;
                const hasExistingVideos =
                    existingVideos.length > 0;

                return `
                            ${hasExistingImages
                        ? `
                            <label style="color: #333 !important; background: transparent !important; font-weight: 500; margin-bottom: 8px; display: block; padding: 0 !important; border: none !important; pointer-events: none;">Current Product Images</label>
                            <div id="editExistingImagesContainer" style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e0e0e0;">
                                ${existingImages
                            .map(
                                (url, index) => `
                                    <div class="existing-image-item" data-image-url="${url}" style="position: relative; border-radius: 6px; overflow: hidden; border: 2px solid #ddd; background: white; flex: 0 0 auto; width: 120px;">
                                        <img src="${url}" alt="Product Image ${index + 1
                                    }" style="width: 100%; height: 120px; object-fit: cover; display: block; cursor: pointer;" onclick="window.staffManager.showImageLightbox('${url}', 'Product Image ${index + 1
                                    }')">
                                        <button type="button" class="remove-existing-image" data-image-url="${url}" style="position: absolute; top: 5px; right: 5px; background: rgba(220, 53, 69, 0.9); color: white; border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 12px; transition: background 0.2s; z-index: 10;">
                                            <i class="fas fa-times"></i>
                                        </button>
                                        <div style="padding: 3px 6px; font-size: 10px; color: #666; text-align: center; background: #f8f9fa; border-top: 1px solid #e0e0e0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">Image ${index + 1
                                    }</div>
                                    </div>
                                `
                            )
                            .join("")}
                            </div>
                            `
                        : ""
                    }
                            <label style="color: #333 !important; background: transparent !important; font-weight: 500; margin-bottom: 8px; display: block; padding: 0 !important; border: none !important; pointer-events: none;">${hasExistingImages
                        ? "Add New Product Images"
                        : "Product Images"
                    } (up to 5) â€” optional</label>
                            <div style="position: relative; display: inline-block; width: 100%; margin-bottom: 8px;">
                                <input type="file" id="editProductImages" accept="image/*" multiple style="position: absolute; opacity: 0; width: 0; height: 0; overflow: hidden;">
                                <label for="editProductImages" id="editProductImagesButtonLabel" style="display: inline-block; background: linear-gradient(135deg, #4CAF50, #45a049); color: white; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500; transition: all 0.3s ease; box-shadow: 0 2px 4px rgba(76, 175, 80, 0.3); text-align: center; width: 100%; box-sizing: border-box;">
                                    <i class="fas fa-image" style="margin-right: 8px;"></i>Choose Images
                                </label>
                            </div>
                            <small style="display: block; margin-top: 4px; color: #666; font-size: 12px;">Supported: JPG, PNG. Up to 5 images will be uploaded.</small>
                            <div id="editProductImagePreview" style="display: none; margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e0e0e0; width: 100% !important; max-width: 100% !important; box-sizing: border-box;">
                                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                                    <strong style="color: #333; font-size: 13px;">New Image Preview</strong>
                                    <button type="button" id="clearEditImagePreview" style="background: #dc3545; color: white; border: none; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 11px;">Clear All</button>
                                </div>
                                <div id="previewEditImagesContainer" style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: flex-start; width: 100%;"></div>
                            </div>
                            ${hasExistingVideos
                        ? `
                            <label style="color: #333 !important; background: transparent !important; font-weight: 500; margin-top: 20px; margin-bottom: 8px; display: block; padding: 0 !important; border: none !important; pointer-events: none;">Current Product Videos</label>
                            <div id="editExistingVideosContainer" style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e0e0e0;">
                                ${existingVideos
                            .map(
                                (url, index) => `
                                    <div class="existing-video-item" data-video-url="${url}" style="position: relative; border-radius: 6px; overflow: hidden; border: 2px solid #ddd; background: white; flex: 0 0 auto; width: 120px;">
                                        <video src="${url}" style="width: 100%; height: 120px; object-fit: cover; display: block; cursor: pointer;" onclick="this.play(); this.paused ? this.play() : this.pause();"></video>
                                        <button type="button" class="remove-existing-video" data-video-url="${url}" style="position: absolute; top: 5px; right: 5px; background: rgba(220, 53, 69, 0.9); color: white; border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 12px; transition: background 0.2s; z-index: 10;">
                                            <i class="fas fa-times"></i>
                                        </button>
                                        <div style="padding: 3px 6px; font-size: 10px; color: #666; text-align: center; background: #f8f9fa; border-top: 1px solid #e0e0e0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">Video ${index + 1
                                    }</div>
                                    </div>
                                `
                            )
                            .join("")}
                            </div>
                            `
                        : ""
                    }
                            <label style="color: #333 !important; background: transparent !important; font-weight: 500; margin-top: 20px; margin-bottom: 8px; display: block; padding: 0 !important; border: none !important; pointer-events: none;">${hasExistingVideos
                        ? "Add New Product Videos"
                        : "Product Videos"
                    } (up to 2, max 1 minute each) â€” optional</label>
                            <div style="position: relative; display: inline-block; width: 100%; margin-bottom: 8px;">
                                <input type="file" id="editProductVideos" accept="video/*" multiple style="position: absolute; opacity: 0; width: 0; height: 0; overflow: hidden;">
                                <label for="editProductVideos" id="editProductVideosButtonLabel" style="display: inline-block; background: linear-gradient(135deg, #4CAF50, #45a049); color: white; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500; transition: all 0.3s ease; box-shadow: 0 2px 4px rgba(76, 175, 80, 0.3); text-align: center; width: 100%; box-sizing: border-box;">
                                    <i class="fas fa-video" style="margin-right: 8px;"></i>Choose Videos
                                </label>
                            </div>
                            <small style="display: block; margin-top: 4px; color: #666; font-size: 12px;">Supported: MP4, WebM, OGG, MOV. Maximum 2 videos, 1 minute per video.</small>
                            <div id="editProductVideoPreview" style="display: none; margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e0e0e0; width: 100% !important; max-width: 100% !important; box-sizing: border-box;">
                                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                                    <strong style="color: #333; font-size: 13px;">New Video Preview</strong>
                                    <button type="button" id="clearEditVideoPreview" style="background: #dc3545; color: white; border: none; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 11px;">Clear All</button>
                                </div>
                                <div id="previewEditVideosContainer" style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: flex-start; width: 100%;"></div>
                            </div>
                        </div>
                        <div class="product-images-right" style="margin-top: 15px; display: flex; gap: 10px; justify-content: flex-end;">
                            <button type="button" class="secondary-btn cancel-red" onclick="window.staffManager.closeModal()">Cancel</button>
                            <button type="submit" class="primary-btn"><i class="fas fa-save"></i> Update Product</button>
                        </div>
                    </div>
                            `;
            })()}
                </div>
            </form>
        `;

        this.showModal(modalContent);

        // Make modal scrollable for edit product form
        const modalContentEl = document.getElementById("modalContent");
        const modalOverlayEl = document.getElementById("modalOverlay");
        if (modalContentEl) {
            modalContentEl.classList.add("scrollable-modal");
            modalContentEl.style.maxHeight = "90vh";
            modalContentEl.style.overflowY = "auto";
        }
        if (modalOverlayEl) {
            modalOverlayEl.classList.add("scrollable-overlay");
        }

        // Setup image and video preview functionality for edit product
        this.setupEditProductImagePreview(product);
        this.setupEditProductVideoPreview(product);

        // Setup remove handlers for existing images/videos
        setTimeout(() => {
            const removeImageBtns = document.querySelectorAll(
                ".remove-existing-image"
            );
            removeImageBtns.forEach((btn) => {
                btn.addEventListener("click", () => {
                    const imageUrl = btn.dataset.imageUrl;
                    const imageItem = btn.closest(".existing-image-item");
                    if (imageItem) {
                        imageItem.style.opacity = "0.5";
                        imageItem.style.pointerEvents = "none";
                        imageItem.dataset.removed = "true";
                    }
                });
            });

            const removeVideoBtns = document.querySelectorAll(
                ".remove-existing-video"
            );
            removeVideoBtns.forEach((btn) => {
                btn.addEventListener("click", () => {
                    const videoUrl = btn.dataset.videoUrl;
                    const videoItem = btn.closest(".existing-video-item");
                    if (videoItem) {
                        videoItem.style.opacity = "0.5";
                        videoItem.style.pointerEvents = "none";
                        videoItem.dataset.removed = "true";
                    }
                });
            });

            // Style file input button labels on hover
            const imageButtonLabel = document.getElementById(
                "editProductImagesButtonLabel"
            );
            if (imageButtonLabel) {
                imageButtonLabel.onmouseenter = () => {
                    imageButtonLabel.style.background =
                        "linear-gradient(135deg, #45a049, #4CAF50)";
                };
                imageButtonLabel.onmouseleave = () => {
                    imageButtonLabel.style.background =
                        "linear-gradient(135deg, #4CAF50, #45a049)";
                };
            }

            const videoButtonLabel = document.getElementById(
                "editProductVideosButtonLabel"
            );
            if (videoButtonLabel) {
                videoButtonLabel.onmouseenter = () => {
                    videoButtonLabel.style.background =
                        "linear-gradient(135deg, #45a049, #4CAF50)";
                };
                videoButtonLabel.onmouseleave = () => {
                    videoButtonLabel.style.background =
                        "linear-gradient(135deg, #4CAF50, #45a049)";
                };
            }
        }, 100);

        const form = document.getElementById("editProductForm");
        form.addEventListener("submit", async (e) => {
            e.preventDefault();
            const submitBtn = form.querySelector('button[type="submit"]');
            if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.innerHTML =
                    '<i class="fas fa-spinner fa-spin"></i> Updating...';
            }
            try {
                await this.updateProduct(id);
            } finally {
                if (submitBtn) {
                    submitBtn.disabled = false;
                    submitBtn.innerHTML = '<i class="fas fa-save"></i> Update Product';
                }
            }
        });

        // Add event listener to refresh products when modal closes
        const modalOverlay = document.getElementById("modalOverlay");
        if (modalOverlay) {
            const originalCloseModal = this.closeModal.bind(this);
            this.closeModal = () => {
                originalCloseModal();
                // Refresh products after closing edit modal
                setTimeout(() => {
                    this.loadProducts();
                }, 100);
            };
        }
    }
    showProductDetailsModal(id, product) {
        const productImageSection = this._buildProductImageSection(id, product, {
            variant: "modal",
            wrapperClass: "product-image--modal",
        });

        // Get Friday-Saturday harvest dates
        const harvestDates = this.getNextHarvestDates();
        const formatDateSimple = (dateStr) => {
            if (!dateStr) return "";
            try {
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) return dateStr;
                const month = String(date.getMonth() + 1).padStart(2, "0");
                const day = String(date.getDate()).padStart(2, "0");
                const year = date.getFullYear();
                return `${month}/${day}/${year}`;
            } catch (e) {
                return dateStr;
            }
        };

        // Format as Friday-date - Saturday-date
        const harvestDateDisplay = `${formatDateSimple(
            harvestDates.friday
        )} - ${formatDateSimple(harvestDates.saturday)}`;

        const modalContent = `
                <div class="modal-header">
                    <h3>Product Details</h3>
                <button class="close-modal" onclick="window.staffManager.closeModal()">&times;</button>
                </div>
            <div class="product-details-view">
                <div style="display: flex; flex-direction: column; align-items: center; margin-bottom: 30px;">
                    <div class="product-image-large" style="margin: 0 0 20px 0; padding: 0; width: 100%; display: flex; justify-content: center;">
                        ${productImageSection}
                    </div>
                    <div class="product-basic-info" style="width: 100%; text-align: center; margin: 0; padding: 0;">
                        <h2 style="margin: 0 0 15px 0; font-size: 1.8rem; font-weight: 600; color: #2c3e50;">${product.name
            }</h2>
                        <div style="margin: 0 0 10px 0; font-size: 1.1rem; color: #7f8c8d;">${product.category
            }</div>
                        <div style="margin: 0 0 10px 0; display: flex; justify-content: center;">
                            <span class="status-badge ${(product.status || "active") === "active"
                ? "active"
                : "inactive"
            }" style="display: inline-block; padding: 4px 12px; border-radius: 20px; font-size: 0.9rem; font-weight: 500;">${(product.status || "active") === "active" ? "Active" : "Inactive"
            }</span>
                        </div>
                        <div style="margin: 0; font-size: 1.5rem; font-weight: bold; color: #27ae60;">â‚±${product.price.toLocaleString()}</div>
                            </div>
                            </div>
                <div class="form-grid">
                    <div class="form-field">
                        <label>Available Quantity</label>
                        ${(() => {
                const base =
                    Number(
                        product.availableQuantity ?? product.quantity ?? 0
                    ) || 0;
                const res = Number(product.currentReserved ?? 0) || 0;
                return `<input type="text" value="${base} ${product.unit
                    }${res > 0 ? ` (reserved ${res})` : ""
                    }" readonly style="background-color: #f8f9fa; cursor: default;">`;
            })()}
                    </div>
                    <div class="form-field">
                        <label>Harvest Date</label>
                        <input type="text" value="${harvestDateDisplay}" readonly style="background-color: #f8f9fa; cursor: default;">
                    </div>
                    <div class="form-field">
                        <label>Added Date</label>
                        <input type="text" value="${product.createdAt || product.created_at
                ? new Date(
                    product.createdAt || product.created_at
                ).toLocaleDateString()
                : "N/A"
            }" readonly style="background-color: #f8f9fa; cursor: default;">
                        </div>
                    ${(() => {
                const formatDateTime = (timestamp) => {
                    if (!timestamp) return "N/A";
                    const date = new Date(timestamp);
                    return date.toLocaleString("en-US", {
                        month: "short",
                        day: "numeric",
                        year: "numeric",
                        hour: "2-digit",
                        minute: "2-digit",
                    });
                };

                // Added By fields
                const addedByName =
                    product.addedByName || product.added_by_name || "";
                const addedByRole =
                    product.addedByRole || product.added_by_role || "";
                const addedByDisplay =
                    addedByName && addedByRole
                        ? `${addedByName} (${addedByRole})`
                        : addedByName || addedByRole || "Staff";

                // Updated By fields (only show if product has been updated)
                // A product is considered updated only if updated_by_name or updated_by_role is set
                // This is the most reliable indicator since updated_at might be set automatically
                const updatedByName =
                    product.updatedByName || product.updated_by_name || "";
                const updatedByRole =
                    product.updatedByRole || product.updated_by_role || "";

                // Product has been updated if updated_by_name or updated_by_role exists
                // This is more reliable than comparing timestamps since updated_at might be set by DB triggers
                const hasBeenUpdated = !!(updatedByName || updatedByRole);

                const updatedByDisplay =
                    updatedByName && updatedByRole
                        ? `${updatedByName} (${updatedByRole})`
                        : updatedByName || updatedByRole || "Staff";

                const updatedAt = product.updatedAt || product.updated_at;

                return `
                    <div class="form-field">
                        <label>Added By</label>
                        <input type="text" value="${addedByDisplay}" readonly style="background-color: #f8f9fa; cursor: default;">
                    </div>
                    ${hasBeenUpdated ? `
                    <div class="form-field">
                        <label>Updated At</label>
                        <input type="text" value="${formatDateTime(
                    updatedAt
                )}" readonly style="background-color: #f8f9fa; cursor: default;">
                    </div>
                    <div class="form-field">
                        <label>Updated By</label>
                        <input type="text" value="${updatedByDisplay}" readonly style="background-color: #f8f9fa; cursor: default;">
                    </div>
                    ` : ""}`;
            })()}
                    <div class="form-field full-width">
                        <label>Description</label>
                        <textarea rows="3" readonly style="background-color: #f8f9fa; cursor: default; resize: none;">${product.description || "No description available"
            }</textarea>
                    </div>
                </div>
            </div>
        `;

        this.showModal(modalContent);
    }

    async updateProduct(id) {
        try {
            const staffUid =
                sessionStorage.getItem("staffUid") ||
                sessionStorage.getItem("adminUid") ||
                "staff";
            const staffName =
                sessionStorage.getItem("staffName") ||
                sessionStorage.getItem("adminName") ||
                "Staff";
            const staffRole =
                sessionStorage.getItem("staffRole") ||
                (this.isAdmin() ? "Administrator" : "Staff");

            const formData = {
                name: document.getElementById("editProductName").value.trim(),
                category: document.getElementById("editProductCategory").value,
                price: parseFloat(document.getElementById("editProductPrice").value),
                availableQuantity: parseInt(
                    document.getElementById("editProductQuantity").value
                ),
                unit: document.getElementById("editProductUnit").value,
                harvestDate: document.getElementById("editProductHarvestDate").value,
                description: document
                    .getElementById("editProductDescription")
                    .value.trim(),
                status: document.getElementById("editProductStatus").value,
                updatedAt: Date.now(),
                updatedBy: staffUid,
                updatedByName: staffName,
                updatedByRole: staffRole,
            };

            // Validation
            if (
                !formData.name ||
                formData.price <= 0 ||
                formData.availableQuantity < 0
            ) {
                alert("Please fill in all required fields with valid values.");
                return;
            }

            // Get existing product to check current images/videos and quantity
            const existingProduct = (await ProductHelpers.getProduct(id)) || {};
            const existingImages =
                existingProduct.imageUrls || existingProduct.image_urls || [];
            const existingVideos =
                existingProduct.videoUrls || existingProduct.video_urls || [];
            
            // Check if this is a restock (new quantity >= current quantity)
            const currentQuantity = existingProduct.availableQuantity || existingProduct.available_quantity || existingProduct.quantity || 0;
            const newQuantity = formData.availableQuantity;
            const isRestock = newQuantity >= currentQuantity;

            // Get images/videos that were removed (marked with data-removed="true")
            const existingImageItems = document.querySelectorAll(
                ".existing-image-item"
            );
            const existingVideoItems = document.querySelectorAll(
                ".existing-video-item"
            );
            const keptImages = [];
            const keptVideos = [];

            existingImageItems.forEach((item) => {
                if (item.dataset.removed !== "true") {
                    const imageUrl = item.dataset.imageUrl;
                    if (imageUrl) keptImages.push(imageUrl);
                }
            });

            existingVideoItems.forEach((item) => {
                if (item.dataset.removed !== "true") {
                    const videoUrl = item.dataset.videoUrl;
                    if (videoUrl) keptVideos.push(videoUrl);
                }
            });

            // Check if new images were uploaded
            const editImageFiles = document.getElementById("editProductImages");
            const newImageFiles = editImageFiles
                ? Array.from(editImageFiles.files || [])
                : [];

            // Check if new videos were uploaded
            const editVideoFiles = document.getElementById("editProductVideos");
            const newVideoFiles = editVideoFiles
                ? Array.from(editVideoFiles.files || [])
                : [];

            const submitBtn = document.querySelector(
                '#editProductForm button[type="submit"]'
            );
            const formEl = document.getElementById("editProductForm");
            let progressEl = formEl ? formEl.querySelector(".upload-progress") : null;

            if (
                !progressEl &&
                (newImageFiles.length > 0 || newVideoFiles.length > 0)
            ) {
                progressEl = document.createElement("div");
                progressEl.style.cssText =
                    "margin-top:8px;font-size:0.85rem;color:#666;";
                progressEl.className = "upload-progress";
                formEl.appendChild(progressEl);
            }

            // Handle new images
            let newImageUrls = [];
            if (newImageFiles.length > 0) {
                const compressImage = (file, maxDim = 1280, quality = 0.7) =>
                    new Promise((resolve, reject) => {
                        const img = new Image();
                        const url = URL.createObjectURL(file);
                        img.onload = () => {
                            const canvas = document.createElement("canvas");
                            let { width, height } = img;
                            if (width > height && width > maxDim) {
                                height = Math.round(height * (maxDim / width));
                                width = maxDim;
                            } else if (height > maxDim) {
                                width = Math.round(width * (maxDim / height));
                                height = maxDim;
                            }
                            canvas.width = width;
                            canvas.height = height;
                            const ctx = canvas.getContext("2d");
                            ctx.drawImage(img, 0, 0, width, height);
                            const outType =
                                file.type === "image/png" ? "image/png" : "image/jpeg";
                            canvas.toBlob(
                                (blob) => {
                                    URL.revokeObjectURL(url);
                                    if (!blob) return reject(new Error("Compression failed"));
                                    resolve(
                                        new File([blob], file.name.replace(/\s+/g, "_"), {
                                            type: outType,
                                        })
                                    );
                                },
                                outType,
                                outType === "image/jpeg" ? quality : undefined
                            );
                        };
                        img.onerror = () => {
                            URL.revokeObjectURL(url);
                            reject(new Error("Invalid image"));
                        };
                        img.src = url;
                    });

                const limitedFiles = newImageFiles.slice(0, 5);
                const tasks = await Promise.all(
                    limitedFiles.map(async (file, index) => {
                        try {
                            const compressed = await compressImage(file);
                            return { original: file, file: compressed, index };
                        } catch (_) {
                            return { original: file, file, index };
                        }
                    })
                );

                const total = tasks.length;
                let completed = 0;
                let overallPct = 0;
                const updateProgressText = () => {
                    const pctText = overallPct ? ` - ${Math.round(overallPct)}%` : "";
                    if (progressEl)
                        progressEl.textContent = `Uploading images: ${completed}/${total}${pctText}`;
                    if (submitBtn)
                        submitBtn.innerHTML = `<i class=\"fas fa-spinner fa-spin\"></i> Uploading images (${completed}/${total})${pctText}...`;
                };
                updateProgressText();

                const urls = [];
                const queue = tasks.slice();
                const uploadOne = async (item) => {
                    try {
                        const url = await FirebaseUtils.uploadToSupabase(
                            item.file,
                            id,
                            item.index,
                            (pct) => {
                                overallPct = Math.max(overallPct, pct * 0.6);
                                updateProgressText();
                            }
                        );
                        urls[item.index] = url;
                        completed += 1;
                        overallPct = Math.round((completed / total) * 100);
                        updateProgressText();
                    } catch (error) {
                        console.error(`Error uploading image ${item.index}:`, error);
                        completed += 1;
                        updateProgressText();
                        throw error;
                    }
                };
                const worker = async () => {
                    while (queue.length) {
                        const item = queue.shift();
                        await uploadOne(item);
                    }
                };
                const workers = [worker(), worker()];
                await Promise.all(workers);
                newImageUrls = urls.filter((url) => url); // Filter out undefined
            }

            // Handle new videos
            let newVideoUrls = [];
            if (newVideoFiles.length > 0) {
                const limitedVideos = newVideoFiles.slice(0, 2);
                const total = limitedVideos.length;
                let completed = 0;
                const updateProgressText = () => {
                    if (progressEl)
                        progressEl.textContent = `Uploading videos: ${completed}/${total}`;
                    if (submitBtn)
                        submitBtn.innerHTML = `<i class=\"fas fa-spinner fa-spin\"></i> Uploading videos (${completed}/${total})...`;
                };
                updateProgressText();

                const urls = [];
                for (let i = 0; i < limitedVideos.length; i++) {
                    try {
                        const url = await FirebaseUtils.uploadVideoToSupabase(
                            limitedVideos[i],
                            id,
                            i
                        );
                        urls[i] = url;
                        completed += 1;
                        updateProgressText();
                    } catch (error) {
                        console.error(`Error uploading video ${i}:`, error);
                        completed += 1;
                        updateProgressText();
                    }
                }
                newVideoUrls = urls.filter((url) => url);
            }

            // Combine kept images with new images (max 5 total)
            const allImageUrls = [...keptImages, ...newImageUrls].slice(0, 5);
            formData.image_url = allImageUrls[0] || "";
            formData.imageUrls = allImageUrls;
            formData.imageUrl = allImageUrls[0] || "";
            formData.imagesStored = allImageUrls.length > 0;

            // Combine kept videos with new videos (max 2 total)
            const allVideoUrls = [...keptVideos, ...newVideoUrls].slice(0, 2);
            formData.video_url = allVideoUrls[0] || "";
            formData.videoUrls = allVideoUrls;
            formData.videoUrl = allVideoUrls[0] || "";
            formData.videosStored = allVideoUrls.length > 0;

            await ProductHelpers.updateProduct(id, formData);

            // Send notification if product was restocked (new quantity >= current quantity)
            if (isRestock) {
                try {
                    const productName = formData.name || existingProduct.name || "Product";
                    const unit = formData.unit || existingProduct.unit || "kg";
                    const title = "Product Restocked!";
                    const message = `${productName} has been restocked! Now available: ${newQuantity} ${unit}`;
                    
                    console.log(`ðŸ“¢ Attempting to send restock notification for product: ${productName}`);
                    const result = await NotificationHelpers.notifyAllCustomers(
                        title,
                        message,
                        "product_restocked",
                        id
                    );
                    console.log(`âœ… Successfully sent restock notification for product: ${productName}`, result);
                } catch (notificationError) {
                    console.error("âŒ Error: Failed to send restock notification:", notificationError);
                    console.error("âŒ Error details:", notificationError.message || notificationError);
                    // Don't fail the product update if notification fails
                    alert(`Product updated successfully, but notification failed: ${notificationError.message || notificationError}`);
                }
            }

            // Close modal
            this.closeModal();

            this.showSuccessMessage("Product updated successfully");
            this.loadProducts();
        } catch (error) {
            console.error("Error updating product:", error);
            alert("Error updating product: " + error.message);
        }
    }

    updateDeleteSelection() {
        const checkboxes = document.querySelectorAll(".product-checkbox:checked");
        this.selectedProducts.clear();

        checkboxes.forEach((checkbox) => {
            this.selectedProducts.add(checkbox.dataset.productId);
        });

        const bulkDeleteContainer = document.querySelector(
            ".bulk-delete-container"
        );
        const selectedCount = document.querySelector(".selected-count");

        if (this.selectedProducts.size > 0) {
            bulkDeleteContainer.style.display = "block";
            selectedCount.textContent = `${this.selectedProducts.size} product${this.selectedProducts.size !== 1 ? "s" : ""
                } selected`;
        } else {
            bulkDeleteContainer.style.display = "none";
        }
    }

    toggleSelectAll() {
        const checkboxes = document.querySelectorAll(".product-checkbox");
        const selectAllBtn = document.querySelector(".select-all-btn");
        const isAllSelected = checkboxes.length === this.selectedProducts.size;

        if (isAllSelected) {
            // Deselect all
            checkboxes.forEach((checkbox) => {
                checkbox.checked = false;
            });
            this.selectedProducts.clear();
            selectAllBtn.innerHTML = '<i class="fas fa-square"></i> Select All';
        } else {
            // Select all
            checkboxes.forEach((checkbox) => {
                checkbox.checked = true;
                this.selectedProducts.add(checkbox.dataset.productId);
            });
            selectAllBtn.innerHTML =
                '<i class="fas fa-check-square"></i> Deselect All';
        }

        this.updateDeleteSelection();
    }

    async deleteSelectedProducts() {
        if (this.selectedProducts.size === 0) {
            alert("No products selected for deletion.");
            return;
        }

        const selectedCount = this.selectedProducts.size;
        const confirmMessage = `Are you sure you want to delete ${selectedCount} product${selectedCount !== 1 ? "s" : ""
            }? This action cannot be undone.`;

        if (confirm(confirmMessage)) {
            try {
                const deletePromises = Array.from(this.selectedProducts).map((id) =>
                    ProductHelpers.deleteProduct(id)
                );

                await Promise.all(deletePromises);
                this.selectedProducts.clear();
                this.showSuccessMessage(
                    `${selectedCount} product${selectedCount !== 1 ? "s" : ""
                    } deleted successfully`
                );
                this.loadProducts();

                // Hide bulk delete container
                const bulkDeleteContainer = document.querySelector(
                    ".bulk-delete-container"
                );
                if (bulkDeleteContainer) {
                    bulkDeleteContainer.style.display = "none";
                }
            } catch (error) {
                console.error("Error deleting products:", error);
                alert("Error deleting products: " + error.message);
            }
        }
    }

    showAddProductModal() {
        const modalContent = `
            <div class="modal-header">
                <h3>Add New Product</h3>
                <button class="close-modal" onclick="window.staffManager.closeModal()">&times;</button>
            </div>
            <form id="addProductForm" style="padding: 20px;">
                <div class="form-grid">
                    <div class="form-field">
                        <label for="productName" class="required">Product Name</label>
                        <input type="text" id="productName" required>
                    </div>
                    <div class="form-field">
                        <label for="category" class="required">Category</label>
                        <select id="category" required>
                            <option value="Vegetables">Vegetables</option>
                            <option value="Fruits">Fruits</option>
                            <option value="Grains">Grains</option>
                            <option value="Dairy">Dairy</option>
                            <option value="Meat">Meat</option>
                            <option value="Other">Other</option>
                        </select>
                    </div>
                    <div class="form-field">
                        <label for="quantity" class="required">Quantity</label>
                        <input type="number" id="quantity" min="1" required>
                    </div>
                    <div class="form-field">
                        <label for="unit" class="required">Unit</label>
                        <select id="unit" required>
                            <option value="kg">Kilograms (kg)</option>
                            <option value="pcs">Pieces (pcs)</option>
                            <option value="bundle">Bundle</option>
                            <option value="dozen">Dozen</option>
                        </select>
                    </div>
                    <div class="form-field">
                        <label for="price" class="required">Price per Unit (â‚±)</label>
                        <input type="number" id="price" min="0" step="0.01" required>
                    </div>
                    <div class="form-field">
                        <label for="harvestDate" class="required">Harvest Date</label>
                        <div id="harvestDateDisplay" style="padding: 10px; background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 6px; margin-bottom: 8px; font-size: 14px; color: #333;">
                            <span id="harvestDateFriday"></span> - <span id="harvestDateSaturday"></span>
                        </div>
                        <input type="date" id="harvestDate" required style="display: none;">
                        <small style="display: block; margin-top: 4px; color: #666; font-size: 12px;">
                            <i class="fas fa-info-circle"></i> Harvest dates are automatically set to Friday-Saturday (alternating) and updated weekly every Monday at 12:00 AM.
                        </small>
                    </div>
                    <div class="form-field full-width">
                        <label for="description" class="required">Description</label>
                        <textarea id="description" rows="3" required></textarea>
                    </div>
                    <div class="form-field full-width product-images-action-row" style="display: block !important;">
                        <div class="product-images-left" style="width: 100% !important; max-width: 100% !important;">
                            <label style="color: #333 !important; background: transparent !important; font-weight: 500; margin-bottom: 8px; display: block; padding: 0 !important; border: none !important; pointer-events: none;">Product Images (up to 5) â€” optional</label>
                            <div style="position: relative; display: inline-block; width: 100%; margin-bottom: 8px;">
                                <input type="file" id="productImages" accept="image/*" multiple style="position: absolute; opacity: 0; width: 0; height: 0; overflow: hidden;">
                                <label for="productImages" id="productImagesButtonLabel" style="display: inline-block; background: linear-gradient(135deg, #4CAF50, #45a049); color: white; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500; transition: all 0.3s ease; box-shadow: 0 2px 4px rgba(76, 175, 80, 0.3); text-align: center; width: 100%; box-sizing: border-box;">
                                    <i class="fas fa-image" style="margin-right: 8px;"></i>Choose Images
                                </label>
                            </div>
                            <small style="display: block; margin-top: 4px; color: #666; font-size: 12px;">Supported: JPG, PNG. Up to 5 images will be uploaded.</small>
                            <div id="productImagePreview" style="display: none; margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e0e0e0; width: 100% !important; max-width: 100% !important; box-sizing: border-box;">
                                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                                    <strong style="color: #333; font-size: 13px;">Image Preview</strong>
                                    <button type="button" id="clearImagePreview" style="background: #dc3545; color: white; border: none; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 11px;">Clear All</button>
                                </div>
                                <div id="previewImagesContainer" style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: flex-start; width: 100%;"></div>
                            </div>
                            <label style="color: #333 !important; background: transparent !important; font-weight: 500; margin-top: 20px; margin-bottom: 8px; display: block; padding: 0 !important; border: none !important; pointer-events: none;">Product Videos (up to 2, max 1 minute each) â€” optional</label>
                            <div style="position: relative; display: inline-block; width: 100%; margin-bottom: 8px;">
                                <input type="file" id="productVideos" accept="video/*" multiple style="position: absolute; opacity: 0; width: 0; height: 0; overflow: hidden;">
                                <label for="productVideos" id="productVideosButtonLabel" style="display: inline-block; background: linear-gradient(135deg, #4CAF50, #45a049); color: white; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500; transition: all 0.3s ease; box-shadow: 0 2px 4px rgba(76, 175, 80, 0.3); text-align: center; width: 100%; box-sizing: border-box;">
                                    <i class="fas fa-video" style="margin-right: 8px;"></i>Choose Videos
                                </label>
                            </div>
                            <small style="display: block; margin-top: 4px; color: #666; font-size: 12px;">Supported: MP4, WebM, OGG, MOV. Maximum 2 videos, 1 minute per video.</small>
                            <div id="productVideoPreview" style="display: none; margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e0e0e0; width: 100% !important; max-width: 100% !important; box-sizing: border-box;">
                                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                                    <strong style="color: #333; font-size: 13px;">Video Preview</strong>
                                    <button type="button" id="clearVideoPreview" style="background: #dc3545; color: white; border: none; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 11px;">Clear All</button>
                                </div>
                                <div id="previewVideosContainer" style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: flex-start; width: 100%;"></div>
                            </div>
                        </div>
                        <div class="product-images-right" style="margin-top: 15px; display: flex; gap: 10px; justify-content: flex-end;">
                            <button type="button" class="secondary-btn cancel-red" onclick="staffManager.closeModal()">Cancel</button>
                            <button type="submit" class="primary-btn"><i class="fas fa-plus"></i> Add Product</button>
                        </div>
                    </div>
                </div>
            </form>
        `;

        this.showModal(modalContent);

        // Make modal scrollable for add product form
        const modalContentEl = document.getElementById("modalContent");
        const modalOverlayEl = document.getElementById("modalOverlay");
        if (modalContentEl) {
            modalContentEl.classList.add("scrollable-modal");
            modalContentEl.style.maxHeight = "90vh";
            modalContentEl.style.overflowY = "auto";
        }
        if (modalOverlayEl) {
            modalOverlayEl.classList.add("scrollable-overlay");
        }

        // Setup image preview functionality
        this.setupProductImagePreview();

        // Setup video preview functionality
        this.setupProductVideoPreview();

        // Display both Friday and Saturday harvest dates
        const harvestDateInput = document.getElementById("harvestDate");
        const harvestDateFriday = document.getElementById("harvestDateFriday");
        const harvestDateSaturday = document.getElementById("harvestDateSaturday");

        if (harvestDateInput && harvestDateFriday && harvestDateSaturday) {
            const harvestDates = this.getNextHarvestDates();

            // Format dates for display (e.g., "January 15, 2024")
            const formatDateDisplay = (dateStr) => {
                const date = new Date(dateStr + "T00:00:00");
                return date.toLocaleDateString("en-US", {
                    year: "numeric",
                    month: "long",
                    day: "numeric",
                });
            };

            harvestDateFriday.textContent = formatDateDisplay(harvestDates.friday);
            harvestDateSaturday.textContent = formatDateDisplay(
                harvestDates.saturday
            );

            // Set the hidden input to Friday (default for new products)
            harvestDateInput.value = harvestDates.friday;
        }

        // Style the file input button labels on hover (after a short delay to ensure DOM is ready)
        setTimeout(() => {
            // Image button
            const fileInputButtonLabel = document.getElementById(
                "productImagesButtonLabel"
            );
            if (fileInputButtonLabel) {
                fileInputButtonLabel.onmouseenter = () => {
                    fileInputButtonLabel.style.background =
                        "linear-gradient(135deg, #45a049, #4CAF50)";
                    fileInputButtonLabel.style.transform = "translateY(-2px)";
                    fileInputButtonLabel.style.boxShadow =
                        "0 4px 8px rgba(76, 175, 80, 0.4)";
                };
                fileInputButtonLabel.onmouseleave = () => {
                    fileInputButtonLabel.style.background =
                        "linear-gradient(135deg, #4CAF50, #45a049)";
                    fileInputButtonLabel.style.transform = "translateY(0)";
                    fileInputButtonLabel.style.boxShadow =
                        "0 2px 4px rgba(76, 175, 80, 0.3)";
                };
                fileInputButtonLabel.onmousedown = () => {
                    fileInputButtonLabel.style.transform = "translateY(0)";
                };
                fileInputButtonLabel.onmouseup = () => {
                    fileInputButtonLabel.style.transform = "translateY(-2px)";
                };
            }

            // Video button
            const videoInputButtonLabel = document.getElementById(
                "productVideosButtonLabel"
            );
            if (videoInputButtonLabel) {
                videoInputButtonLabel.onmouseenter = () => {
                    videoInputButtonLabel.style.background =
                        "linear-gradient(135deg, #45a049, #4CAF50)";
                    videoInputButtonLabel.style.transform = "translateY(-2px)";
                    videoInputButtonLabel.style.boxShadow =
                        "0 4px 8px rgba(76, 175, 80, 0.4)";
                };
                videoInputButtonLabel.onmouseleave = () => {
                    videoInputButtonLabel.style.background =
                        "linear-gradient(135deg, #4CAF50, #45a049)";
                    videoInputButtonLabel.style.transform = "translateY(0)";
                    videoInputButtonLabel.style.boxShadow =
                        "0 2px 4px rgba(76, 175, 80, 0.3)";
                };
                videoInputButtonLabel.onmousedown = () => {
                    videoInputButtonLabel.style.transform = "translateY(0)";
                };
                videoInputButtonLabel.onmouseup = () => {
                    videoInputButtonLabel.style.transform = "translateY(-2px)";
                };
            }
        }, 100);

        const form = document.getElementById("addProductForm");
        form.addEventListener("submit", async (e) => {
            e.preventDefault();
            const submitBtn = form.querySelector('button[type="submit"]');
            if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.innerHTML =
                    '<i class="fas fa-spinner fa-spin"></i> Adding...';
            }
            try {
                await this.createProduct();
            } finally {
                if (submitBtn) {
                    submitBtn.disabled = false;
                    submitBtn.innerHTML = '<i class="fas fa-plus"></i> Add Product';
                }
            }
        });
    }

    setupProductImagePreview() {
        const fileInput = document.getElementById("productImages");
        const previewContainer = document.getElementById("productImagePreview");
        const previewImagesContainer = document.getElementById(
            "previewImagesContainer"
        );
        const clearPreviewBtn = document.getElementById("clearImagePreview");

        if (!fileInput || !previewContainer || !previewImagesContainer) return;

        // Store current files to preserve them when adding more
        let currentFiles = [];

        // Capture reference to this for lightbox
        const self = this;

        // Function to display image previews
        const displayPreviews = (files) => {
            // Don't clear the container - we'll update it intelligently
            const existingPreviews = Array.from(
                previewImagesContainer.querySelectorAll("[data-file-key]")
            );
            const existingFileKeys = new Set(
                existingPreviews.map((el) => el.dataset.fileKey)
            );

            if (files.length === 0) {
                previewContainer.style.display = "none";
                previewImagesContainer.innerHTML = "";
                return;
            }

            previewContainer.style.display = "block";
            const limitedFiles = Array.from(files).slice(0, 5);
            const newFileKeys = new Set();

            // Process each file
            limitedFiles.forEach((file, index) => {
                if (!file.type.startsWith("image/")) return;

                // Create unique file identifier
                const fileKey = `${file.name}_${file.size}_${file.lastModified}`;
                newFileKeys.add(fileKey);

                // Check if preview already exists for this file
                const existingPreview = previewImagesContainer.querySelector(
                    `[data-file-key="${fileKey}"]`
                );
                if (existingPreview) {
                    // Preview already exists, skip
                    return;
                }

                // Create new preview for this file
                const reader = new FileReader();
                reader.onload = (e) => {
                    const previewItem = document.createElement("div");
                    previewItem.style.cssText =
                        "position: relative; border-radius: 6px; overflow: hidden; border: 2px solid #ddd; background: white; flex: 0 0 auto; width: 120px;";
                    previewItem.dataset.fileKey = fileKey;

                    const img = document.createElement("img");
                    img.src = e.target.result;
                    img.style.cssText =
                        "width: 100%; height: 120px; object-fit: cover; display: block; cursor: pointer; transition: transform 0.2s, opacity 0.2s;";
                    img.alt = `Preview ${index + 1}`;

                    // Add hover effect
                    img.onmouseenter = () => {
                        img.style.transform = "scale(1.05)";
                        img.style.opacity = "0.9";
                        previewItem.style.boxShadow = "0 4px 8px rgba(0,0,0,0.2)";
                    };
                    img.onmouseleave = () => {
                        img.style.transform = "scale(1)";
                        img.style.opacity = "1";
                        previewItem.style.boxShadow = "none";
                    };

                    // Add click handler for lightbox - capture the image source
                    const imageSrc = e.target.result; // Capture from FileReader
                    img.onclick = (clickEvent) => {
                        clickEvent.stopPropagation();
                        self.showImageLightbox(imageSrc, file.name);
                    };

                    const removeBtn = document.createElement("button");
                    removeBtn.type = "button";
                    removeBtn.innerHTML = '<i class="fas fa-times"></i>';
                    removeBtn.style.cssText = `
                        position: absolute;
                        top: 5px;
                        right: 5px;
                        background: rgba(220, 53, 69, 0.9);
                        color: white;
                        border: none;
                        border-radius: 50%;
                        width: 24px;
                        height: 24px;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 12px;
                        transition: background 0.2s;
                        z-index: 10;
                    `;
                    removeBtn.onmouseover = () =>
                        (removeBtn.style.background = "rgba(220, 53, 69, 1)");
                    removeBtn.onmouseout = () =>
                        (removeBtn.style.background = "rgba(220, 53, 69, 0.9)");

                    removeBtn.onclick = () => {
                        // Remove file from input by matching file properties
                        const dt = new DataTransfer();
                        const filesToKeep = Array.from(fileInput.files).filter((f) => {
                            const fKey = `${f.name}_${f.size}_${f.lastModified}`;
                            return fKey !== fileKey;
                        });

                        filesToKeep.forEach((f) => dt.items.add(f));
                        fileInput.files = dt.files;

                        // Update currentFiles array
                        currentFiles = filesToKeep;

                        displayPreviews(fileInput.files);
                    };

                    const fileName = document.createElement("div");
                    fileName.textContent =
                        file.name.length > 12
                            ? file.name.substring(0, 12) + "..."
                            : file.name;
                    fileName.style.cssText =
                        "padding: 3px 6px; font-size: 10px; color: #666; text-align: center; background: #f8f9fa; border-top: 1px solid #e0e0e0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;";

                    previewItem.appendChild(img);
                    previewItem.appendChild(removeBtn);
                    previewItem.appendChild(fileName);
                    previewImagesContainer.appendChild(previewItem);
                };
                reader.readAsDataURL(file);
            });

            // Remove previews for files that are no longer selected
            existingPreviews.forEach((previewEl) => {
                if (!newFileKeys.has(previewEl.dataset.fileKey)) {
                    previewEl.remove();
                }
            });

            // Remove existing warning if any
            const existingWarning =
                previewImagesContainer.querySelector(".image-warning");
            if (existingWarning) {
                existingWarning.remove();
            }

            // Show count if more than 5 files selected
            if (files.length > 5) {
                const warning = document.createElement("div");
                warning.className = "image-warning";
                warning.style.cssText =
                    "margin-top: 8px; padding: 6px; background: #fff3cd; color: #856404; border-radius: 4px; font-size: 11px; text-align: center; width: 100%; flex-basis: 100%;";
                warning.textContent = `âš ï¸ Only the first 5 images will be uploaded (${files.length} selected)`;
                previewImagesContainer.appendChild(warning);
            }
        };

        // Handle file selection - merge with existing files
        fileInput.addEventListener("change", (e) => {
            const newFiles = Array.from(e.target.files || []);
            const existingFileKeys = new Set(
                currentFiles.map((f) => `${f.name}_${f.size}_${f.lastModified}`)
            );

            // Add new files that aren't already in the list
            newFiles.forEach((newFile) => {
                const newFileKey = `${newFile.name}_${newFile.size}_${newFile.lastModified}`;
                if (!existingFileKeys.has(newFileKey)) {
                    currentFiles.push(newFile);
                }
            });

            // Limit to 5 files
            currentFiles = currentFiles.slice(0, 5);

            // Update the file input with merged files
            const dt = new DataTransfer();
            currentFiles.forEach((file) => dt.items.add(file));
            fileInput.files = dt.files;

            // Display all files
            displayPreviews(fileInput.files);
        });

        // Clear all previews
        if (clearPreviewBtn) {
            clearPreviewBtn.onclick = () => {
                fileInput.value = "";
                currentFiles = [];
                displayPreviews([]);
            };
        }
    }

    setupEditProductImagePreview(product) {
        const fileInput = document.getElementById("editProductImages");
        const previewContainer = document.getElementById("editProductImagePreview");
        const previewImagesContainer = document.getElementById(
            "previewEditImagesContainer"
        );
        const clearPreviewBtn = document.getElementById("clearEditImagePreview");

        if (!fileInput || !previewContainer || !previewImagesContainer) return;

        let currentFiles = [];
        const self = this;

        const displayPreviews = (files) => {
            const existingPreviews = Array.from(
                previewImagesContainer.querySelectorAll("[data-file-key]")
            );
            const existingFileKeys = new Set(
                existingPreviews.map((el) => el.dataset.fileKey)
            );

            if (files.length === 0) {
                previewContainer.style.display = "none";
                previewImagesContainer.innerHTML = "";
                return;
            }

            previewContainer.style.display = "block";
            const limitedFiles = Array.from(files).slice(0, 5);
            const newFileKeys = new Set();

            limitedFiles.forEach((file, index) => {
                if (!file.type.startsWith("image/")) return;

                const fileKey = `${file.name}_${file.size}_${file.lastModified}`;
                newFileKeys.add(fileKey);

                const existingPreview = previewImagesContainer.querySelector(
                    `[data-file-key="${fileKey}"]`
                );
                if (existingPreview) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const previewItem = document.createElement("div");
                    previewItem.style.cssText =
                        "position: relative; border-radius: 6px; overflow: hidden; border: 2px solid #ddd; background: white; flex: 0 0 auto; width: 120px;";
                    previewItem.dataset.fileKey = fileKey;

                    const img = document.createElement("img");
                    img.src = e.target.result;
                    img.style.cssText =
                        "width: 100%; height: 120px; object-fit: cover; display: block; cursor: pointer; transition: transform 0.2s, opacity 0.2s;";
                    img.alt = `Preview ${index + 1}`;

                    img.onmouseenter = () => {
                        img.style.transform = "scale(1.05)";
                        img.style.opacity = "0.9";
                        previewItem.style.boxShadow = "0 4px 8px rgba(0,0,0,0.2)";
                    };
                    img.onmouseleave = () => {
                        img.style.transform = "scale(1)";
                        img.style.opacity = "1";
                        previewItem.style.boxShadow = "none";
                    };

                    const imageSrc = e.target.result;
                    img.onclick = (clickEvent) => {
                        clickEvent.stopPropagation();
                        self.showImageLightbox(imageSrc, file.name);
                    };

                    const removeBtn = document.createElement("button");
                    removeBtn.type = "button";
                    removeBtn.innerHTML = '<i class="fas fa-times"></i>';
                    removeBtn.style.cssText = `
                        position: absolute;
                        top: 5px;
                        right: 5px;
                        background: rgba(220, 53, 69, 0.9);
                        color: white;
                        border: none;
                        border-radius: 50%;
                        width: 24px;
                        height: 24px;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 12px;
                        transition: background 0.2s;
                        z-index: 10;
                    `;
                    removeBtn.onmouseover = () =>
                        (removeBtn.style.background = "rgba(220, 53, 69, 1)");
                    removeBtn.onmouseout = () =>
                        (removeBtn.style.background = "rgba(220, 53, 69, 0.9)");

                    removeBtn.onclick = () => {
                        const dt = new DataTransfer();
                        const filesToKeep = Array.from(fileInput.files).filter((f) => {
                            const fKey = `${f.name}_${f.size}_${f.lastModified}`;
                            return fKey !== fileKey;
                        });

                        filesToKeep.forEach((f) => dt.items.add(f));
                        fileInput.files = dt.files;
                        currentFiles = filesToKeep;
                        displayPreviews(fileInput.files);
                    };

                    const fileName = document.createElement("div");
                    fileName.textContent =
                        file.name.length > 12
                            ? file.name.substring(0, 12) + "..."
                            : file.name;
                    fileName.style.cssText =
                        "padding: 3px 6px; font-size: 10px; color: #666; text-align: center; background: #f8f9fa; border-top: 1px solid #e0e0e0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;";

                    previewItem.appendChild(img);
                    previewItem.appendChild(removeBtn);
                    previewItem.appendChild(fileName);
                    previewImagesContainer.appendChild(previewItem);
                };
                reader.readAsDataURL(file);
            });

            existingPreviews.forEach((previewEl) => {
                if (!newFileKeys.has(previewEl.dataset.fileKey)) {
                    previewEl.remove();
                }
            });

            const existingWarning =
                previewImagesContainer.querySelector(".image-warning");
            if (existingWarning) {
                existingWarning.remove();
            }

            if (files.length > 5) {
                const warning = document.createElement("div");
                warning.className = "image-warning";
                warning.style.cssText =
                    "margin-top: 8px; padding: 6px; background: #fff3cd; color: #856404; border-radius: 4px; font-size: 11px; text-align: center; width: 100%; flex-basis: 100%;";
                warning.textContent = `âš ï¸ Only the first 5 images will be uploaded (${files.length} selected)`;
                previewImagesContainer.appendChild(warning);
            }
        };

        fileInput.addEventListener("change", (e) => {
            const newFiles = Array.from(e.target.files || []);
            const existingFileKeys = new Set(
                currentFiles.map((f) => `${f.name}_${f.size}_${f.lastModified}`)
            );

            newFiles.forEach((newFile) => {
                const newFileKey = `${newFile.name}_${newFile.size}_${newFile.lastModified}`;
                if (!existingFileKeys.has(newFileKey)) {
                    currentFiles.push(newFile);
                }
            });

            currentFiles = currentFiles.slice(0, 5);

            const dt = new DataTransfer();
            currentFiles.forEach((file) => dt.items.add(file));
            fileInput.files = dt.files;

            displayPreviews(fileInput.files);
        });

        if (clearPreviewBtn) {
            clearPreviewBtn.onclick = () => {
                fileInput.value = "";
                currentFiles = [];
                displayPreviews([]);
            };
        }
    }

    setupEditProductVideoPreview(product) {
        const fileInput = document.getElementById("editProductVideos");
        const previewContainer = document.getElementById("editProductVideoPreview");
        const previewVideosContainer = document.getElementById(
            "previewEditVideosContainer"
        );
        const clearPreviewBtn = document.getElementById("clearEditVideoPreview");

        if (!fileInput || !previewContainer || !previewVideosContainer) return;

        let currentFiles = [];
        const self = this;

        const displayPreviews = (files) => {
            const existingPreviews = Array.from(
                previewVideosContainer.querySelectorAll("[data-file-key]")
            );
            const existingFileKeys = new Set(
                existingPreviews.map((el) => el.dataset.fileKey)
            );

            if (files.length === 0) {
                previewContainer.style.display = "none";
                previewVideosContainer.innerHTML = "";
                return;
            }

            previewContainer.style.display = "block";
            const limitedFiles = Array.from(files).slice(0, 2);
            const newFileKeys = new Set();

            limitedFiles.forEach((file, index) => {
                if (!file.type.startsWith("video/")) return;

                const fileKey = `${file.name}_${file.size}_${file.lastModified}`;
                newFileKeys.add(fileKey);

                const existingPreview = previewVideosContainer.querySelector(
                    `[data-file-key="${fileKey}"]`
                );
                if (existingPreview) return;

                const video = document.createElement("video");
                video.preload = "metadata";
                const videoUrl = URL.createObjectURL(file);
                video.src = videoUrl;

                video.onloadedmetadata = () => {
                    URL.revokeObjectURL(videoUrl);
                    const duration = video.duration;

                    if (duration > 60) {
                        alert(
                            `Video "${file.name}" exceeds 1 minute (${Math.round(
                                duration
                            )}s). Maximum allowed duration is 60 seconds.`
                        );
                        const dt = new DataTransfer();
                        const filesToKeep = Array.from(fileInput.files).filter((f) => {
                            const fKey = `${f.name}_${f.size}_${f.lastModified}`;
                            return fKey !== fileKey;
                        });
                        filesToKeep.forEach((f) => dt.items.add(f));
                        fileInput.files = dt.files;
                        currentFiles = filesToKeep;
                        displayPreviews(fileInput.files);
                        return;
                    }

                    const durationText = `${Math.round(duration)}s`;

                    const previewItem = document.createElement("div");
                    previewItem.style.cssText =
                        "position: relative; border-radius: 6px; overflow: hidden; border: 2px solid #ddd; background: white; flex: 0 0 auto; width: 180px;";
                    previewItem.dataset.fileKey = fileKey;
                    previewItem.dataset.duration = duration;

                    const videoThumb = document.createElement("video");
                    const thumbUrl = URL.createObjectURL(file);
                    videoThumb.src = thumbUrl;
                    videoThumb.style.cssText =
                        "width: 100%; height: 120px; object-fit: cover; display: block; cursor: pointer;";
                    videoThumb.controls = false;
                    videoThumb.muted = true;

                    const playOverlay = document.createElement("div");
                    playOverlay.innerHTML =
                        '<i class="fas fa-play-circle" style="font-size: 32px; color: rgba(255,255,255,0.9);"></i>';
                    playOverlay.style.cssText = `
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        pointer-events: none;
                    `;

                    videoThumb.onclick = () => {
                        self.showImageLightbox(thumbUrl, file.name);
                    };

                    const removeBtn = document.createElement("button");
                    removeBtn.type = "button";
                    removeBtn.innerHTML = '<i class="fas fa-times"></i>';
                    removeBtn.style.cssText = `
                        position: absolute;
                        top: 5px;
                        right: 5px;
                        background: rgba(220, 53, 69, 0.9);
                        color: white;
                        border: none;
                        border-radius: 50%;
                        width: 24px;
                        height: 24px;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 12px;
                        transition: background 0.2s;
                        z-index: 10;
                    `;
                    removeBtn.onmouseover = () =>
                        (removeBtn.style.background = "rgba(220, 53, 69, 1)");
                    removeBtn.onmouseout = () =>
                        (removeBtn.style.background = "rgba(220, 53, 69, 0.9)");

                    removeBtn.onclick = () => {
                        const dt = new DataTransfer();
                        const filesToKeep = Array.from(fileInput.files).filter((f) => {
                            const fKey = `${f.name}_${f.size}_${f.lastModified}`;
                            return fKey !== fileKey;
                        });

                        filesToKeep.forEach((f) => dt.items.add(f));
                        fileInput.files = dt.files;
                        currentFiles = filesToKeep;
                        displayPreviews(fileInput.files);
                    };

                    const durationBadge = document.createElement("div");
                    durationBadge.textContent = durationText;
                    durationBadge.style.cssText = `
                        position: absolute;
                        bottom: 30px;
                        right: 5px;
                        background: rgba(0, 0, 0, 0.7);
                        color: white;
                        padding: 2px 6px;
                        border-radius: 4px;
                        font-size: 10px;
                        font-weight: 500;
                    `;

                    const fileName = document.createElement("div");
                    fileName.textContent =
                        file.name.length > 20
                            ? file.name.substring(0, 20) + "..."
                            : file.name;
                    fileName.style.cssText =
                        "padding: 3px 6px; font-size: 10px; color: #666; text-align: center; background: #f8f9fa; border-top: 1px solid #e0e0e0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;";

                    const videoWrapper = document.createElement("div");
                    videoWrapper.style.cssText = "position: relative;";
                    videoWrapper.appendChild(videoThumb);
                    videoWrapper.appendChild(playOverlay);
                    videoWrapper.appendChild(durationBadge);

                    previewItem.appendChild(videoWrapper);
                    previewItem.appendChild(removeBtn);
                    previewItem.appendChild(fileName);
                    previewVideosContainer.appendChild(previewItem);
                };

                video.onerror = () => {
                    URL.revokeObjectURL(videoUrl);
                    console.error("Failed to load video metadata");
                };
            });

            existingPreviews.forEach((previewEl) => {
                if (!newFileKeys.has(previewEl.dataset.fileKey)) {
                    previewEl.remove();
                }
            });

            const existingWarning =
                previewVideosContainer.querySelector(".video-warning");
            if (existingWarning) {
                existingWarning.remove();
            }

            if (files.length > 2) {
                const warning = document.createElement("div");
                warning.className = "video-warning";
                warning.style.cssText =
                    "margin-top: 8px; padding: 6px; background: #fff3cd; color: #856404; border-radius: 4px; font-size: 11px; text-align: center; width: 100%; flex-basis: 100%;";
                warning.textContent = `âš ï¸ Only the first 2 videos will be uploaded (${files.length} selected)`;
                previewVideosContainer.appendChild(warning);
            }
        };

        fileInput.addEventListener("change", (e) => {
            const newFiles = Array.from(e.target.files || []);
            const existingFileKeys = new Set(
                currentFiles.map((f) => `${f.name}_${f.size}_${f.lastModified}`)
            );

            newFiles.forEach((newFile) => {
                const newFileKey = `${newFile.name}_${newFile.size}_${newFile.lastModified}`;
                if (!existingFileKeys.has(newFileKey)) {
                    currentFiles.push(newFile);
                }
            });

            currentFiles = currentFiles.slice(0, 2);

            const dt = new DataTransfer();
            currentFiles.forEach((file) => dt.items.add(file));
            fileInput.files = dt.files;

            displayPreviews(fileInput.files);
        });

        if (clearPreviewBtn) {
            clearPreviewBtn.onclick = () => {
                fileInput.value = "";
                currentFiles = [];
                displayPreviews([]);
            };
        }
    }

    // Lightbox function to display full-size image
    showImageLightbox(imageSrc, imageName) {
        const lightboxOverlay = document.createElement("div");
        lightboxOverlay.id = "imageLightboxOverlay";
        lightboxOverlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 20000;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.3s ease;
        `;

        const lightboxContent = document.createElement("div");
        lightboxContent.style.cssText = `
            position: relative;
            max-width: 90%;
            max-height: 90%;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: default;
        `;

        const lightboxImg = document.createElement("img");
        lightboxImg.src = imageSrc;
        lightboxImg.alt = imageName;
        lightboxImg.style.cssText = `
            max-width: 100%;
            max-height: 85vh;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        `;

        const lightboxCaption = document.createElement("div");
        lightboxCaption.textContent = imageName;
        lightboxCaption.style.cssText = `
            margin-top: 15px;
            color: white;
            font-size: 14px;
            text-align: center;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
        `;

        const closeBtn = document.createElement("button");
        closeBtn.innerHTML = '<i class="fas fa-times"></i>';
        closeBtn.style.cssText = `
            position: absolute;
            top: -40px;
            right: 0;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: background 0.2s;
        `;
        closeBtn.onmouseenter = () =>
            (closeBtn.style.background = "rgba(255, 255, 255, 0.3)");
        closeBtn.onmouseleave = () =>
            (closeBtn.style.background = "rgba(255, 255, 255, 0.2)");

        const closeLightbox = () => {
            lightboxOverlay.style.opacity = "0";
            setTimeout(() => {
                if (lightboxOverlay.parentNode) {
                    lightboxOverlay.parentNode.removeChild(lightboxOverlay);
                }
            }, 300);
        };

        closeBtn.onclick = (e) => {
            e.stopPropagation();
            closeLightbox();
        };

        lightboxOverlay.onclick = (e) => {
            if (e.target === lightboxOverlay) {
                closeLightbox();
            }
        };

        // Close on Escape key
        const escapeHandler = (e) => {
            if (e.key === "Escape") {
                closeLightbox();
                document.removeEventListener("keydown", escapeHandler);
            }
        };
        document.addEventListener("keydown", escapeHandler);

        lightboxContent.appendChild(closeBtn);
        lightboxContent.appendChild(lightboxImg);
        lightboxContent.appendChild(lightboxCaption);
        lightboxOverlay.appendChild(lightboxContent);
        document.body.appendChild(lightboxOverlay);

        // Fade in
        setTimeout(() => {
            lightboxOverlay.style.opacity = "1";
        }, 10);
    }

    setupProductVideoPreview() {
        const fileInput = document.getElementById("productVideos");
        const previewContainer = document.getElementById("productVideoPreview");
        const previewVideosContainer = document.getElementById(
            "previewVideosContainer"
        );
        const clearPreviewBtn = document.getElementById("clearVideoPreview");

        if (!fileInput || !previewContainer || !previewVideosContainer) return;

        // Store current files to preserve them when adding more
        let currentFiles = [];

        // Capture reference to this for lightbox
        const self = this;

        // Function to display video previews
        const displayPreviews = (files) => {
            // Don't clear the container - we'll update it intelligently
            const existingPreviews = Array.from(
                previewVideosContainer.querySelectorAll("[data-file-key]")
            );
            const existingFileKeys = new Set(
                existingPreviews.map((el) => el.dataset.fileKey)
            );

            if (files.length === 0) {
                previewContainer.style.display = "none";
                previewVideosContainer.innerHTML = "";
                return;
            }

            previewContainer.style.display = "block";
            const limitedFiles = Array.from(files).slice(0, 2); // Max 2 videos
            const newFileKeys = new Set();

            // Process each file
            limitedFiles.forEach((file, index) => {
                if (!file.type.startsWith("video/")) return;

                // Create unique file identifier
                const fileKey = `${file.name}_${file.size}_${file.lastModified}`;
                newFileKeys.add(fileKey);

                // Check if preview already exists for this file
                const existingPreview = previewVideosContainer.querySelector(
                    `[data-file-key="${fileKey}"]`
                );
                if (existingPreview) {
                    // Preview already exists, skip
                    return;
                }

                // Create video element to get duration
                const video = document.createElement("video");
                video.preload = "metadata";
                const videoUrl = URL.createObjectURL(file);
                video.src = videoUrl;

                video.onloadedmetadata = () => {
                    URL.revokeObjectURL(videoUrl);
                    const duration = video.duration;

                    // Validate duration (1 minute = 60 seconds max)
                    if (duration > 60) {
                        alert(
                            `Video "${file.name}" exceeds 1 minute (${Math.round(
                                duration
                            )}s). Maximum allowed duration is 60 seconds.`
                        );
                        // Remove this file from the input
                        const dt = new DataTransfer();
                        const filesToKeep = Array.from(fileInput.files).filter((f) => {
                            const fKey = `${f.name}_${f.size}_${f.lastModified}`;
                            return fKey !== fileKey;
                        });
                        filesToKeep.forEach((f) => dt.items.add(f));
                        fileInput.files = dt.files;
                        currentFiles = filesToKeep;
                        displayPreviews(fileInput.files);
                        return;
                    }

                    const durationText = `${Math.round(duration)}s`;

                    // Create new preview for this file
                    const previewItem = document.createElement("div");
                    previewItem.style.cssText =
                        "position: relative; border-radius: 6px; overflow: hidden; border: 2px solid #ddd; background: white; flex: 0 0 auto; width: 180px;";
                    previewItem.dataset.fileKey = fileKey;
                    previewItem.dataset.duration = duration;

                    // Create video thumbnail
                    const videoThumb = document.createElement("video");
                    const thumbUrl = URL.createObjectURL(file);
                    videoThumb.src = thumbUrl;
                    videoThumb.style.cssText =
                        "width: 100%; height: 120px; object-fit: cover; display: block; cursor: pointer;";
                    videoThumb.muted = true;
                    videoThumb.playsInline = true;

                    // Add play overlay
                    const playOverlay = document.createElement("div");
                    playOverlay.style.cssText = `
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: rgba(0, 0, 0, 0.6);
                        border-radius: 50%;
                        width: 40px;
                        height: 40px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        color: white;
                        font-size: 16px;
                        pointer-events: none;
                        z-index: 5;
                    `;
                    playOverlay.innerHTML = '<i class="fas fa-play"></i>';

                    // Add hover effect
                    videoThumb.onmouseenter = () => {
                        videoThumb.style.transform = "scale(1.05)";
                        videoThumb.style.opacity = "0.9";
                        previewItem.style.boxShadow = "0 4px 8px rgba(0,0,0,0.2)";
                    };
                    videoThumb.onmouseleave = () => {
                        videoThumb.style.transform = "scale(1)";
                        videoThumb.style.opacity = "1";
                        previewItem.style.boxShadow = "none";
                    };

                    // Add click handler for lightbox
                    const videoSrc = thumbUrl;
                    videoThumb.onclick = (e) => {
                        e.stopPropagation();
                        self.showVideoLightbox(videoSrc, file.name, duration);
                    };

                    const removeBtn = document.createElement("button");
                    removeBtn.type = "button";
                    removeBtn.innerHTML = '<i class="fas fa-times"></i>';
                    removeBtn.style.cssText = `
                        position: absolute;
                        top: 5px;
                        right: 5px;
                        background: rgba(220, 53, 69, 0.9);
                        color: white;
                        border: none;
                        border-radius: 50%;
                        width: 24px;
                        height: 24px;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 12px;
                        transition: background 0.2s;
                        z-index: 10;
                    `;
                    removeBtn.onmouseover = () =>
                        (removeBtn.style.background = "rgba(220, 53, 69, 1)");
                    removeBtn.onmouseout = () =>
                        (removeBtn.style.background = "rgba(220, 53, 69, 0.9)");

                    removeBtn.onclick = () => {
                        // Remove file from input by matching file properties
                        const dt = new DataTransfer();
                        const filesToKeep = Array.from(fileInput.files).filter((f) => {
                            const fKey = `${f.name}_${f.size}_${f.lastModified}`;
                            return fKey !== fileKey;
                        });

                        filesToKeep.forEach((f) => dt.items.add(f));
                        fileInput.files = dt.files;

                        // Update currentFiles array
                        currentFiles = filesToKeep;

                        displayPreviews(fileInput.files);
                    };

                    // Duration badge
                    const durationBadge = document.createElement("div");
                    durationBadge.textContent = durationText;
                    durationBadge.style.cssText = `
                        position: absolute;
                        bottom: 30px;
                        right: 5px;
                        background: rgba(0, 0, 0, 0.7);
                        color: white;
                        padding: 2px 6px;
                        border-radius: 4px;
                        font-size: 10px;
                        font-weight: 500;
                    `;

                    const fileName = document.createElement("div");
                    fileName.textContent =
                        file.name.length > 20
                            ? file.name.substring(0, 20) + "..."
                            : file.name;
                    fileName.style.cssText =
                        "padding: 3px 6px; font-size: 10px; color: #666; text-align: center; background: #f8f9fa; border-top: 1px solid #e0e0e0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;";

                    const videoWrapper = document.createElement("div");
                    videoWrapper.style.cssText = "position: relative;";
                    videoWrapper.appendChild(videoThumb);
                    videoWrapper.appendChild(playOverlay);
                    videoWrapper.appendChild(durationBadge);

                    previewItem.appendChild(videoWrapper);
                    previewItem.appendChild(removeBtn);
                    previewItem.appendChild(fileName);
                    previewVideosContainer.appendChild(previewItem);
                };

                video.onerror = () => {
                    URL.revokeObjectURL(videoUrl);
                    console.error("Failed to load video metadata");
                };
            });

            // Remove previews for files that are no longer selected
            existingPreviews.forEach((previewEl) => {
                if (!newFileKeys.has(previewEl.dataset.fileKey)) {
                    previewEl.remove();
                }
            });

            // Remove existing warning if any
            const existingWarning =
                previewVideosContainer.querySelector(".video-warning");
            if (existingWarning) {
                existingWarning.remove();
            }

            // Show count if more than 2 files selected
            if (files.length > 2) {
                const warning = document.createElement("div");
                warning.className = "video-warning";
                warning.style.cssText =
                    "margin-top: 8px; padding: 6px; background: #fff3cd; color: #856404; border-radius: 4px; font-size: 11px; text-align: center; width: 100%; flex-basis: 100%;";
                warning.textContent = `âš ï¸ Only the first 2 videos will be uploaded (${files.length} selected)`;
                previewVideosContainer.appendChild(warning);
            }
        };

        // Handle file selection - merge with existing files
        fileInput.addEventListener("change", (e) => {
            const newFiles = Array.from(e.target.files || []);
            const existingFileKeys = new Set(
                currentFiles.map((f) => `${f.name}_${f.size}_${f.lastModified}`)
            );

            // Add new files that aren't already in the list
            newFiles.forEach((newFile) => {
                const newFileKey = `${newFile.name}_${newFile.size}_${newFile.lastModified}`;
                if (!existingFileKeys.has(newFileKey)) {
                    currentFiles.push(newFile);
                }
            });

            // Limit to 2 files
            currentFiles = currentFiles.slice(0, 2);

            // Update the file input with merged files
            const dt = new DataTransfer();
            currentFiles.forEach((file) => dt.items.add(file));
            fileInput.files = dt.files;

            // Display all files
            displayPreviews(fileInput.files);
        });

        // Clear all previews
        if (clearPreviewBtn) {
            clearPreviewBtn.onclick = () => {
                fileInput.value = "";
                currentFiles = [];
                displayPreviews([]);
            };
        }
    }

    // Lightbox function to display full-size video
    showVideoLightbox(videoSrc, videoName, duration) {
        const lightboxOverlay = document.createElement("div");
        lightboxOverlay.id = "videoLightboxOverlay";
        lightboxOverlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 20000;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.3s ease;
        `;

        const lightboxContent = document.createElement("div");
        lightboxContent.style.cssText = `
            position: relative;
            max-width: 90%;
            max-height: 90%;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: default;
        `;

        const lightboxVideo = document.createElement("video");
        lightboxVideo.src = videoSrc;
        lightboxVideo.controls = true;
        lightboxVideo.style.cssText = `
            max-width: 100%;
            max-height: 85vh;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        `;

        const lightboxCaption = document.createElement("div");
        lightboxCaption.textContent = `${videoName} (${Math.round(duration)}s)`;
        lightboxCaption.style.cssText = `
            margin-top: 15px;
            color: white;
            font-size: 14px;
            text-align: center;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
        `;

        const closeBtn = document.createElement("button");
        closeBtn.innerHTML = '<i class="fas fa-times"></i>';
        closeBtn.style.cssText = `
            position: absolute;
            top: -40px;
            right: 0;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: background 0.2s;
        `;
        closeBtn.onmouseenter = () =>
            (closeBtn.style.background = "rgba(255, 255, 255, 0.3)");
        closeBtn.onmouseleave = () =>
            (closeBtn.style.background = "rgba(255, 255, 255, 0.2)");

        const closeLightbox = () => {
            lightboxVideo.pause();
            lightboxOverlay.style.opacity = "0";
            setTimeout(() => {
                if (lightboxOverlay.parentNode) {
                    lightboxOverlay.parentNode.removeChild(lightboxOverlay);
                }
                URL.revokeObjectURL(videoSrc);
            }, 300);
        };

        closeBtn.onclick = (e) => {
            e.stopPropagation();
            closeLightbox();
        };

        lightboxOverlay.onclick = (e) => {
            if (e.target === lightboxOverlay) {
                closeLightbox();
            }
        };

        // Close on Escape key
        const escapeHandler = (e) => {
            if (e.key === "Escape") {
                closeLightbox();
                document.removeEventListener("keydown", escapeHandler);
            }
        };
        document.addEventListener("keydown", escapeHandler);

        lightboxContent.appendChild(closeBtn);
        lightboxContent.appendChild(lightboxVideo);
        lightboxContent.appendChild(lightboxCaption);
        lightboxOverlay.appendChild(lightboxContent);
        document.body.appendChild(lightboxOverlay);

        // Fade in
        setTimeout(() => {
            lightboxOverlay.style.opacity = "1";
        }, 10);
    }

    // Ensure farmer search clear button toggles visibility like product search
    initFarmerSearch() {
        const input = document.getElementById("farmerSearchInput");
        const clearBtn = document.querySelector(
            "#farmer-users-tab .clear-search-btn"
        );
        const searchIcon = document.querySelector(
            "#farmer-users-tab .search-box i"
        );
        if (!input || !clearBtn) return;
        const toggle = () => {
            clearBtn.style.display = input.value.trim() ? "inline-flex" : "none";
        };
        input.addEventListener("input", toggle);
        toggle();

        if (searchIcon) {
            searchIcon.style.cursor = "pointer";
            searchIcon.onclick = () => {
                // Trigger the same search behavior explicitly
                if (window.staffManager) {
                    window.staffManager.searchUsers("farmer", input.value || "");
                }
            };
        }
    }
    // Ensure customer search clear buttons toggle visibility and icons clickable across sub-tabs
    initCustomerSearch() {
        const configs = [
            {
                inputId: "pendingCustomerSearchInput",
                clearSelector: "#pending-verifications-tab .clear-search-btn",
                iconSelector: "#pending-verifications-tab .search-box i",
                onSearch: (q) => this.searchPendingVerifications(q),
            },
            {
                inputId: "approvedCustomerSearchInput",
                clearSelector: "#approved-customers-tab .clear-search-btn",
                iconSelector: "#approved-customers-tab .search-box i",
                onSearch: (q) => this.searchApprovedCustomers(q),
            },
        ];

        configs.forEach((cfg) => {
            const input = document.getElementById(cfg.inputId);
            const clearBtn = document.querySelector(cfg.clearSelector);
            const icon = document.querySelector(cfg.iconSelector);

            console.log(`ðŸ”§ Initializing search for ${cfg.inputId}:`, {
                input: !!input,
                clearBtn: !!clearBtn,
                icon: !!icon,
                clearSelector: cfg.clearSelector,
            });

            if (!input || !clearBtn) {
                console.warn(`âŒ Missing elements for ${cfg.inputId}:`, {
                    input: !!input,
                    clearBtn: !!clearBtn,
                });
                return;
            }

            // Remove any existing listeners to prevent duplicates
            input.removeEventListener("input", input._searchHandler);
            input.removeEventListener("keypress", input._keypressHandler);
            clearBtn.removeEventListener("click", clearBtn._clearHandler);
            if (icon) icon.removeEventListener("click", icon._iconHandler);

            const toggle = () => {
                clearBtn.style.display = input.value.trim() ? "inline-flex" : "none";
            };

            // Store handlers as properties so we can remove them later
            input._searchHandler = (e) => {
                toggle();
                console.log(
                    `Real-time search triggered for ${cfg.inputId}:`,
                    e.target.value
                );
                // Add small delay to ensure DOM is ready
                setTimeout(() => {
                    cfg.onSearch(e.target.value || "");
                }, 10);
            };
            input._keypressHandler = (e) => {
                if (e.key === "Enter") {
                    cfg.onSearch(input.value || "");
                }
            };
            clearBtn._clearHandler = () => {
                input.value = "";
                cfg.onSearch("");
                toggle();
            };

            input.addEventListener("input", input._searchHandler);
            input.addEventListener("keypress", input._keypressHandler);
            clearBtn.addEventListener("click", clearBtn._clearHandler);
            toggle();

            console.log(`âœ… Event listeners added for ${cfg.inputId}`);

            if (icon) {
                icon.style.cursor = "pointer";
                icon._iconHandler = () => {
                    cfg.onSearch(input.value || "");
                };
                icon.addEventListener("click", icon._iconHandler);
            }
        });
    }

    // Dedicated filter for Approved Customers list
    searchApprovedCustomers(searchTerm) {
        try {
            const q = (searchTerm || "").toString().toLowerCase().trim();
            // Delegate to unified user search so behavior matches pending verifications
            this.searchUsers("customer", q);
        } catch (e) {
            console.warn("searchApprovedCustomers error:", e);
        }
    }

    // Dedicated filter for Pending Verifications (works exactly like customer records)
    searchPendingVerifications(searchTerm) {
        try {
            const q = (searchTerm || "").toString().toLowerCase().trim();

            const container = document.getElementById(
                "customerVerificationsManagement"
            );
            if (!container) {
                console.warn("âŒ Pending verifications container not found");
                return;
            }

            // Find all verification items
            let items = Array.from(container.querySelectorAll(".verification-item"));

            if (items.length === 0) {
                items = Array.from(container.children).filter(
                    (child) =>
                        child.classList.contains("verification-item") ||
                        child.querySelector("h4") ||
                        child.querySelector(".verification-info")
                );
            }

            // Debug: show what items we found
            items.forEach((item, index) => {
                console.log(`Item ${index}:`, {
                    tagName: item.tagName,
                    className: item.className,
                    hasH4: !!item.querySelector("h4"),
                    hasVerificationInfo: !!item.querySelector(".verification-info"),
                    textContent: item.textContent?.substring(0, 50) + "...",
                });
            });

            let anyMatch = false;
            const norm = (s) =>
                (s || "").toString().toLowerCase().trim().normalize("NFKD");

            items.forEach((item) => {
                const attr = norm(item.getAttribute?.("data-searchable"));
                const nameText = norm(item.querySelector?.("h4")?.textContent);
                const fullText = norm(item.textContent);
                const haystack = attr || nameText || fullText;
                const match = q === "" || haystack.includes(q);

                // Force visibility change with !important to override CSS (same as customer records)
                if (match) {
                    item.style.setProperty("display", "flex", "important");
                    item.style.visibility = "visible";
                } else {
                    item.style.setProperty("display", "none", "important");
                    item.style.visibility = "hidden";
                }

                if (match) anyMatch = true;
            });

            // Show/hide "no results" message (same as customer records)
            const existing = container.querySelector(".no-data.search, .no-data");
            if (!anyMatch && q !== "") {
                if (!existing) {
                    const msg = document.createElement("p");
                    msg.className = "no-data search";
                    msg.textContent = "No matching verifications";
                    msg.style.cssText =
                        "text-align: center; padding: 20px; color: #666; font-style: italic;";
                    container.appendChild(msg);
                }
            } else if (existing && existing.classList.contains("search")) {
                existing.remove();
            }
        } catch (e) {
            console.warn("searchPendingVerifications error:", e);
            console.error("Full error:", e);
        }
    }

    // Test function to manually trigger search (for debugging)
    testPendingSearch() {
        console.log("ðŸ§ª Testing pending search manually...");
        this.searchPendingVerifications("test");
    }

    // Clear all search bars when switching between main sections
    clearAllSearchBars() {
        console.log("ðŸ§¹ Clearing all search bars...");

        // Clear farmer search
        const farmerSearchInput = document.getElementById("farmerSearchInput");
        if (farmerSearchInput) {
            farmerSearchInput.value = "";
        }

        // Clear user management search bars
        this.clearUserManagementSearchBars();
    }

    // Clear user management search bars when switching between farmer-users and customer-users
    clearUserManagementSearchBars() {
        console.log("ðŸ§¹ Clearing user management search bars...");

        // Clear farmer search
        const farmerSearchInput = document.getElementById("farmerSearchInput");
        if (farmerSearchInput) {
            farmerSearchInput.value = "";
        }

        // Clear customer management search bars
        this.clearCustomerManagementSearchBars();
    }
    // Clear customer management search bars when switching between pending/rejected/customer records
    clearCustomerManagementSearchBars() {
        // Clear pending verifications search
        const pendingSearchInput = document.getElementById(
            "pendingCustomerSearchInput"
        );
        if (pendingSearchInput) {
            pendingSearchInput.value = "";
        }

        // Clear rejected verifications search
        const rejectedSearchInput = document.getElementById(
            "rejectedCustomerSearchInput"
        );
        if (rejectedSearchInput) {
            rejectedSearchInput.value = "";
        }

        // Clear approved customers search
        const approvedSearchInput = document.getElementById(
            "approvedCustomerSearchInput"
        );
        if (approvedSearchInput) {
            approvedSearchInput.value = "";
        }

        // Clear any search results by triggering empty searches
        this.searchPendingVerifications("");
        this.searchVerifications("rejected", "");
        this.searchApprovedCustomers("");
    }

    renderApprovedCustomersFromCache(q) {
        try {
            const container = document.getElementById("customerList");
            if (!container) return;
            const list = this._approvedCustomersCache || [];
            container.innerHTML = "";
            const filtered = list.filter(([id, customer]) => {
                const name = (customer.fullName || "").toLowerCase();
                const email = (customer.email || "").toLowerCase();
                const phone = (customer.phoneNumber || "").toLowerCase();
                const haystack = `${name} ${email} ${phone}`;
                return (q || "") === "" || haystack.includes(q || "");
            });
            if (filtered.length === 0) {
                const noDataDiv = document.createElement("div");
                noDataDiv.innerHTML = '<p class="no-data">No matching customers</p>';
                container.appendChild(noDataDiv);
                return;
            }
            filtered.forEach(([id, customer]) => {
                const item = this.createCustomerManagementItem(id, customer);
                container.appendChild(item);
            });
        } catch (e) {
            console.warn("renderApprovedCustomersFromCache error:", e);
        }
    }
    async createProduct() {
        try {
            // Get automatic harvest date if not provided
            const harvestDateInput = document.getElementById("harvestDate").value;
            const harvestDates = this.getNextHarvestDates();
            const harvestDate = harvestDateInput || harvestDates.friday;

            const formData = {
                name: document.getElementById("productName").value.trim(),
                category: "Vegetables", // Fixed category
                availableQuantity: parseInt(document.getElementById("quantity").value),
                unit: "kg", // Fixed unit
                price: parseFloat(document.getElementById("price").value),
                harvestDate: harvestDate,
                description: document.getElementById("description").value.trim(),
            };

            // Collect up to 5 image files
            const files = Array.from(
                (document.getElementById("productImages") &&
                    document.getElementById("productImages").files) ||
                []
            );
            const limitedFiles = files.slice(0, 5);
            // Generate unique product ID for Supabase (using timestamp + random)
            const now = Date.now(); // Capture timestamp once to ensure createdAt and updatedAt are equal
            const productId = `product_${now}_${Math.random()
                .toString(36)
                .substr(2, 9)}`;

            // Create product data with structure matching customer app expectations
            const productData = {
                ...formData,
                imageUrl: "",
                imageUrls: [],
                imagesStored: false,
                videoUrl: "",
                videoUrls: [],
                videosStored: false,
                status: "active",
                isAvailable: true, // Add this field for customer app
                farmerId: sessionStorage.getItem("staffUid") || "staff", // Use staff ID as farmer ID
                farmerName: sessionStorage.getItem("staffName") || "Staff Member", // Use staff name
                rating: 0.0, // Default rating
                reviewCount: 0, // Default review count
                tags: [], // Empty tags array
                location: "", // Empty location
                createdAt: now, // Use captured timestamp
                // Set updatedAt to same as createdAt on creation (database requires NOT NULL)
                // This ensures hasBeenUpdated check works correctly (updatedAt === createdAt means not updated)
                updatedAt: now, // Same as createdAt initially - will be different when actually updated
                createdBy: sessionStorage.getItem("staffUid") || "staff",
                staffId: sessionStorage.getItem("staffUid") || "staff",
                // Set added_by fields for the person who created/uploaded the product first
                addedBy: sessionStorage.getItem("staffUid") || "staff",
                addedByName: sessionStorage.getItem("staffName") || "Staff Member",
                addedByRole: sessionStorage.getItem("staffRole") || "Staff",
            };

            // If there are images, upload them first, then save product with URLs
            if (limitedFiles.length > 0) {
                // Compress images client-side and upload with 2-at-a-time concurrency and progress
                const submitBtn = document.querySelector(
                    '#addProductForm button[type="submit"]'
                );
                const progressEl = document.createElement("div");
                progressEl.style.cssText =
                    "margin-top:8px;font-size:0.85rem;color:#666;";
                const formEl = document.getElementById("addProductForm");
                if (formEl && !formEl.querySelector(".upload-progress")) {
                    progressEl.className = "upload-progress";
                    formEl.appendChild(progressEl);
                }

                const compressImage = (file, maxDim = 1280, quality = 0.7) =>
                    new Promise((resolve, reject) => {
                        const img = new Image();
                        const url = URL.createObjectURL(file);
                        img.onload = () => {
                            const canvas = document.createElement("canvas");
                            let { width, height } = img;
                            if (width > height && width > maxDim) {
                                height = Math.round(height * (maxDim / width));
                                width = maxDim;
                            } else if (height > maxDim) {
                                width = Math.round(width * (maxDim / height));
                                height = maxDim;
                            }
                            canvas.width = width;
                            canvas.height = height;
                            const ctx = canvas.getContext("2d");
                            ctx.drawImage(img, 0, 0, width, height);
                            const outType =
                                file.type === "image/png" ? "image/png" : "image/jpeg";
                            canvas.toBlob(
                                (blob) => {
                                    URL.revokeObjectURL(url);
                                    if (!blob) return reject(new Error("Compression failed"));
                                    resolve(
                                        new File([blob], file.name.replace(/\s+/g, "_"), {
                                            type: outType,
                                        })
                                    );
                                },
                                outType,
                                outType === "image/jpeg" ? quality : undefined
                            );
                        };
                        img.onerror = () => {
                            URL.revokeObjectURL(url);
                            reject(new Error("Invalid image"));
                        };
                        img.src = url;
                    });

                // Prepare tasks with compression
                const tasks = await Promise.all(
                    limitedFiles.map(async (file, index) => {
                        try {
                            const compressed = await compressImage(file);
                            return { original: file, file: compressed, index };
                        } catch (_) {
                            return { original: file, file, index }; // fallback to original
                        }
                    })
                );

                const total = tasks.length;
                let completed = 0;
                let overallPct = 0;
                const updateProgressText = () => {
                    const pctText = overallPct ? ` - ${Math.round(overallPct)}%` : "";
                    if (progressEl)
                        progressEl.textContent = `Uploading images: ${completed}/${total}${pctText}`;
                    if (submitBtn)
                        submitBtn.innerHTML = `<i class=\"fas fa-spinner fa-spin\"></i> Uploading images (${completed}/${total})${pctText}...`;
                };
                updateProgressText();

                // Upload to Supabase with concurrency = 2
                const urls = [];
                const queue = tasks.slice();
                const uploadOne = async (item) => {
                    try {
                        // Upload to Supabase bucket 'product_image'
                        const url = await FirebaseUtils.uploadToSupabase(
                            item.file,
                            productId,
                            item.index,
                            (pct) => {
                                overallPct = Math.max(overallPct, pct * 0.6); // rough aggregate
                                updateProgressText();
                            }
                        );
                        urls[item.index] = url;
                        completed += 1;
                        overallPct = Math.round((completed / total) * 100);
                        updateProgressText();
                    } catch (error) {
                        console.error(`Error uploading image ${item.index}:`, error);
                        completed += 1;
                        updateProgressText();
                        throw error; // Re-throw to stop the process
                    }
                };
                const worker = async () => {
                    while (queue.length) {
                        const item = queue.shift();
                        await uploadOne(item);
                    }
                };
                const workers = [worker(), worker()];
                await Promise.all(workers);

                // Store image URLs - use image_url for single image and imageUrls for array
                productData.image_url = urls[0] || ""; // Single image URL for Supabase column
                productData.imageUrls = urls; // Array of all image URLs
                productData.imageUrl = urls[0] || ""; // Keep for backward compatibility
                productData.imagesStored = true;
            }

            // Handle video uploads (max 2 videos, 1 minute each)
            const videoFiles = Array.from(
                (document.getElementById("productVideos") &&
                    document.getElementById("productVideos").files) ||
                []
            );
            const limitedVideoFiles = videoFiles.slice(0, 2);

            if (limitedVideoFiles.length > 0) {
                const formEl = document.getElementById("addProductForm");
                const submitBtn = document.querySelector(
                    '#addProductForm button[type="submit"]'
                );
                const progressEl =
                    formEl?.querySelector(".upload-progress") ||
                    document.createElement("div");
                if (!formEl?.querySelector(".upload-progress")) {
                    progressEl.className = "upload-progress";
                    progressEl.style.cssText =
                        "margin-top:8px;font-size:0.85rem;color:#666;";
                    formEl?.appendChild(progressEl);
                }

                const totalVideos = limitedVideoFiles.length;
                let completedVideos = 0;
                let overallVideoPct = 0;
                const updateVideoProgressText = () => {
                    const pctText = overallVideoPct
                        ? ` - ${Math.round(overallVideoPct)}%`
                        : "";
                    if (progressEl)
                        progressEl.textContent = `Uploading videos: ${completedVideos}/${totalVideos}${pctText}`;
                    if (submitBtn)
                        submitBtn.innerHTML = `<i class="fas fa-spinner fa-spin"></i> Uploading videos (${completedVideos}/${totalVideos})${pctText}...`;
                };
                updateVideoProgressText();

                const videoUrls = [];
                for (let i = 0; i < limitedVideoFiles.length; i++) {
                    try {
                        const videoFile = limitedVideoFiles[i];
                        const result = await FirebaseUtils.uploadVideoToSupabase(
                            videoFile,
                            productId,
                            i,
                            (pct) => {
                                overallVideoPct = Math.max(overallVideoPct, pct * 0.6);
                                updateVideoProgressText();
                            }
                        );
                        videoUrls.push(result.url);
                        completedVideos += 1;
                        overallVideoPct = Math.round((completedVideos / totalVideos) * 100);
                        updateVideoProgressText();
                    } catch (error) {
                        console.error(`Error uploading video ${i}:`, error);
                        completedVideos += 1;
                        updateVideoProgressText();
                        throw error; // Re-throw to stop the process
                    }
                }

                // Store video URLs
                productData.video_url = videoUrls[0] || "";
                productData.videoUrls = videoUrls;
                productData.videoUrl = videoUrls[0] || "";
                productData.videosStored = true;
            }

            // Save to Supabase
            productData.uid = productId; // Set the uid for Supabase
            await ProductHelpers.createProduct(productData);

            // Send notification to all customers about new product
            try {
                const productName = productData.name || "New Product";
                const unit = productData.unit || "kg";
                const quantity = productData.availableQuantity || 0;
                const price = productData.price || 0;
                const title = "New Product Available!";
                const message = `${productName} is now available! ${quantity} ${unit} at â‚±${price.toFixed(2)} per ${unit}`;
                
                console.log(`ðŸ“¢ Attempting to send new product notification for: ${productName}`);
                const result = await NotificationHelpers.notifyAllCustomers(
                    title,
                    message,
                    "product_added",
                    productId
                );
                console.log(`âœ… Successfully sent new product notification for: ${productName}`, result);
            } catch (notificationError) {
                console.error("âŒ Error: Failed to send new product notification:", notificationError);
                console.error("âŒ Error details:", notificationError.message || notificationError);
                // Don't fail the product creation if notification fails
                alert(`Product added successfully, but notification failed: ${notificationError.message || notificationError}`);
            }

            this.closeModal();
            this.showSuccessMessage("Product added successfully");
            this.loadProducts();
            this.loadStats();
        } catch (error) {
            console.error("Error creating product:", error);
            alert("Error creating product: " + error.message);
        }
    }
    async loadPendingOrders() {
        try {
            console.log("Loading pending orders...");
            if (!window.OrderSupabaseAdapter) {
                console.error(
                    "OrderSupabaseAdapter not available; cannot load pending orders"
                );
                this.renderPendingOrdersError(
                    "Supabase orders adapter not available. Please refresh the page."
                );
                return;
            }

            const orders = await OrderSupabaseAdapter.fetchOrders();
            if (orders === null) {
                console.error("Failed to load orders from Supabase");
                this.renderPendingOrdersError(
                    "Unable to load orders from Supabase. Please try again shortly."
                );
                return;
            }

            this.__usingSupabaseOrders = true;
            this.startSupabaseOrdersPolling();
            this.detachFirebaseOrderListeners();

            // Note: No Firebase fallback - all rider assignments are stored in Supabase orders table

            this._ordersCache = orders;
            if (typeof renderPendingOrdersFromObject === "function") {
                renderPendingOrdersFromObject(this._ordersCache);
            }
            this.loadStats();

            this.renderPendingOrdersSection();
        } catch (error) {
            console.error("Error loading orders:", error);
        }
    }

    renderPendingOrdersError(message) {
        const container = document.getElementById("ordersContainer");
        if (container) {
            container.innerHTML = `
                <div style="text-align:center;padding:32px;color:#c62828;background:#ffebee;border:1px solid #ffcdd2;border-radius:8px;">
                    <i class="fas fa-exclamation-triangle" style="font-size:2rem;margin-bottom:12px;"></i>
                    <p style="margin:0;font-size:0.95rem;">${message}</p>
                </div>
            `;
        }
    }

    renderAssignedOrdersError(message) {
        const containers = [
            "assignedOrdersContainerConfirmed",
            "assignedOrdersContainerConfirmedDelivery",
            "assignedOrdersContainerConfirmedPickup",
            "assignedOrdersContainerToReceive",
            "assignedOrdersContainerToReceiveDelivery",
            "assignedOrdersContainerToReceivePickup",
            "assignedOrdersContainerSuccessful",
            "assignedOrdersContainerFailed",
            "assignedOrdersContainerCancelled",
        ];
        containers.forEach((id) => {
            const el = document.getElementById(id);
            if (el) {
                el.innerHTML = `
                    <div style="text-align:center;padding:32px;color:#c62828;background:#ffebee;border:1px solid #ffcdd2;border-radius:8px;">
                        <i class="fas fa-exclamation-circle" style="font-size:2rem;margin-bottom:12px;"></i>
                        <p style="margin:0;font-size:0.95rem;">${message}</p>
                    </div>
                `;
            }
        });
    }

    renderRejectedOrdersError(message) {
        const container = document.getElementById("rejectedProductsContainer");
        const countElement = document.getElementById("rejectedCount");
        if (countElement) countElement.textContent = "0";
        if (container) {
            container.innerHTML = `
                <div style="text-align:center;padding:32px;color:#c62828;background:#ffebee;border:1px solid #ffcdd2;border-radius:8px;">
                    <i class="fas fa-exclamation-triangle" style="font-size:2rem;margin-bottom:12px;"></i>
                    <p style="margin:0;font-size:0.95rem;">${message}</p>
                </div>
            `;
        }
    }

    renderPendingOrdersSection() {
        try {
            const container = document.getElementById("ordersContainer");
            if (!container) {
                console.warn("ordersContainer not found; skipping paint");
                return;
            }

            const orders = this._ordersCache || {};
            if (Object.keys(orders).length === 0) {
                container.innerHTML = '<p class="no-data">No orders found</p>';
                return;
            }

            const filteredOrders = Object.entries(orders).filter(([id, order]) => {
                const s = String(order.status || "").toLowerCase();
                // Only show pending orders - exclude cancelled orders and refunded orders
                // Exclude orders that have been refunded (cancellationConfirmed or refundConfirmedAt set)
                const isRefunded =
                    order.cancellationConfirmed === true ||
                    order.cancellation_confirmed === true ||
                    order.refundConfirmedAt != null ||
                    order.refund_confirmed_at != null;
                return s === "pending" && !isRefunded;
            });

            if (filteredOrders.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px; color: #666;">
                        <i class="fas fa-inbox" style="font-size: 3rem; color: #ddd; margin-bottom: 16px;"></i>
                        <h3 style="margin-bottom: 8px; color: #999;">No Pending Orders</h3>
                        <p style="margin-bottom: 16px; color: #bbb;">All orders are either pending, confirmed, rejected, or cleared.</p>
                        <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; border-left: 4px solid #4CAF50;">
                            <p style="margin: 0; font-size: 0.9rem; color: #666;">
                                <i class="fas fa-info-circle"></i> 
                                <strong>Note:</strong> Confirmed orders are managed in the "Order Management" module. Rejected orders are managed in the "Order Records" module.
                            </p>
                        </div>
                    </div>
                `;
                return;
            }

            const infoNote = document.createElement("div");
            infoNote.style.cssText = `
                background: #e8f5e8;
                border: 1px solid #4CAF50;
                border-radius: 8px;
                padding: 12px;
                margin-bottom: 20px;
                font-size: 0.9rem;
                color: #2e7d32;
            `;
            infoNote.innerHTML = `
                <i class="fas fa-info-circle"></i> 
                <strong>Orders Module:</strong> This module handles pending orders only. 
                Flow: Pending â†’ Confirm. 
                After confirmation, orders move to the "Order Management" module for farmer assignment and delivery.
                Rejected orders are handled in the "Order Records" module.
            `;
            container.innerHTML = "";
            container.appendChild(infoNote);

            const sortedOrders = filteredOrders.sort(
                (a, b) => (b[1]?.createdAt || 0) - (a[1]?.createdAt || 0)
            );
            sortedOrders.forEach(([id, order]) => {
                const item = this.createOrderCard(id, order);
                this.restructurePendingOrderCard(item, id, order);
                container.appendChild(item);
                // Load staff notes after card is created
                setTimeout(() => this.loadStaffNotesIntoCard(id), 100);
                // Attach cut-off button listeners AFTER restructurePendingOrderCard modifies the HTML
                if (
                    order.status === "pending" &&
                    order.cancellationRequested !== true &&
                    this.isAfterWeeklyCutoff()
                ) {
                    setTimeout(() => {
                        this.attachCutoffButtonListeners(item, id);
                    }, 100);
                }
            });
        } catch (err) {
            console.warn("renderPendingOrdersSection error:", err);
        }
    }

    restructurePendingOrderCard(cardElement, id, order) {
        try {
            if (
                !cardElement ||
                String(order.status || "").toLowerCase() !== "pending"
            )
                return;

            const orderDetails =
                cardElement.querySelector("#order-details-" + id) ||
                cardElement.querySelector(".order-details");
            if (!orderDetails) return;

            const actionsNode = orderDetails.querySelector(".order-actions");
            const actionsHtml = actionsNode ? actionsNode.innerHTML : "";
            const cleanedActionsHtml = (() => {
                if (!actionsHtml || typeof document === "undefined") return actionsHtml;
                const temp = document.createElement("div");
                temp.innerHTML = actionsHtml;
                const buttons = temp.querySelectorAll("button");
                buttons.forEach((btn) => {
                    const text = (btn.textContent || "").toLowerCase();
                    if (
                        text.includes("customer details") ||
                        text.includes("contact customer")
                    ) {
                        btn.remove();
                    } else {
                        // Preserve onclick handlers by storing them
                        const onclickAttr = btn.getAttribute("onclick");
                        if (onclickAttr) {
                            btn.setAttribute("data-onclick", onclickAttr);
                        }
                    }
                });
                return temp.innerHTML;
            })();

            const totalDisplay = (() => {
                const val =
                    order.totalAmount != null
                        ? order.totalAmount
                        : order.total != null
                            ? order.total
                            : 0;
                const num = typeof val === "number" ? val : parseFloat(val) || 0;
                return num.toLocaleString();
            })();

            const itemsSafe = Array.isArray(order.items) ? order.items : [];
            const deliveryOption = String(order.deliveryOption || "").toLowerCase();
            const isDelivery = deliveryOption === "delivery";
            const isPickup = deliveryOption === "pickup";

            let addressText = "";
            if (isDelivery && order.deliveryAddress) {
                addressText = this.removeDuplicateCityProvince(order.deliveryAddress);
            } else if (isPickup) {
                if (order.pickupName || order.pickupStreet || order.pickupBarangay) {
                    const parts = [];
                    if (order.pickupName) parts.push(order.pickupName);
                    if (order.pickupStreet) parts.push(order.pickupStreet);
                    if (order.pickupSitio) parts.push(order.pickupSitio);
                    if (order.pickupBarangay) parts.push(order.pickupBarangay);
                    if (order.pickupCity) parts.push(order.pickupCity);
                    if (order.pickupProvince) parts.push(order.pickupProvince);
                    if (order.pickupLandmark)
                        parts.push(`(Landmark: ${order.pickupLandmark})`);
                    addressText = parts.join(", ");
                    if (order.pickupInstructions) {
                        addressText += ` - ${order.pickupInstructions}`;
                    }
                } else if (order.pickupAddress) {
                    addressText = this.removeDuplicateCityProvince(order.pickupAddress);
                } else {
                    addressText = "Pickup location not specified";
                }
            } else {
                const rawAddress = order.deliveryAddress || order.customerAddress || "Address not available";
                addressText = this.removeDuplicateCityProvince(rawAddress);
            }

            orderDetails.innerHTML = `
                <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(280px, 1fr)); gap:20px; margin-bottom:24px;">
                    <div style="background:#f9fafb; padding:16px; border-radius:8px; border:1px solid #e5e7eb;">
                        <h5 style="margin:0 0 12px 0; font-size:12px; font-weight:700; color:#6b7280; text-transform:uppercase; letter-spacing:0.8px;">Customer Information</h5>
                        <div style="display:flex; flex-direction:column; gap:8px;">
                            <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Name</span><span style="color:#111827; font-weight:500; font-size:13px;">${order.customerName || "N/A"
                }</span></div>
                            <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Contact</span><span style="color:#111827; font-weight:500; font-size:13px;">${order.customerPhone || "N/A"
                }</span></div>
                            <div style="display:flex; flex-direction:column; gap:10px; margin-top:12px;">
                                <button class="secondary-btn" onclick="staffManager.viewOrderCustomerDetails('${id}', '${(order.customerName || "").replace(/'/g, "\\'")}', '${(order.customerPhone || "").replace(/'/g, "\\'")}', '${((order.deliveryAddress || order.customerAddress || "").replace(/'/g, "\\'"))}')" style="padding:10px 20px; border-radius:6px; font-size:13px; font-weight:500;">
                                    <i class="fas fa-user"></i> Customer Details
                                </button>
                                <button class="secondary-btn" onclick="(async function(){ try { const customerId = '${(
                    order.customerId ||
                    order.customer_id ||
                    id
                )
                    .toString()
                    .replace(/'/g, "\\'")}'; let customerName = '${(
                        order.customerName || "Customer"
                    )
                        .replace(/'/g, "\\'")
                        .replace(
                            /"/g,
                            "&quot;"
                        )}'; if(typeof openChatWithCustomer === 'function') { await openChatWithCustomer(customerId, customerName); } else if(typeof window.openChatWithCustomer === 'function') { await window.openChatWithCustomer(customerId, customerName); } else { console.error('openChatWithCustomer function not found'); } } catch(e) { console.error('Error opening chat:', e); } })();" style="padding:10px 20px; border-radius:6px; font-size:13px; font-weight:500; background:linear-gradient(135deg, #4CAF50, #45a049); color:white; border:none; box-shadow:0 2px 8px rgba(76, 175, 80, 0.3);">
                                    <i class="fas fa-comments"></i> Contact Customer
                                </button>
                            </div>
                        </div>
                    </div>
                    <div style="background:#f9fafb; padding:16px; border-radius:8px; border:1px solid #e5e7eb;">
                        <h5 style="margin:0 0 12px 0; font-size:12px; font-weight:700; color:#6b7280; text-transform:uppercase; letter-spacing:0.8px;">Order Summary</h5>
                        <div style="display:flex; flex-direction:column; gap:8px;">
                            <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Order ID</span><span style="color:#111827; font-weight:600; font-size:13px;">#${id
                    .substr(-8)
                    .toUpperCase()}</span></div>
                            <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Order Date</span><span style="color:#111827; font-weight:500; font-size:13px;">${order.createdAt
                    ? new Date(order.createdAt).toLocaleString()
                    : "Unknown"
                }</span></div>
                            ${(order.deliveryOption || "").toLowerCase() === "pickup" &&
                    (order.readyForPickup === true || order.ready_for_pickup === true) &&
                    (order.ready_for_pickup_at || order.readyForPickupAt)
                    ? `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Pickup Schedule</span><span style="color:#111827; font-weight:500; font-size:13px;">${new Date(
                        order.ready_for_pickup_at || order.readyForPickupAt
                    ).toLocaleDateString()}</span></div>`
                    : ""
                }
                            ${order.cancellationRequested === true ||
                    order.cancellation_requested === true
                    ? `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Cancellation Requested At</span><span style="color:#111827; font-weight:500; font-size:13px;">${order.cancellationRequestedAt || order.cancellation_requested_at
                        ? new Date(
                            order.cancellationRequestedAt || order.cancellation_requested_at
                        ).toLocaleString()
                        : "Unknown"}</span></div>`
                    : ""
                }
                            <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Total Amount</span><span style="color:#059669; font-weight:700; font-size:15px;">â‚±${totalDisplay}</span></div>
                            <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Payment Method</span><span style="color:#111827; font-weight:600; font-size:13px; text-transform:uppercase;">${(() => {
                    const pm = String(order.paymentMethod || "cash").toLowerCase();
                    // If GCash and has payment_proof (rider upload), it's COD paid through GCash
                    if (pm === "gcash" && (order.payment_proof || order.paymentProof)) {
                        return "COD - PAID THROUGH GCASH";
                    }
                    return (order.paymentMethod || "cash").toUpperCase();
                })()}</span></div>
                            <div style="display:flex; justify-content:space-between; padding:6px 0;"><span style="color:#6b7280; font-size:13px;">Status</span>${(() => {
                    const isCancellationRequested =
                        order.cancellationRequested === true ||
                        order.cancellation_requested === true;
                    if (isCancellationRequested) {
                        return '<span style="padding:4px 8px; background:#fee2e2; color:#dc2626; border-radius:4px; font-size:11px; font-weight:600; text-transform:uppercase;">Cancellation Requested</span>';
                    } else {
                        return '<span style="padding:4px 8px; background:#fef3c7; color:#92400e; border-radius:4px; font-size:11px; font-weight:600; text-transform:uppercase;">Pending</span>';
                    }
                })()}</div>
                        </div>
                    </div>
                </div>
                
                <div id="order-notes-container-${id}" style="margin-bottom:20px;">
                    ${(() => {
                        const rawNotes = order.order_notes || order.orderNotes || order.deliveryNotes || order.delivery_notes || "";
                        const filteredNotes = this.filterCustomerNotes(rawNotes);
                        const deliveryOption = (order.deliveryOption || "").toLowerCase();
                        const isPickup = deliveryOption === "pickup";
                        const isDelivery = !isPickup;
                        
                        // Check if rider is assigned (for delivery orders)
                        const hasRider = !!(order.riderId || order.rider_id || order.riderName || order.rider_name);
                        
                        // Customer notes - always show if they exist
                        let customerNotesHtml = '';
                        if (filteredNotes) {
                            customerNotesHtml = `
                    <div style="padding:16px; background:#fff7ed; border-left:4px solid #f59e0b; border-radius:8px;">
                        <div style="display:flex; align-items:center; gap:10px; margin-bottom:12px;">
                            <i class="fas fa-sticky-note" style="color:#f59e0b; font-size:16px;"></i>
                            <h5 style="margin:0; font-size:14px; font-weight:700; color:#9a3412;">${isPickup ? "Order/Pickup Notes" : "Order/Delivery Notes"} (Customer)</h5>
                        </div>
                        <div style="background:#ffffff; padding:12px; border-radius:6px; border:1px solid #fed7aa;">
                            <div style="color:#92400e; font-size:13px; line-height:1.5; font-style:italic;">
                                "${this.esc(filteredNotes)}"
                            </div>
                        </div>
                    </div>
                    `;
                        }
                        
                        // Staff notes container - always for delivery orders (regardless of status or rider assignment)
                        let staffNotesContainerHtml = '';
                        if (isDelivery) {
                            staffNotesContainerHtml = `<div id="staff-notes-container-${id}"></div>`;
                        }
                        
                        return customerNotesHtml + staffNotesContainerHtml;
                    })()}
                </div>

                ${(order.cancellationRequested === true ||
                    order.cancellation_requested === true) &&
                    (order.cancellationReason || order.cancellation_reason)
                    ? `
                <div style="margin-bottom:20px; padding:16px; background:#fff7ed; border-left:4px solid #f59e0b; border-radius:8px;">
                    <div style="display:flex; align-items:center; gap:10px; margin-bottom:12px;">
                        <i class="fas fa-exclamation-triangle" style="color:#f59e0b; font-size:16px;"></i>
                        <h5 style="margin:0; font-size:14px; font-weight:700; color:#9a3412;">Customer Cancellation Request</h5>
                    </div>
                    <div style="background:#ffffff; padding:12px; border-radius:6px; border:1px solid #fed7aa;">
                        <div style="font-size:12px; font-weight:600; color:#78350f; margin-bottom:8px;">Cancellation Reason:</div>
                        <div style="color:#92400e; font-size:13px; line-height:1.5; font-style:italic;">
                            "${order.cancellationReason || order.cancellation_reason || "No reason provided"}"
                        </div>
                    </div>
                </div>
                `
                    : ""
                }

                <div style="background:#f9fafb; border:1px solid #e5e7eb; border-radius:8px; padding:16px;">
                    <h5 style="margin:0 0 16px 0; font-size:12px; font-weight:700; color:#6b7280; text-transform:uppercase; letter-spacing:0.8px; text-align:center;">Order Details</h5>

                    <div style="margin-bottom:20px; padding:12px; background:#ffffff; border:1px solid #e5e7eb; border-radius:6px;">
                        <div style="font-size:13px; font-weight:600; color:#374151; margin-bottom:12px; display:flex; align-items:center; justify-content:center; gap:6px;">
                            <i class="fas fa-shopping-cart" style="color:#6b7280; font-size:12px;"></i>
                            Order Items
                        </div>
                        <div style="display:table; width:100%; border-collapse:collapse;">
                            <div style="display:table-row; border-bottom:1px solid #e5e7eb; font-weight:600; color:#374151; font-size:13px;">
                                <div style="display:table-cell; padding:10px; border-right:1px solid #e5e7eb;">Product</div>
                                <div style="display:table-cell; padding:10px; border-right:1px solid #e5e7eb; text-align:center;">Kilo Ã— Price</div>
                                <div style="display:table-cell; padding:10px; text-align:right;">Total</div>
                            </div>
                            ${itemsSafe
                    .map(
                        (item) => `
                            <div style="display:table-row; border-bottom:1px solid #e5e7eb;">
                                <div style="display:table-cell; padding:10px; border-right:1px solid #e5e7eb; font-weight:600; color:#111827; font-size:14px;">${item.productName || "Item"
                            }</div>
                                <div style="display:table-cell; padding:10px; border-right:1px solid #e5e7eb; text-align:center; color:#6b7280; font-size:13px;">${item.quantity || 0
                            } ${item.unit || ""} Ã— â‚±${(
                                item.price || 0
                            ).toLocaleString()}</div>
                                <div style="display:table-cell; padding:10px; text-align:right; font-weight:700; color:#059669; font-size:15px;">â‚±${(
                                (item.quantity || 0) * (item.price || 0)
                            ).toLocaleString()}</div>
                            </div>
                            `
                    )
                    .join("")}
                        </div>
                    </div>

                    <div style="margin-bottom:20px; padding:12px; background:#ffffff; border:1px solid #e5e7eb; border-radius:6px;">
                        <div style="font-size:13px; font-weight:600; color:#374151; margin-bottom:8px; display:flex; align-items:center; gap:6px;">
                            <i class="fas fa-credit-card" style="color:#6b7280; font-size:12px;"></i>
                            Payment Method
                        </div>
                        <div style="font-size:14px; color:#111827; font-weight:600; text-transform:uppercase; margin-bottom:${(() => {
                    const pm = String(
                        order.paymentMethod || ""
                    ).toLowerCase();
                    return pm === "gcash" && order.gcashReceiptUrl
                        ? "12px"
                        : "0";
                })()};">${(() => {
                    const pm = String(order.paymentMethod || "cash").toLowerCase();
                    // If GCash and has payment_proof (rider upload), it's COD paid through GCash
                    if (pm === "gcash" && (order.payment_proof || order.paymentProof)) {
                        return "COD - PAID THROUGH GCASH";
                    }
                    return (order.paymentMethod || "cash").toUpperCase();
                })()}</div>
                        ${(() => {
                    const pm = String(
                        order.paymentMethod || ""
                    ).toLowerCase();
                    const isGcash = pm === "gcash";
                    // Only show customer's GCash Receipt for original GCash orders (not COD orders paid through GCash)
                    // If payment_proof exists, it means rider uploaded it (COD paid through GCash), so don't show customer receipt
                    const isOriginalGcash = isGcash &&
                        !order.payment_proof &&
                        !order.paymentProof;
                    if (isOriginalGcash && order.gcashReceiptUrl) {
                        const rawUrl = order.gcashReceiptUrl || "";
                        const url = this.getGcashReceiptUrl(rawUrl);
                        if (!url) {
                            return `
                                    <div style="margin-top:12px; padding-top:12px; border-top:1px solid #e5e7eb;">
                                        <div style="font-size:12px; font-weight:600; color:#6b7280; margin-bottom:8px; display:flex; align-items:center; gap:6px;">
                                            <i class="fas fa-receipt" style="color:#6b7280; font-size:11px;"></i>
                                            GCash Receipt (Customer Upload)
                                        </div>
                                        <div style="border:2px dashed #d1d5db; border-radius:6px; padding:16px; background:#f9fafb; display:flex; align-items:center; justify-content:center; gap:10px; min-height:80px;">
                                            <i class="fas fa-receipt" style="color:#9ca3af; font-size:20px;"></i>
                                            <span style="color:#6b7280; font-size:13px;">Receipt not available</span>
                                        </div>
                                    </div>`;
                        }
                        const escapedUrl = url
                            .replace(/'/g, "\\'")
                            .replace(/"/g, "&quot;");
                        return `
                                <div style="margin-top:12px; padding-top:12px; border-top:1px solid #e5e7eb;">
                                    <div style="font-size:12px; font-weight:600; color:#6b7280; margin-bottom:8px; display:flex; align-items:center; gap:6px;">
                                        <i class="fas fa-receipt" style="color:#6b7280; font-size:11px;"></i>
                                        GCash Receipt (Customer Upload)
                                    </div>
                                    <div style="display:flex; flex-direction:column; gap:8px;">
                                        <img src="${url}" alt="GCash Receipt" style="max-width:100%; max-width:300px; border:1px solid #e5e7eb; border-radius:6px; cursor:pointer; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1);" 
                                             onclick="event.preventDefault(); event.stopPropagation(); if(window.staffManager && typeof window.staffManager.showEnlargedImage === 'function') { window.staffManager.showEnlargedImage('${escapedUrl}', 'GCash Receipt'); }" 
                                             onerror="this.style.display='none'" 
                                             onmouseenter="this.style.transform='scale(1.02)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)';"
                                             onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='0 1px 3px rgba(0,0,0,0.1)';"
                                             title="Click to view full size" />
                                    </div>
                                </div>`;
                    }
                    return "";
                })()}
                    </div>

                    <div style="margin-bottom:20px; padding:12px; background:#ffffff; border:1px solid #e5e7eb; border-radius:6px;">
                        <div style="font-size:13px; font-weight:600; color:#374151; margin-bottom:8px; display:flex; align-items:center; gap:6px;">
                            <i class="fas ${isDelivery ? "fa-truck" : "fa-map-marker-alt"
                }" style="color:#6b7280; font-size:12px;"></i>
                            ${isDelivery
                    ? "Delivery Address"
                    : isPickup
                        ? "Pickup Address"
                        : "Address"
                }
                        </div>
                        <div style="font-size:14px; color:#111827; line-height:1.6;">${addressText}</div>
                        ${isPickup && order.pickupMapLink
                    ? `<div style="margin-top:8px;"><a href="${order.pickupMapLink}" target="_blank" rel="noopener" style="color:#2563eb; text-decoration:none; font-size:13px; display:inline-flex; align-items:center; gap:4px;"><i class="fas fa-external-link-alt" style="font-size:11px;"></i> View on Map</a></div>`
                    : ""
                }
                    </div>

                    <div style="padding:12px; background:#ffffff; border:1px solid #e5e7eb; border-radius:6px;">
                        <div style="font-size:13px; font-weight:600; color:#374151; margin-bottom:12px; display:flex; align-items:center; gap:6px;">
                            <i class="fas fa-calculator" style="color:#6b7280; font-size:12px;"></i>
                            Amount Breakdown
                        </div>
                        <div style="display:flex; flex-direction:column; gap:8px;">
                            <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;">
                                <span style="color:#6b7280; font-size:13px;">Subtotal</span>
                                <span style="color:#111827; font-weight:500; font-size:13px;">â‚±${(
                    order.subtotal || 0
                ).toLocaleString()}</span>
                            </div>
                            ${(order.deliveryFee || 0) > 0
                    ? `
                            <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;">
                                <span style="color:#6b7280; font-size:13px;">Delivery Fee</span>
                                <span style="color:#111827; font-weight:500; font-size:13px;">â‚±${order.deliveryFee.toLocaleString()}</span>
                            </div>
                            `
                    : ""
                }
                            <div style="display:flex; justify-content:space-between; padding:6px 0;">
                                <span style="color:#111827; font-weight:700; font-size:15px;">Total Amount</span>
                                <span style="color:#059669; font-weight:700; font-size:16px;">â‚±${totalDisplay}</span>
                            </div>
                        </div>
                    </div>

                    ${(() => {
                    // Show ratings ONLY for delivered/picked_up orders that are rated
                    const statusLower = (order.status || "").toLowerCase();
                    const isRated = order.isRated || order.is_rated || false;

                    // Only show for delivered or picked_up orders that are rated
                    if (
                        (statusLower !== "delivered" &&
                            statusLower !== "picked_up") ||
                        !isRated
                    ) {
                        return "";
                    }

                    const orderRating =
                        order.orderRating || order.order_rating || 0;
                    const orderComment =
                        order.orderComment || order.order_comment || "";
                    const riderRating =
                        order.riderRating || order.rider_rating || 0;
                    const riderComment =
                        order.riderComment || order.rider_comment || "";
                    const orderRatedAt =
                        order.orderRatedAt || order.order_rated_at;
                    const orderMedia = (() => {
                        try {
                            const media = order.orderMedia || order.order_media;
                            if (!media) return [];
                            return typeof media === "string"
                                ? JSON.parse(media)
                                : media;
                        } catch {
                            return [];
                        }
                    })();

                    const renderStars = (rating) => {
                        return Array(5)
                            .fill(0)
                            .map((_, i) =>
                                i < rating
                                    ? '<i class="fas fa-star" style="color:#FFA500;"></i>'
                                    : '<i class="far fa-star" style="color:#D1D5DB;"></i>'
                            )
                            .join("");
                    };

                    const pickupExperience =
                        order.pickupExperienceComment ||
                        order.pickup_experience_comment ||
                        "";
                    const isPickupOrder =
                        (
                            order.deliveryOption ||
                            order.delivery_option ||
                            ""
                        ).toLowerCase() === "pickup";

                    return `
                        <div style="margin-top:24px; padding:20px; background:linear-gradient(135deg, #FFF7ED 0%, #FEF3C7 100%); border:2px solid #F59E0B; border-radius:12px; box-shadow:0 4px 12px rgba(245, 158, 11, 0.15);">
                            <!-- Header -->
                            <div style="margin-bottom:20px; padding-bottom:16px; border-bottom:2px solid #F59E0B;">
                                <div style="display:flex; align-items:center; justify-content:space-between; flex-wrap:wrap; gap:12px;">
                                    <div style="display:flex; align-items:center; gap:10px;">
                                        <div style="width:40px; height:40px; background:linear-gradient(135deg, #F59E0B, #D97706); border-radius:50%; display:flex; align-items:center; justify-content:center; box-shadow:0 2px 8px rgba(245, 158, 11, 0.3);">
                                            <i class="fas fa-star" style="color:#ffffff; font-size:18px;"></i>
                                        </div>
                                        <div>
                                            <div style="font-size:18px; font-weight:700; color:#92400E; line-height:1.2;">Customer Feedback</div>
                                            <div style="font-size:12px; color:#D97706; margin-top:2px;">
                                                ${orderRatedAt
                            ? `Rated on ${new Date(
                                orderRatedAt
                            ).toLocaleDateString()} at ${new Date(
                                orderRatedAt
                            ).toLocaleTimeString()}`
                            : "Order has been rated"
                        }
                                            </div>
                                        </div>
                                    </div>
                                    <div style="padding:6px 14px; background:#dcfce7; border:1px solid #16a34a; border-radius:20px; font-size:11px; font-weight:700; color:#15803d; text-transform:uppercase; letter-spacing:0.5px;">
                                        âœ“ Rated
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Content Grid -->
                            <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(280px, 1fr)); gap:16px;">
                                <!-- Order Rating Card -->
                                <div style="padding:16px; background:#ffffff; border-radius:10px; box-shadow:0 2px 8px rgba(0,0,0,0.08); border-left:4px solid #059669;">
                                    <div style="margin-bottom:12px;">
                                        <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                                            <div style="width:32px; height:32px; background:linear-gradient(135deg, #059669, #047857); border-radius:8px; display:flex; align-items:center; justify-content:center;">
                                                <i class="fas fa-shopping-bag" style="color:#ffffff; font-size:14px;"></i>
                                            </div>
                                            <span style="font-size:15px; font-weight:700; color:#065f46;">Order Rating</span>
                                        </div>
                                        <div style="display:flex; align-items:center; gap:8px; padding:10px; background:#f0fdf4; border-radius:8px;">
                                            <div style="font-size:24px;">${renderStars(
                            orderRating
                        )}</div>
                                            <div style="font-size:20px; font-weight:700; color:#059669;">${orderRating}<span style="font-size:14px; color:#6b7280;">/5</span></div>
                                        </div>
                                    </div>
                                    ${orderComment
                            ? `
                                        <div style="margin-top:12px;">
                                            <div style="font-size:11px; font-weight:600; color:#6b7280; text-transform:uppercase; letter-spacing:0.5px; margin-bottom:6px;">Comment</div>
                                            <div style="font-size:13px; color:#111827; padding:10px; background:#f9fafb; border-radius:6px; border-left:3px solid #059669; line-height:1.5;">
                                                "${orderComment}"
                                            </div>
                                        </div>
                                    `
                            : '<div style="font-size:12px; color:#9ca3af; font-style:italic; margin-top:8px;">No comment provided</div>'
                        }
                                </div>
                                
                                <!-- Rider/Pickup Rating Card -->
                                ${isPickupOrder && pickupExperience
                            ? `
                                <div style="padding:16px; background:#ffffff; border-radius:10px; box-shadow:0 2px 8px rgba(0,0,0,0.08); border-left:4px solid #f97316;">
                                    <div style="margin-bottom:12px;">
                                        <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                                            <div style="width:32px; height:32px; background:linear-gradient(135deg, #f97316, #ea580c); border-radius:8px; display:flex; align-items:center; justify-content:center;">
                                                <i class="fas fa-store" style="color:#ffffff; font-size:14px;"></i>
                                            </div>
                                            <span style="font-size:15px; font-weight:700; color:#c2410c;">Pickup Experience</span>
                                        </div>
                                    </div>
                                    <div style="margin-top:12px;">
                                        <div style="font-size:11px; font-weight:600; color:#6b7280; text-transform:uppercase; letter-spacing:0.5px; margin-bottom:6px;">Comment</div>
                                        <div style="font-size:13px; color:#111827; padding:10px; background:#fff7ed; border-radius:6px; border-left:3px solid #f97316; line-height:1.5;">
                                            "${pickupExperience}"
                                        </div>
                                    </div>
                                </div>
                                `
                            : riderRating > 0
                                ? `
                                <div style="padding:16px; background:#ffffff; border-radius:10px; box-shadow:0 2px 8px rgba(0,0,0,0.08); border-left:4px solid #2563eb;">
                                    <div style="margin-bottom:12px;">
                                        <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                                            <div style="width:32px; height:32px; background:linear-gradient(135deg, #2563eb, #1d4ed8); border-radius:8px; display:flex; align-items:center; justify-content:center;">
                                                <i class="fas fa-motorcycle" style="color:#ffffff; font-size:14px;"></i>
                                            </div>
                                            <span style="font-size:15px; font-weight:700; color:#1e40af;">Rider Rating</span>
                                        </div>
                                        <div style="display:flex; align-items:center; gap:8px; padding:10px; background:#eff6ff; border-radius:8px;">
                                            <div style="font-size:24px;">${renderStars(
                                    riderRating
                                )}</div>
                                            <div style="font-size:20px; font-weight:700; color:#2563eb;">${riderRating}<span style="font-size:14px; color:#6b7280;">/5</span></div>
                                        </div>
                                    </div>
                                    ${riderComment
                                    ? `
                                        <div style="margin-top:12px;">
                                            <div style="font-size:11px; font-weight:600; color:#6b7280; text-transform:uppercase; letter-spacing:0.5px; margin-bottom:6px;">Comment</div>
                                            <div style="font-size:13px; color:#111827; padding:10px; background:#f9fafb; border-radius:6px; border-left:3px solid #2563eb; line-height:1.5;">
                                                "${riderComment}"
                                            </div>
                                        </div>
                                    `
                                    : '<div style="font-size:12px; color:#9ca3af; font-style:italic; margin-top:8px;">No comment provided</div>'
                                }
                                </div>
                                `
                                : ""
                        }
                            </div>
                            
                            <!-- Media Gallery -->
                            ${orderMedia.length > 0
                            ? `
                                <div style="margin-top:20px; padding:16px; background:#ffffff; border-radius:10px; box-shadow:0 2px 8px rgba(0,0,0,0.08);">
                                    <div style="display:flex; align-items:center; gap:8px; margin-bottom:12px;">
                                        <div style="width:28px; height:28px; background:linear-gradient(135deg, #8b5cf6, #7c3aed); border-radius:6px; display:flex; align-items:center; justify-content:center;">
                                            <i class="fas fa-images" style="color:#ffffff; font-size:12px;"></i>
                                        </div>
                                        <span style="font-size:14px; font-weight:700; color:#5b21b6;">Customer Photos & Videos</span>
                                        <span style="font-size:12px; color:#6b7280; background:#f3f4f6; padding:2px 8px; border-radius:12px; font-weight:600;">${orderMedia.length
                            } ${orderMedia.length === 1 ? "file" : "files"
                            }</span>
                                    </div>
                                    <div style="display:grid; grid-template-columns:repeat(auto-fill, minmax(140px, 1fr)); gap:12px;">
                                        ${orderMedia
                                .map((mediaUrl, idx) => {
                                    const isVideo =
                                        mediaUrl
                                            .toLowerCase()
                                            .includes(".mp4") ||
                                        mediaUrl
                                            .toLowerCase()
                                            .includes(".webm") ||
                                        mediaUrl
                                            .toLowerCase()
                                            .includes(".mov");
                                    if (isVideo) {
                                        return `
                                                <div style="position:relative; border-radius:8px; overflow:hidden; box-shadow:0 2px 6px rgba(0,0,0,0.1); transition:transform 0.2s;" onmouseenter="this.style.transform='scale(1.02)'" onmouseleave="this.style.transform='scale(1)'">
                                                    <video controls style="width:100%; height:140px; object-fit:cover; display:block; background:#000;">
                                                        <source src="${mediaUrl}" type="video/mp4">
                                                    </video>
                                                    <div style="position:absolute; top:8px; right:8px; background:rgba(0,0,0,0.7); color:white; padding:4px 8px; border-radius:4px; font-size:10px; font-weight:600;">
                                                        <i class="fas fa-video"></i> VIDEO
                                                    </div>
                                                </div>
                                                `;
                                    }
                                    const escapedUrl = mediaUrl
                                        .replace(/'/g, "\\'")
                                        .replace(/"/g, "&quot;");
                                    return `
                                            <div style="position:relative; border-radius:8px; overflow:hidden; box-shadow:0 2px 6px rgba(0,0,0,0.1); cursor:pointer; transition:transform 0.2s;" 
                                                 onclick="event.preventDefault(); event.stopPropagation(); if(window.staffManager && typeof window.staffManager.showEnlargedImage === 'function') { window.staffManager.showEnlargedImage('${escapedUrl}', 'Customer Feedback ${idx + 1
                                        }'); }"
                                                 onmouseenter="this.style.transform='scale(1.02)'" 
                                                 onmouseleave="this.style.transform='scale(1)'">
                                                <img src="${mediaUrl}" alt="Customer feedback ${idx + 1
                                        }" 
                                                     style="width:100%; height:140px; object-fit:cover; display:block;" 
                                                     onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" />
                                                <div style="display:none; width:100%; height:140px; background:#f3f4f6; align-items:center; justify-content:center; color:#9ca3af;">
                                                    <i class="fas fa-image-slash" style="font-size:24px;"></i>
                                                </div>
                                                <div style="position:absolute; top:8px; right:8px; background:rgba(0,0,0,0.7); color:white; padding:4px 8px; border-radius:4px; font-size:10px; font-weight:600;">
                                                    <i class="fas fa-image"></i> ${idx + 1
                                        }
                                                </div>
                                            </div>
                                            `;
                                })
                                .join("")}
                                    </div>
                                </div>
                            `
                            : ""
                        }
                        </div>
                        `;
                })()}
                </div>

                ${cleanedActionsHtml
                    ? `<div class="order-actions" style="margin-top:20px; display:flex; justify-content:center; align-items:center; gap:12px; flex-wrap:wrap;">${cleanedActionsHtml}</div>`
                    : ""
                }
            `;

            // Ensure no extra contact buttons are appended later within order-actions
            const orderActionsEl = orderDetails.querySelector(".order-actions");
            if (orderActionsEl) {
                const removeExtraContactButtons = () => {
                    orderActionsEl
                        .querySelectorAll(".contact-customer-btn")
                        .forEach((btn) => btn.remove());
                };
                removeExtraContactButtons();
                if (typeof MutationObserver !== "undefined") {
                    if (orderActionsEl._contactBtnObserver) {
                        orderActionsEl._contactBtnObserver.disconnect();
                    }
                    const observer = new MutationObserver(() => {
                        removeExtraContactButtons();
                    });
                    observer.observe(orderActionsEl, { childList: true, subtree: true });
                    orderActionsEl._contactBtnObserver = observer;
                }

                // CRITICAL FIX: Re-attach event handlers to buttons after innerHTML is set
                // This is necessary because setting innerHTML removes all event handlers
                setTimeout(() => {
                    const buttons = orderActionsEl.querySelectorAll("button");
                    buttons.forEach((button, index) => {
                        const text = (button.textContent || "").toLowerCase().trim();

                        // First, try to restore onclick from data-onclick attribute
                        const savedOnclick = button.getAttribute("data-onclick");
                        if (savedOnclick) {
                            button.setAttribute("onclick", savedOnclick);
                            button.removeAttribute("data-onclick");
                        }

                        // If no saved onclick, try to infer from button text
                        if (!button.getAttribute("onclick")) {
                            // Fix confirm button (but not cancellation buttons)
                            if (
                                text.includes("confirm") &&
                                !text.includes("cancel") &&
                                !text.includes("refund")
                            ) {
                                // Try to find the original onclick handler or create a new one
                                button.setAttribute(
                                    "onclick",
                                    `if(window.staffManager && window.staffManager.confirmOrder){window.staffManager.confirmOrder('${id}');}`
                                );
                            }
                            // Fix reject button
                            else if (text.includes("reject")) {
                                button.setAttribute(
                                    "onclick",
                                    `if(window.staffManager && window.staffManager.rejectOrder){window.staffManager.rejectOrder('${id}');}`
                                );
                            }
                        }

                        // Ensure button is clickable with proper styles
                        button.style.cssText +=
                            "position: relative !important; z-index: 100 !important; pointer-events: auto !important; cursor: pointer !important;";

                        // Also add event listener as backup
                        button.addEventListener(
                            "click",
                            function (e) {
                                // Only handle if onclick didn't work
                                if (!e.defaultPrevented) {
                                    const btnText = (this.textContent || "").toLowerCase().trim();
                                    const onclickAttr = this.getAttribute("onclick") || "";

                                    // Check if this is a cancellation button - don't intercept those
                                    const isCancellationButton =
                                        btnText.includes("cancel") ||
                                        btnText.includes("refund") ||
                                        onclickAttr.includes("confirmCancelled") ||
                                        onclickAttr.includes("confirmCancelledNoRefund") ||
                                        onclickAttr.includes("confirmCancelledRefund");

                                    if (
                                        !isCancellationButton &&
                                        btnText.includes("confirm") &&
                                        window.staffManager &&
                                        typeof window.staffManager.confirmOrder === "function"
                                    ) {
                                        e.preventDefault();
                                        e.stopPropagation();
                                        window.staffManager.confirmOrder(id);
                                    } else if (
                                        btnText.includes("reject") &&
                                        window.staffManager &&
                                        typeof window.staffManager.rejectOrder === "function"
                                    ) {
                                        e.preventDefault();
                                        e.stopPropagation();
                                        window.staffManager.rejectOrder(id);
                                    }
                                }
                            },
                            true
                        ); // Use capture phase to ensure it fires
                    });
                }, 50);
            }
        } catch (err) {
            console.warn("Error restructuring pending order card:", err);
        }
    }

    bindFirebaseOrderListeners() {
        if (this.__ordersChildBound) return;
        if (!dbRefs || !dbRefs.orders) return;

        this.__ordersChildBound = true;
        const repaint = () => {
            if (typeof renderPendingOrdersFromObject === "function") {
                renderPendingOrdersFromObject(this._ordersCache);
            }
            this.loadStats();
            this.renderPendingOrdersSection();
        };

        this.__onChildAdded = (snap) => {
            const key = snap.key;
            const val = snap.val();
            if (!key || !val) return;
            this._ordersCache[key] = val;
            repaint();
        };
        this.__onChildChanged = (snap) => {
            const key = snap.key;
            const val = snap.val();
            if (!key) return;
            if (val === null) {
                delete this._ordersCache[key];
            } else {
                this._ordersCache[key] = val;
            }
            repaint();
        };
        this.__onChildRemoved = (snap) => {
            const key = snap.key;
            if (!key) return;
            delete this._ordersCache[key];
            repaint();
        };

        try {
            if (window.__ordersChildAddedHandler && window.__ordersPendingQuery) {
                window.__ordersPendingQuery.off(
                    "child_added",
                    window.__ordersChildAddedHandler
                );
                window.__ordersPendingQuery = null;
                window.__ordersChildAddedHandler = null;
            }
            if (window.__ordersChildChangedHandler) {
                window.dbRefs?.orders?.off(
                    "child_changed",
                    window.__ordersChildChangedHandler
                );
                window.__ordersChildChangedHandler = null;
            }
            window.dbRefs?.orders?.off("value");
        } catch (_) { }

        dbRefs.orders.on("child_added", this.__onChildAdded);
        dbRefs.orders.on("child_changed", (snapshot) => {
            console.log(
                "DEBUG: Main orders - child_changed detected:",
                snapshot.key,
                snapshot.val()
            );
            this.__onChildChanged(snapshot);
        });
        dbRefs.orders.on("child_removed", this.__onChildRemoved);
    }

    detachFirebaseOrderListeners() {
        if (!this.__ordersChildBound) return;
        try {
            if (dbRefs?.orders) {
                dbRefs.orders.off("child_added", this.__onChildAdded);
                dbRefs.orders.off("child_changed", this.__onChildChanged);
                dbRefs.orders.off("child_removed", this.__onChildRemoved);
            }
        } catch (err) {
            console.warn("Failed to detach Firebase order listeners", err);
        }
        this.__ordersChildBound = false;
        this.__onChildAdded = null;
        this.__onChildChanged = null;
        this.__onChildRemoved = null;
    }

    startSupabaseOrdersPolling() {
        if (!window.OrderSupabaseAdapter) return;
        if (this.__supabaseOrdersPollingTimer) return;

        const poll = async () => {
            try {
                const latest = await OrderSupabaseAdapter.fetchOrders();
                if (latest === null) return;
                const hash = OrderSupabaseAdapter.computeHash(latest);
                if (hash !== this.__supabaseOrdersHash) {
                    this.__supabaseOrdersHash = hash;
                    this._ordersCache = latest;
                    if (typeof renderPendingOrdersFromObject === "function") {
                        renderPendingOrdersFromObject(this._ordersCache);
                    }
                    this.loadStats();
                    this.renderPendingOrdersSection();
                }
            } catch (err) {
                console.warn("Supabase orders polling error:", err);
            }
        };

        this.__supabaseOrdersHash = OrderSupabaseAdapter.computeHash(
            this._ordersCache || {}
        );
        this.__supabaseOrdersPollingTimer = setInterval(poll, 15000);
        poll();
    }

    stopSupabaseOrdersPolling() {
        if (this.__supabaseOrdersPollingTimer) {
            clearInterval(this.__supabaseOrdersPollingTimer);
            this.__supabaseOrdersPollingTimer = null;
        }
        this.__supabaseOrdersHash = null;
    }
    async loadRejectedProducts() {
        try {
            console.log("Loading rejected products...");
            if (!window.OrderSupabaseAdapter) {
                this.renderRejectedOrdersError(
                    "Supabase orders adapter not available. Please refresh the page."
                );
                return;
            }

            const orders = await OrderSupabaseAdapter.fetchOrders();
            if (orders === null) {
                this.renderRejectedOrdersError(
                    "Unable to load rejected orders from Supabase."
                );
                return;
            }

            const entries = Object.entries(orders || {});
            const activeRejectedOrders = entries.filter(([id, order]) => {
                const s = String(order.status || "").toLowerCase();
                return s === "rejected";
            });

            const container = document.getElementById("rejectedProductsContainer");
            const countElement = document.getElementById("rejectedCount");
            if (!container || !countElement) return;

            countElement.textContent = activeRejectedOrders.length;
            container.innerHTML = "";

            if (activeRejectedOrders.length === 0) {
                container.innerHTML = `
                    <div class="empty-rejected">
                        <i class="fas fa-times-circle"></i>
                        <h3>No Rejected Products</h3>
                        <p>All rejected orders will appear here.</p>
                    </div>
                `;
                return;
            }

            const bulkDeleteContainer = document.createElement("div");
            bulkDeleteContainer.className = "bulk-delete-container";
            bulkDeleteContainer.style.cssText = `
                margin-bottom: 20px;
                padding: 15px;
                background: white;
                border-radius: 12px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                display: none;
            `;
            bulkDeleteContainer.innerHTML = `
                <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
                    <span class="selected-count">0 rejected products selected</span>
                    <button class="delete-selected-btn" onclick="staffManager.deleteSelectedRejectedProducts()">
                        <i class="fas fa-trash"></i> Delete Selected
                    </button>
                    <button class="select-all-btn" onclick="staffManager.toggleSelectAllRejectedProducts()">
                        <i class="fas fa-check-square"></i> Select All
                    </button>
                </div>
            `;
            container.appendChild(bulkDeleteContainer);

            // Use same grouping logic as cancelled/successful/failed tabs
            if (!this._ordersRejectedSortMode)
                this._ordersRejectedSortMode = "weekly"; // 'weekly' | 'monthly'
            if (!this._ordersRejectedExpanded) this._ordersRejectedExpanded = {}; // key -> bool

            const ensureSortToolbar = () => {
                const toolbarId = "rejected-orders-toolbar";
                let toolbar = document.getElementById(toolbarId);
                if (!toolbar) {
                    toolbar = document.createElement("div");
                    toolbar.id = toolbarId;
                    toolbar.style.cssText =
                        "display:flex; align-items:center; justify-content:flex-end; gap:8px; margin:6px 0 10px;";
                    toolbar.innerHTML = `
                        <label style="font-size:12px; color:#666;">Group by</label>
                        <select id="rejected-sort-select" style="padding:6px 8px; border:1px solid #ddd; border-radius:6px; font-size:12px;">
                            <option value="weekly">Weekly</option>
                            <option value="monthly">Monthly</option>
                        </select>
                    `;
                    container.parentElement?.insertBefore(toolbar, container);
                    const selectEl = toolbar.querySelector("select");
                    if (selectEl) {
                        selectEl.value = this._ordersRejectedSortMode;
                        selectEl.addEventListener("change", (e) => {
                            this._ordersRejectedSortMode = e.target.value;
                            this.loadRejectedProducts(); // re-render
                        });
                    }
                } else {
                    const selectEl = toolbar.querySelector("select");
                    if (selectEl) selectEl.value = this._ordersRejectedSortMode;
                }
            };

            ensureSortToolbar();

            // Use same week calculation logic as successful/failed/cancelled tabs
            const getWeekKey = (ts) => {
                const d = new Date(Number(ts || 0));
                const year = d.getFullYear();

                const date = new Date(d);
                date.setHours(0, 0, 0, 0);

                const dayOfWeek = date.getDay();
                const daysToMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;

                const monday = new Date(date);
                monday.setDate(date.getDate() - daysToMonday);

                const jan1 = new Date(year, 0, 1);
                jan1.setHours(0, 0, 0, 0);
                const jan1DayOfWeek = jan1.getDay();

                const firstMonday = new Date(jan1);
                if (jan1DayOfWeek === 0) {
                    firstMonday.setDate(2);
                } else if (jan1DayOfWeek === 1) {
                    // firstMonday is already Jan 1
                } else {
                    const daysToFirstMonday = 8 - jan1DayOfWeek;
                    firstMonday.setDate(1 + daysToFirstMonday);
                }

                const daysDiff = Math.floor(
                    (monday.getTime() - firstMonday.getTime()) / (1000 * 60 * 60 * 24)
                );
                const weekNumber = Math.floor(daysDiff / 7) + 1;

                if (daysDiff < 0) {
                    return `${year}-W1`;
                }

                return `${year}-W${weekNumber}`;
            };

            const getGroupKey = (ts) => {
                const d = new Date(Number(ts || 0));
                if (this._ordersRejectedSortMode === "monthly") {
                    const mm = String(d.getMonth() + 1).padStart(2, "0");
                    return `${d.getFullYear()}-${mm}`;
                }
                return getWeekKey(ts);
            };

            const getGroupTitle = (key) => {
                if (this._ordersRejectedSortMode === "monthly") {
                    const [year, mm] = key.split("-");
                    const monthNames = [
                        "",
                        "January",
                        "February",
                        "March",
                        "April",
                        "May",
                        "June",
                        "July",
                        "August",
                        "September",
                        "October",
                        "November",
                        "December",
                    ];
                    return `${monthNames[Number(mm)]} ${year}`;
                }
                return getWeekTitle(key);
            };

            const getWeekTitle = (wKey) => {
                const [year, wStr] = String(wKey || "").split("-W");
                const week = Number(wStr);

                const jan1 = new Date(Number(year), 0, 1);
                jan1.setHours(0, 0, 0, 0);
                const jan1DayOfWeek = jan1.getDay();

                const firstMonday = new Date(jan1);
                if (jan1DayOfWeek === 0) {
                    firstMonday.setDate(2);
                } else if (jan1DayOfWeek === 1) {
                    // firstMonday is already Jan 1
                } else {
                    const daysToFirstMonday = 8 - jan1DayOfWeek;
                    firstMonday.setDate(1 + daysToFirstMonday);
                }

                const weekStart = new Date(firstMonday);
                weekStart.setDate(firstMonday.getDate() + (week - 1) * 7);

                const weekEnd = new Date(weekStart);
                weekEnd.setDate(weekStart.getDate() + 6);

                const fmt = (d) => {
                    const day = String(d.getDate()).padStart(2, "0");
                    const month = String(d.getMonth() + 1).padStart(2, "0");
                    return `${day}/${month}/${d.getFullYear()}`;
                };
                return `Week of ${fmt(weekStart)} - ${fmt(weekEnd)}`;
            };

            const buildGroupHeader = (key, count) => {
                const isExpanded = !!this._ordersRejectedExpanded[key];
                const header = document.createElement("div");
                header.style.cssText =
                    "display:flex; align-items:center; gap:10px; padding:10px 12px; background:#f5f9ff; border:1px solid #e3f2fd; border-radius:8px; cursor:pointer;";
                header.innerHTML = `
                    <i class="fas ${this._ordersRejectedSortMode === "monthly"
                        ? "fa-calendar-alt"
                        : "fa-calendar-week"
                    }" style="color:#1976d2;"></i>
                    <div style="flex:1;">
                        <div style="font-weight:600; color:#1976d2;">${getGroupTitle(
                        key
                    )}</div>
                        <div style="font-size:12px; color:#5c6bc0;">${this._ordersRejectedSortMode === "monthly"
                        ? "Monthly View"
                        : "Weekly View"
                    }</div>
                    </div>
                    <div style="display:flex; align-items:center; gap:10px;">
                        <span style="font-size:12px; color:#555;">${count} orders</span>
                        <i class="fas ${isExpanded ? "fa-chevron-up" : "fa-chevron-down"
                    }" style="color:#1976d2;"></i>
                    </div>
                `;
                header.addEventListener("click", () => {
                    this._ordersRejectedExpanded[key] = !isExpanded;
                    this.loadRejectedProducts();
                });
                return header;
            };

            // Build groups
            const map = new Map();
            activeRejectedOrders.forEach(([id, o]) => {
                // Group by createdAt (when order was placed)
                const ts =
                    o.createdAt ||
                    o.created_at ||
                    o.orderDate ||
                    o.order_date ||
                    Date.now();
                const key = getGroupKey(ts);
                if (!map.has(key)) map.set(key, []);
                map.get(key).push([id, o]);
            });

            const keys = Array.from(map.keys()).sort((a, b) => b.localeCompare(a));
            keys.forEach((key) => {
                const groupDiv = document.createElement("div");
                groupDiv.style.cssText = "margin:8px 0;";
                const groupItems = map.get(key) || [];
                groupDiv.appendChild(buildGroupHeader(key, groupItems.length));
                if (this._ordersRejectedExpanded[key]) {
                    if (this._ordersRejectedSortMode === "monthly") {
                        const weekMap = new Map();
                        groupItems.forEach(([id, o]) => {
                            const ts =
                                o.createdAt ||
                                o.created_at ||
                                o.orderDate ||
                                o.order_date ||
                                Date.now();
                            const wKey = getWeekKey(ts);
                            if (!weekMap.has(wKey)) weekMap.set(wKey, []);
                            weekMap.get(wKey).push([id, o]);
                        });
                        const weekKeys = Array.from(weekMap.keys()).sort((a, b) =>
                            b.localeCompare(a)
                        );
                        weekKeys.forEach((wKey) => {
                            const composite = `${key}::${wKey}`;
                            const wkHeader = document.createElement("div");
                            const isWExpanded = !!this._ordersRejectedExpanded[composite];
                            wkHeader.style.cssText =
                                "margin:8px 0 4px; padding:8px 10px; background:#eef4ff; border:1px dashed #c5d7fe; border-radius:6px; cursor:pointer; display:flex; align-items:center; gap:8px;";
                            wkHeader.innerHTML = `
                                <i class="fas fa-calendar-week" style="color:#3f51b5;"></i>
                                <div style="flex:1; color:#3f51b5; font-weight:600;">${getWeekTitle(
                                wKey
                            )}</div>
                                <i class="fas ${isWExpanded
                                    ? "fa-chevron-up"
                                    : "fa-chevron-down"
                                }" style="color:#3f51b5;"></i>
                            `;
                            wkHeader.addEventListener("click", () => {
                                this._ordersRejectedExpanded[composite] = !isWExpanded;
                                this.loadRejectedProducts();
                            });
                            groupDiv.appendChild(wkHeader);
                            if (isWExpanded) {
                                const listDiv = document.createElement("div");
                                listDiv.style.cssText =
                                    "margin-top:4px; display:flex; flex-direction:column; gap:8px;";
                                const weekItems = weekMap.get(wKey) || [];
                                // Sort by createdAt (when order was placed) - descending
                                weekItems.sort((a, b) => {
                                    const at =
                                        a[1].createdAt ||
                                        a[1].created_at ||
                                        a[1].orderDate ||
                                        a[1].order_date ||
                                        0;
                                    const bt =
                                        b[1].createdAt ||
                                        b[1].created_at ||
                                        b[1].orderDate ||
                                        b[1].order_date ||
                                        0;
                                    return bt - at;
                                });
                                weekItems.forEach(([id, order]) => {
                                    const card = this.createRejectedProductCard(id, order);
                                    listDiv.appendChild(card);
                                    // Load staff notes after card is created
                                    setTimeout(() => this.loadStaffNotesIntoCard(id), 100);
                                });
                                groupDiv.appendChild(listDiv);
                            }
                        });
                    } else {
                        const listDiv = document.createElement("div");
                        listDiv.style.cssText =
                            "margin-top:8px; display:flex; flex-direction:column; gap:8px;";
                        // Sort by createdAt (when order was placed) - descending
                        groupItems.sort((a, b) => {
                            const at =
                                a[1].createdAt ||
                                a[1].created_at ||
                                a[1].orderDate ||
                                a[1].order_date ||
                                0;
                            const bt =
                                b[1].createdAt ||
                                b[1].created_at ||
                                b[1].orderDate ||
                                b[1].order_date ||
                                0;
                            return bt - at;
                        });
                        groupItems.forEach(([id, order]) => {
                            const card = this.createRejectedProductCard(id, order);
                            listDiv.appendChild(card);
                            // Load staff notes after card is created
                            setTimeout(() => this.loadStaffNotesIntoCard(id), 100);
                        });
                        groupDiv.appendChild(listDiv);
                    }
                }
                container.appendChild(groupDiv);
            });
        } catch (error) {
            console.error("Error loading rejected products:", error);
            this.renderRejectedOrdersError("Failed to load rejected orders.");
        }
    }
    createRejectedProductCard(id, order) {
        const div = document.createElement("div");
        div.className = "rejected-product-card fade-in";
        div.style.cssText =
            "background:#ffffff; border:1px solid #e5e7eb; border-radius:10px; margin-bottom:16px; overflow:hidden; box-shadow:0 1px 3px rgba(0,0,0,0.1); transition:box-shadow 0.2s;";

        const statusLower = String(order.status || "").toLowerCase();
        const rejectedTimestamp =
            order.rejectedAt ||
            order.rejected_at ||
            order.updatedAt ||
            order.createdAt;
        const eventTs =
            statusLower === "cancelled"
                ? order.refundConfirmedAt ||
                order.refundConfirmed_at ||
                order.cancellationRequestedAt ||
                order.cancellation_requested_at ||
                order.createdAt
                : rejectedTimestamp || order.createdAt;
        const rejectedDate = new Date(eventTs);

        // Track expanded state per order
        if (!window.staffManager._orderCardsExpanded)
            window.staffManager._orderCardsExpanded = {};
        const isExpanded = !!window.staffManager._orderCardsExpanded[id];

        div.innerHTML = `
            <div class="rejected-selection" style="position:absolute; left:16px; top:18px; z-index:10;">
                <input type="checkbox" class="rejected-checkbox" data-order-id="${id}" onchange="staffManager.updateRejectedSelection()" onclick="event.stopPropagation();">
                <label class="checkbox-label"></label>
            </div>
            <div class="rejected-product-header" style="padding:20px 20px 20px 50px; cursor:pointer; background:linear-gradient(to right, #f9fafb 0%, #ffffff 100%); border-bottom:1px solid #e5e7eb; display:flex; align-items:center; gap:16px; position:relative; transition:background 0.2s;" onmouseover="this.style.background='linear-gradient(to right, #f3f4f6 0%, #f9fafb 100%)';" onmouseout="this.style.background='linear-gradient(to right, #f9fafb 0%, #ffffff 100%)';" onclick="(function(){ const card=this.closest('.rejected-product-card'); const details=card.querySelector('.order-details-container'); const icon=card.querySelector('.expand-icon'); if(details.style.display==='none'){details.style.display='block';icon.classList.remove('fa-chevron-down');icon.classList.add('fa-chevron-up');window.staffManager._orderCardsExpanded['${id}']=true;}else{details.style.display='none';icon.classList.remove('fa-chevron-up');icon.classList.add('fa-chevron-down');window.staffManager._orderCardsExpanded['${id}']=false;}}).call(this);">
                <i class="fas ${isExpanded ? "fa-chevron-up" : "fa-chevron-down"
            } expand-icon" style="color:#6b7280; font-size:16px; min-width:20px;"></i>
                <div class="rejected-product-info" style="flex:1;">
                    <div style="display:flex; align-items:center; gap:12px; margin-bottom:8px;">
                        <h4 style="margin:0; font-size:18px; font-weight:700; color:#111827; letter-spacing:-0.5px;">Order #${id
                .substr(-8)
                .toUpperCase()}</h4>
                        ${(() => {
                // Check if order is cancelled (by status or cancellation flags)
                const isCancelled =
                    statusLower === "cancelled" ||
                    order.cancellationConfirmed === true ||
                    order.cancellation_confirmed === true ||
                    order.refundConfirmedAt ||
                    order.refund_confirmed_at ||
                    order.refundDenied === true ||
                    order.refund_denied === true ||
                    order.refundReceiptUrl ||
                    order.refund_receipt_url;

                if (isCancelled) {
                    // Check if refunded - exclude refundDenied orders (they are explicitly NOT refunded)
                    // If refundDenied is true, it's NOT refunded regardless of other fields
                    const isRefundDenied =
                        order.refundDenied === true ||
                        order.refund_denied === true;
                    const hasRefundReceipt = !!(
                        order.refundReceiptUrl || order.refund_receipt_url
                    );
                    const hasRefundConfirmed = !!(
                        order.refundConfirmedAt ||
                        order.refund_confirmed_at
                    );
                    // Only consider refunded if NOT denied AND (has refund receipt OR refund confirmed)
                    const isRefunded =
                        !isRefundDenied &&
                        (hasRefundReceipt || hasRefundConfirmed);
                    const refundStatus = isRefunded
                        ? "Refunded"
                        : "None-refunded";
                    const bgColor = isRefunded ? "#d1fae5" : "#fee2e2";
                    const textColor = isRefunded
                        ? "#065f46"
                        : "#991b1b";
                    return `<span style="padding:4px 10px; background:${bgColor}; color:${textColor}; border-radius:6px; font-size:11px; font-weight:600; text-transform:uppercase; letter-spacing:0.5px;">Cancelled: ${refundStatus}</span>`;
                } else if (statusLower === "rejected") {
                    return `<span style="padding:4px 10px; background:#fee2e2; color:#991b1b; border-radius:6px; font-size:11px; font-weight:600; text-transform:uppercase; letter-spacing:0.5px;">Rejected</span>`;
                } else {
                    return `<span style="padding:4px 10px; background:#f3f4f6; color:#374151; border-radius:6px; font-size:11px; font-weight:600; text-transform:uppercase; letter-spacing:0.5px;">${statusLower || "Unknown"
                        }</span>`;
                }
            })()}
                    </div>
                    <div style="display:flex; flex-wrap:wrap; gap:20px; font-size:14px; color:#4b5563;">
                        <span style="display:flex; align-items:center; gap:6px;"><i class="fas fa-user" style="color:#9ca3af; font-size:12px;"></i><strong style="color:#374151;">${order.customerName
            }</strong></span>
                        <span style="display:flex; align-items:center; gap:6px;"><i class="fas fa-peso-sign" style="color:#9ca3af; font-size:12px;"></i><strong style="color:#059669;">â‚±${order.totalAmount.toLocaleString()}</strong></span>
                        <span style="display:flex; align-items:center; gap:6px;"><i class="fas fa-calendar" style="color:#9ca3af; font-size:12px;"></i>${order.createdAt
                ? new Date(order.createdAt).toLocaleDateString(
                    "en-US",
                    {
                        month: "short",
                        day: "numeric",
                        year: "numeric",
                    }
                )
                : "Unknown"
            }</span>
                    </div>
                </div>
            </div>
            <div class="order-details-container" style="display:${isExpanded ? "block" : "none"
            }; padding:24px; background:#ffffff;">
                <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(280px, 1fr)); gap:20px; margin-bottom:24px;">
                    <div style="background:#f9fafb; padding:16px; border-radius:8px; border:1px solid #e5e7eb;">
                        <h5 style="margin:0 0 12px 0; font-size:12px; font-weight:700; color:#6b7280; text-transform:uppercase; letter-spacing:0.8px;">Customer Information</h5>
                        <div style="display:flex; flex-direction:column; gap:8px;">
                            <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Name</span><span style="color:#111827; font-weight:500; font-size:13px;">${order.customerName
            }</span></div>
                            <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Contact</span><span style="color:#111827; font-weight:500; font-size:13px;">${order.customerPhone
            }</span></div>
                            <div style="display:flex; flex-direction:column; gap:10px; margin-top:12px;">
                                <button class="secondary-btn" onclick="staffManager.viewOrderCustomerDetails('${id}', '${(order.customerName || "").replace(/'/g, "\\'")}', '${(order.customerPhone || "").replace(/'/g, "\\'")}', '${((order.deliveryAddress || order.customerAddress || "").replace(/'/g, "\\'"))}')" style="padding:10px 20px; border-radius:6px; font-size:13px; font-weight:500;">
                                    <i class="fas fa-user"></i> Customer Details
                                </button>
                                <button class="secondary-btn" onclick="(async function(){ try { const customerId = '${(
                    order.customerId ||
                    order.customer_id ||
                    id
                )
                    .toString()
                    .replace(/'/g, "\\'")}'; let customerName = '${(
                        order.customerName || "Customer"
                    )
                        .replace(/'/g, "\\'")
                        .replace(
                            /"/g,
                            "&quot;"
                        )}'; if(typeof openChatWithCustomer === 'function') { await openChatWithCustomer(customerId, customerName); } else if(typeof window.openChatWithCustomer === 'function') { await window.openChatWithCustomer(customerId, customerName); } else { console.error('openChatWithCustomer function not found'); } } catch(e) { console.error('Error opening chat:', e); } })();" style="padding:10px 20px; border-radius:6px; font-size:13px; font-weight:500; background:linear-gradient(135deg, #4CAF50, #45a049); color:white; border:none; box-shadow:0 2px 8px rgba(76, 175, 80, 0.3);">
                                    <i class="fas fa-comments"></i> Contact Customer
                                </button>
                            </div>
                        </div>
                    </div>
                    <div style="background:#f9fafb; padding:16px; border-radius:8px; border:1px solid #e5e7eb;">
                        <h5 style="margin:0 0 12px 0; font-size:12px; font-weight:700; color:#6b7280; text-transform:uppercase; letter-spacing:0.8px;">Order Summary</h5>
                        <div style="display:flex; flex-direction:column; gap:8px;">
                            <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Order ID</span><span style="color:#111827; font-weight:600; font-size:13px;">#${id
                .substr(-8)
                .toUpperCase()}</span></div>
                            <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Order Date</span><span style="color:#111827; font-weight:500; font-size:13px;">${order.createdAt
                ? new Date(order.createdAt).toLocaleString()
                : "Unknown"
            }</span></div>
                            ${(order.deliveryOption || "").toLowerCase() === "pickup" &&
                (order.readyForPickup === true || order.ready_for_pickup === true) &&
                (order.ready_for_pickup_at || order.readyForPickupAt)
                ? `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Pickup Schedule</span><span style="color:#111827; font-weight:500; font-size:13px;">${new Date(
                    order.ready_for_pickup_at || order.readyForPickupAt
                ).toLocaleDateString()}</span></div>`
                : ""
            }
                            ${(() => {
                // Show confirmed date and confirmed by for GCash orders that were confirmed but then cancelled
                // COD orders are already confirmed upon placement, so these fields don't apply
                // COD orders paid through GCash (has payment_proof) should also not show these fields
                const confirmedAt =
                    order.confirmedAt || order.confirmed_at;
                const confirmedByName =
                    order.confirmedByName ||
                    order.confirmed_by_name;
                const confirmedByRole =
                    order.confirmedByRole ||
                    order.confirmed_by_role ||
                    "";
                const confirmedByDisplay = confirmedByRole
                    ? `${confirmedByName} (${confirmedByRole})`
                    : confirmedByName;
                const isGCash =
                    String(
                        order.paymentMethod || ""
                    ).toLowerCase() === "gcash";
                const hasPaymentProof = !!(order.payment_proof || order.paymentProof);
                // Show only for original GCash orders (not COD orders, not COD paid through GCash)
                const isOriginalGcashOrder = isGCash && !hasPaymentProof;
                const isCancelled =
                    statusLower === "cancelled" ||
                    order.cancellationConfirmed === true ||
                    order.cancellation_confirmed === true ||
                    order.refundConfirmedAt ||
                    order.refund_confirmed_at ||
                    order.refundDenied === true ||
                    order.refund_denied === true;

                if (isOriginalGcashOrder && isCancelled && confirmedAt) {
                    return `
                                        <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Confirmed Date</span><span style="color:#111827; font-weight:500; font-size:13px;">${new Date(
                        confirmedAt
                    ).toLocaleString()}</span></div>
                                        ${confirmedByName
                            ? `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Confirmed By</span><span style="color:#111827; font-weight:500; font-size:13px;">${confirmedByDisplay}</span></div>`
                            : ""
                        }
                                    `;
                }
                return "";
            })()}
                            ${order.cancellationRequested === true &&
                String(
                    order.paymentMethod || ""
                ).toLowerCase() === "gcash" &&
                order.cancellationRequestedAt
                ? `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Cancellation Requested At</span><span style="color:#111827; font-weight:500; font-size:13px;">${new Date(
                    order.cancellationRequestedAt
                ).toLocaleString()}</span></div>`
                : ""
            }
                            <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Total Amount</span><span style="color:#059669; font-weight:700; font-size:15px;">â‚±${order.totalAmount.toLocaleString()}</span></div>
                            ${(() => {
                // Check if order is cancelled by status OR cancellation flags - do NOT show "Rejected At" and "Rejected By" for cancelled orders
                const isCancelled =
                    statusLower === "cancelled" ||
                    order.cancellationConfirmed === true ||
                    order.cancellation_confirmed === true ||
                    order.refundConfirmedAt ||
                    order.refund_confirmed_at ||
                    order.refundDenied === true ||
                    order.refund_denied === true ||
                    order.refundReceiptUrl ||
                    order.refund_receipt_url;
                if (isCancelled) {
                    // For cancelled orders, show "Cancelled: Refunded" or "Cancelled: None-refunded" instead of just status
                    // Check if refunded - exclude refundDenied orders (they are explicitly NOT refunded)
                    const isRefundDenied =
                        order.refundDenied === true ||
                        order.refund_denied === true;
                    const hasRefundReceipt = !!(
                        order.refundReceiptUrl ||
                        order.refund_receipt_url
                    );
                    const hasRefundConfirmed = !!(
                        order.refundConfirmedAt ||
                        order.refund_confirmed_at
                    );
                    // Only consider refunded if NOT denied AND (has refund receipt OR refund confirmed)
                    const isRefunded =
                        !isRefundDenied &&
                        (hasRefundReceipt || hasRefundConfirmed);
                    const refundStatus = isRefunded
                        ? "Refunded"
                        : "None-refunded";
                    const statusText = `Cancelled: ${refundStatus}`;
                    return `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Status</span><span style="color:#111827; font-weight:500; font-size:13px;">${statusText}</span></div>`;
                } else {
                    // For non-cancelled orders (rejected), show "Rejected At" and "Rejected By"
                    const rejectedByName =
                        order.rejectedByName ||
                        order.rejected_by_name ||
                        order.rejectedBy ||
                        order.rejected_by ||
                        order.updatedByName ||
                        order.updatedBy ||
                        order.cancellationInitiatedBy ||
                        "Staff";
                    const rejectedByRole =
                        order.rejectedByRole ||
                        order.rejected_by_role ||
                        "";
                    const rejectedByDisplay = rejectedByRole
                        ? `${rejectedByName} (${rejectedByRole})`
                        : rejectedByName;

                    return `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Rejected At</span><span style="color:#111827; font-weight:500; font-size:13px;">${rejectedTimestamp
                        ? new Date(
                            rejectedTimestamp
                        ).toLocaleString()
                        : "Unknown"
                        }</span></div>
                            <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Rejected By</span><span style="color:#111827; font-weight:500; font-size:13px;" id="rejected-by-${id}">${rejectedByDisplay}</span></div>
                            <div style="display:flex; justify-content:space-between; padding:6px 0;"><span style="color:#6b7280; font-size:13px;">Status</span><span style="padding:4px 8px; background:${statusLower === "cancelled"
                ? "#fef3c7"
                : "#fee2e2"
            }; color:${statusLower === "cancelled" ? "#92400e" : "#991b1b"
            }; border-radius:4px; font-size:11px; font-weight:600; text-transform:uppercase;">${statusLower}</span></div>`;
                }
                            })()}
                        </div>
                    </div>
                </div>
                
                ${statusLower === "rejected"
                ? `
                <div style="background:#fef2f2; border-left:4px solid #dc2626; border-radius:6px; padding:16px; margin-bottom:20px;">
                    <div style="display:flex; align-items:center; gap:10px; margin-bottom:10px;">
                        <i class="fas fa-exclamation-triangle" style="color:#dc2626; font-size:16px;"></i>
                        <h5 style="margin:0; font-size:14px; font-weight:700; color:#991b1b;">Rejection Reason</h5>
                    </div>
                    <p style="margin:0; font-size:14px; color:#7f1d1d; line-height:1.6;">${order.rejectionReason || "No reason provided"
                }</p>
                </div>
                `
                : ""
            }

                ${statusLower === "cancelled"
                ? `
                  ${(() => {
                    const pm = String(order.paymentMethod || "").toLowerCase();
                    // Fix: Check for GCash first, then cash (to avoid matching "gcash" as "cash")
                    const isGcash = pm === "gcash";
                    const isCash =
                        !isGcash &&
                        (pm.includes("cash") ||
                            pm === "cash_on_delivery" ||
                            pm === "cod");
                    const initiatedBy = String(
                        order.cancellationInitiatedBy || "customer"
                    );
                    if (isCash && initiatedBy !== "staff") {
                        const cancelledTs =
                            order.cancellationRequestedAt ||
                            order.updatedAt ||
                            order.createdAt;
                        const cancelledAt = cancelledTs
                            ? new Date(cancelledTs).toLocaleString()
                            : "Unknown";
                        const reason =
                            order.cancellationReason || "No reason provided";
                        return `
                    <div style="background:#fff7ed; border-left:4px solid #f59e0b; border-radius:6px; padding:16px; margin-bottom:20px;">
                      <div style="display:flex; align-items:center; gap:10px; margin-bottom:12px;">
                        <i class="fas fa-undo" style="color:#f59e0b; font-size:16px;"></i>
                        <h5 style="margin:0; font-size:14px; font-weight:700; color:#9a3412;">Cancellation Details</h5>
                      </div>
                      <div style="display:flex; flex-direction:column; gap:10px;">
                        <div style="display:flex; justify-content:space-between; padding:8px 0; border-bottom:1px solid #fed7aa;"><span style="color:#92400e; font-size:13px; font-weight:500;">Cancelled at</span><span style="color:#78350f; font-size:13px;">${cancelledAt}</span></div>
                        <div style="display:flex; justify-content:space-between; padding:8px 0; border-bottom:1px solid #fed7aa;"><span style="color:#92400e; font-size:13px; font-weight:500;">Payment</span><span style="color:#78350f; font-size:13px; font-weight:600;">CASH</span></div>
                        <div style="padding:8px 0;"><span style="color:#92400e; font-size:13px; font-weight:500; display:block; margin-bottom:6px;">Customer Reason</span><span style="color:#78350f; font-size:13px; line-height:1.5;">${reason}</span></div>
                      </div>
                    </div>`;
                    }
                    return "";
                })()}
                  ${(() => {
                    const pm = String(order.paymentMethod || "").toLowerCase();
                    // Fix: Check for GCash first, then cash (to avoid matching "gcash" as "cash")
                    const isGcash = pm === "gcash";
                    const isCash =
                        !isGcash &&
                        (pm.includes("cash") ||
                            pm === "cash_on_delivery" ||
                            pm === "cod");
                    const initiatedBy = String(
                        order.cancellationInitiatedBy || "customer"
                    );
                    if (isCash && initiatedBy !== "staff") {
                        // For cash customer-initiated cancellations, do not render refunded/not-refunded sections
                        return "";
                    }
                    // Handle cancelled GCash orders that are not refunded and not denied
                    // Check both refundConfirmedAt and refundReceiptUrl - if either exists, it's refunded
                    const hasRefund = !!(
                        order.refundConfirmedAt ||
                        order.refund_confirmed_at ||
                        order.refundReceiptUrl ||
                        order.refund_receipt_url
                    );
                    if (isGcash && order.refundDenied !== true && !hasRefund) {
                        const cancelledTs =
                            order.cancellationRequestedAt ||
                            order.updatedAt ||
                            order.createdAt;
                        const cancelledAt = cancelledTs
                            ? new Date(cancelledTs).toLocaleString()
                            : "Unknown";
                        const reason =
                            order.cancellationReason || "No reason provided";
                        return `
                    <div style="background:#fff7ed; border-left:4px solid #f59e0b; border-radius:6px; padding:16px; margin-bottom:20px;">
                      <div style="display:flex; align-items:center; gap:10px; margin-bottom:12px;">
                        <i class="fas fa-undo" style="color:#f59e0b; font-size:16px;"></i>
                        <h5 style="margin:0; font-size:14px; font-weight:700; color:#9a3412;">Cancellation Details</h5>
                      </div>
                      <div style="display:flex; flex-direction:column; gap:10px; margin-bottom:16px;">
                        ${order.cancellationRequestedAt
                                ? `<div style="display:flex; justify-content:space-between; padding:8px 0; border-bottom:1px solid #fed7aa;"><span style="color:#92400e; font-size:13px; font-weight:500;">Cancellation requested at</span><span style="color:#78350f; font-size:13px;">${new Date(
                                    order.cancellationRequestedAt
                                ).toLocaleString()}</span></div>`
                                : ""
                            }
                        <div style="display:flex; justify-content:space-between; padding:8px 0; border-bottom:1px solid #fed7aa;"><span style="color:#92400e; font-size:13px; font-weight:500;">Cancelled at</span><span style="color:#78350f; font-size:13px;">${cancelledAt}</span></div>
                        <div style="display:flex; justify-content:space-between; padding:8px 0; border-bottom:1px solid #fed7aa;"><span style="color:#92400e; font-size:13px; font-weight:500;">Payment</span><span style="color:#78350f; font-size:13px; font-weight:600;">GCASH</span></div>
                        <div style="padding:8px 0;"><span style="color:#92400e; font-size:13px; font-weight:500; display:block; margin-bottom:6px;">Customer Reason</span><span style="color:#78350f; font-size:13px; line-height:1.5;">${reason}</span></div>
                      </div>
                    </div>`;
                    }
                    return order.refundDenied === true
                        ? `
                    <div style="background:#fef2f2; border-left:4px solid #dc2626; border-radius:6px; padding:16px; margin-bottom:20px;">
                      <div style="display:flex; align-items:center; gap:10px; margin-bottom:12px;">
                        <i class="fas fa-times-circle" style="color:#dc2626; font-size:16px;"></i>
                        <h5 style="margin:0; font-size:14px; font-weight:700; color:#991b1b;">Cancelled (Not Refunded)</h5>
                      </div>
                      <div style="display:flex; flex-direction:column; gap:10px; margin-bottom:16px;">
                        ${order.cancellationRequestedAt
                            ? `<div style="display:flex; justify-content:space-between; padding:8px 0; border-bottom:1px solid #fecaca;"><span style="color:#991b1b; font-size:13px; font-weight:500;">Cancellation requested</span><span style="color:#7f1d1d; font-size:13px;">${new Date(
                                order.cancellationRequestedAt
                            ).toLocaleString()}</span></div>`
                            : ""
                        }
                        <div style="display:flex; justify-content:space-between; padding:8px 0; border-bottom:1px solid #fecaca;"><span style="color:#991b1b; font-size:13px; font-weight:500;">Payment</span><span style="color:#7f1d1d; font-size:13px; font-weight:600;">${String(
                            order.paymentMethod || ""
                        ).toUpperCase()}</span></div>
                        ${pm === "gcash"
                            ? `<div style="padding:8px 0; border-bottom:1px solid #fecaca;"><span style="color:#991b1b; font-size:13px; font-weight:500; display:block; margin-bottom:6px;">Customer Reason</span><span style="color:#7f1d1d; font-size:13px; line-height:1.5;">${order.cancellationReason || "No reason provided"
                            }</span></div>`
                            : ""
                        }
                        <div style="display:flex; justify-content:space-between; padding:8px 0; border-bottom:1px solid #fecaca;"><span style="color:#991b1b; font-size:13px; font-weight:500;">Status</span><span style="padding:4px 8px; background:#fee2e2; color:#991b1b; border-radius:4px; font-size:11px; font-weight:600;">Not Refunded</span></div>
                        <div style="padding:8px 0; border-bottom:1px solid #fecaca;"><span style="color:#991b1b; font-size:13px; font-weight:500; display:block; margin-bottom:6px;">Refund Rejection Reason</span><span style="color:#7f1d1d; font-size:13px; line-height:1.5;">${order.refundDeniedReason || "No reason provided"
                        }</span></div>
                        ${(() => {
                            const confirmedByName =
                                order.cancellation_confirmed_by_name ||
                                order.refundDeniedByName ||
                                order.refundDeniedBy ||
                                "Unknown";
                            const confirmedByRole =
                                order.cancellation_confirmed_by_role || "";
                            const confirmedByDisplay = confirmedByRole
                                ? `${confirmedByName} Â· ${confirmedByRole}`
                                : confirmedByName;
                            return `<div style="display:flex; justify-content:space-between; padding:8px 0; border-bottom:1px solid #fecaca;"><span style="color:#991b1b; font-size:13px; font-weight:500;">Cancellation confirmed by</span><span style="color:#7f1d1d; font-size:13px;" id="refund-denied-by-${id}">${confirmedByDisplay}</span></div>`;
                        })()}
                        <div style="display:flex; justify-content:space-between; padding:8px 0;"><span style="color:#991b1b; font-size:13px; font-weight:500;">Confirmed at</span><span style="color:#7f1d1d; font-size:13px;">${order.refundDeniedAt
                            ? new Date(order.refundDeniedAt).toLocaleString()
                            : "Unknown"
                        }</span></div>
                      </div>
                    </div>
                  `
                        : `
                    <div style="background:#f0fdf4; border-left:4px solid #10b981; border-radius:6px; padding:16px; margin-bottom:20px;">
                      <div style="display:flex; align-items:center; gap:10px; margin-bottom:12px;">
                        <i class="fas fa-check-circle" style="color:#10b981; font-size:16px;"></i>
                        <h5 style="margin:0; font-size:14px; font-weight:700; color:#166534;">Cancelled & Refunded</h5>
                      </div>
                      <div style="display:flex; flex-direction:column; gap:10px; margin-bottom:16px;">
                        ${order.cancellationRequestedAt
                            ? `<div style="display:flex; justify-content:space-between; padding:8px 0; border-bottom:1px solid #86efac;"><span style="color:#166534; font-size:13px; font-weight:500;">Cancellation requested</span><span style="color:#14532d; font-size:13px;">${new Date(
                                order.cancellationRequestedAt
                            ).toLocaleString()}</span></div>`
                            : ""
                        }
                        <div style="display:flex; justify-content:space-between; padding:8px 0; border-bottom:1px solid #86efac;"><span style="color:#166534; font-size:13px; font-weight:500;">Payment</span><span style="color:#14532d; font-size:13px; font-weight:600;">${String(
                            order.paymentMethod || ""
                        ).toUpperCase()}</span></div>
                        ${pm === "gcash"
                            ? `<div style="padding:8px 0; border-bottom:1px solid #86efac;"><span style="color:#166534; font-size:13px; font-weight:500; display:block; margin-bottom:6px;">Customer Reason</span><span style="color:#14532d; font-size:13px; line-height:1.5;">${order.cancellationReason || "No reason provided"
                            }</span></div>`
                            : ""
                        }
                        <div style="display:flex; justify-content:space-between; padding:8px 0; border-bottom:1px solid #86efac;"><span style="color:#166534; font-size:13px; font-weight:500;">Refund confirmed</span><span style="color:#14532d; font-size:13px;">${(() => {
                            const t =
                                order.refundConfirmedAt ||
                                order.updatedAt ||
                                order.cancellationRequestedAt;
                            return t ? new Date(t).toLocaleString() : "Unknown";
                        })()}</span></div>
                        ${(() => {
                            const refundedByName =
                                order.cancellation_confirmed_by_name ||
                                order.refundConfirmedByName ||
                                order.refundConfirmedBy ||
                                "Unknown";
                            const refundedByRole =
                                order.cancellation_confirmed_by_role || "";
                            const refundedByDisplay = refundedByRole
                                ? `${refundedByName} Â· ${refundedByRole}`
                                : refundedByName;
                            return `<div style="display:flex; justify-content:space-between; padding:8px 0;"><span style="color:#166534; font-size:13px; font-weight:500;">Cancellation Refunded by</span><span style="color:#14532d; font-size:13px;" id="refund-by-${id}">${refundedByDisplay}</span></div>`;
                        })()}
                      </div>
                      ${String(order.paymentMethod || "").toLowerCase() ===
                            "gcash" &&
                            (order.refundReceiptUrl || order.refund_receipt_url)
                            ? `
                        <div class="gcash-receipt" style="background:#eff6ff; border:1px solid #93c5fd; border-radius:6px; padding:14px; margin-top:12px;">
                          <div style="display:flex; align-items:center; gap:8px; margin-bottom:12px;">
                            <i class="fas fa-receipt" style="color:#2563eb; font-size:14px;"></i>
                            <strong style="font-size:13px; font-weight:600; color:#1e40af;">Official GCash Receipt (amount refunded)</strong>
                          </div>
                          ${(() => {
                                // Check both camelCase and snake_case versions
                                const url =
                                    order.refundReceiptUrl ||
                                    order.refund_receipt_url ||
                                    "";
                                if (!url || String(url).startsWith("pending:")) {
                                    return `
                                <div style="border:2px dashed #d1d5db; border-radius:6px; padding:16px; background:#f9fafb; display:flex; align-items:center; justify-content:center; gap:10px; min-height:80px;">
                                  <i class="fas fa-receipt" style="color:#9ca3af; font-size:20px;"></i>
                                  <span style="color:#6b7280; font-size:13px;">Refund receipt not available</span>
                                </div>`;
                                }
                                // Use getRefundReceiptUrl to fix duplicate bucket names if needed (refund receipts use refund_receipt bucket, not gcash_receipt)
                                const processedUrl = this.getRefundReceiptUrl
                                    ? this.getRefundReceiptUrl(url)
                                    : url;
                                if (!processedUrl) {
                                    return `
                                <div style="border:2px dashed #d1d5db; border-radius:6px; padding:16px; background:#f9fafb; display:flex; align-items:center; justify-content:center; gap:10px; min-height:80px;">
                                  <i class="fas fa-receipt" style="color:#9ca3af; font-size:20px;"></i>
                                  <span style="color:#6b7280; font-size:13px;">Refund receipt URL is invalid</span>
                                </div>`;
                                }
                                const escapedRefundUrl = processedUrl
                                    .replace(/'/g, "\\'")
                                    .replace(/"/g, "&quot;");
                                return `
                              <div style="display:flex; flex-direction:column; gap:8px;">
                                <img src="${processedUrl}" alt="Refund Receipt" style="max-width:100%; max-width:300px; border:1px solid #e5e7eb; border-radius:6px; cursor:pointer; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1);" 
                                     onclick="event.preventDefault(); event.stopPropagation(); if(window.staffManager && typeof window.staffManager.showEnlargedImage === 'function') { window.staffManager.showEnlargedImage('${escapedRefundUrl}', 'Refund Receipt'); }" 
                                     onerror="this.style.display='none'; this.nextElementSibling && (this.nextElementSibling.style.display='block');" 
                                     onmouseenter="this.style.transform='scale(1.02)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)';"
                                     onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='0 1px 3px rgba(0,0,0,0.1)';"
                                     title="Click to view full size" />
                              </div>`;
                            })()}
                        </div>
                      `
                            : ""
                        }
                    </div>
                  `;
                })()}
                `
                : ""
            }
                
                <div id="order-notes-container-${id}" style="margin-bottom:20px;">
                    ${(() => {
                        const rawNotes = order.order_notes || order.orderNotes || order.deliveryNotes || order.delivery_notes || "";
                        const filteredNotes = this.filterCustomerNotes(rawNotes);
                        const deliveryOption = (order.deliveryOption || "").toLowerCase();
                        const isPickup = deliveryOption === "pickup";
                        const isDelivery = !isPickup;
                        
                        // Check if rider is assigned (for delivery orders)
                        const hasRider = !!(order.riderId || order.rider_id || order.riderName || order.rider_name);
                        
                        // Customer notes - always show if they exist
                        let customerNotesHtml = '';
                        if (filteredNotes) {
                            customerNotesHtml = `
                    <div style="padding:16px; background:#fff7ed; border-left:4px solid #f59e0b; border-radius:8px;">
                        <div style="display:flex; align-items:center; gap:10px; margin-bottom:12px;">
                            <i class="fas fa-sticky-note" style="color:#f59e0b; font-size:16px;"></i>
                            <h5 style="margin:0; font-size:14px; font-weight:700; color:#9a3412;">${isPickup ? "Order/Pickup Notes" : "Order/Delivery Notes"} (Customer)</h5>
                        </div>
                        <div style="background:#ffffff; padding:12px; border-radius:6px; border:1px solid #fed7aa;">
                            <div style="color:#92400e; font-size:13px; line-height:1.5; font-style:italic;">
                                "${this.esc(filteredNotes)}"
                            </div>
                        </div>
                    </div>
                    `;
                        }
                        
                        // Staff notes container - always for delivery orders (regardless of status or rider assignment)
                        let staffNotesContainerHtml = '';
                        if (isDelivery) {
                            staffNotesContainerHtml = `<div id="staff-notes-container-${id}"></div>`;
                        }
                        
                        return customerNotesHtml + staffNotesContainerHtml;
                    })()}
                </div>
                
                <div style="background:#f9fafb; border:1px solid #e5e7eb; border-radius:8px; padding:16px;">
                    <h5 style="margin:0 0 16px 0; font-size:12px; font-weight:700; color:#6b7280; text-transform:uppercase; letter-spacing:0.8px;">Order Details</h5>
                    
                    <!-- Order Items -->
                    <div style="margin-bottom:20px; padding:12px; background:#ffffff; border:1px solid #e5e7eb; border-radius:6px;">
                        <div style="font-size:13px; font-weight:600; color:#374151; margin-bottom:12px; display:flex; align-items:center; justify-content:center; gap:6px;">
                            <i class="fas fa-shopping-cart" style="color:#6b7280; font-size:12px;"></i>
                            Order Items
                        </div>
                        <div style="display:table; width:100%; border-collapse:collapse;">
                            <div style="display:table-row; border-bottom:1px solid #e5e7eb; font-weight:600; color:#374151; font-size:13px;">
                                <div style="display:table-cell; padding:10px; border-right:1px solid #e5e7eb;">Product</div>
                                <div style="display:table-cell; padding:10px; border-right:1px solid #e5e7eb; text-align:center;">Kilo Ã— Price</div>
                                <div style="display:table-cell; padding:10px; text-align:right;">Total</div>
                            </div>
                            ${order.items
                .map(
                    (item) => `
                            <div style="display:table-row; border-bottom:1px solid #e5e7eb;">
                                <div style="display:table-cell; padding:10px; border-right:1px solid #e5e7eb; font-weight:600; color:#111827; font-size:14px;">${item.productName || "Item"
                            }</div>
                                <div style="display:table-cell; padding:10px; border-right:1px solid #e5e7eb; text-align:center; color:#6b7280; font-size:13px;">${item.quantity || 0
                            } ${item.unit || ""} Ã— â‚±${(
                                item.price || 0
                            ).toLocaleString()}</div>
                                <div style="display:table-cell; padding:10px; text-align:right; font-weight:700; color:#059669; font-size:15px;">â‚±${(
                                (item.quantity || 0) * (item.price || 0)
                            ).toLocaleString()}</div>
                            </div>
                            `
                )
                .join("")}
                        </div>
                    </div>
                    
                    <!-- Payment Method -->
                    <div style="margin-bottom:20px; padding:12px; background:#ffffff; border:1px solid #e5e7eb; border-radius:6px;">
                        <div style="font-size:13px; font-weight:600; color:#374151; margin-bottom:8px; display:flex; align-items:center; gap:6px;">
                            <i class="fas fa-credit-card" style="color:#6b7280; font-size:12px;"></i>
                            Payment Method
                        </div>
                        <div style="font-size:14px; color:#111827; font-weight:600; text-transform:uppercase; margin-bottom:${(() => {
                const pm = String(
                    order.paymentMethod || ""
                ).toLowerCase();
                return pm === "gcash" && order.gcashReceiptUrl
                    ? "12px"
                    : "0";
            })()};">${(() => {
                const pm = String(order.paymentMethod || "cash").toLowerCase();
                // If GCash and has payment_proof (rider upload), it's COD paid through GCash
                if (pm === "gcash" && (order.payment_proof || order.paymentProof)) {
                    return "COD - PAID THROUGH GCASH";
                }
                return (order.paymentMethod || "cash").toUpperCase();
            })()}</div>
                        ${(() => {
                const pm = String(
                    order.paymentMethod || ""
                ).toLowerCase();
                const isGcash = pm === "gcash";
                // Only show customer's GCash Receipt for original GCash orders (not COD orders paid through GCash)
                // If payment_proof exists, it means rider uploaded it (COD paid through GCash), so don't show customer receipt
                const isOriginalGcash = isGcash &&
                    !order.payment_proof &&
                    !order.paymentProof;
                if (isOriginalGcash && order.gcashReceiptUrl) {
                    const rawUrl = order.gcashReceiptUrl || "";
                    const url = this.getGcashReceiptUrl(rawUrl);
                    if (!url) {
                        return `
                                    <div style="margin-top:12px; padding-top:12px; border-top:1px solid #e5e7eb;">
                                        <div style="font-size:12px; font-weight:600; color:#6b7280; margin-bottom:8px; display:flex; align-items:center; gap:6px;">
                                            <i class="fas fa-receipt" style="color:#6b7280; font-size:11px;"></i>
                                            GCash Receipt (Customer Upload)
                                        </div>
                                        <div style="border:2px dashed #d1d5db; border-radius:6px; padding:16px; background:#f9fafb; display:flex; align-items:center; justify-content:center; gap:10px; min-height:80px;">
                                            <i class="fas fa-receipt" style="color:#9ca3af; font-size:20px;"></i>
                                            <span style="color:#6b7280; font-size:13px;">Receipt not available</span>
                                        </div>
                                    </div>`;
                    }
                    const escapedUrl = url
                        .replace(/'/g, "\\'")
                        .replace(/"/g, "&quot;");
                    return `
                                <div style="margin-top:12px; padding-top:12px; border-top:1px solid #e5e7eb;">
                                    <div style="font-size:12px; font-weight:600; color:#6b7280; margin-bottom:8px; display:flex; align-items:center; gap:6px;">
                                        <i class="fas fa-receipt" style="color:#6b7280; font-size:11px;"></i>
                                        GCash Receipt (Customer Upload)
                                    </div>
                                    <div style="display:flex; flex-direction:column; gap:8px;">
                                        <img src="${url}" alt="GCash Receipt" style="max-width:100%; max-width:300px; border:1px solid #e5e7eb; border-radius:6px; cursor:pointer; transition:all 0.2s ease; box-shadow:0 1px 3px rgba(0,0,0,0.1);" 
                                             onclick="event.preventDefault(); event.stopPropagation(); if(window.staffManager && typeof window.staffManager.showEnlargedImage === 'function') { window.staffManager.showEnlargedImage('${escapedUrl}', 'GCash Receipt'); }" 
                                             onerror="this.style.display='none'" 
                                             onmouseenter="this.style.transform='scale(1.02)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)';"
                                             onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='0 1px 3px rgba(0,0,0,0.1)';"
                                             title="Click to view full size" />
                                    </div>
                                </div>`;
                }
                return "";
            })()}
                    </div>
                    
                    <!-- Delivery/Pickup Address -->
                    ${(() => {
                const deliveryOption = String(
                    order.deliveryOption || ""
                ).toLowerCase();
                const isDelivery = deliveryOption === "delivery";
                const isPickup = deliveryOption === "pickup";
                let addressText = "";

                if (isDelivery && order.deliveryAddress) {
                    addressText = this.removeDuplicateCityProvince(order.deliveryAddress);
                } else if (isPickup) {
                    // Build pickup address from structured fields or pickupAddress
                    if (
                        order.pickupName ||
                        order.pickupStreet ||
                        order.pickupBarangay
                    ) {
                        const parts = [];
                        if (order.pickupName) parts.push(order.pickupName);
                        if (order.pickupStreet)
                            parts.push(order.pickupStreet);
                        if (order.pickupSitio) parts.push(order.pickupSitio);
                        if (order.pickupBarangay)
                            parts.push(order.pickupBarangay);
                        if (order.pickupCity) parts.push(order.pickupCity);
                        if (order.pickupProvince)
                            parts.push(order.pickupProvince);
                        if (order.pickupLandmark)
                            parts.push(`(Landmark: ${order.pickupLandmark})`);
                        addressText = parts.join(", ");
                        if (order.pickupInstructions) {
                            addressText += ` - ${order.pickupInstructions}`;
                        }
                    } else if (order.pickupAddress) {
                        addressText = this.removeDuplicateCityProvince(order.pickupAddress);
                    } else {
                        addressText = "Pickup location not specified";
                    }
                } else {
                    addressText = "Address not available";
                }

                return `
                        <div style="margin-bottom:20px; padding:12px; background:#ffffff; border:1px solid #e5e7eb; border-radius:6px;">
                            <div style="font-size:13px; font-weight:600; color:#374151; margin-bottom:8px; display:flex; align-items:center; gap:6px;">
                                <i class="fas ${isDelivery ? "fa-truck" : "fa-map-marker-alt"
                    }" style="color:#6b7280; font-size:12px;"></i>
                                ${isDelivery
                        ? "Delivery Address"
                        : isPickup
                            ? "Pickup Address"
                            : "Address"
                    }
                            </div>
                            <div style="font-size:14px; color:#111827; line-height:1.6;">${addressText}</div>
                            ${isPickup && order.pickupMapLink
                        ? `<div style="margin-top:8px;"><a href="${order.pickupMapLink}" target="_blank" rel="noopener" style="color:#2563eb; text-decoration:none; font-size:13px; display:inline-flex; align-items:center; gap:4px;"><i class="fas fa-external-link-alt" style="font-size:11px;"></i> View on Map</a></div>`
                        : ""
                    }
                        </div>`;
            })()}
                    
                    <!-- Total Amount Breakdown -->
                    <div style="padding:12px; background:#ffffff; border:1px solid #e5e7eb; border-radius:6px;">
                        <div style="font-size:13px; font-weight:600; color:#374151; margin-bottom:12px; display:flex; align-items:center; gap:6px;">
                            <i class="fas fa-calculator" style="color:#6b7280; font-size:12px;"></i>
                            Amount Breakdown
                        </div>
                        <div style="display:flex; flex-direction:column; gap:8px;">
                            <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;">
                                <span style="color:#6b7280; font-size:13px;">Subtotal</span>
                                <span style="color:#111827; font-weight:500; font-size:13px;">â‚±${(
                order.subtotal || 0
            ).toLocaleString()}</span>
                            </div>
                            ${(order.deliveryFee || 0) > 0
                ? `
                            <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;">
                                <span style="color:#6b7280; font-size:13px;">Delivery Fee</span>
                                <span style="color:#111827; font-weight:500; font-size:13px;">â‚±${order.deliveryFee.toLocaleString()}</span>
                            </div>
                            `
                : ""
            }
                            <div style="display:flex; justify-content:space-between; padding:6px 0;">
                                <span style="color:#111827; font-weight:700; font-size:15px;">Total Amount</span>
                                <span style="color:#059669; font-weight:700; font-size:16px;">â‚±${(
                order.totalAmount ||
                order.total ||
                0
            ).toLocaleString()}</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;

        // Resolve and replace staff UID with full name if needed (for historical records without stored names)
        try {
            if (statusLower === "cancelled") {
                const nameNode = div.querySelector(`#refund-by-${id}`);
                const currentText = nameNode ? (nameNode.textContent || "").trim() : "";
                const uid =
                    order.refundConfirmedBy ||
                    order.refundProcessedBy ||
                    order.refundedBy ||
                    order.updatedBy ||
                    order.confirmedBy;
                const hasStoredName = !!(
                    order.refundConfirmedByName ||
                    order.refundProcessedByName ||
                    order.refundedByName ||
                    order.updatedByName ||
                    order.confirmedByName
                );
                const looksLikeUid = uid && currentText === uid;
                const isUnknown =
                    currentText.toLowerCase() === "unknown" || currentText === "";
                if (nameNode && uid && (!hasStoredName || looksLikeUid || isUnknown)) {
                    (async () => {
                        try {
                            let resolvedName = null;
                            if (window.dbRefs && window.dbRefs.staff) {
                                const snap = await window.dbRefs.staff.child(uid).once("value");
                                const data = snap.val();
                                if (data) {
                                    resolvedName = data.fullName || data.name || null;
                                }
                            }
                            if (!resolvedName && window.dbRefs && window.dbRefs.users) {
                                const snap2 = await window.dbRefs.users
                                    .child(uid)
                                    .once("value");
                                const data2 = snap2.val();
                                if (data2) {
                                    resolvedName = data2.fullName || data2.name || null;
                                }
                            }
                            if (resolvedName) {
                                nameNode.textContent = resolvedName;
                            }
                        } catch (_) { }
                    })();
                }
            }

            const rejectedNameNode = div.querySelector(`#rejected-by-${id}`);
            const rejectedUid =
                order.rejectedBy ||
                order.rejected_by ||
                order.updatedBy ||
                order.confirmedBy;
            const rejectedStoredName =
                order.rejectedByName || order.rejected_by_name || order.updatedByName;
            if (
                rejectedNameNode &&
                (!rejectedStoredName || rejectedStoredName.toLowerCase() === "staff") &&
                rejectedUid
            ) {
                (async () => {
                    try {
                        let resolvedName = null;
                        const tryResolve = async (path) => {
                            if (!path) return;
                            try {
                                const snap = await path.child(rejectedUid).once("value");
                                const data = snap.val();
                                if (data) {
                                    resolvedName = data.fullName || data.name || null;
                                }
                            } catch (_) { }
                        };
                        if (window.dbRefs?.staff) await tryResolve(window.dbRefs.staff);
                        if (!resolvedName && window.dbRefs?.adminAccounts)
                            await tryResolve(window.dbRefs.adminAccounts);
                        if (!resolvedName && window.dbRefs?.users)
                            await tryResolve(window.dbRefs.users);
                        if (resolvedName) {
                            rejectedNameNode.textContent = resolvedName;
                        } else if (
                            rejectedNameNode.textContent?.trim().toLowerCase() === "staff"
                        ) {
                            rejectedNameNode.textContent = "Administrator";
                        }
                    } catch (_) { }
                })();
            }
        } catch (_) { }

        return div;
    }

    async clearRejectedProducts() {
        if (
            !confirm(
                "Are you sure you want to clear all rejected products? This action cannot be undone."
            )
        ) {
            return;
        }

        try {
            const snapshot = await dbRefs.orders
                .orderByChild("status")
                .equalTo("rejected")
                .once("value");
            const rejectedOrders = snapshot.val() || {};

            if (Object.keys(rejectedOrders).length === 0) {
                alert("No rejected products to clear.");
                return;
            }

            const updates = {};
            Object.keys(rejectedOrders).forEach((orderId) => {
                updates[`orders/${orderId}/status`] = "cleared";
                updates[`orders/${orderId}/clearedAt`] = FirebaseUtils.getTimestamp();
                updates[`orders/${orderId}/clearedBy`] = "manual-staff";
            });

            await database.ref().update(updates);
            console.log("Manually cleared rejected products");

            // Refresh the rejected products display
            this.loadRejectedProducts();

            alert("All rejected products have been cleared successfully.");
        } catch (error) {
            console.error("Error clearing rejected products:", error);
            alert("Error clearing rejected products: " + error.message);
        }
    }

    // Helper function to get correct Supabase public URL for refund receipt
    getRefundReceiptUrl(url) {
        if (!url || String(url).startsWith("pending:")) {
            console.log("[Refund Receipt] No URL or pending:", url);
            return null;
        }

        const urlStr = String(url).trim();
        const SUPABASE_URL = "https://afkwexvvuxwbpioqnelp.supabase.co";
        const BUCKET_NAME = "refund_receipt";

        // If it's already a full URL starting with http/https
        if (urlStr.startsWith("http://") || urlStr.startsWith("https://")) {
            // Check if it's a valid Supabase URL format
            if (
                urlStr.includes("supabase.co/storage/v1/object/public/refund_receipt")
            ) {
                // Fix duplicate bucket names in URL
                if (urlStr.includes(`/${BUCKET_NAME}/${BUCKET_NAME}/`)) {
                    const fixedUrl = urlStr.replace(
                        `/${BUCKET_NAME}/${BUCKET_NAME}/`,
                        `/${BUCKET_NAME}/`
                    );
                    console.log(
                        "[Refund Receipt] Fixed duplicate bucket name in URL:",
                        fixedUrl
                    );
                    return fixedUrl;
                }
                console.log("[Refund Receipt] Using existing full URL:", urlStr);
                return urlStr;
            }
            // If it's a Supabase URL but wrong format, try to fix it
            if (urlStr.includes("supabase.co")) {
                console.log(
                    "[Refund Receipt] Supabase URL but wrong format, attempting to fix:",
                    urlStr
                );
                // Try to extract file path from various URL formats
                let pathMatch =
                    urlStr.match(/refund_receipt\/(.+?)(?:\?|$)/) ||
                    urlStr.match(
                        /\/storage\/v1\/object\/public\/refund_receipt\/(.+?)(?:\?|$)/
                    ) ||
                    urlStr.match(/\/refund_receipt\/(.+?)(?:\?|$)/);
                if (pathMatch && pathMatch[1]) {
                    let filePath = decodeURIComponent(pathMatch[1]);
                    // Clean up the file path - remove duplicate bucket name
                    filePath = filePath.replace(/^\/+/, "").replace(/\/+$/, "");
                    if (filePath.startsWith(BUCKET_NAME + "/")) {
                        filePath = filePath
                            .substring(BUCKET_NAME.length + 1)
                            .replace(/^\/+/, "");
                    }
                    const fixedUrl = `${SUPABASE_URL}/storage/v1/object/public/${BUCKET_NAME}/${filePath}`;
                    console.log("[Refund Receipt] Fixed URL:", fixedUrl);
                    return fixedUrl;
                }
            }
            // Return as-is if it's already a full URL (might be from different source)
            console.log("[Refund Receipt] Using provided full URL as-is:", urlStr);
            return urlStr;
        }

        // If it's a file path, construct the full Supabase public URL
        // Remove leading/trailing slashes
        let filePath = urlStr.replace(/^\/+/, "").replace(/\/+$/, "");
        // Remove bucket name if it's already in the path
        if (filePath.startsWith(BUCKET_NAME + "/")) {
            filePath = filePath.substring(BUCKET_NAME.length + 1).replace(/^\/+/, "");
        }
        const fullUrl = `${SUPABASE_URL}/storage/v1/object/public/${BUCKET_NAME}/${filePath}`;
        console.log("[Refund Receipt] Constructed URL from path:", fullUrl);
        return fullUrl;
    }

    // Helper function to get correct Supabase public URL for GCash receipt
    getGcashReceiptUrl(url) {
        if (!url || String(url).startsWith("pending:")) {
            console.log("[GCash Receipt] No URL or pending:", url);
            return null;
        }

        const urlStr = String(url).trim();
        const SUPABASE_URL = "https://afkwexvvuxwbpioqnelp.supabase.co";
        const BUCKET_NAME = "gcash_receipt";

        // If it's already a full URL starting with http/https
        if (urlStr.startsWith("http://") || urlStr.startsWith("https://")) {
            // Check if it's a valid Supabase URL format
            if (
                urlStr.includes("supabase.co/storage/v1/object/public/gcash_receipt")
            ) {
                // Fix duplicate bucket names in URL
                if (urlStr.includes(`/${BUCKET_NAME}/${BUCKET_NAME}/`)) {
                    const fixedUrl = urlStr.replace(
                        `/${BUCKET_NAME}/${BUCKET_NAME}/`,
                        `/${BUCKET_NAME}/`
                    );
                    console.log(
                        "[GCash Receipt] Fixed duplicate bucket name in URL:",
                        fixedUrl
                    );
                    return fixedUrl;
                }
                console.log("[GCash Receipt] Using existing full URL:", urlStr);
                return urlStr;
            }
            // If it's a Supabase URL but wrong format, try to fix it
            if (urlStr.includes("supabase.co")) {
                console.log(
                    "[GCash Receipt] Supabase URL but wrong format, attempting to fix:",
                    urlStr
                );
                // Try to extract file path from various URL formats
                let pathMatch =
                    urlStr.match(/gcash_receipt\/(.+?)(?:\?|$)/) ||
                    urlStr.match(
                        /\/storage\/v1\/object\/public\/gcash_receipt\/(.+?)(?:\?|$)/
                    ) ||
                    urlStr.match(/\/gcash_receipt\/(.+?)(?:\?|$)/);
                if (pathMatch && pathMatch[1]) {
                    let filePath = decodeURIComponent(pathMatch[1]);
                    // Clean up the file path - remove duplicate bucket name
                    filePath = filePath.replace(/^\/+/, "").replace(/\/+$/, "");
                    if (filePath.startsWith(BUCKET_NAME + "/")) {
                        filePath = filePath
                            .substring(BUCKET_NAME.length + 1)
                            .replace(/^\/+/, "");
                    }
                    const fixedUrl = `${SUPABASE_URL}/storage/v1/object/public/${BUCKET_NAME}/${filePath}`;
                    console.log("[GCash Receipt] Fixed URL:", fixedUrl);
                    return fixedUrl;
                }
            }
            // Return as-is if it's already a full URL (might be from different source)
            console.log("[GCash Receipt] Using provided full URL as-is:", urlStr);
            return urlStr;
        }

        // If it's a file path, construct the full Supabase public URL
        // Remove leading/trailing slashes
        let filePath = urlStr.replace(/^\/+/, "").replace(/\/+$/, "");

        // Remove bucket name if already in path (handle multiple occurrences)
        while (filePath.startsWith(BUCKET_NAME + "/")) {
            filePath = filePath.substring(BUCKET_NAME.length + 1).replace(/^\/+/, "");
        }

        const constructedUrl = `${SUPABASE_URL}/storage/v1/object/public/${BUCKET_NAME}/${filePath}`;
        console.log("[GCash Receipt] Constructed URL from path:", {
            original: urlStr,
            filePath: filePath,
            constructed: constructedUrl,
        });

        return constructedUrl;
    }

    // Test function to verify GCash receipt URL (for debugging)
    async testGcashReceiptUrl(orderId) {
        try {
            const orderRef = window.dbRefs.orders.child(orderId);
            const snapshot = await orderRef.once("value");
            const order = snapshot.val();

            if (!order || !order.gcashReceiptUrl) {
                console.error(
                    "[GCash Receipt Test] No receipt URL found for order:",
                    orderId
                );
                return;
            }

            const rawUrl = order.gcashReceiptUrl;
            const processedUrl = this.getGcashReceiptUrl(rawUrl);

            console.log("[GCash Receipt Test] Order:", orderId);
            console.log("[GCash Receipt Test] Raw URL from Firebase:", rawUrl);
            console.log("[GCash Receipt Test] Processed URL:", processedUrl);

            // Try to fetch the URL to verify it works
            if (processedUrl) {
                try {
                    const response = await fetch(processedUrl, { method: "HEAD" });
                    console.log(
                        "[GCash Receipt Test] URL Status:",
                        response.status,
                        response.statusText
                    );
                    if (response.ok) {
                        console.log("[GCash Receipt Test] âœ… URL is accessible");
                    } else {
                        console.error(
                            "[GCash Receipt Test] âŒ URL returned status:",
                            response.status
                        );
                    }
                } catch (fetchError) {
                    console.error("[GCash Receipt Test] âŒ Fetch error:", fetchError);
                }
            }
        } catch (error) {
            console.error("[GCash Receipt Test] Error:", error);
        }
    }

    createOrderCard(id, order) {
        const div = document.createElement("div");
        div.className = "order-card fade-in";
        // Version: 2025-01-03-v2 - Removed old GCash receipt placeholder

        const statusLower = String(order.status || "").toLowerCase();
        const deliveryOption = String(order.deliveryOption || "").toLowerCase();
        const isPickupOrder = deliveryOption === "pickup";
        const isDeliveryOrder =
            deliveryOption === "delivery" ||
            (deliveryOption && deliveryOption !== "pickup");
        let statusClass = "status-pending";
        if (statusLower === "confirmed") statusClass = "status-confirmed";
        if (statusLower === "packed") statusClass = "status-packed";
        if (statusLower === "to_receive") statusClass = "status-shipped";
        if (statusLower === "out_for_delivery" || statusLower === "pickup_ready")
            statusClass = "status-pickup-ready";
        if (statusLower === "delivered") statusClass = "status-delivered";
        if (
            statusLower === "failed" ||
            statusLower === "delivery_failed" ||
            statusLower === "failed_pickup"
        )
            statusClass = "status-failed";
        if (statusLower === "cancelled")
            statusClass = order.cancellationConfirmed
                ? "status-cancelled"
                : "status-pending";

        // Handle pending orders with cancellation requests
        if (statusLower === "pending" && order.cancellationRequested === true) {
            statusClass = "status-cancellation-requested";
        }

        // Display status text: show "cancellation requested" for pending orders when customer requests cancellation
        const cancellationInitiatedBy = String(
            order.cancellationInitiatedBy || "customer"
        );
        const isCustomerInitiatedCancel = cancellationInitiatedBy !== "staff";
        const canShowCancelRequestedLabel =
            isCustomerInitiatedCancel && !this.isAfterWeeklyCutoff();
        const displayStatusText =
            statusLower === "cancelled" &&
                order.cancellationConfirmed !== true &&
                canShowCancelRequestedLabel
                ? "cancellation requested"
                : statusLower === "pending" && order.cancellationRequested === true
                    ? "cancellation requested"
                    : this.formatStatus(order.status, order);

        div.innerHTML = `
            <div class="order-header clickable" onclick="staffManager.toggleOrderDetails('${id}')">
                <div class="order-id">
                    <i class="fas fa-chevron-right order-toggle-icon" id="toggle-icon-${id}"></i>
                    Order #${id.substr(-8).toUpperCase()}
                    ${isPickupOrder
                ? '<span style="margin-left:8px; padding:2px 8px; background:#ffe082; color:#4e342e; border-radius:999px; font-weight:700; font-size:11px; letter-spacing:.5px;">PICKUP</span>'
                : ""
            }
                    ${isDeliveryOrder
                ? '<span style="margin-left:8px; padding:2px 8px; background:#e3f2fd; color:#0d47a1; border-radius:999px; font-weight:700; font-size:11px; letter-spacing:.5px;">DELIVERY</span>'
                : ""
            }
                    ${order.rescheduledNextWeek
                ? (() => {
                    const status = statusLower;
                    const shouldShowDates = status === "to_receive" ||
                        status === "out_for_delivery" ||
                        status === "pickup_ready" ||
                        status === "delivered" ||
                        status === "picked_up" ||
                        status === "failed" ||
                        status === "delivery_failed" ||
                        status === "failed_pickup";
                    if (shouldShowDates) {
                        const { saturday, sunday } = getNextWeekendDates();
                        const satDate = formatDateMMDDYY(saturday);
                        const sunDate = formatDateMMDDYY(sunday);
                        return `<span style="margin-left:8px; padding:2px 8px; background:#ffebee; color:#c62828; border-radius:999px; font-weight:700; font-size:11px; letter-spacing:.5px;">Reschedule - ${satDate} - ${sunDate}</span>`;
                    }
                    return '<span style="margin-left:8px; padding:2px 8px; background:#ffebee; color:#c62828; border-radius:999px; font-weight:700; font-size:11px; letter-spacing:.5px;">RESCHEDULED</span>';
                })()
                : ""
            }
                </div>
                <div class="order-status ${statusClass}">${displayStatusText}</div>
            </div>
            <div class="order-details collapsed" id="order-details-${id}">
                <div class="order-info">
                    <p><strong>Customer:</strong> ${order.customerName}</p>
                    <p><strong>Contact:</strong> ${order.customerPhone}</p>
                    ${this.buildAddressSection(order)}
                    <p><strong>Payment Method:</strong> ${order.paymentMethod
            }</p>
                    <p><strong>Total Amount:</strong> â‚±${order.totalAmount.toLocaleString()}</p>
                    <p><strong>Order Date:</strong> ${new Date(
                order.createdAt
            ).toLocaleString()}</p>
                    ${order.status === "packed"
                ? `
                        <p><strong>Packed Date:</strong> ${order.packedAt
                    ? new Date(order.packedAt).toLocaleString()
                    : "Unknown"
                }</p>
                    `
                : ""
            }
                    ${order.status === "out_for_delivery" &&
                order.outForDeliveryAt
                ? `
                        <p><strong>Out for Delivery Date:</strong> ${new Date(
                    order.outForDeliveryAt
                ).toLocaleString()}</p>
                    `
                : ""
            }
                    ${order.status === "delivered"
                ? `
                        <div style="background: #e8f5e8; padding: 16px; border-radius: 8px; margin: 8px 0; border: 1px solid #4caf50;">
                            <h4 style="color: #2e7d32; margin: 0 0 12px 0; font-size: 16px; font-weight: 600;"><i class="fas fa-check-circle"></i> Delivered Details</h4>
                            <div style="display: flex; flex-direction: column; gap: 8px;">
                                <p style="margin: 0;"><strong>Rider Name:</strong> ${order.deliveredByName ||
                order.delivered_by_name ||
                order.deliveryRiderName ||
                order.riderName ||
                "Unknown"
                }</p>
                                ${(() => {
                    const proofImages =
                        order.deliveryProof ||
                        order.delivery_proof ||
                        order.proofImages ||
                        [];
                    const imageArray = Array.isArray(proofImages)
                        ? proofImages
                        : proofImages
                            ? [proofImages]
                            : [];
                    if (imageArray.length > 0) {
                        const formatDeliveryProofUrl = (urlStr) => {
                            if (!urlStr || typeof urlStr !== "string")
                                return urlStr;
                            const trimmed = urlStr.trim();
                            if (!trimmed) return trimmed;

                            const SUPABASE_URL =
                                "https://afkwexvvuxwbpioqnelp.supabase.co";
                            const BUCKET_NAME = "delivery_proof";

                            // If already a full URL, check and fix if needed
                            if (
                                trimmed.startsWith("http://") ||
                                trimmed.startsWith("https://")
                            ) {
                                // If it's a Supabase URL with duplicate bucket name, fix it
                                if (
                                    trimmed.includes(
                                        `/${BUCKET_NAME}/${BUCKET_NAME}/`
                                    )
                                ) {
                                    return trimmed.replace(
                                        `/${BUCKET_NAME}/${BUCKET_NAME}/`,
                                        `/${BUCKET_NAME}/`
                                    );
                                }
                                // If it's already a valid Supabase URL, return as is
                                if (
                                    trimmed.includes(
                                        `supabase.co/storage/v1/object/public/${BUCKET_NAME}/`
                                    )
                                ) {
                                    return trimmed;
                                }
                                // If it's a Supabase URL but wrong format, try to extract path
                                if (trimmed.includes("supabase.co")) {
                                    const pathMatch = trimmed.match(
                                        /delivery_proof\/(.+?)(?:\?|$)/
                                    );
                                    if (pathMatch && pathMatch[1]) {
                                        let filePath = decodeURIComponent(
                                            pathMatch[1]
                                        );
                                        // Remove duplicate bucket name if present
                                        if (
                                            filePath.startsWith(
                                                BUCKET_NAME + "/"
                                            )
                                        ) {
                                            filePath = filePath.substring(
                                                BUCKET_NAME.length + 1
                                            );
                                        }
                                        return `${SUPABASE_URL}/storage/v1/object/public/${BUCKET_NAME}/${filePath}`;
                                    }
                                }
                                return trimmed;
                            }

                            // If it's a file path, clean it up
                            let cleanPath = trimmed;

                            // Remove leading slash if present
                            cleanPath = cleanPath.startsWith("/")
                                ? cleanPath.substring(1)
                                : cleanPath;

                            // Remove duplicate bucket name if present in path
                            if (
                                cleanPath.startsWith(BUCKET_NAME + "/")
                            ) {
                                cleanPath = cleanPath.substring(
                                    BUCKET_NAME.length + 1
                                );
                            }

                            // Construct full public URL
                            return `${SUPABASE_URL}/storage/v1/object/public/${BUCKET_NAME}/${cleanPath}`;
                        };

                        return `
                                            <div style="margin-top: 12px;">
                                                <p style="margin: 0 0 8px 0; font-weight: 600;"><strong>Proof of Delivery Images:</strong></p>
                                                <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                                                    ${imageArray
                                .map((imgUrl, idx) => {
                                    const rawUrl = String(
                                        imgUrl || ""
                                    ).trim();
                                    if (!rawUrl) return "";
                                    const url =
                                        formatDeliveryProofUrl(
                                            rawUrl
                                        );
                                    const escapedUrl = url
                                        .replace(/'/g, "\\'")
                                        .replace(
                                            /"/g,
                                            "&quot;"
                                        );
                                    return `
                                                            <div style="position: relative; width: 120px; height: 120px; border: 2px solid #4caf50; border-radius: 8px; overflow: hidden; cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease; background: #f5f5f5;" 
                                                                 onclick="event.preventDefault(); event.stopPropagation(); if(window.staffManager && typeof window.staffManager.showEnlargedImage === 'function') { window.staffManager.showEnlargedImage('${escapedUrl}', 'Proof of Delivery ${idx + 1
                                        }'); }"
                                                                 onmouseenter="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.2)';"
                                                                 onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='none';"
                                                                 title="Click to view full size">
                                                                <img src="${url}" 
                                                                     alt="Proof of Delivery ${idx + 1
                                        }" 
                                                                     style="width: 100%; height: 100%; object-fit: cover; display: block;"
                                                                     onerror="this.style.display='none'; this.nextElementSibling.style.display='flex'; console.error('Failed to load delivery proof image:', '${escapedUrl}');"
                                                                     loading="lazy" />
                                                                <div style="display: none; width: 100%; height: 100%; align-items: center; justify-content: center; background: #ffebee; color: #c62828; font-size: 11px; text-align: center; padding: 4px;">
                                                                    <div>
                                                                        <i class="fas fa-exclamation-triangle" style="display: block; margin-bottom: 4px; font-size: 16px;"></i>
                                                                        <span>Failed to load</span>
                                                                        <div style="font-size: 9px; margin-top: 4px; word-break: break-all;">${rawUrl.substring(
                                            0,
                                            30
                                        )}...</div>
                                        </div>
                                </div>
                                                            </div>
                                                        `;
                                })
                                .join("")}
                                                </div>
                                            </div>
                                        `;
                    }
                    return "";
                })()}
                                ${(() => {
                    // Display payment proof for GCash orders
                    const paymentProof =
                        order.paymentProof ||
                        order.payment_proof ||
                        null;
                    if (
                        paymentProof &&
                        (order.payment_method === "gcash" ||
                            String(order.payment_method || "")
                                .toLowerCase() === "gcash")
                    ) {
                        const formatPaymentProofUrl = (urlStr) => {
                            if (!urlStr || typeof urlStr !== "string")
                                return urlStr;
                            const trimmed = urlStr.trim();
                            if (!trimmed) return trimmed;

                            const SUPABASE_URL =
                                "https://afkwexvvuxwbpioqnelp.supabase.co";
                            const BUCKET_NAME = "delivery_proof_payment";

                            // If already a full URL, check and fix if needed
                            if (
                                trimmed.startsWith("http://") ||
                                trimmed.startsWith("https://")
                            ) {
                                // If it's a Supabase URL with duplicate bucket name, fix it
                                if (
                                    trimmed.includes(
                                        `/${BUCKET_NAME}/${BUCKET_NAME}/`
                                    )
                                ) {
                                    return trimmed.replace(
                                        `/${BUCKET_NAME}/${BUCKET_NAME}/`,
                                        `/${BUCKET_NAME}/`
                                    );
                                }
                                // If it's already a valid Supabase URL, return as is
                                if (
                                    trimmed.includes(
                                        `supabase.co/storage/v1/object/public/${BUCKET_NAME}/`
                                    )
                                ) {
                                    return trimmed;
                                }
                                // If it's a Supabase URL but wrong format, try to extract path
                                if (trimmed.includes("supabase.co")) {
                                    const pathMatch = trimmed.match(
                                        /delivery_proof_payment\/(.+?)(?:\?|$)/
                                    );
                                    if (pathMatch && pathMatch[1]) {
                                        let filePath = decodeURIComponent(
                                            pathMatch[1]
                                        );
                                        // Remove duplicate bucket name if present
                                        if (
                                            filePath.startsWith(
                                                BUCKET_NAME + "/"
                                            )
                                        ) {
                                            filePath = filePath.substring(
                                                BUCKET_NAME.length + 1
                                            );
                                        }
                                        return `${SUPABASE_URL}/storage/v1/object/public/${BUCKET_NAME}/${filePath}`;
                                    }
                                }
                                return trimmed;
                            }

                            // If it's a file path, clean it up
                            let cleanPath = trimmed;

                            // Remove leading slash if present
                            cleanPath = cleanPath.startsWith("/")
                                ? cleanPath.substring(1)
                                : cleanPath;

                            // Remove duplicate bucket name if present in path
                            if (
                                cleanPath.startsWith(BUCKET_NAME + "/")
                            ) {
                                cleanPath = cleanPath.substring(
                                    BUCKET_NAME.length + 1
                                );
                            }

                            // Construct full public URL
                            return `${SUPABASE_URL}/storage/v1/object/public/${BUCKET_NAME}/${cleanPath}`;
                        };

                        const url = formatPaymentProofUrl(
                            paymentProof
                        );
                        const escapedUrl = url
                            .replace(/'/g, "\\'")
                            .replace(/"/g, "&quot;");

                        return `
                                            <div style="margin-top: 12px;">
                                                <p style="margin: 0 0 8px 0; font-weight: 600;"><strong>GCash Payment Proof:</strong></p>
                                                <div style="position: relative; width: 200px; height: 200px; border: 2px solid #4caf50; border-radius: 8px; overflow: hidden; cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease; background: #f5f5f5;" 
                                                     onclick="event.preventDefault(); event.stopPropagation(); if(window.staffManager && typeof window.staffManager.showEnlargedImage === 'function') { window.staffManager.showEnlargedImage('${escapedUrl}', 'GCash Payment Proof'); }"
                                                     onmouseenter="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.2)';"
                                                     onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='none';"
                                                     title="Click to view full size">
                                                    <img src="${url}" 
                                                         alt="GCash Payment Proof" 
                                                         style="width: 100%; height: 100%; object-fit: cover; display: block;"
                                                         onerror="this.style.display='none'; this.nextElementSibling.style.display='flex'; console.error('Failed to load payment proof image:', '${escapedUrl}');"
                                                         loading="lazy" />
                                                    <div style="display: none; width: 100%; height: 100%; align-items: center; justify-content: center; background: #ffebee; color: #c62828; font-size: 11px; text-align: center; padding: 4px;">
                                                        <div>
                                                            <i class="fas fa-exclamation-triangle" style="display: block; margin-bottom: 4px; font-size: 16px;"></i>
                                                            <span>Failed to load</span>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        `;
                    }
                    return "";
                })()}
                            </div>
                        </div>
                    `
                : ""
            }
                    ${order.status === "failed" ||
                String(order.status || "").toLowerCase() ===
                "delivery_failed"
                ? `
                        <div style="background: #ffebee; padding: 12px; border-radius: 8px; margin: 8px 0;">
                            <h4 style="color: #d32f2f; margin: 0 0 8px 0; font-size: 14px;"><i class="fas fa-exclamation-triangle"></i> Failed Details</h4>
                            <p style="margin: 4px 0;"><strong>Reasons of Failed Delivery:</strong> ${order.failureReason || "No reason provided"
                }</p>
                            <p style="margin: 4px 0;"><strong>Rider Name:</strong> ${order.failureRiderName ||
                order.failedByName ||
                order.failed_by_name ||
                "Unknown"
                }</p>
                        </div>
                    `
                : ""
            }
                    ${statusLower === "cancelled" &&
                order.cancellationConfirmed !== true &&
                String(order.cancellationInitiatedBy || "customer") !==
                "staff" &&
                !this.isAfterWeeklyCutoff()
                ? `
                    <div class="cancel-requested-banner">
                      <strong>Cancellation and refund requested</strong>
                      ${order.cancellationReason
                    ? `<div style="margin-top:4px;"><strong>Reason:</strong> ${order.cancellationReason}</div>`
                    : ""
                }
                    </div>`
                : ""
            }
                    ${statusLower === "pending" &&
                order.cancellationRequested === true &&
                String(order.cancellationInitiatedBy || "customer") !==
                "staff" &&
                !this.isAfterWeeklyCutoff()
                ? `
                    <div class="cancel-requested-banner">
                      <strong>Cancellation and refund requested</strong>
                      ${order.cancellationReason
                    ? `<div style="margin-top:4px;"><strong>Reason:</strong> ${order.cancellationReason}</div>`
                    : ""
                }
                    </div>`
                : ""
            }
                    ${statusLower === "pending" &&
                order.cancellationRequested === true &&
                String(order.paymentMethod || "").toLowerCase() ===
                "gcash" &&
                order.cancellationReason
                ? `
                    <div style="margin-top:8px; padding:12px; background:#fff3e0; border:1px solid #ffb74d; border-radius:6px;">
                      <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                        <i class="fas fa-info-circle" style="color:#f57c00;"></i>
                        <strong style="color:#e65100;">GCash Order Cancellation Reason:</strong>
                      </div>
                      <div style="color:#bf360c; font-style:italic; line-height:1.4;">
                        "${order.cancellationReason}"
                      </div>
                    </div>`
                : ""
            }
                    <div class="order-items">
                        <strong>Items:</strong>
                        <ul>
                            ${order.items
                .map(
                    (item) => `
                                <li>${item.productName} - ${item.quantity} ${item.unit
                        } Ã— â‚±${item.price} = â‚±${(
                            item.quantity * item.price
                        ).toLocaleString()}</li>
                            `
                )
                .join("")}
                        </ul>
                    </div>
                    ${["to_receive", "out_for_delivery", "pickup_ready"].includes(
                    statusLower
                )
                ? `
                    <div id="saved-qr-display-${id}" class="saved-qr-section" style="margin-top: 16px; display: block; max-height: 300px; overflow-y: auto; overflow-x: hidden; padding-bottom: 10px; pointer-events: auto;">
                        <div style="border-top: 1px solid #eee; padding-top: 12px; pointer-events: auto;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; pointer-events: auto;">
                                <strong style="color: #333; font-size: 14px;">
                                    <i class="fas fa-qrcode" style="color: #ccc; margin-right: 6px;"></i>
                                    Saved QR Codes
                                </strong>
                                <button id="qr-generate-btn-header-${id}" class="secondary-btn qr-generate-btn" data-order-id="${id}" style="font-size: 11px; padding: 4px 8px; position: relative; z-index: 10; pointer-events: auto; cursor: pointer;">
                                    <i class="fas fa-plus"></i> Generate QR
                                </button>
                            </div>
                            <div style="text-align: center; padding: 8px; color: #666; font-size: 12px;">
                                Loading QR codes...
                            </div>
                        </div>
                    </div>
                    `
                : ""
            }

                    ${
            // Only show customer's GCash Receipt for original GCash orders (not COD orders paid through GCash)
            // If payment_proof exists, it means rider uploaded it (COD paid through GCash), so don't show customer receipt
            String(order.paymentMethod || "").toLowerCase() === "gcash" &&
                order.gcashReceiptUrl &&
                !order.payment_proof &&
                !order.paymentProof
                ? `
                    <div class="gcash-receipt" style="margin-top:16px; padding:12px; background:#f8f9fa; border:1px solid #e9ecef; border-radius:8px;">
                      <div style="display:flex; align-items:center; gap:8px; margin-bottom:10px;">
                        <i class="fas fa-receipt" style="color:#4CAF50;"></i>
                        <strong style="color:#333;">GCash Receipt (Payment Proof)</strong>
                      </div>
                      ${(() => {
                    const rawUrl = order.gcashReceiptUrl || "";
                    const url = this.getGcashReceiptUrl(rawUrl);
                    if (!url) {
                        return `
                            <div style="margin-top:8px; border:2px dashed #ddd; border-radius:8px; padding:12px; background:#fafafa; display:flex; align-items:center; gap:10px;">
                              <i class="fas fa-receipt" style="color:#9e9e9e;"></i>
                              <span style="color:#777;">Receipt pending upload</span>
                            </div>`;
                    }
                    // Supabase URL from gcash_receipt bucket
                    const escapedUrl = url
                        .replace(/'/g, "\\'")
                        .replace(/"/g, "&quot;");
                    return `
                          <div style="margin-top:8px; display:flex; flex-direction:column; gap:10px;">
                            <div style="display:flex; justify-content:flex-start;">
                              <img src="${url}" alt="GCash Receipt" style="max-width:100%; max-height:400px; border:1px solid #e0e0e0; border-radius:6px; box-shadow:0 2px 4px rgba(0,0,0,0.1); cursor:pointer; transition:transform 0.2s ease,box-shadow 0.2s ease;" 
                                   onclick="event.preventDefault(); event.stopPropagation(); if(window.staffManager && typeof window.staffManager.showEnlargedImage === 'function') { window.staffManager.showEnlargedImage('${escapedUrl}', 'GCash Receipt'); }" 
                                   onerror="console.error('[GCash Receipt] Image load error for URL:', '${url}'); this.style.display='none'; const errorDiv = this.nextElementSibling; if(errorDiv) errorDiv.style.display='block';" 
                                   onload="console.log('[GCash Receipt] Image loaded successfully:', '${url}')"
                                   onmouseenter="this.style.transform='scale(1.02)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)';"
                                   onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)';"
                                   title="Click to view full size" />
                              <div style="display:none; padding:12px; background:#ffebee; border:1px solid #ffcdd2; border-radius:6px; color:#c62828;">
                                <i class="fas fa-exclamation-triangle"></i> Failed to load image. <a href="${url}" target="_blank" rel="noopener" style="color:#c62828; text-decoration:underline;">Click here to open receipt</a>
                                <div style="margin-top:4px; font-size:11px; color:#999; word-break:break-all;">URL: ${url}</div>
                              </div>
                            </div>
                          </div>`;
                })()}
                    </div>
                    `
                : ""
            }
                </div>
                <div class="order-actions" style="position: relative !important; z-index: 10000 !important; pointer-events: auto !important; margin-top: 20px !important; padding-top: 15px !important; border-top: 1px solid #e9ecef !important;">
                    ${order.status === "pending" &&
                order.cancellationRequested !== true
                ? `
                        ${this.isAfterWeeklyCutoff()
                    ? `
                        <button type="button" class="secondary-btn reschedule-btn-cutoff" data-order-id="${id}" data-action="reschedule" style="position: relative !important; z-index: 10001 !important; pointer-events: auto !important; cursor: pointer !important; display: inline-block !important; background: white !important; color: #61a029 !important; border: 2px solid #ff9800 !important; padding: 10px 16px !important; border-radius: 8px !important; font-size: 0.9rem !important; font-weight: 600 !important;">
                            <i class="fas fa-calendar-week"></i> Reschedule
                        </button>
                        <button class="confirm-btn" onclick="staffManager.showConfirmOrderDialog('${id}')" style="position: relative !important; z-index: 10001 !important; pointer-events: auto !important; cursor: pointer !important; display: inline-block !important;">
                            <i class="fas fa-check"></i> Confirm Order
                        </button>
                        <button type="button" class="confirm-btn refund-btn-cutoff" data-order-id="${id}" data-action="refund" style="position: relative !important; z-index: 10001 !important; pointer-events: auto !important; cursor: pointer !important; display: inline-block !important; background: #30442d !important; color: white !important; border: none !important; padding: 8px 16px !important; border-radius: 6px !important; font-size: 0.9rem !important;">
                            <i class="fas fa-undo"></i> Refund
                        </button>
                        <button class="reject-btn" onclick="staffManager.showRejectModal('${id}')">
                            <i class="fas fa-times"></i> Reject
                        </button>
                        `
                    : `
                        <button class="confirm-btn" onclick="staffManager.showConfirmOrderDialog('${id}')">
                            <i class="fas fa-check"></i> Confirm Order
                        </button>
                        <button class="reject-btn" onclick="staffManager.rejectOrder('${id}')">
                            <i class="fas fa-times"></i> Reject
                        </button>
                        `
                }
                    `
                : ""
            }
                    ${((order.status === "pending" ||
                String(order.status || "").toLowerCase() ===
                "confirmed") &&
                order.cancellationRequested === true &&
                String(order.paymentMethod || "").toLowerCase() ===
                "gcash" &&
                !order.cancellationConfirmed &&
                !order.refundConfirmedAt) ||
                (String(order.status || "").toLowerCase() ===
                    "cancelled" &&
                    order.cancellationConfirmed !== true &&
                    !order.refundConfirmedAt &&
                    String(order.paymentMethod || "").toLowerCase() ===
                    "gcash")
                ? `
                        <!-- GCash Refund Management Container -->
                        <div style="margin-top:16px; padding:16px; background:#fff9e6; border:2px solid #ffc107; border-radius:8px; box-shadow:0 2px 4px rgba(0,0,0,0.05);">
                          <div style="display:flex; align-items:center; gap:8px; margin-bottom:12px; padding-bottom:12px; border-bottom:1px solid #ffc107;">
                            <i class="fas fa-money-bill-wave" style="color:#f57c00; font-size:18px;"></i>
                            <strong style="color:#e65100; font-size:15px;">GCash Refund Management</strong>
                          </div>
                          
                          <!-- Refund Receipt Upload Section -->
                          <div style="margin-bottom:16px;">
                            <div style="display:flex; align-items:center; gap:12px; flex-wrap:wrap; margin-bottom:12px;">
                              <input type="file" accept="image/*" id="refund-receipt-${id}" style="display:none" onchange="staffManager.handleRefundReceiptUpload('${id}')" />
                              <button class="secondary-btn" onclick="document.getElementById('refund-receipt-${id}').click()" style="min-width:180px;">
                                <i class="fas fa-upload"></i> Upload Refund Receipt
                              </button>
                            </div>
                            
                            <!-- Uploaded Receipt Preview - Only shows when image is selected or already uploaded -->
                            ${(() => {
                    const rawRefundUrl = order.refundReceiptUrl || "";
                    let refundUrl = null;

                    // Process refund receipt URL
                    if (
                        rawRefundUrl &&
                        !rawRefundUrl.startsWith("pending:")
                    ) {
                        const urlStr = String(rawRefundUrl).trim();
                        const SUPABASE_URL =
                            "https://afkwexvvuxwbpioqnelp.supabase.co";
                        const BUCKET_NAME = "refund_receipt"; // Refund receipts bucket

                        // If it's already a full URL
                        if (
                            urlStr.startsWith("http://") ||
                            urlStr.startsWith("https://")
                        ) {
                            refundUrl = urlStr;
                        } else {
                            // It's a file path, construct Supabase URL
                            let cleanPath = urlStr.replace(/^\/+/, "");
                            // Remove bucket name if present (handle both refund_receipt and gcash_receipt for backward compatibility)
                            while (
                                cleanPath.startsWith("refund_receipt/") ||
                                cleanPath.startsWith("gcash_receipt/")
                            ) {
                                if (
                                    cleanPath.startsWith("refund_receipt/")
                                ) {
                                    cleanPath = cleanPath
                                        .substring("refund_receipt/".length)
                                        .replace(/^\/+/, "");
                                } else {
                                    cleanPath = cleanPath
                                        .substring("gcash_receipt/".length)
                                        .replace(/^\/+/, "");
                                }
                            }
                            refundUrl = `${SUPABASE_URL}/storage/v1/object/public/${BUCKET_NAME}/${cleanPath}`;
                        }
                    }

                    if (refundUrl) {
                        const escapedRefundUrl = refundUrl
                            .replace(/'/g, "\\'")
                            .replace(/"/g, "&quot;");
                        return `
                                  <div id="refund-receipt-preview-${id}" style="margin-top:12px; padding:12px; background:#f8fff8; border:2px solid #4CAF50; border-radius:6px;">
                                    <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                                      <i class="fas fa-check-circle" style="color:#4CAF50;"></i>
                                      <strong style="color:#2e7d32;">Refund Receipt Uploaded</strong>
                                    </div>
                                    <div style="position:relative; display:inline-block; width:fit-content;">
                                      <img src="${refundUrl}" alt="Refund Receipt" style="max-width:260px; width:auto; height:auto; border:1px solid #e0e0e0; border-radius:6px; cursor:pointer; transition:transform 0.2s ease,box-shadow 0.2s ease; display:block;" 
                                           onclick="event.preventDefault(); event.stopPropagation(); if(window.staffManager && typeof window.staffManager.showEnlargedImage === 'function') { window.staffManager.showEnlargedImage('${escapedRefundUrl}', 'Refund Receipt'); }" 
                                           onerror="this.style.display='none';this.nextElementSibling.style.display='block';" 
                                           onmouseenter="this.style.transform='scale(1.02)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)';"
                                           onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)';"
                                           title="Click to view full size" />
                                      <button onclick="event.preventDefault(); event.stopPropagation(); if(window.staffManager && typeof window.staffManager.removeRefundReceipt === 'function') { window.staffManager.removeRefundReceipt('${id}'); }" 
                                              style="position:absolute; top:8px; right:8px; background:#f44336; color:white; border:none; border-radius:50%; width:32px; height:32px; display:flex; align-items:center; justify-content:center; cursor:pointer; box-shadow:0 2px 8px rgba(0,0,0,0.3); transition:all 0.2s ease; z-index:10; margin:0; padding:0;" 
                                              onmouseenter="this.style.background='#d32f2f'; this.style.transform='scale(1.1)';" 
                                              onmouseleave="this.style.background='#f44336'; this.style.transform='scale(1)';" 
                                              title="Remove image">
                                        <i class="fas fa-times" style="font-size:14px;"></i>
                                      </button>
                                    </div>
                                    <div style="display:none; padding:12px; background:#ffebee; border:1px solid #ffcdd2; border-radius:6px; color:#c62828;">
                                      <i class="fas fa-exclamation-triangle"></i> Failed to load image. <a href="${refundUrl}" target="_blank" rel="noopener" style="color:#c62828; text-decoration:underline;">Click here to open receipt</a>
                                    </div>
                                  </div>
                                `;
                    }
                    return `
                                <div id="refund-receipt-preview-${id}" style="display:none; margin-top:12px; padding:12px; background:#f8fff8; border:2px dashed #4CAF50; border-radius:6px;">
                                  <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                                    <i class="fas fa-check-circle" style="color:#4CAF50;"></i>
                                    <strong style="color:#2e7d32;">Refund Receipt Selected</strong>
                                  </div>
                                  <div style="position:relative; display:inline-block; width:fit-content;">
                                    <img id="refund-receipt-image-${id}" src="" alt="Refund Receipt Preview" style="max-width:260px; width:auto; height:auto; border:1px solid #e0e0e0; border-radius:6px; cursor:pointer; transition:transform 0.2s ease,box-shadow 0.2s ease; display:block;" 
                                         onmouseenter="this.style.transform='scale(1.02)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)';"
                                         onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)';"
                                         title="Refund receipt preview" />
                                    <button onclick="event.preventDefault(); event.stopPropagation(); if(window.staffManager && typeof window.staffManager.removeRefundReceipt === 'function') { window.staffManager.removeRefundReceipt('${id}'); }" 
                                            style="position:absolute; top:8px; right:8px; background:#f44336; color:white; border:none; border-radius:50%; width:32px; height:32px; display:flex; align-items:center; justify-content:center; cursor:pointer; box-shadow:0 2px 8px rgba(0,0,0,0.3); transition:all 0.2s ease; z-index:10; margin:0; padding:0;" 
                                            onmouseenter="this.style.background='#d32f2f'; this.style.transform='scale(1.1)';" 
                                            onmouseleave="this.style.background='#f44336'; this.style.transform='scale(1)';" 
                                            title="Remove image">
                                      <i class="fas fa-times" style="font-size:14px;"></i>
                                    </button>
                                  </div>
                                </div>
                              `;
                })()}
                          </div>
                          
                          <!-- Action Buttons Section -->
                          <div style="padding-top:12px; border-top:1px solid #ffc107;">
                            <div style="display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap; margin-bottom:8px;">
                              <button class="confirm-btn" onclick="staffManager.confirmCancelledRefund('${id}')" style="min-width:180px;">
                                <i class="fas fa-check-circle"></i> Confirm Cancel & Refund
                              </button>
                              ${(String(order.status || "").toLowerCase() ===
                    "pending" ||
                    String(order.status || "").toLowerCase() ===
                    "confirmed") &&
                    order.cancellationRequested === true &&
                    String(
                        order.paymentMethod || ""
                    ).toLowerCase() === "gcash" &&
                    !order.cancellationConfirmed &&
                    !order.refundConfirmedAt
                    ? `
                              <button class="danger-btn" onclick="staffManager.confirmCancelledNoRefund('${id}')" style="min-width:180px;">
                                <i class="fas fa-ban"></i> Confirm Cancel (No-refund)
                              </button>
                              `
                    : ""
                }
                            </div>
                            <div style="margin-top:8px; padding:8px; background:#fff3e0; border-radius:4px;">
                              <p style="margin:0; color:#bf360c; font-size:0.85rem; line-height:1.4;">
                                <i class="fas fa-info-circle"></i> 
                                ${(String(order.status || "").toLowerCase() ===
                    "pending" ||
                    String(order.status || "").toLowerCase() ===
                    "confirmed") &&
                    order.cancellationRequested === true &&
                    String(
                        order.paymentMethod || ""
                    ).toLowerCase() === "gcash"
                    ? "Upload the GCash refund receipt before confirming the cancellation. If no payment was received, confirm cancellation without refund and provide a reason."
                    : "Upload the GCash refund receipt before confirming the cancellation."
                }
                              </p>
                            </div>
                          </div>
                        </div>
                    `
                : ""
            }
                    ${((order.status === "pending" ||
                String(order.status || "").toLowerCase() ===
                "confirmed") &&
                order.cancellationRequested === true &&
                String(order.paymentMethod || "").toLowerCase() ===
                "gcash" &&
                !order.cancellationConfirmed &&
                !order.refundConfirmedAt) ||
                (String(order.status || "").toLowerCase() ===
                    "cancelled" &&
                    order.cancellationConfirmed !== true &&
                    !order.refundConfirmedAt &&
                    String(order.paymentMethod || "").toLowerCase() ===
                    "gcash")
                ? `
                        <button class="secondary-btn" onclick="staffManager.viewOrderCustomerDetails('${id}', '${(
                    order.customerName || ""
                ).replace(/'/g, "\\'")}', '${(
                    order.customerPhone || ""
                ).replace(/'/g, "\\'")}', '${(
                    order.deliveryAddress ||
                    order.customerAddress ||
                    ""
                ).replace(
                    /'/g,
                    "\\'"
                )}')" style="width:100%; margin-top:12px;">
                            <i class="fas fa-user"></i> Customer Details
                        </button>
                    `
                : ""
            }
                </div>
            </div>
        `;

        // Only load saved QR codes for active delivery states
        // This ensures QR codes are visible even after page refresh
        // and continue to be shown when an order moves to Out for delivery
        if (
            ["to_receive", "out_for_delivery", "pickup_ready"].includes(
                String(order.status || "").toLowerCase()
            )
        ) {
            setTimeout(() => {
                this.loadSavedQrForOrderCard(id);
            }, 100); // Small delay to ensure DOM is ready
        }

        // Note: Event listeners for cut-off buttons are now attached AFTER restructurePendingOrderCard
        // See attachCutoffButtonListeners method

        // Attach event listeners directly to QR buttons after DOM is created
        setTimeout(() => {
            const qrFooterBtn = div.querySelector(`#qr-generate-btn-footer-${id}`);

            if (qrFooterBtn) {
                // Remove any existing listeners and add fresh one
                const newBtn = qrFooterBtn.cloneNode(true);
                qrFooterBtn.parentNode.replaceChild(newBtn, qrFooterBtn);
                newBtn.addEventListener(
                    "click",
                    function (e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log("QR footer button clicked for order:", id);
                        if (
                            window.staffManager &&
                            typeof window.staffManager.openQrModal === "function"
                        ) {
                            window.staffManager.openQrModal(id);
                        } else {
                            console.error("staffManager.openQrModal not available");
                            alert(
                                "QR modal function not available. Please refresh the page."
                            );
                        }
                    },
                    true
                );
                console.log(
                    "âœ… QR footer button event listener attached for order:",
                    id
                );
            }
        }, 50);

        return div;
    }

    // Attach event listeners for refund and reschedule buttons during cut-off time
    // This is called AFTER restructurePendingOrderCard modifies the HTML
    attachCutoffButtonListeners(cardElement, orderId) {
        if (!cardElement) return;

        const self = this; // Store reference to this StaffManager instance

        // Use event delegation on the order card
        const handleCutoffButtonClick = (e) => {
            const target = e.target.closest(
                ".reschedule-btn-cutoff, .refund-btn-cutoff"
            );
            if (target && target.hasAttribute("data-order-id")) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                const id = target.getAttribute("data-order-id");
                const action = target.getAttribute("data-action");
                console.log("âœ… Cut-off button clicked:", action, "for order:", id);

                // Use self (this StaffManager instance) instead of window.staffManager
                if (action === "reschedule") {
                    console.log("Calling showRescheduleConfirmation for order:", id);
                    if (typeof self.showRescheduleConfirmation === "function") {
                        self.showRescheduleConfirmation(id);
                    } else {
                        console.error(
                            "showRescheduleConfirmation function not found on staffManager"
                        );
                    }
                } else if (action === "refund") {
                    console.log("Calling showRefundModal for order:", id);
                    if (typeof self.showRefundModal === "function") {
                        self.showRefundModal(id);
                    } else {
                        console.error("showRefundModal function not found on staffManager");
                    }
                }
                return false;
            }
        };

        // Add event delegation listener
        cardElement.addEventListener("click", handleCutoffButtonClick, true);
        cardElement.addEventListener("mousedown", handleCutoffButtonClick, true);

        // Also attach direct listeners to buttons
        setTimeout(() => {
            const rescheduleBtn = cardElement.querySelector(
                '.reschedule-btn-cutoff[data-order-id="' + orderId + '"]'
            );
            const refundBtn = cardElement.querySelector(
                '.refund-btn-cutoff[data-order-id="' + orderId + '"]'
            );

            console.log("Attaching cut-off button listeners for order:", orderId);
            console.log("Reschedule button found:", !!rescheduleBtn);
            console.log("Refund button found:", !!refundBtn);

            if (rescheduleBtn) {
                const handleReschedule = function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    const id = this.getAttribute("data-order-id");
                    console.log("âœ… Direct Reschedule clicked for order:", id);
                    console.log("Calling showRescheduleConfirmation for order:", id);
                    if (typeof self.showRescheduleConfirmation === "function") {
                        self.showRescheduleConfirmation(id);
                    } else {
                        console.error("showRescheduleConfirmation function not found");
                    }
                    return false;
                };
                rescheduleBtn.addEventListener("click", handleReschedule, true);
                rescheduleBtn.addEventListener("mousedown", handleReschedule, true);
            }

            if (refundBtn) {
                const handleRefund = function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    const id = this.getAttribute("data-order-id");
                    console.log("âœ… Direct Refund clicked for order:", id);
                    console.log("Calling showRefundModal for order:", id);
                    if (typeof self.showRefundModal === "function") {
                        self.showRefundModal(id);
                    } else {
                        console.error("showRefundModal function not found");
                    }
                    return false;
                };
                refundBtn.addEventListener("click", handleRefund, true);
                refundBtn.addEventListener("mousedown", handleRefund, true);
            }
        }, 50);
    }

    // Weekly cutoff helper: Thursday 8:01 PM through Sunday 11:59 PM (local time)
    isAfterWeeklyCutoff() {
        try {
            const now = new Date();
            const day = now.getDay(); // 0=Sun, 4=Thu
            const hour = now.getHours();
            const minute = now.getMinutes();
            if (day === 0) return true; // Sunday (all day)
            if (day > 4) return true; // Friday, Saturday
            // Thursday from 8:01 PM onward
            if (day === 4 && (hour > 20 || (hour === 20 && minute >= 1))) return true;
            return false;
        } catch (e) {
            return false;
        }
    }

    // Check if it's Thursday 8:01 PM or later (transition time)
    isTransitionTime() {
        try {
            const now = new Date();
            const day = now.getDay(); // 0 = Sunday, 1 = Monday, ..., 4 = Thursday
            const hour = now.getHours();
            const minute = now.getMinutes();

            // Thursday 8:01 PM or later (day = 4, hour >= 20, minute >= 1)
            if (day === 4 && (hour > 20 || (hour === 20 && minute >= 1))) return true;
            // Friday, Saturday, Sunday (days 5, 6, 0) - definitely should be transitioned
            if (day === 5 || day === 6 || day === 0) return true;

            return false;
        } catch (e) {
            console.error("isTransitionTime error:", e);
            return false;
        }
    }

    // Automatically transition confirmed orders to "to_receive" at Thursday 8:01 PM
    async autoTransitionConfirmedOrders() {
        try {
            console.log("Checking for automatic order transition...");

            // Get all confirmed orders
            const confirmedOrdersSnapshot = await dbRefs.orders
                .orderByChild("status")
                .equalTo("confirmed")
                .once("value");
            const confirmedOrders = confirmedOrdersSnapshot.val();

            if (!confirmedOrders) {
                console.log("No confirmed orders found for transition");
                return;
            }

            const transitionPromises = [];
            const transitionedOrders = [];

            for (const [orderId, order] of Object.entries(confirmedOrders)) {
                // Skip orders with cancellation requests
                if (order.cancellationRequested === true) {
                    continue;
                }

                // Update order status to "to_receive"
                const updateData = {
                    status: "to_receive",
                    transitionedAt: Date.now(),
                    updatedAt: Date.now(),
                };

                transitionPromises.push(
                    dbRefs.orders.child(orderId).update(updateData)
                );

                transitionedOrders.push(orderId);
            }

            if (transitionPromises.length > 0) {
                await Promise.all(transitionPromises);
                console.log(
                    `Automatically transitioned ${transitionedOrders.length} orders to "to_receive" status`
                );

                // Refresh the orders display
                this.loadPendingOrders();
                this.loadAssignedOrders();

                // Show notification to staff
                this.showSuccessMessage(
                    `Automatically transitioned ${transitionedOrders.length} confirmed orders to "To Receive" status`
                );
            }
        } catch (error) {
            console.error("Error in autoTransitionConfirmedOrders:", error);
        }
    }

    // Check for and transition any "stuck" confirmed orders
    async checkForStuckConfirmedOrders() {
        try {
            console.log("Checking for stuck confirmed orders...");

            // Get all confirmed orders
            const confirmedOrdersSnapshot = await dbRefs.orders
                .orderByChild("status")
                .equalTo("confirmed")
                .once("value");
            const confirmedOrders = confirmedOrdersSnapshot.val();

            if (!confirmedOrders) {
                console.log("No confirmed orders found");
                return;
            }

            const now = new Date();
            const day = now.getDay();
            const hour = now.getHours();
            const minute = now.getMinutes();

            // Check if we're in the transition period (Thursday 8:01 PM onwards)
            const shouldTransition =
                (day === 4 && (hour > 20 || (hour === 20 && minute >= 1))) ||
                day === 5 ||
                day === 6 ||
                day === 0;

            if (shouldTransition) {
                console.log(
                    `Found ${Object.keys(confirmedOrders).length
                    } confirmed orders that should be transitioned`
                );
                await this.autoTransitionConfirmedOrders();
            }
        } catch (error) {
            console.error("Error checking for stuck confirmed orders:", error);
        }
    }

    // Start the automatic transition scheduler
    startAutoTransitionScheduler() {
        // Check every minute for transition time
        setInterval(() => {
            if (this.isTransitionTime()) {
                this.autoTransitionConfirmedOrders();
            }
        }, 60000); // Check every minute

        // Also check immediately when the page loads
        if (this.isTransitionTime()) {
            this.autoTransitionConfirmedOrders();
        }

        // Check for stuck orders immediately when page loads
        setTimeout(() => {
            this.checkForStuckConfirmedOrders();
        }, 2000); // Small delay to ensure page is fully loaded

        // Check for stuck orders every 5 minutes
        setInterval(() => {
            this.checkForStuckConfirmedOrders();
        }, 300000); // Check every 5 minutes
    }

    // Watcher to auto-refresh pending UI at cutoff boundaries without DB changes
    startCutoffWatcher() {
        try {
            if (this.__cutoffWatcherStarted) return;
            this.__cutoffWatcherStarted = true;
            let lastState = this.isAfterWeeklyCutoff();

            const refreshIfNeeded = () => {
                const current = this.isAfterWeeklyCutoff();
                if (current !== lastState) {
                    lastState = current;
                    // Only refresh if on order management and pending tab is active
                    const isOnOrders = this.currentSection === "order-management";
                    const isPendingTab =
                        (this.currentOrderManagementTab || "pending-orders") ===
                        "pending-orders";
                    if (
                        isOnOrders &&
                        isPendingTab &&
                        typeof this.loadOrders === "function"
                    ) {
                        this.loadPendingOrders();
                    }
                }
            };

            // Periodic check as safety net
            this.__cutoffInterval = setInterval(refreshIfNeeded, 30000); // 30s

            // Precise boundary scheduling
            const scheduleNextBoundary = () => {
                if (this.__cutoffTimeout) {
                    clearTimeout(this.__cutoffTimeout);
                }
                const now = new Date();
                const d = now.getDay(); // 0=Sun
                const ms = now.getTime();

                const mk = (targetDow, h, m, s) => {
                    const t = new Date(now);
                    const diff = (targetDow - d + 7) % 7;
                    t.setDate(now.getDate() + diff);
                    t.setHours(h, m, s, 0);
                    return t.getTime();
                };

                // Boundaries: Thu 20:01 enters cutoff; Mon 00:00 exits cutoff
                const nextThu2001 = mk(4, 20, 1, 0);
                const nextMon0000 = mk(1, 0, 0, 0);

                // If currently before Thu 20:00 this week, and nextThu is in the past (meaning today is Thu after 20:00), bump to next week's Thu
                let targetTs;
                if (this.isAfterWeeklyCutoff()) {
                    // schedule exit at next Monday 00:00
                    targetTs =
                        nextMon0000 <= ms
                            ? mk(1, 0, 0, 0) + 7 * 24 * 3600 * 1000
                            : nextMon0000;
                } else {
                    // schedule enter at this week's Thu 20:01 (or next week's if already past)
                    targetTs =
                        nextThu2001 <= ms
                            ? nextThu2001 + 7 * 24 * 3600 * 1000
                            : nextThu2001;
                }

                const delay = Math.max(1000, targetTs - ms);
                this.__cutoffTimeout = setTimeout(() => {
                    refreshIfNeeded();
                    scheduleNextBoundary();
                }, delay);
            };

            scheduleNextBoundary();
        } catch (_) { }
    }

    // Compute next weekend (Saturday-Sunday) timestamps
    _computeNextWeekendRange() {
        const now = new Date();
        const day = now.getDay();
        // days until coming Saturday
        const daysUntilThisSaturday = (6 - day + 7) % 7;
        // next week's Saturday => add 7 more days
        const daysUntilNextSaturday = daysUntilThisSaturday + 7;
        const saturday = new Date(
            now.getFullYear(),
            now.getMonth(),
            now.getDate() + daysUntilNextSaturday
        );
        saturday.setHours(0, 0, 0, 0);
        const sunday = new Date(saturday);
        sunday.setDate(saturday.getDate() + 1);
        sunday.setHours(23, 59, 59, 999);
        return {
            startTs: saturday.getTime(),
            endTs: sunday.getTime(),
            startLabel: saturday.toLocaleDateString(),
            endLabel: sunday.toLocaleDateString(),
        };
    }

    async rescheduleOrderNextWeek(orderId) {
        try {
            // Fetch order from Supabase
            const order = await OrderSupabaseAdapter.fetchOrderById(orderId);
            if (!order || !order.id) {
                throw new Error("Order not found");
            }

            // Decrease reserved quantities only (available quantity unchanged) - like confirm order
            if (String(order.status || "").toLowerCase() === "pending") {
                await this.decreaseReservedQuantities(order);
            }

            const weekend = this._computeNextWeekendRange();
            const staffUid =
                this.userUid ||
                this.getUserUid() ||
                sessionStorage.getItem("staffUid") ||
                sessionStorage.getItem("adminUid") ||
                "staff";
            let staffName =
                this.userName ||
                this.getUserName() ||
                sessionStorage.getItem("staffName") ||
                sessionStorage.getItem("adminName") ||
                "Staff";
            let staffRole = null;

            // Get role from sessionStorage
            const userRole = sessionStorage.getItem("userRole");
            if (userRole === "admin") {
                staffRole = "System Administrator";
            } else if (userRole === "staff") {
                staffRole = "Staff Member";
            } else if (sessionStorage.getItem("adminUid")) {
                staffRole = "System Administrator";
            } else if (sessionStorage.getItem("staffUid")) {
                staffRole = "Staff Member";
            }

            // Try to get name from database if not in sessionStorage
            if (!staffName || staffName === "Staff") {
                try {
                    if (window.dbRefs && window.dbRefs.staff) {
                        const staffSnapshot = await window.dbRefs.staff
                            .child(staffUid)
                            .once("value");
                        const staffData = staffSnapshot.val();
                        if (staffData) {
                            staffName = staffData.fullName || staffData.name || staffName;
                        }
                    }
                } catch (_) {
                    // ignore name resolution errors; fallback to sessionStorage value
                }
            }

            const isPickup =
                String(order.deliveryOption || "").toLowerCase() === "pickup";
            const deliveryNote = `Your order will be delivered next week for the one-day delivery.`;
            const pickupNote = `You can pickup your order next week.`;
            const estimateLine = isPickup
                ? `Estimate Pickup Schedule: ${weekend.startLabel} - ${weekend.endLabel}`
                : `Estimate Delivery: ${weekend.startLabel} - ${weekend.endLabel}`;
            const composedNote = `${isPickup ? pickupNote : deliveryNote
                }\n${estimateLine}`;

            const nowMs = Date.now();
            const updates = {
                status: "to_receive",
                to_receive_at: nowMs,
                to_receive_by: staffUid,
                to_receive_by_name: staffName,
                updated_at: nowMs,
                updated_by: staffUid,
                updated_by_name: staffName,
                rescheduled_next_week: true,
                rescheduled_at: nowMs,
                rescheduled_by: staffUid,
                rescheduled_by_name: staffName,
                estimated_delivery_start: weekend.startTs,
                estimated_delivery_end: weekend.endTs,
                delivery_notes: (
                    order.deliveryNotes ||
                    order.delivery_notes ||
                    order.order_notes ||
                    order.orderNotes ||
                    ""
                ).trim()
                    ? `${(
                        order.deliveryNotes ||
                        order.delivery_notes ||
                        order.order_notes ||
                        order.orderNotes ||
                        ""
                    ).trim()}\n${composedNote}`.trim()
                    : composedNote,
            };

            // Add role if available
            if (staffRole) {
                updates.rescheduled_by_role = staffRole;
            }

            // Update order in Supabase
            await OrderSupabaseAdapter.updateOrder(orderId, updates);
            console.log("âœ… Order rescheduled in Supabase:", orderId);

            // Refresh all relevant sections:
            // - Pending orders (to remove the rescheduled order)
            // - Assigned orders / To Receive tab (to show the rescheduled order)
            // - Products (to show updated quantities)
            if (this.loadPendingOrders) {
                this.loadPendingOrders();
            }
            if (this.loadAssignedOrders) {
                this.loadAssignedOrders();
            }
            if (this.loadProducts) {
                this.loadProducts();
            }
            if (this.loadStats) {
                this.loadStats();
            }

            alert(
                "Order rescheduled to next week and moved to To Receive tab with status: Rescheduled."
            );
        } catch (err) {
            console.error("rescheduleOrderNextWeek error", err);
            alert(
                "Failed to reschedule order: " +
                (err && err.message ? err.message : err)
            );
        }
    }

    // removed setEstimatedDeliveryNextWeekend per requirement

    async refundPendingOrder(orderId) {
        try {
            const confirmMsg =
                "Mark this order for refund? You will upload the GCash refund receipt next.";
            if (!confirm(confirmMsg)) return;

            const order = await OrderSupabaseAdapter.fetchOrderById(orderId);
            let firebaseOrder = null;
            if (!order || !order.id) {
                // Fallback to Firebase if Supabase doesn't have the order
                const orderRef = dbRefs.orders.child(orderId);
                const snap = await orderRef.once("value");
                firebaseOrder = snap.val() || {};
            }

            const nowMs = Date.now();

            // Flag as refund requested but keep it in Pending until receipt is uploaded and confirmed - SAVE TO SUPABASE
            const supabaseUpdates = {
                cancellationRequested: true,
                cancellationConfirmed: false,
                cancellationInitiatedBy: "staff",
                updatedAt: nowMs,
            };

            // Release reserved quantities (decrease reserved, increase available) - like reject button
            // This happens when refund is processed (after receipt upload and confirm)
            const orderForStock = order || firebaseOrder;
            if (String(orderForStock.status || "").toLowerCase() === "pending") {
                try {
                    await this.releaseReservedQuantities(orderForStock);
                    console.log(
                        "âœ… Released reserved quantities for refund order:",
                        orderId
                    );
                } catch (err) {
                    console.error("Error releasing reserved quantities for refund:", err);
                }
            }

            // Save to Supabase - NO FIREBASE FALLBACK
            await OrderSupabaseAdapter.updateOrder(orderId, supabaseUpdates);
            console.log("âœ… Refund request saved to Supabase for order:", orderId);

            // Refresh UI to reveal the upload receipt actions on the same card
            if (this.loadPendingOrders) {
                this.loadPendingOrders();
            }
            if (this.loadProducts) {
                this.loadProducts();
            }

            // Expand the order details and focus the upload control if present
            setTimeout(() => {
                try {
                    const detailsEl = document.getElementById(`order-details-${orderId}`);
                    if (detailsEl && detailsEl.classList.contains("collapsed")) {
                        detailsEl.classList.remove("collapsed");
                    }
                    const uploadInput = document.querySelector(
                        `#refund-receipt-${orderId}`
                    );
                    if (uploadInput && uploadInput.scrollIntoView) {
                        uploadInput.scrollIntoView({ behavior: "smooth", block: "center" });
                    }
                } catch (_) { }
            }, 250);

            alert(
                "Refund initiated. Please upload the GCash refund receipt and confirm."
            );
        } catch (err) {
            console.error("refundPendingOrder error", err);
            alert(
                "Failed to initiate refund: " + (err && err.message ? err.message : err)
            );
        }
    }

    // Load saved QR codes for order card display
    async loadSavedQrForOrderCard(orderId) {
        try {
            const qrDisplayContainer = document.getElementById(
                `saved-qr-display-${orderId}`
            );
            const qrContainer = document.getElementById(
                `saved-qr-container-${orderId}`
            );

            if (!qrDisplayContainer) {
                console.log(`QR container not found for order ${orderId}`);
                return;
            }

            // Ensure the container maintains scrollable properties
            qrDisplayContainer.style.maxHeight = "400px";
            qrDisplayContainer.style.overflowY = "auto";
            qrDisplayContainer.style.overflowX = "hidden";
            qrDisplayContainer.style.padding = "8px";

            console.log(`Loading QR codes for order ${orderId}`);
            const qr = await this.fetchSupabaseQrRecord(orderId, {
                forceRefresh: true,
            });

            // Update header and button visibility
            const hasQr = !!qr;

            // Container is always visible now, just update content
            const footerBtn = document.getElementById(
                `qr-generate-btn-footer-${orderId}`
            );
            if (footerBtn) {
                // Hide footer button if QR exists, show if no QR
                footerBtn.style.display = hasQr ? "none" : "block";
                // Ensure button remains clickable and has proper attributes
                footerBtn.style.pointerEvents = "auto";
                footerBtn.style.cursor = "pointer";
                footerBtn.style.zIndex = "10";
                footerBtn.style.position = "relative";
                // Ensure class and data attribute are set for event delegation
                if (!footerBtn.classList.contains("qr-generate-btn")) {
                    footerBtn.classList.add("qr-generate-btn");
                }
                if (!footerBtn.dataset.orderId) {
                    footerBtn.dataset.orderId = orderId;
                }
            }

            const contentArea = qrDisplayContainer.querySelector("div:last-child");
            if (!qr) {
                if (contentArea) {
                    contentArea.innerHTML =
                        '<div style="text-align: center; padding: 20px; color: #999; font-size: 14px; font-style:italic;">No QR code generated yet</div>';
                }
                return;
            }

            // Render the single QR card (no delete button, only edit/download/print)
            if (contentArea) {
                const createdTxt = qr.createdAt
                    ? new Date(qr.createdAt).toLocaleString()
                    : "N/A";
                const updatedTxt = qr.updatedAt
                    ? new Date(qr.updatedAt).toLocaleString()
                    : null;
                const hasBeenUpdated =
                    qr.updatedAt && qr.createdAt && qr.updatedAt !== qr.createdAt;

                contentArea.innerHTML = [
                    '<div style="border: 1px solid #e0e0e0; border-radius: 6px; padding: 10px; background: #f9f9f9; min-width: 220px;">',
                    '<div style="margin-bottom: 8px;">',
                    `<div style=\"font-size:12px;color:#555;\"><strong>Order Code:</strong> ${orderId
                        .substr(-8)
                        .toUpperCase()}</div>`,
                    `<div style=\"font-size:12px;color:#555;\"><strong>Generated At:</strong> ${createdTxt}</div>`,
                    hasBeenUpdated
                        ? `<div style=\"font-size:12px;color:#555;\"><strong>Updated At:</strong> ${updatedTxt}</div>`
                        : "",
                    "</div>",
                    qr.qrImageUrl
                        ? `<div style="margin: 8px 0; text-align: center;"><img src="${qr.qrImageUrl}" alt="QR Packaging" style="max-width:150px; max-height:150px; border:1px solid #e0e0e0; border-radius:6px; cursor:pointer;" onerror="this.style.display='none'" onclick="staffManager.showImageLightbox('${qr.qrImageUrl}')" /></div>`
                        : "",
                    qr.header
                        ? `<div style=\"font-weight:600; margin-top:6px; text-align: center;\">${qr.header}</div>`
                        : "",
                    qr.notes
                        ? `<div style="font-size: 12px; color: #666; margin-top: 2px; white-space: pre-line; text-align: center;">${qr.notes}</div>`
                        : "",
                    '<div style="display: flex; gap: 4px; flex-wrap: wrap; margin-top:12px; margin-bottom:12px; justify-content: center; padding: 8px; background: #f0f0f0; border-radius: 4px;">',
                    this.getQrActionButtons(orderId, qr),
                    "</div>",
                    "</div>",
                ].join("");
            }
        } catch (e) {
            console.error("loadSavedQrForOrderCard error:", e);
            const qrDisplayContainer = document.getElementById(
                `saved-qr-display-${orderId}`
            );
            if (qrDisplayContainer) {
                qrDisplayContainer.innerHTML =
                    '<div style="text-align:center;padding:8px;color:#f44336;font-size:12px;">Failed to load QR codes</div>';
            }
        }
    }

    // Edit QR from order card
    async editQrFromCard(qrId, orderId) {
        try {
            // Open the QR modal first
            await this.openQrModal(orderId);

            // Hide the Generate button in edit mode
            const genBtn = document.getElementById(`qr-generate-action-${orderId}`);
            if (genBtn) genBtn.style.display = "none";

            // Then load the latest QR data into the preview
            await this.loadQrData(qrId, orderId);
        } catch (e) {
            console.error("editQrFromCard error:", e);
            alert("Failed to load QR for editing");
        }
    }

    // Delete saved QR from order card
    async deleteSavedQrFromCard(qrId, orderId) {
        if (!confirm("Are you sure you want to delete this QR code?")) return;

        try {
            const supabase = this.getQrSupabaseClient();
            if (!supabase) {
                alert("Supabase client not available. Please refresh and try again.");
                return;
            }

            const targetOrderId = orderId || qrId;
            const { error } = await supabase
                .from("qr_codes")
                .delete()
                .eq("order_id", targetOrderId);

            if (error) {
                throw error;
            }

            this.invalidateQrCache(targetOrderId);

            // Reload the QR display for this order
            this.loadSavedQrForOrderCard(targetOrderId);

            alert("QR code deleted successfully");
        } catch (e) {
            console.error("deleteSavedQrFromCard error:", e);
            alert("Failed to delete QR code");
        }
    }

    async markPacked(orderId) {
        try {
            const orderRef = dbRefs.orders.child(orderId);
            const snapshot = await orderRef.once("value");
            const order = snapshot.val();

            if (!order) {
                alert("Order not found");
                return;
            }

            await orderRef.update({
                status: "packed",
                packedAt: FirebaseUtils.getTimestamp(),
                packedBy: sessionStorage.getItem("staffUid") || "staff",
                updatedAt: FirebaseUtils.getTimestamp(),
            });

            // Send notification to customer
            await this.sendPackedNotification(orderId, order);

            this.showSuccessMessage("Order marked as packed");
            this.loadPendingOrders();
            this.loadAssignedOrders();
            this.loadStats();
        } catch (error) {
            console.error("Error marking packed:", error);
            alert("Error updating order: " + error.message);
        }
    }
    async handleRefundReceiptUpload(orderId) {
        const input = document.getElementById(`refund-receipt-${orderId}`);
        const previewDiv = document.getElementById(
            `refund-receipt-preview-${orderId}`
        );
        const previewImage = document.getElementById(
            `refund-receipt-image-${orderId}`
        );

        if (!input || !input.files || input.files.length === 0) {
            // Hide the preview container when no file is selected
            if (previewDiv) {
                previewDiv.style.display = "none";
            }
            return;
        }

        const file = input.files[0];
        if (!file) return;

        try {
            // Step 1: Immediately clear and prepare preview container
            if (previewDiv) {
                // Hide any existing uploaded container (solid border - from DB)
                const existingUploadedContainer = previewDiv.querySelector(
                    'div[style*="border:2px solid #4CAF50"], div[style*="border: 2px solid #4CAF50"]'
                );
                if (existingUploadedContainer) {
                    existingUploadedContainer.style.display = "none";
                }

                // Show the selected preview container (dashed border) - this should already exist
                const selectedContainer = previewDiv.querySelector(
                    'div[style*="border:2px dashed #4CAF50"], div[style*="border: 2px dashed #4CAF50"]'
                );
                if (selectedContainer) {
                    selectedContainer.style.display = "block";
                } else {
                    // If selected container doesn't exist, create it (shouldn't happen but just in case)
                    previewDiv.innerHTML = `
                        <div style="display:block; margin-top:12px; padding:12px; background:#f8fff8; border:2px dashed #4CAF50; border-radius:6px;">
                            <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                                <i class="fas fa-check-circle" style="color:#4CAF50;"></i>
                                <strong style="color:#2e7d32;">Refund Receipt Selected</strong>
                            </div>
                            <div style="position:relative; display:inline-block; width:fit-content;">
                                <img id="refund-receipt-image-${orderId}" src="" alt="Refund Receipt Preview" style="max-width:260px; width:auto; height:auto; border:1px solid #e0e0e0; border-radius:6px; cursor:pointer; transition:transform 0.2s ease,box-shadow 0.2s ease; display:block;" 
                                     onmouseenter="this.style.transform='scale(1.02)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)';"
                                     onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)';"
                                     title="Refund receipt preview" />
                                <button onclick="event.preventDefault(); event.stopPropagation(); if(window.staffManager && typeof window.staffManager.removeRefundReceipt === 'function') { window.staffManager.removeRefundReceipt('${orderId}'); }" 
                                        style="position:absolute; top:8px; right:8px; background:#f44336; color:white; border:none; border-radius:50%; width:32px; height:32px; display:flex; align-items:center; justify-content:center; cursor:pointer; box-shadow:0 2px 8px rgba(0,0,0,0.3); transition:all 0.2s ease; z-index:10; margin:0; padding:0;" 
                                        onmouseenter="this.style.background='#d32f2f'; this.style.transform='scale(1.1)';" 
                                        onmouseleave="this.style.background='#f44336'; this.style.transform='scale(1)';" 
                                        title="Remove image">
                                    <i class="fas fa-times" style="font-size:14px;"></i>
                                </button>
                            </div>
                        </div>
                    `;
                    // Preview image element is now in the DOM after innerHTML update
                    // We'll get it directly in the FileReader callback using getElementById
                }

                // Show the preview container
                previewDiv.style.display = "block";
            }

            // Step 2: Use FileReader to show INSTANT local preview (no upload delay)
            // This provides immediate visual feedback before upload completes
            const reader = new FileReader();
            reader.onload = (e) => {
                // Show local preview immediately for instant feedback - NO DELAY
                requestAnimationFrame(() => {
                    const currentPreviewImage = document.getElementById(
                        `refund-receipt-image-${orderId}`
                    );
                    const currentPreviewDiv = document.getElementById(
                        `refund-receipt-preview-${orderId}`
                    );

                    if (currentPreviewImage && currentPreviewDiv) {
                        // Ensure the selected container is visible
                        const selectedContainer = currentPreviewDiv.querySelector(
                            'div[style*="border:2px dashed #4CAF50"], div[style*="border: 2px dashed #4CAF50"]'
                        );
                        if (selectedContainer) {
                            selectedContainer.style.display = "block";
                        }

                        // Set new image immediately - no delay, no waiting for upload
                        currentPreviewImage.src = e.target.result;
                        currentPreviewImage.style.opacity = "1";
                        currentPreviewImage.style.display = "block";
                        currentPreviewImage.style.transition = "opacity 0.15s ease";

                        // Set click handler for local preview
                        currentPreviewImage.onclick = function (event) {
                            event.preventDefault();
                            event.stopPropagation();
                            if (
                                window.staffManager &&
                                typeof window.staffManager.showEnlargedImage === "function"
                            ) {
                                window.staffManager.showEnlargedImage(
                                    e.target.result,
                                    "Refund Receipt"
                                );
                            }
                        };

                        // Ensure preview container is visible
                        currentPreviewDiv.style.display = "block";
                    }
                });
            };
            reader.onerror = () => {
                console.error("Error reading file for preview");
            };
            // Start reading immediately - this is synchronous and instant
            reader.readAsDataURL(file);

            // Check if Supabase client is available
            const supabase = window.getSupabaseClient
                ? window.getSupabaseClient()
                : window.supabaseClient || null;
            if (!supabase) {
                throw new Error("Supabase client not initialized");
            }

            // Generate unique filename
            const timestamp = Date.now();
            const random = Math.floor(Math.random() * 10000);
            const extension = file.name.split(".").pop();
            const fileName = `${orderId}_${timestamp}_${random}.${extension}`;
            const filePath = `${orderId}/${fileName}`;

            // Read file as array buffer
            const arrayBuffer = await file.arrayBuffer();

            // Upload to Supabase refund_receipt bucket (background upload)
            console.log("ðŸ“¤ Uploading refund receipt to Supabase...", {
                orderId,
                fileName,
            });
            const { data: uploadData, error: uploadError } = await supabase.storage
                .from("refund_receipt")
                .upload(filePath, arrayBuffer, {
                    contentType: file.type,
                    upsert: true, // Allow overwriting if file exists
                });

            if (uploadError) {
                console.error("âŒ Supabase upload error:", uploadError);
                throw new Error(
                    `Failed to upload refund receipt: ${uploadError.message}`
                );
            }

            // Get public URL
            const { data: urlData } = supabase.storage
                .from("refund_receipt")
                .getPublicUrl(filePath);

            if (!urlData || !urlData.publicUrl) {
                throw new Error("Failed to get refund receipt URL from Supabase");
            }

            const publicUrl = urlData.publicUrl;
            console.log("âœ… Refund receipt uploaded successfully:", publicUrl);

            // Show success message immediately (don't wait for DB update)
            // The preview is already showing via FileReader, so user sees instant feedback
            this.showSuccessMessage("Refund receipt uploaded successfully");

            // Step 3: Save the URL to the order in Supabase (background operation with delay)
            // Delay the update to prevent real-time listener from triggering immediate refresh
            // The local preview already shows instantly, so we can delay the DB update
            setTimeout(() => {
                OrderSupabaseAdapter.updateOrder(orderId, {
                    refundReceiptUrl: publicUrl,
                    updatedAt: Date.now(),
                })
                    .then(() => {
                        console.log("âœ… Refund receipt URL saved to order:", orderId);
                        // Don't try to update the preview here - it's already showing via FileReader
                        // This prevents glitches and refreshes
                    })
                    .catch((updateError) => {
                        console.error(
                            "âš ï¸ Failed to save refund receipt URL to order:",
                            updateError
                        );
                        // Continue - the file is uploaded, URL just didn't save to order
                    });
            }, 2000); // Delay 2 seconds to allow user to see the success message without refresh
        } catch (error) {
            console.error("âŒ Error uploading refund receipt:", error);
            alert("Failed to upload refund receipt: " + (error.message || error));

            // Hide preview on error
            if (previewDiv) {
                previewDiv.style.display = "none";
            }
            if (previewImage) {
                previewImage.src = "";
            }
            if (input) {
                input.value = ""; // Clear the input
            }
        }
    }
    removeRefundReceipt(orderId) {
        const input = document.getElementById(`refund-receipt-${orderId}`);
        const previewDiv = document.getElementById(
            `refund-receipt-preview-${orderId}`
        );
        const previewImage = document.getElementById(
            `refund-receipt-image-${orderId}`
        );

        // Clear the file input
        if (input) {
            input.value = "";
        }

        // Clear the preview image
        if (previewImage) {
            previewImage.src = "";
        }

        // Hide the preview container
        if (previewDiv) {
            previewDiv.style.display = "none";
        }
    }
    async confirmCancelledRefund(orderId) {
        try {
            const input = document.getElementById(`refund-receipt-${orderId}`);

            // Check if receipt was already uploaded (should have URL in order)
            let refundReceiptUrl = null;
            try {
                const currentOrder = await OrderSupabaseAdapter.fetchOrderById(orderId);
                if (
                    currentOrder &&
                    currentOrder.refundReceiptUrl &&
                    !currentOrder.refundReceiptUrl.startsWith("pending:")
                ) {
                    refundReceiptUrl = currentOrder.refundReceiptUrl;
                    console.log(
                        "âœ… Using existing refund receipt URL:",
                        refundReceiptUrl
                    );
                }
            } catch (err) {
                console.warn(
                    "âš ï¸ Could not fetch current order for refund receipt URL:",
                    err
                );
            }

            // If no receipt URL exists, check if file is selected for upload
            if (!refundReceiptUrl) {
                if (!input || !input.files || input.files.length === 0) {
                    alert(
                        "Please upload the GCash refund receipt image before confirming."
                    );
                    return;
                }

                const file = input.files[0];

                // Upload the receipt now
                try {
                    const supabase = window.getSupabaseClient
                        ? window.getSupabaseClient()
                        : window.supabaseClient || null;
                    if (!supabase) {
                        throw new Error("Supabase client not initialized");
                    }

                    const timestamp = Date.now();
                    const random = Math.floor(Math.random() * 10000);
                    const extension = file.name.split(".").pop();
                    const fileName = `${orderId}_${timestamp}_${random}.${extension}`;
                    const filePath = `${orderId}/${fileName}`;
                    const arrayBuffer = await file.arrayBuffer();

                    const { data: uploadData, error: uploadError } =
                        await supabase.storage
                            .from("refund_receipt")
                            .upload(filePath, arrayBuffer, {
                                contentType: file.type,
                                upsert: true,
                            });

                    if (uploadError) {
                        throw new Error(
                            `Failed to upload refund receipt: ${uploadError.message}`
                        );
                    }

                    const { data: urlData } = supabase.storage
                        .from("refund_receipt")
                        .getPublicUrl(filePath);

                    if (!urlData || !urlData.publicUrl) {
                        throw new Error("Failed to get refund receipt URL from Supabase");
                    }

                    refundReceiptUrl = urlData.publicUrl;
                    console.log(
                        "âœ… Refund receipt uploaded during confirmation:",
                        refundReceiptUrl
                    );
                } catch (uploadErr) {
                    console.error("âŒ Failed to upload refund receipt:", uploadErr);
                    alert(
                        "Failed to upload refund receipt: " +
                        (uploadErr.message || uploadErr)
                    );
                    return;
                }
            }

            // Resolve staff full name and role for accountability
            const staffUid =
                sessionStorage.getItem("staffUid") ||
                sessionStorage.getItem("adminUid") ||
                "staff";
            let staffFullName =
                sessionStorage.getItem("staffName") ||
                sessionStorage.getItem("adminName") ||
                null;
            let staffRole = null;

            // Get role from sessionStorage
            const userRole = sessionStorage.getItem("userRole");
            if (userRole === "admin") {
                staffRole = "System Administrator";
            } else if (userRole === "staff") {
                staffRole = "Staff Member";
            } else if (sessionStorage.getItem("adminUid")) {
                staffRole = "System Administrator";
            } else if (sessionStorage.getItem("staffUid")) {
                staffRole = "Staff Member";
            }

            // Try to get name from database if not in sessionStorage
            if (!staffFullName) {
                try {
                    if (window.dbRefs && window.dbRefs.staff) {
                        const staffSnapshot = await window.dbRefs.staff
                            .child(staffUid)
                            .once("value");
                        const staffData = staffSnapshot.val();
                        if (staffData) {
                            staffFullName = staffData.fullName || staffData.name || null;
                        }
                    }
                } catch (_) {
                    // ignore name resolution errors; fallback to UID
                }
            }

            // Read order to restore stock on refund
            const order = (await OrderSupabaseAdapter.fetchOrderById(orderId)) || {};
            if (!order || !order.id) {
                // Fallback to Firebase if Supabase doesn't have the order
                const orderSnap = await dbRefs.orders.child(orderId).once("value");
                const firebaseOrder = orderSnap.val() || {};
                Object.assign(order, firebaseOrder);
            }

            const nowMs = Date.now();

            // Update order with refund confirmation metadata and mark as cancelled - SAVE TO SUPABASE
            // Note: Only use camelCase keys - fieldMapping will convert to snake_case automatically
            const supabaseUpdates = {
                refundReceiptUrl: refundReceiptUrl,
                cancellationConfirmed: true, // Will be converted to cancellation_confirmed by fieldMapping
                cancellationConfirmedAt: nowMs,
                refundConfirmedAt: nowMs,
                refundConfirmedBy: staffUid,
                status: "cancelled",
                cancellationRequested: false, // no longer a request - will be converted to cancellation_requested
                cancellationInitiatedBy: "staff",
                updatedAt: nowMs,
            };
            if (staffFullName) {
                supabaseUpdates.refundConfirmedByName = staffFullName;
                supabaseUpdates.cancellation_confirmed_by_name = staffFullName;
            }
            if (staffRole) {
                supabaseUpdates.cancellation_confirmed_by_role = staffRole;
            }

            // Save to Supabase - NO FIREBASE FALLBACK
            try {
                console.log(
                    "ðŸ”„ Saving cancellation to Supabase for order:",
                    orderId,
                    "Updates:",
                    supabaseUpdates
                );
                await OrderSupabaseAdapter.updateOrder(orderId, supabaseUpdates);
                console.log(
                    "âœ… Refund confirmation saved to Supabase for order:",
                    orderId
                );
                console.log(
                    'âœ… Order status set to "cancelled" - should NOT appear in confirmed tab'
                );

                // Wait a bit for database to propagate
                await new Promise((resolve) => setTimeout(resolve, 1000));

                // Double-check the update was successful - verify status is 'cancelled' AND cancellationConfirmed is true
                const verifyOrder = await OrderSupabaseAdapter.fetchOrderById(orderId);
                console.log("ðŸ” Verification - Fetched order from database:", {
                    orderId: orderId,
                    status: verifyOrder?.status,
                    cancellationConfirmed: verifyOrder?.cancellationConfirmed,
                    cancellation_confirmed: verifyOrder?.cancellation_confirmed,
                    refundConfirmedAt: verifyOrder?.refundConfirmedAt,
                    refund_confirmed_at: verifyOrder?.refund_confirmed_at,
                    fullOrder: verifyOrder,
                });

                const verifyStatus = String(verifyOrder?.status || "").toLowerCase();
                const verifyCancellationConfirmed =
                    verifyOrder?.cancellationConfirmed === true ||
                    verifyOrder?.cancellation_confirmed === true ||
                    verifyOrder?.cancellation_confirmed === 1;
                const verifyRefundConfirmed =
                    verifyOrder?.refundConfirmedAt ||
                    verifyOrder?.refund_confirmed_at ||
                    verifyOrder?.refundConfirmedAt > 0 ||
                    verifyOrder?.refund_confirmed_at > 0;

                if (
                    verifyOrder &&
                    (verifyStatus !== "cancelled" ||
                        !verifyCancellationConfirmed ||
                        !verifyRefundConfirmed)
                ) {
                    console.warn(
                        "âš ï¸ Order verification failed - status:",
                        verifyStatus,
                        "cancellationConfirmed:",
                        verifyCancellationConfirmed,
                        "refundConfirmed:",
                        verifyRefundConfirmed
                    );
                    console.warn("âš ï¸ Full order data:", verifyOrder);
                    // Force update again to ensure status is cancelled and flags are set
                    await OrderSupabaseAdapter.updateOrder(orderId, {
                        status: "cancelled",
                        cancellationConfirmed: true,
                        cancellation_confirmed: true,
                        cancellationRequested: false,
                        cancellation_requested: false,
                        refundConfirmedAt: nowMs,
                        refund_confirmed_at: nowMs,
                        updatedAt: Date.now(),
                    });
                    console.log(
                        "âœ… Forced update applied to ensure order is properly cancelled"
                    );

                    // Verify again after forced update
                    await new Promise((resolve) => setTimeout(resolve, 500));
                    const verifyOrder2 = await OrderSupabaseAdapter.fetchOrderById(
                        orderId
                    );
                    console.log("ðŸ” Second verification after forced update:", {
                        orderId: orderId,
                        status: verifyOrder2?.status,
                        cancellationConfirmed: verifyOrder2?.cancellationConfirmed,
                        cancellation_confirmed: verifyOrder2?.cancellation_confirmed,
                        refundConfirmedAt: verifyOrder2?.refundConfirmedAt,
                        refund_confirmed_at: verifyOrder2?.refund_confirmed_at,
                    });
                } else {
                    console.log(
                        "âœ… Order verification passed - order is properly cancelled"
                    );
                }
            } catch (updateError) {
                console.error(
                    "âŒ Failed to save refund confirmation to Supabase:",
                    updateError
                );
                alert(
                    "Failed to save refund confirmation: " +
                    (updateError.message || updateError)
                );
                throw updateError; // Re-throw to prevent continuing with stock restoration
            }

            // Clear the order from cache so it reloads fresh from Supabase
            if (this._ordersCache && this._ordersCache[orderId]) {
                delete this._ordersCache[orderId];
            }

            // Also clear from any other potential caches
            if (window.OrderSupabaseAdapter && window.OrderSupabaseAdapter._cache) {
                delete window.OrderSupabaseAdapter._cache[orderId];
            }

            // Force a small delay to ensure database write has propagated
            await new Promise((resolve) => setTimeout(resolve, 500));

            // Restore stock based on order status when cancellation was requested
            // IMPORTANT: Order is fetched BEFORE status is updated to 'cancelled', so order.status has original status
            // For pending orders: When placed, available_quantity was decreased AND current_reserved was increased
            // So we need to: increase available_quantity (add back) AND decrease current_reserved
            try {
                const items = Array.isArray(order.items) ? order.items : [];
                const orderStatus = String(order.status || "").toLowerCase();
                const wasPending = orderStatus === "pending";
                const wasConfirmed = orderStatus === "confirmed";

                // Check if order had cancellation requested - this indicates it was likely pending
                const hadCancellationRequested =
                    order.cancellationRequested === true ||
                    order.cancellation_requested === true ||
                    order.cancellationRequested === 1 ||
                    order.cancellation_requested === 1;

                console.log(
                    `[Stock Restore] Order ${orderId}: status="${orderStatus}", wasPending=${wasPending}, wasConfirmed=${wasConfirmed}, hadCancellationRequested=${hadCancellationRequested}`
                );

                // For pending orders or orders with cancellation requested, ALWAYS restore reserved stock
                // This means: increase available_quantity AND decrease current_reserved
                let shouldRestoreReserved = wasPending || hadCancellationRequested;

                // Additional check: if status is unclear but there's reserved stock, treat as pending
                if (!shouldRestoreReserved && items.length > 0) {
                    console.log(
                        `[Stock Restore] Status unclear, checking reserved stock...`
                    );
                    for (const item of items) {
                        if (item && item.productId && item.quantity) {
                            try {
                                const testProduct = await ProductHelpers.getProduct(
                                    item.productId
                                );
                                const currentReserved =
                                    Number(testProduct.currentReserved || 0) || 0;
                                const itemQty = Number(item.quantity || 0) || 0;
                                console.log(
                                    `[Stock Restore] Product ${item.productId}: reserved=${currentReserved}, orderQty=${itemQty}`
                                );
                                if (currentReserved >= itemQty) {
                                    shouldRestoreReserved = true;
                                    console.log(
                                        `[Stock Restore] Found reserved stock >= order quantity, treating as pending order`
                                    );
                                    break;
                                }
                            } catch (err) {
                                console.warn(
                                    `[Stock Restore] Error checking product ${item.productId}:`,
                                    err
                                );
                            }
                        }
                    }
                }

                console.log(
                    `[Stock Restore] Final decision: shouldRestoreReserved=${shouldRestoreReserved}`
                );

                for (const it of items) {
                    const productId = it && it.productId ? it.productId : null;
                    const qty = it && it.quantity ? Number(it.quantity) : 0;
                    if (!productId || qty <= 0) {
                        console.warn(
                            `[Stock Restore] Skipping invalid item: productId=${productId}, qty=${qty}`
                        );
                        continue;
                    }

                    try {
                        const pVal = await ProductHelpers.getProduct(productId);
                        if (!pVal) {
                            console.warn(`[Stock Restore] Product ${productId} not found`);
                            continue;
                        }

                        const currentReserved = Number(pVal.currentReserved || 0) || 0;
                        const baseAvailable =
                            Number(pVal.availableQuantity ?? pVal.quantity ?? 0) || 0;

                        console.log(
                            `[Stock Restore] Product ${productId} BEFORE: available=${baseAvailable}, reserved=${currentReserved}, orderQty=${qty}`
                        );

                        if (shouldRestoreReserved) {
                            // Order was pending: increase available_quantity (add back) AND decrease current_reserved
                            const restoredReserved = Math.max(0, currentReserved - qty);
                            const restoredAvailable = baseAvailable + qty; // Add back to available quantity

                            console.log(
                                `[Stock Restore] Product ${productId}: Restoring reserved stock - available ${baseAvailable} -> ${restoredAvailable} (+${qty}), reserved ${currentReserved} -> ${restoredReserved} (-${qty})`
                            );

                            const updateResult = await ProductHelpers.updateProduct(
                                productId,
                                {
                                    availableQuantity: restoredAvailable,
                                    currentReserved: restoredReserved,
                                    updatedAt: Date.now(),
                                }
                            );

                            // Verify the update
                            await new Promise((resolve) => setTimeout(resolve, 200)); // Small delay for DB propagation
                            const verifyProduct = await ProductHelpers.getProduct(productId);
                            const verifyAvailable =
                                Number(
                                    verifyProduct?.availableQuantity ??
                                    verifyProduct?.quantity ??
                                    0
                                ) || 0;
                            const verifyReserved =
                                Number(verifyProduct?.currentReserved || 0) || 0;

                            console.log(
                                `[Stock Restore] Product ${productId} AFTER: available=${verifyAvailable}, reserved=${verifyReserved}`
                            );

                            if (
                                verifyAvailable === restoredAvailable &&
                                verifyReserved === restoredReserved
                            ) {
                                console.log(`âœ… Successfully restored stock for ${productId}`);
                            } else {
                                console.error(
                                    `âŒ Stock restore verification failed for ${productId}: expected available=${restoredAvailable}, reserved=${restoredReserved}, got available=${verifyAvailable}, reserved=${verifyReserved}`
                                );
                            }
                        } else if (wasConfirmed && !hadCancellationRequested) {
                            // Order was confirmed: restore availableQuantity (stock was deducted)
                            const restored = baseAvailable + qty;
                            await ProductHelpers.updateProduct(productId, {
                                availableQuantity: restored,
                                updatedAt: Date.now(),
                            });
                            console.log(
                                `Restored available stock for ${productId}: ${baseAvailable} -> ${restored} (qty: ${qty})`
                            );
                        } else {
                            console.warn(
                                `âš ï¸ Stock not restored for ${productId}: order status unclear (status: ${orderStatus}, wasPending: ${wasPending}, hadCancellationRequested: ${hadCancellationRequested}, shouldRestoreReserved: ${shouldRestoreReserved})`
                            );
                        }
                    } catch (itemError) {
                        console.error(
                            `âŒ Error restoring stock for product ${productId}:`,
                            itemError
                        );
                    }
                }
            } catch (e) {
                console.error("âŒ Stock restore on refund failed:", e);
                console.warn("Stock restore on refund failed or partial:", e);
            }

            // Show notification with view button (keep current view; do not remove cards here)
            this.showRefundConfirmationNotification();
            // Refresh lists so the order disappears from pending/confirmed without manual refresh
            try {
                if (this.loadPendingOrders) {
                    await this.loadPendingOrders();
                }
                if (this.loadConfirmedOrders) {
                    await this.loadConfirmedOrders();
                }
                if (this.loadAssignedOrders) {
                    await this.loadAssignedOrders(); // refresh confirmed tab containers
                }
                if (this.loadCancelledOrders) {
                    await this.loadCancelledOrders();
                }
            } catch (refreshErr) {
                console.warn("âš ï¸ Refresh after cancelled refund failed:", refreshErr);
            }
            return;

            // Immediately remove the order card from DOM for instant feedback (works for both pending and confirmed tabs)
            try {
                // Try to find and remove from pending tab
                const toggleEl = document.getElementById(`toggle-icon-${orderId}`);
                const card = toggleEl ? toggleEl.closest(".order-card") : null;
                if (card && card.parentElement) {
                    const wrapper = card.parentElement;
                    // Check if parent is the wrapper div (for assigned orders) or direct parent
                    if (
                        wrapper.classList &&
                        wrapper.classList.contains("order-card-wrapper")
                    ) {
                        wrapper.remove();
                    } else {
                        card.remove();
                    }
                }

                // Also try to remove from assigned orders (confirmed tab) if it exists there
                const assignedToggleEl = document.querySelector(
                    `[id*="toggle-icon-${orderId}"]`
                );
                if (assignedToggleEl) {
                    const assignedCard = assignedToggleEl.closest(".order-card");
                    if (assignedCard && assignedCard.parentElement) {
                        const assignedWrapper = assignedCard.parentElement;
                        if (
                            assignedWrapper.classList &&
                            assignedWrapper.classList.contains("order-card-wrapper")
                        ) {
                            assignedWrapper.remove();
                        } else {
                            assignedCard.remove();
                        }
                    }
                }
            } catch (_) { }

            // Refresh pending orders list (to remove from pending tab)
            // Use setTimeout to ensure order update has completed in Supabase first
            setTimeout(() => {
                this.loadPendingOrders && this.loadPendingOrders();
                this.loadStats && this.loadStats();
            }, 300);

            // DO NOT call loadAssignedOrders() - it would reload the confirmed tab
            // The cancelled order should NOT appear in confirmed tab
            // Explicitly ensure the order is removed from confirmed tab display if it was there

            // Navigate to Cancelled tab and force-load cancelled list
            try {
                // Switch to Orders module first (where cancelled tab is)
                if (typeof switchToSection === "function") {
                    switchToSection("orders");
                } else if (this.switchSection) {
                    this.switchSection("orders");
                }
                // Immediately activate cancelled tab in Orders module
                if (this.switchOrderManagementTab) {
                    this.switchOrderManagementTab("cancelled-orders");
                }
                // Force a reload to reflect the newly cancelled order (with delay to ensure Supabase has updated)
                setTimeout(() => {
                    try {
                        this.loadCancelledOrders && this.loadCancelledOrders();
                    } catch (err) {
                        console.error("Error loading cancelled orders:", err);
                    }
                }, 800); // Increased delay to ensure Supabase has time to reflect changes and prevent showing in confirmed tab
            } catch (err) {
                console.error("Error navigating to cancelled tab:", err);
            }
        } catch (error) {
            console.error("Error confirming cancelled refund:", error);
            alert("Error confirming refund: " + error.message);
        }
    }

    async confirmCancelledNoRefund(orderId) {
        try {
            const reason = prompt(
                "Provide a reason why the refund is denied (e.g., payment not received):"
            );
            if (!reason || reason.trim() === "") {
                alert("Please provide a reason to proceed without refund.");
                return;
            }

            // Read order from Supabase first, fallback to Firebase if needed
            const order = await OrderSupabaseAdapter.fetchOrderById(orderId);
            let firebaseOrder = null;
            if (!order || !order.id) {
                // Fallback to Firebase if Supabase doesn't have the order
                const orderRef = dbRefs.orders.child(orderId);
                const orderSnap = await orderRef.once("value");
                firebaseOrder = orderSnap.val();
                if (!firebaseOrder) {
                    alert("Order not found");
                    return;
                }
            }

            const orderForStock = order || firebaseOrder;

            const staffUid =
                sessionStorage.getItem("staffUid") ||
                sessionStorage.getItem("adminUid") ||
                "staff";
            const staffFullName =
                sessionStorage.getItem("staffName") ||
                sessionStorage.getItem("adminName") ||
                null;
            let staffRole = null;

            // Get role from sessionStorage
            const userRole = sessionStorage.getItem("userRole");
            if (userRole === "admin") {
                staffRole = "System Administrator";
            } else if (userRole === "staff") {
                staffRole = "Staff Member";
            } else if (sessionStorage.getItem("adminUid")) {
                staffRole = "System Administrator";
            } else if (sessionStorage.getItem("staffUid")) {
                staffRole = "Staff Member";
            }

            const nowMs = Date.now();

            // Save to Supabase - NO FIREBASE FALLBACK
            // Note: Only use camelCase keys - fieldMapping will convert to snake_case automatically
            const supabaseUpdates = {
                status: "cancelled",
                cancellationConfirmed: true, // cancellation confirmed, but no refund - will be converted to cancellation_confirmed
                cancellationConfirmedAt: nowMs,
                cancellationRequested: false, // no longer a request - will be converted to cancellation_requested
                refundDenied: true, // will be converted to refund_denied
                refundDeniedReason: reason.trim(), // will be converted to refund_denied_reason
                refundDeniedAt: nowMs, // will be converted to refund_denied_at
                refundDeniedBy: staffUid, // will be converted to refund_denied_by
                updatedAt: nowMs,
            };
            if (staffFullName) {
                supabaseUpdates.refundDeniedByName = staffFullName;
                supabaseUpdates.cancellation_confirmed_by_name = staffFullName;
            }
            if (staffRole) {
                supabaseUpdates.cancellation_confirmed_by_role = staffRole;
            }

            // Save to Supabase - NO FIREBASE FALLBACK
            try {
                await OrderSupabaseAdapter.updateOrder(orderId, supabaseUpdates);
                console.log(
                    "âœ… Cancellation without refund saved to Supabase for order:",
                    orderId
                );
                console.log(
                    'âœ… Order status set to "cancelled" - should NOT appear in confirmed tab'
                );

                // Double-check the update was successful - verify status is 'cancelled' AND cancellationConfirmed is true
                const verifyOrder = await OrderSupabaseAdapter.fetchOrderById(orderId);
                const verifyStatus = String(verifyOrder?.status || "").toLowerCase();
                const verifyCancellationConfirmed =
                    verifyOrder?.cancellationConfirmed === true ||
                    verifyOrder?.cancellation_confirmed === true;
                const verifyRefundDenied =
                    verifyOrder?.refundDenied === true ||
                    verifyOrder?.refund_denied === true;

                if (
                    verifyOrder &&
                    (verifyStatus !== "cancelled" ||
                        !verifyCancellationConfirmed ||
                        !verifyRefundDenied)
                ) {
                    console.warn(
                        "âš ï¸ Order verification failed - status:",
                        verifyStatus,
                        "cancellationConfirmed:",
                        verifyCancellationConfirmed,
                        "refundDenied:",
                        verifyRefundDenied
                    );
                    // Force update again to ensure status is cancelled and flags are set
                    await OrderSupabaseAdapter.updateOrder(orderId, {
                        status: "cancelled",
                        cancellationConfirmed: true,
                        cancellation_confirmed: true,
                        cancellationRequested: false,
                        cancellation_requested: false,
                        refundDenied: true,
                        refund_denied: true,
                        updatedAt: Date.now(),
                    });
                    console.log(
                        "âœ… Forced update applied to ensure order is properly cancelled"
                    );
                } else {
                    console.log(
                        "âœ… Order verification passed - order is properly cancelled"
                    );
                }
            } catch (updateError) {
                console.error(
                    "âŒ Failed to save cancellation without refund to Supabase:",
                    updateError
                );
                alert(
                    "Failed to save cancellation: " + (updateError.message || updateError)
                );
                throw updateError;
            }

            // Clear the order from cache so it reloads fresh from Supabase
            if (this._ordersCache && this._ordersCache[orderId]) {
                delete this._ordersCache[orderId];
            }

            // Also clear from any other potential caches
            if (window.OrderSupabaseAdapter && window.OrderSupabaseAdapter._cache) {
                delete window.OrderSupabaseAdapter._cache[orderId];
            }

            // Force a small delay to ensure database write has propagated
            await new Promise((resolve) => setTimeout(resolve, 500));

            // Restore stock based on order status when cancellation was requested
            // IMPORTANT: Order is fetched BEFORE status is updated to 'cancelled', so orderForStock.status has original status
            // For pending orders: When placed, available_quantity was decreased AND current_reserved was increased
            // So we need to: increase available_quantity (add back) AND decrease current_reserved
            try {
                const items = Array.isArray(orderForStock.items)
                    ? orderForStock.items
                    : [];
                const orderStatus = String(orderForStock.status || "").toLowerCase();
                const wasPending = orderStatus === "pending";
                const wasConfirmed = orderStatus === "confirmed";

                // Check if order had cancellation requested - this indicates it was likely pending
                const hadCancellationRequested =
                    orderForStock.cancellationRequested === true ||
                    orderForStock.cancellation_requested === true ||
                    orderForStock.cancellationRequested === 1 ||
                    orderForStock.cancellation_requested === 1;

                console.log(
                    `[Stock Restore] Order ${orderId}: status="${orderStatus}", wasPending=${wasPending}, wasConfirmed=${wasConfirmed}, hadCancellationRequested=${hadCancellationRequested}`
                );

                // For pending orders or orders with cancellation requested, ALWAYS restore reserved stock
                // This means: increase available_quantity AND decrease current_reserved
                let shouldRestoreReserved = wasPending || hadCancellationRequested;

                // Additional check: if status is unclear but there's reserved stock, treat as pending
                if (!shouldRestoreReserved && items.length > 0) {
                    console.log(
                        `[Stock Restore] Status unclear, checking reserved stock...`
                    );
                    for (const item of items) {
                        if (item && item.productId && item.quantity) {
                            try {
                                const testProduct = await ProductHelpers.getProduct(
                                    item.productId
                                );
                                const currentReserved =
                                    Number(testProduct.currentReserved || 0) || 0;
                                const itemQty = Number(item.quantity || 0) || 0;
                                console.log(
                                    `[Stock Restore] Product ${item.productId}: reserved=${currentReserved}, orderQty=${itemQty}`
                                );
                                if (currentReserved >= itemQty) {
                                    shouldRestoreReserved = true;
                                    console.log(
                                        `[Stock Restore] Found reserved stock >= order quantity, treating as pending order`
                                    );
                                    break;
                                }
                            } catch (err) {
                                console.warn(
                                    `[Stock Restore] Error checking product ${item.productId}:`,
                                    err
                                );
                            }
                        }
                    }
                }

                console.log(
                    `[Stock Restore] Final decision: shouldRestoreReserved=${shouldRestoreReserved}`
                );

                for (const it of items) {
                    const productId = it && it.productId ? it.productId : null;
                    const qty = it && it.quantity ? Number(it.quantity) : 0;
                    if (!productId || qty <= 0) {
                        console.warn(
                            `[Stock Restore] Skipping invalid item: productId=${productId}, qty=${qty}`
                        );
                        continue;
                    }

                    try {
                        const pVal = await ProductHelpers.getProduct(productId);
                        if (!pVal) {
                            console.warn(`[Stock Restore] Product ${productId} not found`);
                            continue;
                        }

                        const currentReserved = Number(pVal.currentReserved || 0) || 0;
                        const baseAvailable =
                            Number(pVal.availableQuantity ?? pVal.quantity ?? 0) || 0;

                        console.log(
                            `[Stock Restore] Product ${productId} BEFORE: available=${baseAvailable}, reserved=${currentReserved}, orderQty=${qty}`
                        );

                        if (shouldRestoreReserved) {
                            // Order was pending: increase available_quantity (add back) AND decrease current_reserved
                            const restoredReserved = Math.max(0, currentReserved - qty);
                            const restoredAvailable = baseAvailable + qty; // Add back to available quantity

                            console.log(
                                `[Stock Restore] Product ${productId}: Restoring reserved stock - available ${baseAvailable} -> ${restoredAvailable} (+${qty}), reserved ${currentReserved} -> ${restoredReserved} (-${qty})`
                            );

                            const updateResult = await ProductHelpers.updateProduct(
                                productId,
                                {
                                    availableQuantity: restoredAvailable,
                                    currentReserved: restoredReserved,
                                    updatedAt: Date.now(),
                                }
                            );

                            // Verify the update
                            await new Promise((resolve) => setTimeout(resolve, 200)); // Small delay for DB propagation
                            const verifyProduct = await ProductHelpers.getProduct(productId);
                            const verifyAvailable =
                                Number(
                                    verifyProduct?.availableQuantity ??
                                    verifyProduct?.quantity ??
                                    0
                                ) || 0;
                            const verifyReserved =
                                Number(verifyProduct?.currentReserved || 0) || 0;

                            console.log(
                                `[Stock Restore] Product ${productId} AFTER: available=${verifyAvailable}, reserved=${verifyReserved}`
                            );

                            if (
                                verifyAvailable === restoredAvailable &&
                                verifyReserved === restoredReserved
                            ) {
                                console.log(`âœ… Successfully restored stock for ${productId}`);
                            } else {
                                console.error(
                                    `âŒ Stock restore verification failed for ${productId}: expected available=${restoredAvailable}, reserved=${restoredReserved}, got available=${verifyAvailable}, reserved=${verifyReserved}`
                                );
                            }
                        } else if (wasConfirmed && !hadCancellationRequested) {
                            // Order was confirmed: restore availableQuantity (stock was deducted)
                            const restored = baseAvailable + qty;
                            await ProductHelpers.updateProduct(productId, {
                                availableQuantity: restored,
                                updatedAt: Date.now(),
                            });
                            console.log(
                                `Restored available stock for ${productId}: ${baseAvailable} -> ${restored} (qty: ${qty})`
                            );
                        } else {
                            console.warn(
                                `âš ï¸ Stock not restored for ${productId}: order status unclear (status: ${orderStatus}, wasPending: ${wasPending}, hadCancellationRequested: ${hadCancellationRequested}, shouldRestoreReserved: ${shouldRestoreReserved})`
                            );
                        }
                    } catch (itemError) {
                        console.error(
                            `âŒ Error restoring stock for product ${productId}:`,
                            itemError
                        );
                    }
                }
            } catch (e) {
                console.error(
                    "âŒ Stock restore on cancellation without refund failed:",
                    e
                );
                console.warn(
                    "Stock restore on cancellation without refund failed or partial:",
                    e
                );
            }

            // Notify the customer
            await this.sendNoRefundCancellationNotification(orderId, reason.trim());

            this.showSuccessMessage("Cancellation confirmed without refund");

            // Refresh lists so the order disappears from pending/confirmed without blanking the UI
            try {
                if (this.loadPendingOrders) {
                    await this.loadPendingOrders();
                }
                if (this.loadConfirmedOrders) {
                    await this.loadConfirmedOrders();
                }
                if (this.loadAssignedOrders) {
                    await this.loadAssignedOrders(); // refresh confirmed tab containers
                }
                if (this.loadCancelledOrders) {
                    await this.loadCancelledOrders();
                }
                if (this.loadProducts) {
                    await this.loadProducts();
                }
                if (this.loadStats) {
                    await this.loadStats();
                }
            } catch (refreshErr) {
                console.warn("âš ï¸ Refresh after cancellation without refund failed:", refreshErr);
            }
        } catch (error) {
            console.error("Error confirming cancellation without refund:", error);
            alert("Error: " + (error && error.message ? error.message : error));
        }
    }

    async sendNoRefundCancellationNotification(orderId, reason) {
        try {
            const orderSnapshot = await dbRefs.orders.child(orderId).once("value");
            const order = orderSnapshot.val();
            if (order && order.customerId) {
                // Use sendCustomerNotification to send to Supabase
                await this.sendCustomerNotification(order.customerId, {
                    id: FirebaseUtils.generateId(),
                    title: "Cancellation Confirmed (No Refund)",
                    message: `Your order #${orderId
                        .substr(-8)
                        .toUpperCase()} was cancelled. Refund was not issued. Reason: ${reason}`,
                    type: "order_update",
                    orderId: orderId,
                    timestamp: Date.now(),
                    isRead: false,
                });
            }
        } catch (error) {
            console.error(
                "Error sending no-refund cancellation notification:",
                error
            );
        }
    }

    showRefundConfirmationNotification() {
        // Create notification element
        const notification = document.createElement("div");
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #4CAF50;
            color: white;
            padding: 16px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000;
            max-width: 400px;
            font-family: Arial, sans-serif;
        `;

        notification.innerHTML = `
            <div style="display: flex; align-items: center; gap: 12px;">
                <i class="fas fa-check-circle" style="font-size: 20px;"></i>
                <div style="flex: 1;">
                    <div style="font-weight: 600; margin-bottom: 4px;">Order cancellation confirmed</div>
                    <div style="font-size: 14px; opacity: 0.9;">Record has been moved to the cancelled tabs.</div>
                </div>
                <button onclick="staffManager.viewCancelledOrders()" style="
                    background: rgba(255,255,255,0.2);
                    border: 1px solid rgba(255,255,255,0.3);
                    color: white;
                    padding: 6px 12px;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 12px;
                    font-weight: 500;
                ">View</button>
                <button onclick="this.parentElement.parentElement.remove()" style="
                    background: none;
                    border: none;
                    color: white;
                    cursor: pointer;
                    padding: 4px;
                    opacity: 0.7;
                ">Ã—</button>
            </div>
        `;

        document.body.appendChild(notification);

        // Auto-remove after 8 seconds
        setTimeout(() => {
            if (notification.parentElement) {
                notification.remove();
            }
        }, 8000);
    }
    viewCancelledOrders() {
        // Switch to the orders module and then to cancelled tab
        try {
            this.switchOrderManagementTab("cancelled-orders");
        } catch (_) {
            // fallback: ensure section is visible then switch tab
            try {
                this.switchToSection && this.switchToSection("order-management");
            } catch (_) { }
            setTimeout(() => {
                try {
                    this.switchOrderManagementTab &&
                        this.switchOrderManagementTab("cancelled-orders");
                } catch (_) { }
            }, 100);
        }
    }
    async markOutForDelivery(orderId) {
        try {
            // Get order details first to get customer information
            const orderSnapshot = await dbRefs.orders.child(orderId).once("value");
            const order = orderSnapshot.val();

            if (!order) {
                throw new Error("Order not found");
            }

            // Check if QR code exists for this order
            const qrCode = await this.fetchSupabaseQrRecord(orderId);

            if (!qrCode) {
                const orderCode = orderId.substr(-8).toUpperCase();
                alert(
                    `QR code must be generated first before marking order for delivery.\n\nOrder Code: ${orderCode}\n\nPlease generate a QR code for this order.`
                );
                return;
            }

            // Show rider selection modal for single order
            await this.showRiderSelectionModal([orderId]);
        } catch (error) {
            console.error("Error marking out for delivery:", error);
            alert("Error updating order: " + error.message);
        }
    }

    // QR Code Modal for order packaging
    async openQrModal(orderId) {
        try {
            console.log("Opening QR modal for order:", orderId);

            // Remove any existing QR modal first
            const existingModal = document.querySelector(
                ".modal-overlay[data-qr-modal]"
            );
            if (existingModal) {
                existingModal.remove();
            }

            const container = document.createElement("div");
            container.className = "modal-overlay show";
            container.setAttribute("data-qr-modal", "true");
            container.style.cssText =
                "position:fixed;inset:0;background:rgba(0,0,0,0.4);display:flex;align-items:center;justify-content:center;z-index:10000;opacity:1;visibility:visible;";

            // Fetch order data from cache dom if available, else minimal fetch
            const detailsEl = document.getElementById(`order-details-${orderId}`);
            const orderTitle = `Order #${orderId.substr(-8).toUpperCase()}`;
            const orderSummaryHtml = detailsEl
                ? detailsEl.querySelector(".order-items")?.outerHTML || ""
                : "";

            container.innerHTML = `
                <div class="modal" style="background:#fff;border-radius:12px;max-width:820px;width:100%;box-shadow:0 10px 30px rgba(0,0,0,.15);">
                    <div style="padding:16px 20px;border-bottom:1px solid #eee;display:flex;align-items:center;justify-content:space-between;">
                        <div style="font-weight:700;">Generate Packaging QR â€¢ ${orderTitle}</div>
                        <button onclick="this.closest('.modal-overlay').remove()" style="background:none;border:none;font-size:20px;cursor:pointer;">Ã—</button>
                    </div>
                    <div style="padding:16px 20px;max-height:70vh;overflow:auto;">
                        <div id="qr-order-info" style="margin-bottom:12px;"></div>
                        ${orderSummaryHtml}
                        <div style="margin-top:12px;">
                            <strong>Farmer Contributions</strong>
                            <div id="qr-farmer-rows" data-order-id="${orderId}" style="margin-top:8px;display:flex;flex-direction:column;gap:8px;"></div>
                            <div id="qr-alloc-summary" style="margin-top:8px;font-size:12px;color:#555;"></div>
                            <button class="secondary-btn" style="margin-top:8px;" onclick="staffManager.addFarmerContributionRow()"><i class="fas fa-plus"></i> Add Contribution</button>
                        </div>
                        <div style="margin-top:16px;">
                            <button id="qr-generate-action-${orderId}" class="confirm-btn" onclick="staffManager.generateOrderQr('${orderId}')"><i class="fas fa-qrcode"></i> Generate</button>
                        </div>
                        
                        <div id="qr-preview" style="margin-top:16px;display:none;">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
                                <strong>QR Packaging Preview</strong>
                            </div>
                            <div id="qr-packaging-card" style="border-radius:12px;overflow:hidden;border:1px solid #e0e0e0;box-shadow:0 4px 12px rgba(0,0,0,0.06);background-color:#f5f5f5;font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;max-width:780px;margin:0 auto;">
                                <!-- Header with logos and branding -->
                                <div style="background:linear-gradient(135deg,#315E26 0%,#4A7C3A 100%);padding:20px 24px;text-align:center;color:#FFFEF9;">
                                    <div style="display:flex;justify-content:center;align-items:center;gap:16px;margin-bottom:12px;">
                                        <div style="width:72px;height:72px;border-radius:50%;background-color:#FFFEF9;padding:4px;box-shadow:0 4px 12px rgba(0,0,0,0.18);display:flex;align-items:center;justify-content:center;">
                                            <img src="https://afkwexvvuxwbpioqnelp.supabase.co/storage/v1/object/public/email_assets/agricart_logo.png" alt="AgriCart Logo" style="max-width:64px;max-height:64px;object-fit:contain;border-radius:50%;" />
                                        </div>
                                        <div style="width:72px;height:72px;border-radius:50%;background-color:#FFFEF9;padding:4px;box-shadow:0 4px 12px rgba(0,0,0,0.18);display:flex;align-items:center;justify-content:center;">
                                            <img src="https://afkwexvvuxwbpioqnelp.supabase.co/storage/v1/object/public/email_assets/calcoa_logo.png" alt="CALCOA Logo" style="max-width:64px;max-height:64px;object-fit:contain;border-radius:50%;" />
                                        </div>
                                    </div>
                                    <div style="font-size:24px;font-weight:700;letter-spacing:0.5px;">AgriCart</div>
                                    <div style="font-size:14px;margin-top:4px;opacity:0.95;">
                                        Cabintan Livelihood Community Agriculture â€“ Cooperative (CALCOA)
                                    </div>
                                </div>

                                <!-- Body content -->
                                <div style="background-color:#ffffff;padding:20px 24px 24px 24px;font-size:14px;color:#333333;line-height:1.6;">
                                    <div style="border-bottom:1px solid #e0e0e0;padding-bottom:8px;margin-bottom:8px;font-weight:600;">To:</div>
                                    <div style="margin-bottom:12px;">
                                        <div style="font-weight:600;" id="qr-to-name">Customer Name</div>
                                        <div style="margin-top:2px;">Phone: <span id="qr-to-phone">N/A</span></div>
                                        <div style="margin-top:2px;"><span id="qr-address-label">Delivery Address:</span></div>
                                        <div id="qr-to-address" style="margin-top:2px;white-space:pre-line;"></div>
                                    </div>

                                    <div style="border-bottom:1px solid #e0e0e0;padding-bottom:8px;margin-bottom:8px;font-weight:600;">From:</div>
                                    <div style="margin-bottom:12px;">
                                        <div>CALCOA: Purok 3, Brgy. Cabintan, Ormoc City, Leyte</div>
                                        <div style="margin-top:2px;">Phone Number: <span id="qr-from-phone">+63 123 456 7890</span></div>
                                        <div style="margin-top:2px;">Email: <span id="qr-from-email">calcoacoop@gmail.com</span></div>
                                    </div>

                                    <div style="border-bottom:1px solid #e0e0e0;padding-bottom:8px;margin-bottom:8px;font-weight:600;">Total Amount:</div>
                                    <div style="margin-bottom:12px;">
                                        <div>â‚±<span id="qr-order-total">0.00</span></div>
                                    </div>

                                    <div style="border-bottom:1px solid #e0e0e0;padding-bottom:8px;margin-bottom:8px;font-weight:600;">Order Details</div>
                                    <div style="margin-bottom:12px;">
                                        <div>Order Code: <span id="qr-order-code">${orderId
                    .toString()
                    .toUpperCase()
                    .slice(-8)}</span></div>
                                        <div style="margin-top:2px;">Order Date: <span id="qr-order-date">â€”</span></div>
                                        <div style="margin-top:2px;">Generated At: <span id="qr-generated-at">â€”</span></div>
                                    </div>

                                    <div style="margin-top:16px;text-align:center;">
                                        <div id="qr-header" style="font-weight:700;font-size:18px;margin-bottom:8px;"></div>
                                        <div style="display:inline-block;padding:8px;border-radius:10px;border:1px solid #e0e0e0;background:#fafafa;">
                                            <img id="qr-image" alt="QR Code" style="max-width:260px;border-radius:6px;display:block;" />
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div style="margin-top:12px; display:flex; gap:8px; flex-wrap:wrap;">
                                <button id="save-qr-button-${orderId}" class="confirm-btn" onclick="staffManager.saveQrToDatabase('${orderId}')"><i class="fas fa-save"></i> Save Packaging</button>
                            </div>
                        </div>
                        
                        <!-- Saved QR List -->
                        <div id="saved-qr-list" style="margin-top:16px;display:none;">
                            <strong>Saved QR Codes</strong>
                            <div id="saved-qr-items" style="margin-top:8px;"></div>
                        </div>
                    </div>
                    <div style="padding:12px 20px;border-top:1px solid #eee;display:flex;justify-content:flex-end;gap:8px;">
                        <button class="secondary-btn" onclick="this.closest('.modal-overlay').remove()">Close</button>
                    </div>
                </div>
            `;

            document.body.appendChild(container);
            console.log("QR modal container appended to body");

            // Ensure modal is visible
            setTimeout(() => {
                container.classList.add("show");
                container.style.opacity = "1";
                container.style.visibility = "visible";
                container.style.display = "flex";
                console.log("QR modal should now be visible");
            }, 10);

            // Seed a single row by default
            await this.addFarmerContributionRow();

            // Load full order details for display (SUPABASE ONLY - NO FIREBASE)
            try {
                let order = null;

                if (
                    window.OrderSupabaseAdapter &&
                    typeof window.OrderSupabaseAdapter.fetchOrderById === "function"
                ) {
                    order = await window.OrderSupabaseAdapter.fetchOrderById(orderId);
                    console.log(
                        "âœ… Loaded order details from Supabase for QR modal:",
                        orderId
                    );
                } else {
                    console.error("âŒ OrderSupabaseAdapter not available");
                }

                if (order) {
                    const totalRaw =
                        order.totalAmount != null ? order.totalAmount : order.total;
                    const totalNum =
                        typeof totalRaw === "number"
                            ? totalRaw
                            : parseFloat(totalRaw || "0") || 0;
                    const totalDisplay = `â‚±${totalNum.toLocaleString()}`;
                    const createdAtDate = order.createdAt
                        ? new Date(order.createdAt)
                        : null;
                    const createdAt = createdAtDate
                        ? createdAtDate.toLocaleString()
                        : "Unknown";
                    const customerName = order.customerName || "Unknown";
                    const customerPhone =
                        order.customerPhone ||
                        order.contactNumber ||
                        order.phone ||
                        "N/A";
                    const paymentMethod = (order.paymentMethod || "N/A")
                        .toString()
                        .toUpperCase();

                    // Check if order is pickup - if so, use pickup area instead of delivery address
                    const deliveryOption = String(
                        order.deliveryOption || order.delivery_option || ""
                    ).toLowerCase();

                    let customerAddress = "";
                    if (deliveryOption === "pickup") {
                        // Build pickup address from structured fields
                        const pickupParts = [];
                        if (order.pickupName || order.pickup_name) {
                            pickupParts.push(order.pickupName || order.pickup_name);
                        }
                        if (order.pickupStreet || order.pickup_street) {
                            pickupParts.push(order.pickupStreet || order.pickup_street);
                        }
                        if (order.pickupSitio || order.pickup_sitio) {
                            pickupParts.push(order.pickupSitio || order.pickup_sitio);
                        }
                        if (order.pickupBarangay || order.pickup_barangay) {
                            pickupParts.push(order.pickupBarangay || order.pickup_barangay);
                        }
                        if (order.pickupCity || order.pickup_city) {
                            pickupParts.push(order.pickupCity || order.pickup_city);
                        }
                        if (order.pickupProvince || order.pickup_province) {
                            pickupParts.push(order.pickupProvince || order.pickup_province);
                        }
                        if (order.pickupLandmark || order.pickup_landmark) {
                            pickupParts.push(`Landmark: ${order.pickupLandmark || order.pickup_landmark}`);
                        }

                        // Fallback to pickupAddress if structured fields not available
                        customerAddress = pickupParts.length > 0
                            ? pickupParts.join(", ")
                            : order.pickupAddress || order.pickup_address || "Pickup Location";
                    } else {
                        // Delivery order - use delivery address
                        customerAddress =
                            order.deliveryAddress || order.customerAddress || "Unknown";
                    }

                    const infoEl = container.querySelector("#qr-order-info");
                    if (infoEl) {
                        infoEl.innerHTML = ``;
                    }

                    // Populate packaging template fields
                    const toNameEl = container.querySelector("#qr-to-name");
                    const toPhoneEl = container.querySelector("#qr-to-phone");
                    const toAddressEl = container.querySelector("#qr-to-address");
                    const addressLabelEl = container.querySelector("#qr-address-label");
                    const orderCodeEl = container.querySelector("#qr-order-code");
                    const orderDateEl = container.querySelector("#qr-order-date");

                    if (toNameEl) toNameEl.textContent = customerName;
                    if (toPhoneEl) toPhoneEl.textContent = customerPhone;
                    if (toAddressEl) toAddressEl.textContent = customerAddress;
                    // Update address label based on delivery option
                    if (addressLabelEl) {
                        addressLabelEl.textContent = deliveryOption === "pickup"
                            ? "Pickup Area:"
                            : "Delivery Address:";
                    }
                    if (orderCodeEl)
                        orderCodeEl.textContent = orderId
                            .toString()
                            .toUpperCase()
                            .slice(-8);
                    if (orderDateEl) orderDateEl.textContent = createdAt;

                    // Set total amount in preview
                    const orderTotalEl = container.querySelector("#qr-order-total");
                    if (orderTotalEl) {
                        orderTotalEl.textContent = totalNum.toFixed(2);
                    }

                    // Load "From" contact details from system_data.contactSupport
                    try {
                        await this._loadContactSupportSettingsForQr();
                    } catch (contactErr) {
                        console.warn(
                            "Failed to load contact support settings for QR packaging:",
                            contactErr
                        );
                    }
                }
            } catch (e) {
                console.error(
                    "âŒ Failed to load order details from Supabase for QR modal:",
                    e
                );
            }

            // Add click handler to close modal when clicking outside
            container.addEventListener("click", function (e) {
                if (e.target === container) {
                    container.remove();
                }
            });

            // Run initial validation after modal is set up
            setTimeout(() => {
                this.recomputeContributionAllocation();
            }, 500);

            console.log("QR modal fully initialized for order:", orderId);
        } catch (e) {
            console.error("openQrModal error:", e);
            alert("Error opening QR modal: " + (e.message || "Unknown error"));
        }
    }

    async addFarmerContributionRow(existingContrib = null) {
        const list = document.getElementById("qr-farmer-rows");
        if (!list) return;
        const rowId =
            "qr-row-" + Date.now() + "-" + Math.floor(Math.random() * 1000);
        const row = document.createElement("div");
        row.id = rowId;
        row.style.cssText =
            "display:flex;gap:8px;align-items:center;flex-wrap:wrap;";

        // Build farmer dropdown options from Supabase farmers table
        let optionsHtml = '<option value="">Select Farmer</option>';
        try {
            // Get Supabase client
            let supabase = null;
            if (typeof window.getSupabaseClient === "function") {
                supabase = window.getSupabaseClient();
            } else if (window.supabaseClient) {
                supabase = window.supabaseClient;
            } else if (typeof window.supabase !== "undefined") {
                const SUPABASE_URL = "https://afkwexvvuxwbpioqnelp.supabase.co";
                const SUPABASE_ANON_KEY =
                    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFma3dleHZ2dXh3YnBpb3FuZWxwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI5MzA3MjcsImV4cCI6MjA3ODUwNjcyN30.7r5j1xfWdJwiRZZm8AcOIaBp9VaXoD2QWE3WrGYZNyM";
                supabase = window.supabase.createClient(
                    SUPABASE_URL,
                    SUPABASE_ANON_KEY
                );
                window.supabaseClient = supabase;
            }

            if (supabase) {
                const { data: farmers, error } = await supabase
                    .from("farmers")
                    .select("uid, full_name")
                    .order("full_name", { ascending: true });

                if (!error && farmers) {
                    farmers.forEach((farmer) => {
                        optionsHtml += `<option value="${farmer.uid}">${farmer.full_name || farmer.uid
                            }</option>`;
                    });
                }
            }
        } catch (e) {
            console.warn("Failed to load farmers list:", e);
        }

        // Build product dropdown options from THIS ORDER's items only
        let productOptionsHtml = '<option value="">Select Product</option>';
        try {
            const listEl = document.getElementById("qr-farmer-rows");
            const thisOrderId = listEl ? listEl.getAttribute("data-order-id") : "";

            if (thisOrderId) {
                // Fetch order data from Supabase to get items array (NO FIREBASE FALLBACK)
                let order = null;

                if (
                    window.OrderSupabaseAdapter &&
                    typeof window.OrderSupabaseAdapter.fetchOrderById === "function"
                ) {
                    try {
                        order = await window.OrderSupabaseAdapter.fetchOrderById(
                            thisOrderId
                        );
                        console.log(
                            "âœ… Fetched order from Supabase for QR modal:",
                            thisOrderId,
                            order
                        );
                    } catch (supabaseErr) {
                        console.error(
                            "âŒ Failed to fetch order from Supabase:",
                            supabaseErr
                        );
                        throw new Error(
                            "Failed to fetch order from Supabase: " +
                            (supabaseErr.message || supabaseErr)
                        );
                    }
                } else {
                    console.error("âŒ OrderSupabaseAdapter not available");
                    throw new Error("OrderSupabaseAdapter not available");
                }

                // Extract product names from order items
                if (order && order.items) {
                    const items = Array.isArray(order.items) ? order.items : [];
                    const productNames = new Set();

                    items.forEach((item) => {
                        // Handle different item structures (productName, product_name, name)
                        const productName =
                            item.productName || item.product_name || item.name || "";
                        if (productName && productName.trim()) {
                            productNames.add(productName.trim());
                        }
                    });

                    const sorted = Array.from(productNames).sort((a, b) =>
                        a.localeCompare(b)
                    );
                    productOptionsHtml += sorted
                        .map((name) => `<option value="${name}">${name}</option>`)
                        .join("");

                    console.log(
                        `âœ… Populated ${sorted.length} products from order items for QR modal`
                    );
                } else {
                    console.warn(
                        "âš ï¸ Order has no items array or order not found:",
                        thisOrderId
                    );
                }
            }
        } catch (e) {
            console.warn("Failed to build order-specific product options:", e);
        }

        row.innerHTML = `
            <select class="input qr-farmer" style="flex:1;min-width:200px;">${optionsHtml}</select>
            <select class="input qr-product" style="flex:2;min-width:200px;">${productOptionsHtml}</select>
            <input type="number" placeholder="Quantity (kg)" class="input qr-qty" style="width:140px;" step="0.01" min="0" />
            <button class="danger-btn" title="Remove" onclick="this.parentElement.remove(); staffManager.recomputeContributionAllocation().catch(err => console.error('Validation error:', err))">Remove</button>
        `;
        list.appendChild(row);

        // If loading existing contribution, populate the fields
        if (existingContrib) {
            const selects = row.querySelectorAll("select");
            const inputs = row.querySelectorAll("input");

            // Set farmer
            const farmerSelect = selects[0];
            if (farmerSelect) {
                farmerSelect.value = existingContrib.farmerId;
            }

            // Set product
            const productSelect = selects[1];
            if (productSelect) {
                productSelect.value = existingContrib.productId;
            }

            // Set quantity
            const quantityInput = inputs[0];
            if (quantityInput) {
                quantityInput.value = existingContrib.quantity;
            }
        }

        // Bind change handlers for validation (async function)
        const productSelect = row.querySelector(".qr-product");
        const qtyInput = row.querySelector(".qr-qty");
        if (productSelect)
            productSelect.addEventListener("change", () => {
                this.recomputeContributionAllocation().catch((err) =>
                    console.error("Validation error:", err)
                );
            });
        if (qtyInput)
            qtyInput.addEventListener("input", () => {
                this.recomputeContributionAllocation().catch((err) =>
                    console.error("Validation error:", err)
                );
            });
    }

    async generateOrderQr(orderId) {
        try {
            // Collect contributions
            const rows = document.querySelectorAll("#qr-farmer-rows > div");
            const contributions = [];
            rows.forEach((r) => {
                const selects = r.querySelectorAll("select");
                const inputs = r.querySelectorAll("input");
                const farmerSelect = selects[0];
                const productSelect = selects[1];
                const farmerId = (farmerSelect?.value || "").trim();
                const farmerName = farmerSelect
                    ? farmerSelect.options[farmerSelect.selectedIndex]?.text || ""
                    : "";
                const productId = (productSelect?.value || "").trim();
                const productName = productSelect
                    ? productSelect.options[productSelect.selectedIndex]?.text || ""
                    : "";
                const quantity = Number((inputs[0]?.value || "0").trim()) || 0;
                if (farmerId && productId && quantity > 0) {
                    contributions.push({
                        farmerId,
                        farmerName,
                        productId,
                        productName,
                        quantity,
                    });
                }
            });

            const payload = {
                type: "order_packaging",
                header: (orderId || "").toString().toUpperCase().slice(-8),
                orderId,
                timestamp: Date.now(),
                contributions,
            };

            // Get order details for human-readable format
            let humanReadableText = "";
            try {
                if (window.OrderSupabaseAdapter && typeof window.OrderSupabaseAdapter.fetchOrderById === "function") {
                    const order = await window.OrderSupabaseAdapter.fetchOrderById(orderId);
                    if (order) {
                        const orderCode = (orderId || "").toString().toUpperCase().slice(-8);
                        const customerName = order.customerName || order.customer_name || "N/A";
                        const customerPhone = order.customerPhone || order.customer_phone || order.contactNumber || "N/A";
                        const deliveryOption = String(order.deliveryOption || order.delivery_option || "").toLowerCase();

                        let address = "";
                        if (deliveryOption === "pickup") {
                            const pickupParts = [];
                            if (order.pickupName || order.pickup_name) pickupParts.push(order.pickupName || order.pickup_name);
                            if (order.pickupStreet || order.pickup_street) pickupParts.push(order.pickupStreet || order.pickup_street);
                            if (order.pickupSitio || order.pickup_sitio) pickupParts.push(order.pickupSitio || order.pickup_sitio);
                            if (order.pickupBarangay || order.pickup_barangay) pickupParts.push(order.pickupBarangay || order.pickup_barangay);
                            if (order.pickupCity || order.pickup_city) pickupParts.push(order.pickupCity || order.pickup_city);
                            if (order.pickupProvince || order.pickup_province) pickupParts.push(order.pickupProvince || order.pickup_province);
                            address = pickupParts.length > 0 ? pickupParts.join(", ") : (order.pickupAddress || order.pickup_address || "Pickup Location");
                        } else {
                            address = order.deliveryAddress || order.delivery_address || order.customerAddress || order.customer_address || "N/A";
                        }

                        const orderDate = order.createdAt ? new Date(order.createdAt).toLocaleString() : (order.created_at ? new Date(order.created_at).toLocaleString() : "N/A");
                        const totalRaw = order.totalAmount || order.total || order.total_amount || 0;
                        const totalNum = typeof totalRaw === "number" ? totalRaw : parseFloat(totalRaw || "0") || 0;
                        const subtotalRaw = order.subtotal || 0;
                        const subtotalNum = typeof subtotalRaw === "number" ? subtotalRaw : parseFloat(subtotalRaw || "0") || 0;
                        const deliveryFeeRaw = order.deliveryFee || order.delivery_fee || 0;
                        const deliveryFeeNum = typeof deliveryFeeRaw === "number" ? deliveryFeeRaw : parseFloat(deliveryFeeRaw || "0") || (totalNum - subtotalNum >= 0 ? totalNum - subtotalNum : 0);
                        const generatedAt = new Date().toLocaleString();
                        const paymentMethod = (order.paymentMethod || "N/A").toString().toUpperCase();

                        // Build items list
                        const items = order.items || [];
                        let itemsText = "";
                        if (items.length > 0) {
                            itemsText = "\nITEMS:\n";
                            items.forEach((item) => {
                                const productName = item.productName || item.product_name || "Product";
                                const quantity = item.quantity || 0;
                                const unit = item.unit || "kg";
                                const price = item.price || 0;
                                const itemTotal = price * quantity;
                                itemsText += `${productName}: ${quantity} ${unit} Ã— â‚±${price.toFixed(2)} = â‚±${itemTotal.toFixed(2)}\n`;
                            });
                        } else {
                            itemsText = "\nITEMS:\nNo items found\n";
                        }

                        // Build farmer contributions
                        let contributionsText = "";
                        if (contributions.length > 0) {
                            contributionsText = "\nFARMER CONTRIBUTIONS:\n";
                            contributions.forEach((contrib) => {
                                const farmerName = contrib.farmerName || "Farmer";
                                const productName = contrib.productName || "Product";
                                const qty = contrib.quantity || 0;
                                contributionsText += `${farmerName}: ${productName} - ${qty} kg\n`;
                            });
                        } else {
                            contributionsText = "\nFARMER CONTRIBUTIONS:\nNo contributions provided\n";
                        }

                        // Human-readable text with phone number for mobile scanners
                        // Full Order ID is included at the end (after control chars) so mobile scanners don't display it prominently
                        // Customer app will extract it from the text
                        // Using form feed and vertical tab to hide full order ID from standard mobile scanners
                        const formFeed = "\f";
                        const verticalTab = "\v";
                        humanReadableText = `AGRICART ORDER\n\nOrder Code: ${orderCode}\nCustomer: ${customerName}\nPhone: ${customerPhone}\n${deliveryOption === "pickup" ? "Pickup Area" : "Address"}: ${address}\nPayment: ${paymentMethod}\nOrder Date: ${orderDate}\nGenerated: ${generatedAt}\n\nCOST BREAKDOWN:\nSubtotal: â‚±${subtotalNum.toFixed(2)}\nDelivery Fee: â‚±${deliveryFeeNum.toFixed(2)}\nTotal: â‚±${totalNum.toFixed(2)}${itemsText}${contributionsText}${formFeed}${verticalTab}Full Order ID: ${orderId}`;
                    } else {
                        // If order not found, use basic info with full order ID hidden
                        const orderCode = (orderId || "").toString().toUpperCase().slice(-8);
                        const formFeed = "\f";
                        const verticalTab = "\v";
                        humanReadableText = `AGRICART ORDER\n\nOrder Code: ${orderCode}${formFeed}${verticalTab}Full Order ID: ${orderId}`;
                    }
                } else {
                    // Fallback if adapter not available
                    const orderCode = (orderId || "").toString().toUpperCase().slice(-8);
                    const formFeed = "\f";
                    const verticalTab = "\v";
                    humanReadableText = `AGRICART ORDER\n\nOrder Code: ${orderCode}${formFeed}${verticalTab}Full Order ID: ${orderId}`;
                }
            } catch (err) {
                // If order fetch fails, just use basic info with full order ID hidden
                console.warn("Failed to fetch order for QR human-readable text:", err);
                const orderCode = (orderId || "").toString().toUpperCase().slice(-8);
                const formFeed = "\f";
                const verticalTab = "\v";
                humanReadableText = `AGRICART ORDER\n\nOrder Code: ${orderCode}${formFeed}${verticalTab}Full Order ID: ${orderId}`;
            }

            // For standard scanners: Only include human-readable text (NO JSON)
            // Customer app will extract order ID from text and fetch from Supabase
            // This ensures no JSON or codes are visible on standard scanners
            const qrData = humanReadableText;
            const encoded = encodeURIComponent(qrData);
            const url = `https://api.qrserver.com/v1/create-qr-code/?size=260x260&data=${encoded}`;

            // Also create a version with JSON for customer app (stored separately, not in QR)
            // The customer app can extract order ID from human-readable text and fetch order details
            const json = JSON.stringify(payload);
            // Store JSON separately if needed for customer app compatibility
            // But it's NOT included in the QR code data to prevent display on standard scanners

            const img = document.getElementById("qr-image");
            const preview = document.getElementById("qr-preview");
            const headerEl = document.getElementById("qr-header");
            if (img && preview && headerEl) {
                img.src = url;
                headerEl.textContent = payload.header;
                preview.style.display = "block";

                // Stamp the "Generated At" time on the packaging template
                const generatedAtEl = document.getElementById("qr-generated-at");
                if (generatedAtEl) {
                    generatedAtEl.textContent = new Date().toLocaleString();
                }
            }

            // Hide the Generate button after successful generation
            const generateBtn = document.getElementById(`qr-generate-action-${orderId}`);
            if (generateBtn) {
                generateBtn.style.display = "none";
            }

            // Recompute validation and toggle Save button
            this.recomputeContributionAllocation().catch((err) =>
                console.error("Validation error:", err)
            );
        } catch (e) {
            console.error("generateOrderQr error:", e);
            alert("Failed to generate QR");
        }
    }

    // Download QR with header as a single image
    async downloadQrImage(orderId) {
        try {
            const img = document.getElementById("qr-image");
            const headerEl = document.getElementById("qr-header");
            if (!img || !img.src) return;
            const header = headerEl?.textContent || orderId.substr(-8).toUpperCase();
            const qr = await this._composeQrCanvas(img.src, header);
            const link = document.createElement("a");
            link.download = `QR_${header}.png`;
            link.href = qr.toDataURL("image/png");
            link.click();
        } catch (e) {
            console.error("downloadQrImage error:", e);
        }
    }

    // Print QR with header
    async printQrImage(orderId) {
        try {
            const img = document.getElementById("qr-image");
            const headerEl = document.getElementById("qr-header");
            if (!img || !img.src) return;
            const header = headerEl?.textContent || orderId.substr(-8).toUpperCase();
            const canvas = await this._composeQrCanvas(img.src, header);
            const dataUrl = canvas.toDataURL("image/png");
            const w = window.open("");
            if (!w) return;
            w.document.write(
                `<html><head><title>${header}</title></head><body style="margin:0;display:flex;align-items:center;justify-content:center;">`
            );
            w.document.write(`<img src="${dataUrl}" style="max-width:100%;" />`);
            w.document.write("</body></html>");
            w.document.close();
            w.focus();
            setTimeout(() => {
                w.print();
                w.close();
            }, 300);
        } catch (e) {
            console.error("printQrImage error:", e);
        }
    }

    // Print full packaging label
    async printQrPackaging(orderId) {
        try {
            const canvas = await this._composeQrPackagingCanvas(orderId);
            if (!canvas) return;

            const orderCodeEl = document.getElementById("qr-order-code");
            const header =
                (orderCodeEl?.textContent || orderId.toString().toUpperCase()).slice(
                    -8
                );

            const dataUrl = canvas.toDataURL("image/png");
            const w = window.open("");
            if (!w) return;
            w.document.write(
                `<html><head><title>PACKAGING_${header}</title></head><body style="margin:0;display:flex;align-items:center;justify-content:center;">`
            );
            // Limit both width and height so the image always fits on a single printed page
            w.document.write(
                `<img src="${dataUrl}" style="max-width:90%;max-height:90vh;object-fit:contain;" />`
            );
            w.document.write("</body></html>");
            w.document.close();
            w.focus();
            setTimeout(() => {
                w.print();
                w.close();
            }, 300);
        } catch (e) {
            console.error("printQrPackaging error:", e);
            alert(
                "Failed to print QR packaging image: " +
                (e.message || "Unknown error")
            );
        }
    }

    // Download full packaging label (template + QR + metadata) as an image
    async downloadQrPackaging(orderId) {
        try {
            const canvas = await this._composeQrPackagingCanvas(orderId);
            if (!canvas) return;

            const orderCodeEl = document.getElementById("qr-order-code");
            const header =
                (orderCodeEl?.textContent || orderId.toString().toUpperCase()).slice(
                    -8
                );

            const dataUrl = canvas.toDataURL("image/png");

            // Trigger browser download
            const link = document.createElement("a");
            link.download = `PACKAGING_${header}.png`;
            link.href = dataUrl;
            link.click();

            // Also upload to Supabase Storage (bucket: qr_packaging) for archival
            try {
                let supabase = null;
                if (typeof window.getSupabaseClient === "function") {
                    supabase = window.getSupabaseClient();
                } else if (window.supabaseClient) {
                    supabase = window.supabaseClient;
                }

                if (supabase) {
                    const fileName = `${orderId}_${Date.now()}.png`;
                    const blob = this._dataUrlToBlob(dataUrl);
                    const { error } = await supabase.storage
                        .from("qr_packaging")
                        .upload(fileName, blob, {
                            contentType: "image/png",
                        });

                    if (error) {
                        console.warn("Failed to upload QR packaging image:", error);
                    } else {
                        console.log(
                            "âœ… QR packaging image uploaded to Supabase bucket qr_packaging"
                        );
                    }
                } else {
                    console.warn(
                        "Supabase client not available, skipping QR packaging upload"
                    );
                }
            } catch (uploadErr) {
                console.warn("Error uploading QR packaging image:", uploadErr);
            }
        } catch (e) {
            console.error("downloadQrPackaging error:", e);
            alert(
                "Failed to download QR packaging image: " +
                (e.message || "Unknown error")
            );
        }
    }

    // Toggle QR details editor
    toggleQrEditor() {
        const editor = document.getElementById("qr-details-editor");
        if (editor) {
            const isVisible = editor.style.display !== "none";
            editor.style.display = isVisible ? "none" : "block";
        }
    }

    // Update QR details
    updateQrDetails(orderId) {
        const headerInput = document.getElementById("qr-header-input");
        const notesInput = document.getElementById("qr-notes-input");
        const headerEl = document.getElementById("qr-header");
        const notesEl = document.getElementById("qr-notes");

        if (headerInput && headerEl) {
            headerEl.textContent =
                headerInput.value.trim() || orderId.substr(-8).toUpperCase();
        }
        if (notesInput && notesEl) {
            notesEl.textContent = notesInput.value.trim();
            notesEl.style.display = notesInput.value.trim() ? "block" : "none";
        }

        // Hide editor after update
        this.toggleQrEditor();
    }

    getQrSupabaseClient() {
        try {
            if (typeof this.getSupabaseClient === "function") {
                const client = this.getSupabaseClient();
                if (client) return client;
            }
        } catch (_) { }
        if (typeof window.getSupabaseClient === "function") {
            try {
                const client = window.getSupabaseClient();
                if (client) return client;
            } catch (_) { }
        }
        return window.supabaseClient || null;
    }

    normalizeSupabaseQrRecord(row) {
        if (!row) return null;
        const contributions = Array.isArray(row.contributions)
            ? row.contributions.map((c) => ({
                farmerId: c.farmerId || c.farmer_id,
                farmerName: c.farmerName || c.farmer_name,
                productId: c.productId || c.product_id,
                productName: c.productName || c.product_name,
                quantity: c.quantity,
                id: c.id || c.qrContributionId || c.qr_contribution_id,
                createdAt: c.createdAt || c.created_at,
                updatedAt: c.updatedAt || c.updated_at,
            }))
            : [];
        return {
            orderId: row.order_id || row.orderId,
            header: row.header,
            qrImageUrl: row.qr_image_url || row.qrImageUrl,
            notes: row.notes,
            contributions,
            createdAt: row.created_at || row.createdAt,
            updatedAt: row.updated_at || row.updatedAt,
            createdBy: row.created_by || row.createdBy,
            updatedBy: row.updated_by || row.updatedBy,
        };
    }

    async fetchSupabaseQrRecord(orderId, { forceRefresh = false } = {}) {
        if (!orderId) return null;
        this._qrCodesCache = this._qrCodesCache || {};
        if (
            !forceRefresh &&
            Object.prototype.hasOwnProperty.call(this._qrCodesCache, orderId)
        ) {
            return this._qrCodesCache[orderId];
        }

        const supabase = this.getQrSupabaseClient();
        if (!supabase) {
            throw new Error("Supabase client not available");
        }

        const { data, error } = await supabase
            .from("qr_codes_with_contributions")
            .select("*")
            .eq("order_id", orderId)
            .limit(1);

        if (error && error.code !== "PGRST116") {
            throw error;
        }

        const record =
            Array.isArray(data) && data.length
                ? this.normalizeSupabaseQrRecord(data[0])
                : null;
        this._qrCodesCache[orderId] = record;
        return record;
    }

    async fetchAllSupabaseQrRecords(forceRefresh = false) {
        if (this._qrCodesCache && !forceRefresh) {
            return this._qrCodesCache;
        }

        const supabase = this.getQrSupabaseClient();
        if (!supabase) {
            throw new Error("Supabase client not available");
        }

        const { data, error } = await supabase
            .from("qr_codes_with_contributions")
            .select("*");

        if (error) {
            throw error;
        }

        const mapped = {};
        (data || []).forEach((row) => {
            const normalized = this.normalizeSupabaseQrRecord(row);
            if (normalized && normalized.orderId) {
                mapped[normalized.orderId] = normalized;
            }
        });
        this._qrCodesCache = mapped;
        return mapped;
    }

    invalidateQrCache(orderId = null) {
        if (!this._qrCodesCache) return;
        if (orderId) {
            delete this._qrCodesCache[orderId];
        } else {
            this._qrCodesCache = {};
        }
    }

    // Save QR to database
    async saveQrToDatabase(orderId) {
        try {
            const saveBtn = document.getElementById(`save-qr-button-${orderId}`);
            const originalBtnContent = saveBtn ? saveBtn.innerHTML : "";

            // Show loading indicator
            if (saveBtn) {
                saveBtn.disabled = true;
                saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';
            }

            const img = document.getElementById("qr-image");
            const headerEl = document.getElementById("qr-header");
            const notesEl = document.getElementById("qr-notes");
            const orderCodeEl = document.getElementById("qr-order-code");

            if (!img || !img.src) {
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.innerHTML = originalBtnContent;
                }
                alert("Please generate a QR code first");
                return;
            }

            const header = headerEl?.textContent || orderId.substr(-8).toUpperCase();
            const notes = notesEl?.textContent || "";
            const orderCodeText =
                orderCodeEl?.textContent ||
                orderId.toString().toUpperCase().slice(-8);

            // Collect contributions
            const rows = document.querySelectorAll("#qr-farmer-rows > div");
            const contributions = [];
            rows.forEach((r) => {
                const selects = r.querySelectorAll("select");
                const inputs = r.querySelectorAll("input");
                const farmerSelect = selects[0];
                const productSelect = selects[1];
                const farmerId = (farmerSelect?.value || "").trim();
                const farmerName = farmerSelect
                    ? farmerSelect.options[farmerSelect.selectedIndex]?.text || ""
                    : "";
                const productId = (productSelect?.value || "").trim();
                const productName = productSelect
                    ? productSelect.options[productSelect.selectedIndex]?.text || ""
                    : "";
                const quantity = Number((inputs[0]?.value || "0").trim()) || 0;
                if (farmerId && productId && quantity > 0) {
                    contributions.push({
                        farmerId,
                        farmerName,
                        productId,
                        productName,
                        quantity,
                    });
                }
            });

            const supabase = this.getQrSupabaseClient();
            if (!supabase) {
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.innerHTML = originalBtnContent;
                }
                alert("Supabase client not available. Please refresh and try again.");
                return;
            }

            // Compose full packaging image and upload to qr_packaging bucket
            const packagingCanvas = await this._composeQrPackagingCanvas(orderId);
            const packagingDataUrl = packagingCanvas.toDataURL("image/png");

            let packagingUrl = null;
            try {
                const packagingBlob = this._dataUrlToBlob(packagingDataUrl);
                const fileName = `${orderId}_${Date.now()}.png`;
                const { data: uploadData, error: uploadError } = await supabase.storage
                    .from("qr_packaging")
                    .upload(fileName, packagingBlob, {
                        contentType: "image/png",
                        upsert: false,
                    });

                if (uploadError) {
                    console.warn(
                        "Failed to upload QR packaging image during save:",
                        uploadError
                    );
                } else if (uploadData && uploadData.path) {
                    const { data: publicUrlData } = supabase.storage
                        .from("qr_packaging")
                        .getPublicUrl(uploadData.path);
                    packagingUrl = publicUrlData?.publicUrl || null;
                }
            } catch (uploadErr) {
                console.warn(
                    "Unexpected error uploading QR packaging image during save:",
                    uploadErr
                );
            }

            const actor = this.currentUser?.uid || "staff";
            const { error } = await supabase.rpc("save_qr_payload", {
                p_order_id: orderId,
                p_header: header,
                // Store packaging image URL if available, otherwise fall back to QR-only URL
                p_qr_image_url: packagingUrl || img.src,
                p_notes: notes,
                p_contributions: contributions,
                p_actor: actor,
            });

            if (error) {
                throw new Error(error.message || "Failed to save QR payload");
            }

            this.invalidateQrCache(orderId);

            console.log("QR saved to Supabase:", {
                orderId,
                header,
                contributionsCount: contributions.length,
            });

            // Show success message briefly before closing
            if (saveBtn) {
                saveBtn.innerHTML = '<i class="fas fa-check"></i> Saved!';
                saveBtn.style.backgroundColor = "#4caf50";
            }

            // Close the modal automatically after a brief delay
            setTimeout(() => {
                const modal = document.querySelector(".modal-overlay[data-qr-modal]");
                if (modal) {
                    modal.remove();
                }
            }, 800);

            // Update QR status immediately
            setTimeout(() => {
                this.updateQrStatus(orderId);
            }, 100);

            // Refresh the QR display on the order card immediately
            // Use a small delay to ensure the database write is complete
            setTimeout(() => {
                this.loadSavedQrForOrderCard(orderId);
                // Also update QR status to reflect the new QR
                this.updateQrStatus(orderId);
            }, 300);
        } catch (e) {
            console.error("saveQrToDatabase error:", e);

            // Restore button on error
            const saveBtn = document.getElementById(`save-qr-button-${orderId}`);
            if (saveBtn) {
                saveBtn.disabled = false;
                saveBtn.innerHTML = '<i class="fas fa-save"></i> Save Packaging';
            }

            alert("Failed to save QR code: " + (e.message || "Unknown error"));
        }
    }

    // Load saved QR codes for an order
    async loadSavedQr(orderId) {
        try {
            const savedList = document.getElementById("saved-qr-list");
            const savedItems = document.getElementById("saved-qr-items");

            if (!savedList || !savedItems) return;

            // Show loading
            savedItems.innerHTML =
                '<div style="text-align:center;padding:20px;">Loading saved QR codes...</div>';
            savedList.style.display = "block";

            const qrRecord = await this.fetchSupabaseQrRecord(orderId, {
                forceRefresh: true,
            });

            if (!qrRecord) {
                savedItems.innerHTML =
                    '<div style="text-align:center;padding:20px;color:#666;">No saved QR codes found for this order</div>';
                return;
            }

            // Display saved QR code
            const qr = qrRecord;
            const qrId = qr.orderId || orderId;
            const createdDisplay = qr.createdAt
                ? new Date(qr.createdAt).toLocaleString()
                : "N/A";
            savedItems.innerHTML = `
                <div style="border:1px solid #e0e0e0;border-radius:8px;padding:12px;margin-bottom:8px;">
                    <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:8px;">
                        <div>
                            <div style="font-weight:600;">${qr.header || "QR Code"
                }</div>
                            <div style="font-size:12px;color:#666;">Created: ${createdDisplay}</div>
                        </div>
                        <button class="danger-btn" onclick="staffManager.deleteSavedQr('${qrId}')" style="font-size:12px;padding:4px 8px;">Delete</button>
                    </div>
                    ${qr.notes
                    ? `<div style="font-size:14px;color:#666;margin-bottom:8px;">${qr.notes}</div>`
                    : ""
                }
                    ${qr.qrImageUrl
                    ? `<div style="text-align:center;margin:8px 0;">
                            <img src="${qr.qrImageUrl}" alt="Saved QR Packaging" style="max-width:260px;max-height:260px;border:1px solid #e0e0e0;border-radius:6px;cursor:pointer;box-shadow:0 2px 8px rgba(0,0,0,0.08);" onclick="staffManager.showImageLightbox('${qr.qrImageUrl}')" />
                           </div>`
                    : ""
                }
                    <div style="display:flex;gap:8px;flex-wrap:wrap;">
                        <button class="secondary-btn" onclick="staffManager.loadQrData('${qrId}', '${orderId}')" style="font-size:12px;padding:6px 12px;">
                            <i class="fas fa-eye"></i> View
                        </button>
                        <button class="secondary-btn" onclick="staffManager.downloadSavedQr('${qrId}', '${qr.header || "QR"
                }')" style="font-size:12px;padding:6px 12px;">
                            <i class="fas fa-download"></i> Download
                        </button>
                        <button class="secondary-btn" onclick="staffManager.printSavedQr('${qrId}', '${qr.header || "QR"
                }')" style="font-size:12px;padding:6px 12px;">
                            <i class="fas fa-print"></i> Print
                        </button>
                    </div>
                </div>
            `;
        } catch (e) {
            console.error("loadSavedQr error:", e);
            alert("Failed to load saved QR codes");
        }
    }

    // Load specific QR data into the editor
    async loadQrData(qrId, orderId) {
        try {
            const targetOrderId = orderId || qrId;
            const qrData = await this.fetchSupabaseQrRecord(targetOrderId, {
                forceRefresh: true,
            });

            if (!qrData) {
                alert("QR data not found");
                return;
            }

            // Load QR image and header into the packaging preview
            const img = document.getElementById("qr-image");
            const preview = document.getElementById("qr-preview");
            const headerEl = document.getElementById("qr-header");
            const notesEl = document.getElementById("qr-notes");
            const orderCodeEl = document.getElementById("qr-order-code");

            if (img && preview && headerEl) {
                img.src = qrData.qrImageUrl;
                headerEl.textContent = qrData.header || "";
                if (notesEl) {
                    notesEl.textContent = qrData.notes || "";
                    notesEl.style.display = qrData.notes ? "block" : "none";
                }
                // Ensure order code reflects header/orderId for consistency
                if (orderCodeEl) {
                    orderCodeEl.textContent =
                        qrData.header ||
                        (orderId || qrId || "")
                            .toString()
                            .toUpperCase()
                            .slice(-8);
                }
                preview.style.display = "block";
            }

            // Load farmer contributions
            const farmerRows = document.getElementById("qr-farmer-rows");
            if (farmerRows && qrData.contributions) {
                farmerRows.innerHTML = "";
                qrData.contributions.forEach((contrib) => {
                    this.addFarmerContributionRow(contrib);
                });
            }

            // Load into editor fields
            const headerInput = document.getElementById("qr-header-input");
            const notesInput = document.getElementById("qr-notes-input");
            if (headerInput) headerInput.value = qrData.header || "";
            if (notesInput) notesInput.value = qrData.notes || "";

            alert("QR data loaded successfully!");
        } catch (e) {
            console.error("loadQrData error:", e);
            alert("Failed to load QR data");
        }
    }

    // Delete saved QR
    async deleteSavedQr(qrId) {
        if (!confirm("Are you sure you want to delete this QR code?")) return;

        try {
            const supabase = this.getQrSupabaseClient();
            if (!supabase) {
                alert("Supabase client not available. Please refresh and try again.");
                return;
            }

            const { error } = await supabase
                .from("qr_codes")
                .delete()
                .eq("order_id", qrId);

            if (error) {
                throw error;
            }

            this.invalidateQrCache(qrId);
            alert("QR code deleted successfully");

            // Reload the saved QR list
            const orderId = document
                .querySelector('[id^="order-"]')
                ?.id?.replace("order-", "");
            if (orderId) {
                this.loadSavedQr(orderId);
            }
        } catch (e) {
            console.error("deleteSavedQr error:", e);
            alert("Failed to delete QR code");
        }
    }

    // Download saved QR
    async downloadSavedQr(qrId, header) {
        try {
            const qrData = await this.fetchSupabaseQrRecord(qrId, {
                forceRefresh: true,
            });

            if (!qrData || !qrData.qrImageUrl) {
                alert("QR data not found");
                return;
            }

            const canvas = await this._composeQrPackagingCanvas(qrId, qrData);
            const link = document.createElement("a");
            link.download = `PACKAGING_${qrData.header || header}.png`;
            link.href = canvas.toDataURL("image/png");
            link.click();
        } catch (e) {
            console.error("downloadSavedQr error:", e);
            alert("Failed to download QR code");
        }
    }

    // Print saved QR
    async printSavedQr(qrId, header) {
        try {
            const qrData = await this.fetchSupabaseQrRecord(qrId, {
                forceRefresh: true,
            });

            if (!qrData || !qrData.qrImageUrl) {
                alert("QR data not found");
                return;
            }

            const canvas = await this._composeQrPackagingCanvas(qrId, qrData);
            const dataUrl = canvas.toDataURL("image/png");

            // Print via hidden iframe to avoid blocking/unresponsive main window
            const iframe = document.createElement("iframe");
            iframe.style.position = "fixed";
            iframe.style.right = "0";
            iframe.style.bottom = "0";
            iframe.style.width = "0";
            iframe.style.height = "0";
            iframe.style.border = "0";
            iframe.style.visibility = "hidden";
            document.body.appendChild(iframe);

            const doc = iframe.contentWindow?.document;
            if (!doc) {
                document.body.removeChild(iframe);
                throw new Error("Unable to create print frame");
            }

            doc.open();
            doc.write(
                `<html><head><title>${qrData.header || header
                }</title></head><body style="margin:0;display:flex;align-items:center;justify-content:center;">`
            );
            doc.write(
                `<img id="qr-print-img" src="${dataUrl}" style="max-width:90%;max-height:90vh;object-fit:contain;" />`
            );
            doc.write("</body></html>");
            doc.close();

            const img = doc.getElementById("qr-print-img");
            if (img) {
                img.onload = () => {
                    setTimeout(() => {
                        iframe.contentWindow?.focus();
                        iframe.contentWindow?.print();
                        setTimeout(() => {
                            document.body.removeChild(iframe);
                        }, 200);
                    }, 100);
                };
                img.onerror = () => {
                    document.body.removeChild(iframe);
                    alert("Failed to load QR for printing");
                };
            } else {
                document.body.removeChild(iframe);
                throw new Error("QR image not found for printing");
            }
        } catch (e) {
            console.error("printSavedQr error:", e);
            alert("Failed to print QR code");
        }
    }

    // Helper to compose a canvas with bold header text above the QR image
    _composeQrCanvas(qrSrc, headerText) {
        return new Promise((resolve, reject) => {
            try {
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.onload = () => {
                    const padding = 16;
                    const headerFont = "bold 20px Arial";
                    const canvas = document.createElement("canvas");
                    const ctx = canvas.getContext("2d");
                    if (!ctx) {
                        reject(new Error("Canvas not supported"));
                        return;
                    }

                    // Measure header text width
                    ctx.font = headerFont;
                    const textWidth = ctx.measureText(headerText).width;
                    const width = Math.max(
                        img.width + padding * 2,
                        textWidth + padding * 2
                    );
                    const headerHeight = 32;
                    const height = headerHeight + padding + img.height + padding;
                    canvas.width = Math.ceil(width);
                    canvas.height = Math.ceil(height);

                    // White background
                    ctx.fillStyle = "#fff";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Header text
                    ctx.fillStyle = "#000";
                    ctx.font = headerFont;
                    const textX = (canvas.width - textWidth) / 2;
                    const textY = padding + 18;
                    ctx.fillText(headerText, textX, textY);

                    // QR image centered
                    const qrX = (canvas.width - img.width) / 2;
                    const qrY = headerHeight + padding / 2;
                    ctx.drawImage(img, qrX, qrY);

                    resolve(canvas);
                };
                img.onerror = reject;
                img.src = qrSrc;
            } catch (e) {
                reject(e);
            }
        });
    }

    // Helper to compose a canvas matching the packaging template layout
    _composeQrPackagingCanvas(orderId, qrDataOverride = null) {
        return new Promise(async (resolve, reject) => {
            try {
                // Prefer QR/image + metadata from override (saved record), otherwise from DOM
                let qrSrc = null;
                let headerText = null;
                let toName = null;
                let toPhone = null;
                let toAddress = null;
                let addressLabel = "Delivery Address:"; // Default label
                let fromPhone = null;
                let fromEmail = null;
                let orderDate = null;
                let generatedAt = null;
                let orderTotal = null;
                // Ensure order is declared before any use (fetched below)
                let order = null;

                if (qrDataOverride) {
                    const effectiveOrderId =
                        qrDataOverride.orderId || orderId || "UNKNOWN";
                    headerText =
                        qrDataOverride.header ||
                        effectiveOrderId.toString().toUpperCase().slice(-8) ||
                        "ORDER";

                    // Rebuild QR image from payload so we always get the real QR, not the saved template image
                    const payload = {
                        type: "order_packaging",
                        header: headerText,
                        orderId: effectiveOrderId,
                        timestamp: qrDataOverride.createdAt || Date.now(),
                        contributions: Array.isArray(qrDataOverride.contributions)
                            ? qrDataOverride.contributions
                            : [],
                    };

                    // Fetch order data from Supabase to get actual customer information
                    if (
                        window.OrderSupabaseAdapter &&
                        typeof window.OrderSupabaseAdapter.fetchOrderById === "function"
                    ) {
                        try {
                            order = await window.OrderSupabaseAdapter.fetchOrderById(
                                effectiveOrderId
                            );
                        } catch (orderErr) {
                            console.warn(
                                "Failed to fetch order for saved QR packaging:",
                                orderErr
                            );
                        }
                    }

                    // Create human-readable text for standard QR scanners
                    let humanReadableText = "";
                    if (order) {
                        const orderCode = headerText;
                        const customerName = order.customerName || order.customer_name || "N/A";
                        const customerPhone = order.customerPhone || order.customer_phone || order.contactNumber || "N/A";
                        const deliveryOption = String(order.deliveryOption || order.delivery_option || "").toLowerCase();

                        let address = "";
                        if (deliveryOption === "pickup") {
                            const pickupParts = [];
                            if (order.pickupName || order.pickup_name) pickupParts.push(order.pickupName || order.pickup_name);
                            if (order.pickupStreet || order.pickup_street) pickupParts.push(order.pickupStreet || order.pickup_street);
                            if (order.pickupSitio || order.pickup_sitio) pickupParts.push(order.pickupSitio || order.pickup_sitio);
                            if (order.pickupBarangay || order.pickup_barangay) pickupParts.push(order.pickupBarangay || order.pickup_barangay);
                            if (order.pickupCity || order.pickup_city) pickupParts.push(order.pickupCity || order.pickup_city);
                            if (order.pickupProvince || order.pickup_province) pickupParts.push(order.pickupProvince || order.pickup_province);
                            address = pickupParts.length > 0 ? pickupParts.join(", ") : (order.pickupAddress || order.pickup_address || "Pickup Location");
                        } else {
                            address = order.deliveryAddress || order.delivery_address || order.customerAddress || order.customer_address || "N/A";
                        }

                        const orderDateVal = order.createdAt || order.created_at || null;
                        const orderDateStr = orderDateVal ? new Date(orderDateVal).toLocaleString() : "N/A";
                        const totalRaw = order.totalAmount || order.total || order.total_amount || 0;
                        const totalNum = typeof totalRaw === "number" ? totalRaw : parseFloat(totalRaw || "0") || 0;
                        const subtotalRaw = order.subtotal || 0;
                        const subtotalNum = typeof subtotalRaw === "number" ? subtotalRaw : parseFloat(subtotalRaw || "0") || 0;
                        const deliveryFeeRaw = order.deliveryFee || order.delivery_fee || 0;
                        const deliveryFeeNum =
                            typeof deliveryFeeRaw === "number"
                                ? deliveryFeeRaw
                                : parseFloat(deliveryFeeRaw || "0") ||
                                (totalNum - subtotalNum >= 0 ? totalNum - subtotalNum : 0);
                        const generatedAtStr = qrDataOverride.createdAt
                            ? new Date(qrDataOverride.createdAt).toLocaleString()
                            : new Date().toLocaleString();
                        const paymentMethod = (order.paymentMethod || "N/A").toString().toUpperCase();

                        // Build items list
                        const items = order.items || [];
                        let itemsText = "";
                        if (items.length > 0) {
                            itemsText = "\nITEMS:\n";
                            items.forEach((item) => {
                                const productName = item.productName || item.product_name || "Product";
                                const quantity = item.quantity || 0;
                                const unit = item.unit || "kg";
                                const price = item.price || 0;
                                const itemTotal = price * quantity;
                                itemsText += `${productName}: ${quantity} ${unit} Ã— â‚±${Number(price).toFixed(2)} = â‚±${itemTotal.toFixed(2)}\n`;
                            });
                        } else {
                            itemsText = "\nITEMS:\nNo items found\n";
                        }

                        // Build farmer contributions
                        const contributions = Array.isArray(qrDataOverride.contributions) ? qrDataOverride.contributions : [];
                        let contributionsText = "";
                        if (contributions.length > 0) {
                            contributionsText = "\nFARMER CONTRIBUTIONS:\n";
                            contributions.forEach((contrib) => {
                                const farmerName = contrib.farmerName || "Farmer";
                                const productName = contrib.productName || "Product";
                                const qty = contrib.quantity || 0;
                                contributionsText += `${farmerName}: ${productName} - ${qty} kg\n`;
                            });
                        } else {
                            contributionsText = "\nFARMER CONTRIBUTIONS:\nNo contributions provided\n";
                        }

                        // Human-readable text without phone number (already on packaging) and without JSON
                        // Include full order ID for customer app to extract and fetch order details
                        humanReadableText = `AGRICART ORDER\n\nOrder Code: ${headerText}\nFull Order ID: ${effectiveOrderId}\nCustomer: ${customerName}\n${deliveryOption === "pickup" ? "Pickup Area" : "Address"}: ${address}\nPayment: ${paymentMethod}\nOrder Date: ${orderDateStr}\nGenerated: ${generatedAtStr}\n\nCOST BREAKDOWN:\nSubtotal: â‚±${subtotalNum.toFixed(2)}\nDelivery Fee: â‚±${deliveryFeeNum.toFixed(2)}\nTotal: â‚±${totalNum.toFixed(2)}${itemsText}${contributionsText}`;
                    } else {
                        // Fallback if order not available
                        humanReadableText = `AGRICART ORDER\n\nOrder Code: ${headerText}\nFull Order ID: ${effectiveOrderId}`;
                    }

                    // For standard scanners: Only include human-readable text (NO JSON)
                    // Always generate a fresh QR (avoid saved template image issues)
                    const qrData = humanReadableText;
                    const encoded = encodeURIComponent(qrData);
                    qrSrc = `https://api.qrserver.com/v1/create-qr-code/?size=320x320&data=${encoded}`;

                    // Get customer details from order
                    if (order) {
                        toName = order.customerName || order.customer_name || "Customer Name";
                        toPhone =
                            order.customerPhone ||
                            order.customer_phone ||
                            order.contactNumber ||
                            order.contact_number ||
                            "N/A";

                        // Check if order is pickup - if so, use pickup area instead of delivery address
                        const deliveryOption = String(
                            order.deliveryOption || order.delivery_option || ""
                        ).toLowerCase();

                        // Set address label based on delivery option
                        addressLabel = deliveryOption === "pickup" ? "Pickup Area:" : "Delivery Address:";

                        if (deliveryOption === "pickup") {
                            // Build pickup address from structured fields
                            const pickupParts = [];
                            if (order.pickupName || order.pickup_name) {
                                pickupParts.push(order.pickupName || order.pickup_name);
                            }
                            if (order.pickupStreet || order.pickup_street) {
                                pickupParts.push(order.pickupStreet || order.pickup_street);
                            }
                            if (order.pickupSitio || order.pickup_sitio) {
                                pickupParts.push(order.pickupSitio || order.pickup_sitio);
                            }
                            if (order.pickupBarangay || order.pickup_barangay) {
                                pickupParts.push(order.pickupBarangay || order.pickup_barangay);
                            }
                            if (order.pickupCity || order.pickup_city) {
                                pickupParts.push(order.pickupCity || order.pickup_city);
                            }
                            if (order.pickupProvince || order.pickup_province) {
                                pickupParts.push(order.pickupProvince || order.pickup_province);
                            }
                            if (order.pickupLandmark || order.pickup_landmark) {
                                pickupParts.push(`Landmark: ${order.pickupLandmark || order.pickup_landmark}`);
                            }

                            // Fallback to pickupAddress if structured fields not available
                            toAddress = pickupParts.length > 0
                                ? pickupParts.join(", ")
                                : order.pickupAddress || order.pickup_address || "Pickup Location";
                        } else {
                            // Delivery order - use delivery address
                            toAddress =
                                order.deliveryAddress ||
                                order.delivery_address ||
                                order.customerAddress ||
                                order.customer_address ||
                                "";
                        }

                        orderDate = order.createdAt
                            ? new Date(order.createdAt).toLocaleString()
                            : order.created_at
                                ? new Date(order.created_at).toLocaleString()
                                : "â€”";

                        // Get order total amount
                        const totalRaw = order.totalAmount || order.total || order.total_amount || 0;
                        if (totalRaw) {
                            orderTotal = typeof totalRaw === 'number'
                                ? totalRaw.toFixed(2)
                                : (parseFloat(totalRaw) || 0).toFixed(2);
                        } else {
                            orderTotal = null;
                        }
                    } else {
                        // Fallback to placeholders if order fetch fails
                        toName = qrDataOverride.customerName || "Customer Name";
                        toPhone = qrDataOverride.customerPhone || "N/A";
                        toAddress =
                            qrDataOverride.deliveryAddress ||
                            qrDataOverride.customerAddress ||
                            "";
                        orderDate = "â€”";
                        orderTotal = null;
                    }

                    // Fetch contact support settings from Supabase
                    try {
                        let supabase = null;
                        if (typeof window.getSupabaseClient === "function") {
                            supabase = window.getSupabaseClient();
                        } else if (window.supabaseClient) {
                            supabase = window.supabaseClient;
                        }

                        if (supabase) {
                            const { data: supportData } = await supabase
                                .from("system_data")
                                .select("support_email, support_phone")
                                .eq("id", "contactSupport")
                                .maybeSingle();

                            if (supportData) {
                                fromPhone =
                                    supportData.support_phone || "+63 123 456 7890";
                                fromEmail =
                                    supportData.support_email || "calcoacoop@gmail.com";
                            } else {
                                fromPhone = "+63 123 456 7890";
                                fromEmail = "calcoacoop@gmail.com";
                            }
                        } else {
                            fromPhone = "+63 123 456 7890";
                            fromEmail = "calcoacoop@gmail.com";
                        }
                    } catch (supportErr) {
                        console.warn(
                            "Failed to fetch contact support settings:",
                            supportErr
                        );
                        fromPhone = "+63 123 456 7890";
                        fromEmail = "calcoacoop@gmail.com";
                    }

                    generatedAt = qrDataOverride.createdAt
                        ? new Date(qrDataOverride.createdAt).toLocaleString()
                        : "â€”";

                    // Ensure we have order total - fetch order if not already fetched or total is missing
                    if ((orderTotal === null || orderTotal === undefined || orderTotal === "") && effectiveOrderId && window.OrderSupabaseAdapter && typeof window.OrderSupabaseAdapter.fetchOrderById === "function") {
                        try {
                            if (!order) {
                                order = await window.OrderSupabaseAdapter.fetchOrderById(effectiveOrderId);
                            }
                            if (order) {
                                const totalRaw = order.totalAmount || order.total || order.total_amount || 0;
                                if (totalRaw !== null && totalRaw !== undefined) {
                                    orderTotal = typeof totalRaw === 'number'
                                        ? totalRaw.toFixed(2)
                                        : (parseFloat(totalRaw) || 0).toFixed(2);
                                }
                            }
                        } catch (err) {
                            console.warn("Failed to fetch order total:", err);
                        }
                    }
                } else {
                    const qrImgEl = document.getElementById("qr-image");
                    if (!qrImgEl || !qrImgEl.src) {
                        reject(new Error("QR image not available"));
                        return;
                    }

                    qrSrc = qrImgEl.src;
                    const orderCodeEl = document.getElementById("qr-order-code");
                    const toNameEl = document.getElementById("qr-to-name");
                    const toPhoneEl = document.getElementById("qr-to-phone");
                    const toAddressEl = document.getElementById("qr-to-address");
                    const fromPhoneEl = document.getElementById("qr-from-phone");
                    const fromEmailEl = document.getElementById("qr-from-email");
                    const orderDateEl = document.getElementById("qr-order-date");
                    const generatedAtEl = document.getElementById("qr-generated-at");

                    headerText =
                        (orderCodeEl?.textContent ||
                            orderId.toString().toUpperCase().slice(-8)) || "ORDER";

                    toName = toNameEl?.textContent || "Customer Name";
                    toPhone = toPhoneEl?.textContent || "N/A";
                    toAddress = toAddressEl?.textContent || "";
                    // Get address label from DOM if available
                    const addressLabelEl = document.getElementById("qr-address-label");
                    addressLabel = addressLabelEl?.textContent || "Delivery Address:";
                    fromPhone = fromPhoneEl?.textContent || "+63 123 456 7890";
                    fromEmail = fromEmailEl?.textContent || "calcoacoop@gmail.com";
                    orderDate = orderDateEl?.textContent || "â€”";
                    generatedAt = generatedAtEl?.textContent || "â€”";

                    // Always fetch order to get total amount
                    if (window.OrderSupabaseAdapter && typeof window.OrderSupabaseAdapter.fetchOrderById === "function") {
                        try {
                            const order = await window.OrderSupabaseAdapter.fetchOrderById(orderId);
                            if (order) {
                                const totalRaw = order.totalAmount || order.total || order.total_amount || 0;
                                if (totalRaw) {
                                    orderTotal = typeof totalRaw === 'number'
                                        ? totalRaw.toFixed(2)
                                        : (parseFloat(totalRaw) || 0).toFixed(2);
                                }
                            }
                        } catch (err) {
                            console.warn("Failed to fetch order total:", err);
                            orderTotal = null;
                        }
                    }
                }

                if (!qrSrc) {
                    reject(new Error("QR image not available"));
                    return;
                }

                const agricartLogo = new Image();
                const calcoaLogo = new Image();
                const qrImg = new Image();

                agricartLogo.crossOrigin = "anonymous";
                calcoaLogo.crossOrigin = "anonymous";
                qrImg.crossOrigin = "anonymous";

                agricartLogo.src =
                    "https://afkwexvvuxwbpioqnelp.supabase.co/storage/v1/object/public/email_assets/agricart_logo.png";
                calcoaLogo.src =
                    "https://afkwexvvuxwbpioqnelp.supabase.co/storage/v1/object/public/email_assets/calcoa_logo.png";
                qrImg.src = qrSrc;

                let loaded = 0;
                const handleLoaded = () => {
                    loaded += 1;
                    if (loaded < 3) return;

                    const canvas = document.createElement("canvas");
                    const ctx = canvas.getContext("2d");
                    if (!ctx) {
                        reject(new Error("Canvas not supported"));
                        return;
                    }

                    // Slimmer page size so details + QR fit tightly and are easy to read
                    // Height chosen to keep everything on a single printed page while leaving margins
                    const width = 600;
                    const height = 900;
                    canvas.width = width;
                    canvas.height = height;

                    // Background
                    ctx.fillStyle = "#f5f5f5";
                    ctx.fillRect(0, 0, width, height);

                    // Header gradient with a small top margin so it's not flush to the very top
                    const topMargin = 24;
                    const headerHeight = 180;
                    const headerTop = topMargin;
                    const gradient = ctx.createLinearGradient(
                        0,
                        headerTop,
                        width,
                        headerTop + headerHeight
                    );
                    gradient.addColorStop(0, "#315E26");
                    gradient.addColorStop(1, "#4A7C3A");
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, headerTop, width, headerHeight);

                    // Logos
                    const logoSize = 70;
                    const logoY = headerTop + 26;
                    const logoGap = 26;
                    const logosTotalWidth = logoSize * 2 + logoGap;
                    const logosStartX = (width - logosTotalWidth) / 2;

                    const logoBgRadius = logoSize / 2 + 8;
                    ctx.fillStyle = "#FFFEF9";
                    // AgriCart logo circle
                    ctx.beginPath();
                    ctx.arc(
                        logosStartX + logoBgRadius,
                        logoY + logoBgRadius,
                        logoBgRadius,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                    // CALCOA logo circle
                    ctx.beginPath();
                    ctx.arc(
                        logosStartX + logoBgRadius + logoSize + logoGap,
                        logoY + logoBgRadius,
                        logoBgRadius,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();

                    ctx.drawImage(
                        agricartLogo,
                        logosStartX + logoBgRadius - logoSize / 2,
                        logoY + logoBgRadius - logoSize / 2,
                        logoSize,
                        logoSize
                    );
                    ctx.drawImage(
                        calcoaLogo,
                        logosStartX + logoBgRadius + logoSize + logoGap - logoSize / 2,
                        logoY + logoBgRadius - logoSize / 2,
                        logoSize,
                        logoSize
                    );

                    // Header text
                    ctx.fillStyle = "#FFFEF9";
                    ctx.font = "700 30px 'Segoe UI', Arial";
                    ctx.textAlign = "center";
                    // Place brand text comfortably below the logos to avoid overlap
                    const brandTitleY = headerTop + headerHeight - 40;
                    const brandSubtitleY = headerTop + headerHeight - 18;

                    ctx.fillText("AgriCart", width / 2, brandTitleY);

                    ctx.font = "500 14px 'Segoe UI', Arial";
                    ctx.fillText(
                        "Cabintan Livelihood Community Agriculture â€“ Cooperative (CALCOA)",
                        width / 2,
                        brandSubtitleY
                    );

                    // Card body background (single column; QR centered below details)
                    const bodyX = 44;
                    const bodyY = headerTop + headerHeight + 16;
                    const bodyWidth = width - bodyX * 2;
                    const bodyHeight = height - bodyY - 30;
                    ctx.fillStyle = "#ffffff";
                    ctx.fillRect(bodyX, bodyY, bodyWidth, bodyHeight);

                    ctx.strokeStyle = "#e0e0e0";
                    ctx.lineWidth = 1;
                    ctx.strokeRect(bodyX, bodyY, bodyWidth, bodyHeight);

                    ctx.fillStyle = "#333333";
                    ctx.textAlign = "left";

                    let cursorY = bodyY + 30;
                    const leftMargin = bodyX + 20;

                    // "To:" section
                    ctx.font = "600 19px 'Segoe UI', Arial";
                    ctx.fillText("To:", leftMargin, cursorY);
                    cursorY += 8;
                    ctx.strokeStyle = "#e0e0e0";
                    ctx.beginPath();
                    ctx.moveTo(leftMargin, cursorY);
                    ctx.lineTo(bodyX + bodyWidth - 20, cursorY);
                    ctx.stroke();
                    cursorY += 24;

                    ctx.font = "600 17px 'Segoe UI', Arial";
                    ctx.fillText(toName, leftMargin, cursorY);
                    cursorY += 22;

                    ctx.font = "400 14px 'Segoe UI', Arial";
                    ctx.fillText(`Phone: ${toPhone}`, leftMargin, cursorY);
                    cursorY += 22;

                    const addressLines = toAddress.split(/\r?\n/).filter(Boolean);
                    ctx.fillText(addressLabel, leftMargin, cursorY);
                    cursorY += 20;
                    addressLines.forEach((line) => {
                        ctx.fillText(line, leftMargin + 10, cursorY);
                        cursorY += 18;
                    });

                    cursorY += 26;

                    // "From:" section
                    ctx.font = "600 19px 'Segoe UI', Arial";
                    ctx.fillText("From:", leftMargin, cursorY);
                    cursorY += 8;
                    ctx.strokeStyle = "#e0e0e0";
                    ctx.beginPath();
                    ctx.moveTo(leftMargin, cursorY);
                    ctx.lineTo(bodyX + bodyWidth - 20, cursorY);
                    ctx.stroke();
                    cursorY += 24;

                    ctx.font = "400 15px 'Segoe UI', Arial";
                    ctx.fillText(
                        "CALCOA: Purok 3, Brgy. Cabintan, Ormoc City, Leyte",
                        leftMargin,
                        cursorY
                    );
                    cursorY += 24;
                    ctx.fillText(`Phone Number: ${fromPhone}`, leftMargin, cursorY);
                    cursorY += 22;
                    ctx.fillText(`Email: ${fromEmail}`, leftMargin, cursorY);

                    cursorY += 30;

                    // Total Amount section (next to From section)
                    if (orderTotal !== null && orderTotal !== undefined && orderTotal !== "") {
                        const totalValue = parseFloat(orderTotal);
                        if (!isNaN(totalValue)) {
                            ctx.font = "600 19px 'Segoe UI', Arial";
                            ctx.fillText("Total Amount:", leftMargin, cursorY);
                            cursorY += 8;
                            ctx.strokeStyle = "#e0e0e0";
                            ctx.beginPath();
                            ctx.moveTo(leftMargin, cursorY);
                            ctx.lineTo(bodyX + bodyWidth - 20, cursorY);
                            ctx.stroke();
                            cursorY += 24;

                            // Same font size as other details
                            ctx.font = "400 15px 'Segoe UI', Arial";
                            ctx.fillText(`â‚±${totalValue.toFixed(2)}`, leftMargin, cursorY);
                            cursorY += 22;
                        }
                    }

                    // Order details
                    ctx.font = "600 17px 'Segoe UI', Arial";
                    ctx.fillText("Order Details", leftMargin, cursorY);
                    cursorY += 8;
                    ctx.strokeStyle = "#e0e0e0";
                    ctx.beginPath();
                    ctx.moveTo(leftMargin, cursorY);
                    ctx.lineTo(bodyX + bodyWidth - 20, cursorY);
                    ctx.stroke();
                    cursorY += 24;

                    ctx.font = "400 15px 'Segoe UI', Arial";
                    ctx.fillText(`Order Code: ${headerText}`, leftMargin, cursorY);
                    cursorY += 22;
                    ctx.fillText(`Order Date: ${orderDate}`, leftMargin, cursorY);
                    cursorY += 22;
                    ctx.fillText(`Generated At: ${generatedAt}`, leftMargin, cursorY);

                    // QR section centered below details
                    // Add more spacing after "Generated At" to prevent overlap
                    cursorY += 50; // Extra spacing after the last text line to prevent overflow
                    const qrBoxWidth = 160; // Further reduced width
                    const qrBoxHeight = 200; // Further reduced height
                    const qrBoxX = bodyX + (bodyWidth - qrBoxWidth) / 2;
                    let qrBoxY = cursorY + 20; // Additional spacing before QR box starts
                    // Prevent QR box from overflowing the bottom of the canvas
                    const bottomPadding = 40;
                    if (qrBoxY + qrBoxHeight + bottomPadding > height) {
                        qrBoxY = Math.max(
                            bodyY + 40,
                            height - bottomPadding - qrBoxHeight
                        );
                    }

                    ctx.fillStyle = "#fafafa";
                    ctx.strokeStyle = "#e0e0e0";
                    ctx.lineWidth = 1;
                    ctx.fillRect(qrBoxX, qrBoxY, qrBoxWidth, qrBoxHeight);
                    ctx.strokeRect(qrBoxX, qrBoxY, qrBoxWidth, qrBoxHeight);

                    ctx.fillStyle = "#333333";
                    ctx.font = "600 14px 'Segoe UI', Arial";
                    ctx.textAlign = "center";
                    ctx.fillText(
                        "Order Code",
                        qrBoxX + qrBoxWidth / 2,
                        qrBoxY + 22
                    );

                    ctx.font = "700 18px 'Segoe UI', Arial";
                    ctx.fillText(
                        headerText,
                        qrBoxX + qrBoxWidth / 2,
                        qrBoxY + 46
                    );

                    // Draw QR image - smaller to fit in reduced box and prevent overflow
                    const qrTargetSize = 120; // Further reduced to prevent overflow
                    const qrX = qrBoxX + (qrBoxWidth - qrTargetSize) / 2;
                    const qrY = qrBoxY + 60; // Adjusted vertical position
                    ctx.drawImage(qrImg, qrX, qrY, qrTargetSize, qrTargetSize);

                    resolve(canvas);
                };

                agricartLogo.onload = handleLoaded;
                calcoaLogo.onload = handleLoaded;
                qrImg.onload = handleLoaded;

                agricartLogo.onerror = reject;
                calcoaLogo.onerror = reject;
                qrImg.onerror = reject;
            } catch (e) {
                reject(e);
            }
        });
    }

    // Helper: convert data URL to Blob for Supabase upload
    _dataUrlToBlob(dataUrl) {
        const parts = dataUrl.split(",");
        const mimeMatch = parts[0].match(/:(.*?);/);
        const mime = mimeMatch ? mimeMatch[1] : "image/png";
        const binary = atob(parts[1]);
        const len = binary.length;
        const arr = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            arr[i] = binary.charCodeAt(i);
        }
        return new Blob([arr], { type: mime });
    }

    // Simple image lightbox for viewing saved packaging
    showImageLightbox(imageUrl) {
        try {
            if (!imageUrl) return;
            const existing = document.querySelector(
                ".modal-overlay[data-image-lightbox]"
            );
            if (existing) existing.remove();

            const overlay = document.createElement("div");
            overlay.className = "modal-overlay show";
            overlay.setAttribute("data-image-lightbox", "true");
            overlay.style.cssText =
                "position:fixed;inset:0;background:rgba(0,0,0,0.75);display:flex;align-items:center;justify-content:center;z-index:11000;";

            overlay.innerHTML = `
            <div style="position:relative;max-width:90vw;max-height:90vh;display:flex;align-items:center;justify-content:center;">
                <button style="position:absolute;top:-40px;right:0;background:none;border:none;color:#fff;font-size:28px;cursor:pointer;">&times;</button>
                <img src="${imageUrl}" alt="Packaging Preview" style="max-width:100%;max-height:90vh;border-radius:8px;box-shadow:0 8px 24px rgba(0,0,0,0.45);background:#fff;" />
            </div>
        `;

            overlay.addEventListener("click", (e) => {
                if (e.target === overlay || e.target.tagName === "BUTTON") {
                    overlay.remove();
                }
            });

            document.body.appendChild(overlay);
        } catch (e) {
            console.error("showImageLightbox error:", e);
        }
    }

    // Load contact support settings and apply them to the QR packaging template
    async _loadContactSupportSettingsForQr() {
        try {
            let supabase = null;
            if (typeof window.getSupabaseClient === "function") {
                supabase = window.getSupabaseClient();
            } else if (window.supabaseClient) {
                supabase = window.supabaseClient;
            }

            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            const { data, error } = await supabase
                .from("system_data")
                .select("support_email, support_phone")
                .eq("id", "contactSupport")
                .maybeSingle();

            if (error) {
                throw error;
            }

            const supportEmail =
                data?.support_email || "calcoacoop@gmail.com";
            const supportPhone =
                data?.support_phone || "+63 123 456 7890";

            const fromPhoneEl = document.getElementById("qr-from-phone");
            const fromEmailEl = document.getElementById("qr-from-email");

            if (fromPhoneEl) fromPhoneEl.textContent = supportPhone;
            if (fromEmailEl) fromEmailEl.textContent = supportEmail;
        } catch (error) {
            console.error(
                "Error loading contact support settings for QR packaging:",
                error
            );
        }
    }
    async sendOutForDeliveryNotification(orderId, order) {
        try {
            // Find customer by email or phone
            let customerId = null;

            // Try to find customer by email first
            if (order.customerEmail) {
                const customer = await CustomerHelpers.findCustomerByEmail(
                    order.customerEmail
                );
                if (customer) {
                    customerId = customer.uid;
                }
            }

            if (!customerId && order.customerPhone) {
                // Try to find customer by phone
                const customer = await CustomerHelpers.findCustomerByPhone(
                    order.customerPhone
                );
                if (customer) {
                    customerId = customer.uid;
                }
            }

            if (!customerId) {
                // Hard stop and inform staff so we don't silently miss a notification
                console.warn("Customer not found for order:", orderId);
                alert(
                    "Unable to send notification: customer not found for this order."
                );
                return;
            }

            // Create notification
            const totalAmount = order.total || order.totalAmount || 0;
            const formattedTotal =
                typeof totalAmount === "number"
                    ? `â‚±${totalAmount.toLocaleString()}`
                    : `${totalAmount}`;
            const notificationId = `out_for_delivery_${orderId}_${Date.now()}`;

            // Use sendCustomerNotification to send to Supabase
            await this.sendCustomerNotification(customerId, {
                id: notificationId,
                title: "Order Out for Delivery! ðŸšš",
                message: `Your order #${orderId
                    .slice(-8)
                    .toUpperCase()} is now out for delivery ðŸš›. Please prepare an amount of ${formattedTotal} and be ready to receive it.`,
                type: "order_out_for_delivery",
                timestamp: Date.now(),
                isRead: false,
                orderId: orderId,
            });

            console.log(
                "Out for delivery notification sent to customer:",
                customerId
            );
        } catch (error) {
            console.error("Error sending out for delivery notification:", error);
        }
    }

    async markToReceive(orderId) {
        try {
            const orderRef = dbRefs.orders.child(orderId);
            const snapshot = await orderRef.once("value");
            const order = snapshot.val();

            if (!order) {
                alert("Order not found");
                return;
            }

            // Show confirmation dialog
            const confirmed = confirm(
                'Are you sure you want to mark this order as "To Receive"? This will move it to the next phase and prevent cancellation.'
            );

            if (!confirmed) {
                return;
            }

            await orderRef.update({
                status: "to_receive",
                toReceiveAt: FirebaseUtils.getTimestamp(),
                toReceiveBy: sessionStorage.getItem("staffUid") || "staff",
                updatedAt: FirebaseUtils.getTimestamp(),
            });

            // Send notification to customer
            await this.sendToReceiveStatusNotification(orderId, order);

            this.showSuccessMessage("Order marked as To Receive");
            this.loadAssignedOrders();
            this.loadStats();
        } catch (error) {
            console.error("Error marking order as to receive:", error);
            alert("Error updating order: " + error.message);
        }
    }
    async sendToReceiveStatusNotification(orderId, order) {
        try {
            if (order && order.customerId) {
                await this.sendCustomerNotification(order.customerId, {
                    id: FirebaseUtils.generateId(),
                    title: "Order Ready for Delivery! ðŸ“¦",
                    message: `Your order #${orderId
                        .substr(-8)
                        .toUpperCase()} is now ready for delivery and will be shipped soon!`,
                    type: "order_to_receive",
                    orderId: orderId,
                    timestamp: Date.now(),
                    isRead: false,
                });
            }
        } catch (error) {
            console.error("Error sending to receive status notification:", error);
        }
    }
    async sendToReceiveNotification(orderId, order) {
        try {
            if (order && order.customerId) {
                await this.sendCustomerNotification(order.customerId, {
                    id: FirebaseUtils.generateId(),
                    title: "Order Out for Delivery! ðŸšš",
                    message: `Your order #${orderId
                        .substr(-8)
                        .toUpperCase()} is now out for delivery and will arrive soon!`,
                    type: "order_out_for_delivery",
                    orderId: orderId,
                    timestamp: Date.now(),
                    isRead: false,
                });
            }
        } catch (error) {
            console.error("Error sending to receive notification:", error);
        }
    }

    async markOrderReceived(orderId) {
        try {
            const orderRef = dbRefs.orders.child(orderId);
            const snapshot = await orderRef.once("value");
            const order = snapshot.val();

            if (!order) {
                alert("Order not found");
                return;
            }

            await orderRef.update({
                status: "delivered",
                receivedAt: FirebaseUtils.getTimestamp(),
                receivedBy: sessionStorage.getItem("staffUid") || "staff",
                updatedAt: FirebaseUtils.getTimestamp(),
            });

            // Send notification to customer
            await this.sendOrderReceivedNotification(orderId, order);

            this.showSuccessMessage("Order marked as received");
            this.loadAssignedOrders();
            this.loadStats();
        } catch (error) {
            console.error("Error marking order as received:", error);
            alert("Error updating order: " + error.message);
        }
    }

    async sendOrderReceivedNotification(orderId, order) {
        try {
            if (order && order.customerId) {
                await this.sendCustomerNotification(order.customerId, {
                    id: FirebaseUtils.generateId(),
                    title: "Order Received",
                    message: `Your order #${orderId
                        .substr(-8)
                        .toUpperCase()} has been successfully received! Please rate your experience.`,
                    type: "order_received",
                    orderId: orderId,
                    timestamp: Date.now(),
                    isRead: false,
                });
            }
        } catch (error) {
            console.error("Error sending order received notification:", error);
        }
    }

    async sendOrderDeliveredNotification(orderId, order) {
        try {
            if (order && order.customerId) {
                await this.sendCustomerNotification(order.customerId, {
                    id: FirebaseUtils.generateId(),
                    title: "Order Delivered",
                    message: `Your order #${orderId
                        .substr(-8)
                        .toUpperCase()} has been successfully delivered! Please rate your experience.`,
                    type: "order_delivered",
                    orderId: orderId,
                    timestamp: Date.now(),
                    isRead: false,
                });
            }
        } catch (error) {
            console.error("Error sending order delivered notification:", error);
        }
    }
    async sendPackedNotification(orderId, order) {
        try {
            if (order && order.customerId) {
                await this.sendCustomerNotification(order.customerId, {
                    id: FirebaseUtils.generateId(),
                    title: "Order Packed",
                    message: `Your order #${orderId
                        .substr(-8)
                        .toUpperCase()} has been packed and is ready for delivery! Note: Order can no longer be cancelled.`,
                    type: "order_packed",
                    orderId: orderId,
                    timestamp: Date.now(),
                    isRead: false,
                });
            }
        } catch (error) {
            console.error("Error sending packed notification:", error);
        }
    }

    async markDelivered(orderId) {
        try {
            const orderRef = dbRefs.orders.child(orderId);
            const snapshot = await orderRef.once("value");
            const order = snapshot.val();

            if (!order) {
                alert("Order not found");
                return;
            }

            // Preserve harvest dates in order items if not already saved
            const items = order.items || [];
            const itemsWithHarvestDates = await Promise.all(
                items.map(async (item) => {
                    if (item.productId && !item.harvestDate) {
                        // Get current harvest date from product
                        try {
                            const product = await ProductHelpers.getProduct(item.productId);
                            if (product) {
                                item.harvestDate =
                                    product.harvest_date || product.harvestDate || "";
                            }
                        } catch (error) {
                            console.error(
                                `Error getting harvest date for product ${item.productId}:`,
                                error
                            );
                        }
                    }
                    return item;
                })
            );

            const updateData = {
                status: "delivered",
                deliveredAt: FirebaseUtils.getTimestamp(),
                updatedAt: FirebaseUtils.getTimestamp(),
            };

            // Update order with preserved harvest dates if needed
            if (
                itemsWithHarvestDates.length > 0 &&
                itemsWithHarvestDates.some(
                    (item, idx) => item.harvestDate !== (items[idx]?.harvestDate || "")
                )
            ) {
                updateData.items = itemsWithHarvestDates;
            }

            await orderRef.update(updateData);

            // Send notification to customer
            await this.sendOrderDeliveredNotification(orderId, order);

            this.showSuccessMessage("Order marked as delivered");
            this.loadPendingOrders();
            this.loadAssignedOrders();
            this.loadStats();
        } catch (error) {
            console.error("Error marking delivered:", error);
            alert("Error updating order: " + error.message);
        }
    }
    async confirmOrder(orderId) {
        try {
            // Check if Supabase adapter is available
            if (!window.OrderSupabaseAdapter) {
                alert("Order system not available. Please refresh the page.");
                return;
            }

            // Fetch order from Supabase only
            const order = await OrderSupabaseAdapter.fetchOrderById(orderId);

            if (!order) {
                alert("Order not found");
                return;
            }

            // Preserve harvest dates in order items before confirming
            // This ensures historical records don't change
            const items = order.items || [];
            const itemsWithHarvestDates = await Promise.all(
                items.map(async (item) => {
                    if (item.productId && !item.harvestDate) {
                        // Get current harvest date from product
                        try {
                            const product = await ProductHelpers.getProduct(item.productId);
                            if (product) {
                                item.harvestDate =
                                    product.harvest_date || product.harvestDate || "";
                            }
                        } catch (error) {
                            console.error(
                                `Error getting harvest date for product ${item.productId}:`,
                                error
                            );
                        }
                    }
                    return item;
                })
            );

            // Update product quantities before confirming order
            await this.updateProductQuantities(order);

            // Get current user information
            const currentUid =
                sessionStorage.getItem("staffUid") ||
                sessionStorage.getItem("adminUid") ||
                null;
            let currentName =
                sessionStorage.getItem("staffName") ||
                sessionStorage.getItem("adminName") ||
                sessionStorage.getItem("username") ||
                null;
            const roleKey =
                sessionStorage.getItem("userRole") ||
                sessionStorage.getItem("adminRole") ||
                sessionStorage.getItem("staffRole");
            const currentRole =
                roleKey === "admin" || roleKey === "Administrator"
                    ? "Administrator"
                    : roleKey === "staff" || roleKey === "Staff"
                        ? "Staff"
                        : "Staff";

            // If name is not in session, try to get from database
            if (!currentName && currentUid && window.getSupabaseClient) {
                try {
                    const supabase = window.getSupabaseClient();
                    if (supabase) {
                        // Check if admin
                        const isAdmin =
                            sessionStorage.getItem("userRole") === "admin" ||
                            sessionStorage.getItem("adminRole") === "admin";
                        if (isAdmin) {
                            const { data: adminData } = await supabase
                                .from("admins")
                                .select("fullname, username")
                                .eq("uuid", currentUid)
                                .limit(1)
                                .single();
                            if (adminData) {
                                currentName = adminData.fullname || adminData.username || null;
                            }
                        } else {
                            const { data: staffData } = await supabase
                                .from("staff")
                                .select("full_name, fullName, name")
                                .eq("uuid", currentUid)
                                .limit(1)
                                .single();
                            if (staffData) {
                                currentName =
                                    staffData.full_name ||
                                    staffData.fullName ||
                                    staffData.name ||
                                    null;
                            }
                        }
                    }
                } catch (error) {
                    console.warn("Error fetching user name for confirmed_by:", error);
                }
            }

            // Prepare update data
            const nowMs = Date.now();

            const updateData = {
                status: "confirmed",
                confirmedAt: nowMs,
                confirmedBy: currentUid,
                confirmedByName: currentName,
                confirmedByRole: currentRole,
                updatedAt: nowMs,
                updatedBy: currentUid,
                updatedByName: currentName,
                updatedByRole: currentRole,
            };

            // Update order with preserved harvest dates if needed
            if (itemsWithHarvestDates.length > 0) {
                updateData.items = itemsWithHarvestDates;
            }

            // Update order in Supabase
            await OrderSupabaseAdapter.updateOrder(orderId, updateData);

            // Send notification to customer
            await this.sendConfirmationNotification(orderId, order);

            this.showSuccessMessage("Order confirmed and product quantities updated");
            this.loadPendingOrders();
            this.loadStats();
            this.loadProducts();
        } catch (error) {
            console.error("Error confirming order:", error);
            alert("Error confirming order: " + error.message);
        }
    }
    async markOrderAsToReceive(orderId) {
        try {
            // Check if Supabase adapter is available
            if (!window.OrderSupabaseAdapter) {
                alert("Order system not available. Please refresh the page.");
                return;
            }

            // Confirm action with user
            const confirmed = confirm(
                'Mark this order as "To Receive"? The order will be moved to the To Receive tab.'
            );
            if (!confirmed) return;

            // Fetch order from Supabase
            const order = await OrderSupabaseAdapter.fetchOrderById(orderId);

            if (!order) {
                alert("Order not found");
                return;
            }

            // Check if order is already in to_receive status
            if (String(order.status || "").toLowerCase() === "to_receive") {
                alert("Order is already marked as To Receive");
                return;
            }

            // Prepare update data
            const nowMs = Date.now();

            const updateData = {
                status: "to_receive",
                updatedAt: nowMs,
            };

            // Update order in Supabase
            await OrderSupabaseAdapter.updateOrder(orderId, updateData);

            this.showSuccessMessage("Order marked as To Receive successfully!");

            // Refresh assigned orders to show the order in the To Receive tab
            this.loadAssignedOrders();
            this.loadStats();
        } catch (error) {
            console.error("Error marking order as to receive:", error);
            alert("Error marking order as to receive: " + (error.message || error));
        }
    }
    async bulkMarkOrderAsToReceive(orderIds) {
        try {
            // Check if Supabase adapter is available
            if (!window.OrderSupabaseAdapter) {
                alert("Order system not available. Please refresh the page.");
                return;
            }

            if (!orderIds || orderIds.length === 0) {
                alert("No orders selected");
                return;
            }

            // Confirm action with user
            const confirmed = confirm(
                `Mark ${orderIds.length} order(s) as "To Receive"? The orders will be moved to the To Receive tab.`
            );
            if (!confirmed) return;

            const nowMs = Date.now();
            let successCount = 0;
            let failCount = 0;
            const errors = [];

            // Update each order
            for (const orderId of orderIds) {
                try {
                    // Fetch order from Supabase
                    const order = await OrderSupabaseAdapter.fetchOrderById(orderId);

                    if (!order) {
                        failCount++;
                        errors.push(`Order ${orderId.substr(-8).toUpperCase()}: Not found`);
                        continue;
                    }

                    // Check if order is already in to_receive status
                    if (String(order.status || "").toLowerCase() === "to_receive") {
                        failCount++;
                        errors.push(
                            `Order ${orderId
                                .substr(-8)
                                .toUpperCase()}: Already marked as To Receive`
                        );
                        continue;
                    }

                    // Prepare update data
                    const updateData = {
                        status: "to_receive",
                        updatedAt: nowMs,
                    };

                    // Update order in Supabase
                    await OrderSupabaseAdapter.updateOrder(orderId, updateData);
                    successCount++;
                } catch (error) {
                    failCount++;
                    errors.push(
                        `Order ${orderId.substr(-8).toUpperCase()}: ${error.message || error
                        }`
                    );
                    console.error(`Error marking order ${orderId} as to receive:`, error);
                }
            }

            // Show results
            if (successCount > 0) {
                this.showSuccessMessage(
                    `${successCount} order(s) marked as To Receive successfully!`
                );
            }

            if (failCount > 0) {
                const errorMsg = errors.join("\n");
                alert(`${failCount} order(s) failed to update:\n\n${errorMsg}`);
            }

            // Uncheck all checkboxes
            document.querySelectorAll(".confirmed-checkbox:checked").forEach((cb) => {
                cb.checked = false;
            });

            // Refresh assigned orders to show the orders in the To Receive tab
            this.loadAssignedOrders();
            this.loadStats();
        } catch (error) {
            console.error("Error in bulk mark order as to receive:", error);
            alert("Error marking orders as to receive: " + (error.message || error));
        }
    }
    // Manual test function for debugging
    async testOrderUpdate(orderId) {
        console.log("ðŸ§ª MANUAL TEST: Updating order status to confirmed");
        try {
            const orderRef = dbRefs.orders.child(orderId);

            // Read current order
            const snapshot = await orderRef.once("value");
            const order = snapshot.val();
            console.log("ðŸ“‹ Current order:", order);

            // Update status
            await orderRef.update({
                status: "confirmed",
                confirmedAt: FirebaseUtils.getTimestamp(),
                updatedAt: FirebaseUtils.getTimestamp(),
                confirmedBy: "test_staff",
                testUpdate: true,
                testTimestamp: Date.now(),
            });

            console.log("âœ“ Manual test update completed");

            // Verify update
            const verifySnapshot = await orderRef.once("value");
            const updatedOrder = verifySnapshot.val();
            console.log("ðŸ“‹ Updated order:", updatedOrder);
            console.log("ðŸ“Š Status after update:", updatedOrder?.status);

            // Also send a test notification
            if (order && order.customerId) {
                await this.sendCustomerNotification(order.customerId, {
                    id: "test_" + Date.now(),
                    title: "Test Order Confirmation",
                    message: `Test: Your order #${orderId
                        .substr(-8)
                        .toUpperCase()} has been confirmed for testing purposes.`,
                    type: "test_confirmation",
                    orderId: orderId,
                    timestamp: Date.now(),
                    isRead: false,
                });
                console.log("âœ“ Test notification sent");
            }

            return updatedOrder;
        } catch (error) {
            console.error("Ã¢Å’ Manual test failed:", error);
            return null;
        }
    }

    // Additional test function to force a customer app update
    async forceCustomerAppUpdate(orderId) {
        console.log("ðŸš€ FORCE CUSTOMER APP UPDATE for order:", orderId);
        try {
            const orderRef = dbRefs.orders.child(orderId);

            // Send multiple update triggers
            const triggers = [
                { forceUpdate: true, timestamp: Date.now() },
                { lastUpdate: FirebaseUtils.getTimestamp() },
                { updateTrigger: "manual_" + Date.now() },
            ];

            for (const trigger of triggers) {
                await orderRef.update(trigger);
                console.log("âœ“ Trigger sent:", trigger);
                await new Promise((resolve) => setTimeout(resolve, 100)); // Small delay
            }

            console.log("âœ“ All force update triggers sent");
            return true;
        } catch (error) {
            console.error("Ã¢ÂÅ’ Force update failed:", error);
            return false;
        }
    }

    async updateProductQuantities(order) {
        try {
            if (!order.items || !Array.isArray(order.items)) {
                console.log("No items to update in order");
                return;
            }

            for (const item of order.items) {
                if (item.productId && item.quantity) {
                    const product = await ProductHelpers.getProduct(item.productId);

                    if (product) {
                        const baseQty =
                            Number(product.availableQuantity ?? product.quantity ?? 0) || 0;
                        const reservedQty = Number(product.currentReserved ?? 0) || 0;
                        const qty = Number(item.quantity) || 0;

                        // On confirm: decrease reserved quantity only
                        // (availableQuantity was already decreased when order was placed)
                        // This releases the reserved quantity since order is now confirmed
                        const newReserved = Math.max(0, reservedQty - qty);

                        const updateData = {
                            currentReserved: newReserved,
                            updatedAt: Date.now(),
                        };

                        // If soldQuantity field exists, track it
                        const soldQty = Number(product.soldQuantity ?? 0) || 0;
                        if (product.soldQuantity !== undefined) {
                            updateData.soldQuantity = soldQty + qty;
                        }

                        await ProductHelpers.updateProduct(item.productId, updateData);

                        console.log(
                            `Confirmed order: ${product.name} base ${baseQty} (unchanged), reserved ${reservedQty}->${newReserved} (qty: ${qty})`
                        );
                    }
                }
            }
        } catch (error) {
            console.error("Error updating product quantities:", error);
            throw error;
        }
    }
    async sendConfirmationNotification(orderId, order) {
        try {
            // Don't send confirmation notification if order is cancelled or has cancellation confirmed
            if (order) {
                const orderStatus = String(order.status || "").toLowerCase();
                const isCancelled = orderStatus === "cancelled";
                const cancellationConfirmed =
                    order.cancellationConfirmed === true ||
                    order.cancellation_confirmed === true ||
                    order.cancellationConfirmed === 1 ||
                    order.cancellation_confirmed === 1;

                if (isCancelled || cancellationConfirmed) {
                    console.log(
                        `âš ï¸ Skipping confirmation notification for cancelled order: ${orderId}`
                    );
                    return;
                }
            }

            if (order && order.customerId) {
                await this.sendCustomerNotification(order.customerId, {
                    id: FirebaseUtils.generateId(),
                    title: "Order Confirmed! ðŸŽ‰",
                    message: `Your order #${orderId
                        .substr(-8)
                        .toUpperCase()} with a total of â‚±${order.total.toLocaleString()} has been confirmed and is being prepared for you!`,
                    type: "order_confirmed",
                    orderId: orderId,
                    timestamp: Date.now(),
                    isRead: false,
                });
            }
        } catch (error) {
            console.error("Error sending confirmation notification:", error);
        }
    }
    async rejectOrder(orderId) {
        try {
            const reason = prompt(
                "Please provide a reason for rejecting this order:"
            );
            if (!reason || reason.trim() === "") {
                alert("Please provide a reason for rejection.");
                return;
            }

            let order = (this._ordersCache && this._ordersCache[orderId]) || null;
            if (!order && window.OrderSupabaseAdapter) {
                order = await OrderSupabaseAdapter.fetchOrderById(orderId);
                if (order) {
                    if (!this._ordersCache) this._ordersCache = {};
                    this._ordersCache[orderId] = order;
                }
            }

            if (!order) {
                alert("Order not found");
                return;
            }

            // Release reserved quantities for pending orders
            if (String(order.status || "").toLowerCase() === "pending") {
                await this.releaseReservedQuantities(order);
            }

            // Restore base quantities for confirmed orders
            if (String(order.status || "").toLowerCase() === "confirmed") {
                await this.restoreProductQuantities(order);
            }

            const supabase = OrderSupabaseAdapter.getSupabaseClient
                ? window.getSupabaseClient?.() ||
                OrderSupabaseAdapter.getSupabaseClient()
                : null;
            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            const timestamp = Date.now();
            const rejectedById = this.userUid || this.getUserUid() || "system";
            const rejectedByName =
                this.userName || this.getUserName() || "Administrator";
            const userRole = sessionStorage.getItem("userRole");
            const rejectedByRole =
                userRole === "admin"
                    ? "Administrator"
                    : userRole === "staff"
                        ? "Staff"
                        : "Staff";
            const supabaseUpdate = {
                status: "rejected",
                rejection_reason: reason.trim(),
                rejected_at: timestamp,
                rejected_by: rejectedById,
                rejected_by_name: rejectedByName,
                rejected_by_role: rejectedByRole,
                updated_at: timestamp,
                updated_by: rejectedById,
                updated_by_name: rejectedByName,
                updated_by_role: rejectedByRole,
            };

            const identifier = order.id || order.orderId || order.order_id || orderId;
            const { error } = await supabase
                .from("orders")
                .update(supabaseUpdate)
                .match({ id: identifier });

            if (error) {
                console.error("Supabase rejectOrder update failed:", error);
                throw error;
            }

            // Sync order status to Firebase Database for push notifications
            try {
                if (window.OrderSupabaseAdapter && typeof window.OrderSupabaseAdapter.syncOrderStatusToFirebase === 'function') {
                    await window.OrderSupabaseAdapter.syncOrderStatusToFirebase(identifier, "rejected", { ...order, ...supabaseUpdate, customer_id: order.customerId || order.customer_id });
                }
            } catch (syncError) {
                console.warn("âš ï¸ Failed to sync rejected order status to Firebase:", syncError);
            }

            this._ordersCache[orderId] = {
                ...order,
                status: "rejected",
                rejectionReason: reason.trim(),
                rejectedAt: timestamp,
                rejectedBy: rejectedById,
                rejectedByName: rejectedByName,
                rejectedByRole: rejectedByRole,
                updatedAt: timestamp,
                updatedBy: rejectedById,
                updatedByName: rejectedByName,
                updatedByRole: rejectedByRole,
            };

            await this.sendRejectionNotification(
                orderId,
                reason.trim(),
                this._ordersCache[orderId]
            );

            this.showSuccessMessage("Order rejected");
            this.loadPendingOrders();
            this.loadStats();
            this.loadProducts();
        } catch (error) {
            console.error("Error rejecting order:", error);
            alert("Error rejecting order: " + error.message);
        }
    }

    // Show reschedule confirmation modal
    showRescheduleConfirmation(orderId) {
        try {
            console.log("showRescheduleConfirmation called for order:", orderId);

            // Remove any existing modals first
            const existingModals = document.querySelectorAll(".modal-overlay");
            existingModals.forEach((m) => m.remove());

            const modal = document.createElement("div");
            modal.className = "modal-overlay show";
            modal.id = "reschedule-modal-" + orderId;
            modal.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 100% !important;
                height: 100% !important;
                background: rgba(0,0,0,0.5) !important;
                display: flex !important;
                justify-content: center !important;
                align-items: center !important;
                z-index: 99999 !important;
            `;

            const handleConfirm = () => {
                if (
                    window.staffManager &&
                    typeof window.staffManager.rescheduleOrderNextWeek === "function"
                ) {
                    window.staffManager
                        .rescheduleOrderNextWeek(orderId)
                        .then(() => {
                            modal.remove();
                            if (
                                window.staffManager &&
                                typeof window.staffManager.loadPendingOrders === "function"
                            ) {
                                window.staffManager.loadPendingOrders();
                            }
                        })
                        .catch((err) => {
                            console.error("Error rescheduling order:", err);
                            alert("Error rescheduling order: " + (err.message || err));
                        });
                } else {
                    alert("Reschedule function not available");
                }
            };

            const handleCancel = () => {
                modal.remove();
            };

            modal.innerHTML = `
                <div style="background: white; border-radius: 8px; padding: 24px; max-width: 400px; width: 90%; box-shadow: 0 4px 20px rgba(0,0,0,0.15); z-index: 100000; position: relative;">
                    <div style="text-align: center; margin-bottom: 20px;">
                        <i class="fas fa-calendar-week" style="font-size: 48px; color: #ff9800; margin-bottom: 12px;"></i>
                        <h3 style="margin: 0 0 8px 0; color: #333;">Reschedule Order</h3>
                        <p style="margin: 0; color: #666; line-height: 1.4;">Are you sure you want to reschedule this order? This action cannot be undone or changed later on.</p>
                    </div>
                    <div style="display: flex; gap: 12px; justify-content: center;">
                        <button id="reschedule-confirm-btn-${orderId}" 
                                style="background: #ff9800; color: white; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer; font-weight: 500;">
                            <i class="fas fa-check"></i> Confirm
                        </button>
                        <button id="reschedule-cancel-btn-${orderId}" 
                                style="background: #6c757d; color: white; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer; font-weight: 500;">
                            <i class="fas fa-times"></i> Cancel
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // Attach event listeners
            const confirmBtn = document.getElementById(
                "reschedule-confirm-btn-" + orderId
            );
            const cancelBtn = document.getElementById(
                "reschedule-cancel-btn-" + orderId
            );
            if (confirmBtn) confirmBtn.addEventListener("click", handleConfirm);
            if (cancelBtn) cancelBtn.addEventListener("click", handleCancel);

            console.log("âœ… Reschedule modal appended to body");

            // Also add click handler to close on backdrop click
            modal.addEventListener("click", function (e) {
                if (e.target === modal) {
                    handleCancel();
                }
            });
        } catch (error) {
            console.error("Error showing reschedule confirmation modal:", error);
            alert("Error showing reschedule modal: " + error.message);
        }
    }

    // Show refund modal with cancel option and file upload
    showRefundModal(orderId) {
        try {
            console.log("showRefundModal called for order:", orderId);

            // Preserve active-orders modal if we are in deactivation context (hide, don't remove)
            let preservedActiveOrdersModal = null;
            const isFromDeactivation = window._deactivationRefundCustomerId !== undefined;
            const allModals = document.querySelectorAll(".modal-overlay");
            if (isFromDeactivation) {
                for (const m of allModals) {
                    if (m.id && m.id.startsWith("active-orders-modal-")) {
                        preservedActiveOrdersModal = m;
                        m.style.display = "none"; // hide instead of remove
                    } else {
                        m.remove();
                    }
                }
            } else {
                // Normal flow: remove all existing modals
                allModals.forEach((m) => m.remove());
            }

            const modal = document.createElement("div");
            modal.className = "modal-overlay show";
            modal.id = "refund-modal-" + orderId;
            modal.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 100% !important;
                height: 100% !important;
                background: rgba(0,0,0,0.5) !important;
                display: flex !important;
                justify-content: center !important;
                align-items: center !important;
                z-index: 99999 !important;
            `;

            let selectedFile = null;
            let filePreviewUrl = null;

            const handleFileSelect = (e) => {
                const file = e.target.files[0];
                if (file) {
                    selectedFile = file;
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        filePreviewUrl = event.target.result;
                        const previewDiv = document.getElementById(
                            "refund-preview-" + orderId
                        );
                        if (previewDiv) {
                            previewDiv.innerHTML = `
                                <div style="margin-top: 12px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #dee2e6;">
                                    <div style="font-size: 12px; color: #666; margin-bottom: 8px;">Selected file: ${file.name}</div>
                                    <img src="${filePreviewUrl}" alt="Receipt preview" style="max-width: 100%; max-height: 200px; border-radius: 4px; border: 1px solid #dee2e6;" />
                                </div>
                            `;
                        }
                        const confirmBtn = document.getElementById(
                            "refund-confirm-btn-" + orderId
                        );
                        if (confirmBtn) {
                            confirmBtn.disabled = false;
                            confirmBtn.style.opacity = "1";
                            confirmBtn.style.cursor = "pointer";
                        }
                    };
                    reader.readAsDataURL(file);
                } else {
                    // Reset button state if no file
                    const confirmBtn = document.getElementById(
                        "refund-confirm-btn-" + orderId
                    );
                    if (confirmBtn) {
                        confirmBtn.disabled = true;
                        confirmBtn.style.opacity = "0.5";
                        confirmBtn.style.cursor = "not-allowed";
                    }
                }
            };

            const handleConfirm = async () => {
                if (!selectedFile) {
                    alert("Please select a GCash refund receipt image first.");
                    return;
                }

                const confirmBtn = document.getElementById(
                    "refund-confirm-btn-" + orderId
                );
                if (confirmBtn) {
                    confirmBtn.disabled = true;
                    confirmBtn.innerHTML =
                        '<i class="fas fa-spinner fa-spin"></i> Processing...';
                }

                try {
                    // For cut-off time refund: immediately confirm cancellation with refund
                    // Note: Do NOT call releaseReservedQuantities here - confirmCancelledRefund already handles stock restoration
                    // Calling it here would cause double restoration (restoring twice the quantity)

                    // Confirm cancellation with refund
                    // This will upload receipt, mark as cancelled, restore stock, and move to cancelled tab
                    if (
                        window.staffManager &&
                        typeof window.staffManager.confirmCancelledRefund === "function"
                    ) {
                        // The file is already selected in the input from handleFileSelect
                        // confirmCancelledRefund will handle the upload, confirmation, and stock restoration
                        await window.staffManager.confirmCancelledRefund(orderId);
                    } else {
                        throw new Error("Refund confirmation function not available");
                    }

                    modal.remove();

                    // If we hid an active orders modal, bring it back and mark refund as processed (do NOT rebuild or remove it)
                    if (isFromDeactivation && preservedActiveOrdersModal) {
                        preservedActiveOrdersModal.style.display = "flex";
                        const refundSection = document.getElementById(`refund-section-${orderId}`);
                        if (refundSection) {
                            refundSection.innerHTML = `
                <div style="display: flex; align-items: center; gap: 8px; color: #4caf50;">
                  <i class="fas fa-check-circle"></i>
                  <span style="font-size: 12px; font-weight: 500;">Refund processed</span>
                </div>
              `;
                        }
                        // Lightweight success toast
                        const successMsg = document.createElement("div");
                        successMsg.style.cssText = `
              position: fixed;
              top: 20px;
              right: 20px;
              background: #4caf50;
              color: white;
              padding: 12px 24px;
              border-radius: 6px;
              box-shadow: 0 4px 12px rgba(0,0,0,0.15);
              z-index: 100000;
              font-weight: 500;
            `;
                        successMsg.innerHTML = '<i class="fas fa-check-circle"></i> Refund processed successfully';
                        document.body.appendChild(successMsg);
                        setTimeout(() => successMsg.remove(), 3000);
                    } else {
                        // Refresh all sections to show updated order status (normal flow)
                        if (window.staffManager) {
                            if (window.staffManager.loadPendingOrders) {
                                window.staffManager.loadPendingOrders();
                            }
                            if (window.staffManager.loadCancelledOrders) {
                                window.staffManager.loadCancelledOrders();
                            }
                            if (window.staffManager.loadProducts) {
                                window.staffManager.loadProducts();
                            }
                        }

                        alert(
                            "Refund processed successfully. Order has been moved to Cancelled tab."
                        );
                    }
                } catch (err) {
                    console.error("Error processing refund:", err);
                    alert("Error processing refund: " + (err.message || err));
                    if (confirmBtn) {
                        confirmBtn.disabled = false;
                        confirmBtn.innerHTML = '<i class="fas fa-undo"></i> Process Refund';
                    }
                }
            };

            const handleCancel = () => {
                modal.remove();
                // Restore active-orders modal if we hid it
                if (isFromDeactivation && preservedActiveOrdersModal) {
                    preservedActiveOrdersModal.style.display = "flex";
                }
            };

            modal.innerHTML = `
                <div style="background: white; border-radius: 8px; padding: 24px; max-width: 500px; width: 90%; box-shadow: 0 4px 20px rgba(0,0,0,0.15); z-index: 100000; position: relative; max-height: 90vh; overflow-y: auto;">
                    <div style="text-align: center; margin-bottom: 20px;">
                        <i class="fas fa-undo" style="font-size: 48px; color: #4caf50; margin-bottom: 12px;"></i>
                        <h3 style="margin: 0 0 8px 0; color: #333;">Refund Order</h3>
                        <p style="margin: 0; color: #666; line-height: 1.4;">Upload the GCash refund receipt before confirming the refund.</p>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <label for="refund-receipt-${orderId}" style="display: block; margin-bottom: 8px; font-weight: 500; color: #333;">GCash Refund Receipt:</label>
                        <input type="file" id="refund-receipt-${orderId}" accept="image/*" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 12px;" />
                        <div id="refund-preview-${orderId}"></div>
                    </div>
                    
                    <div style="display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;">
                        <button id="refund-confirm-btn-${orderId}" 
                                disabled
                                style="background: #4caf50; color: white; border: none; padding: 12px 24px; border-radius: 6px; cursor: not-allowed; font-weight: 500; opacity: 0.5;">
                            <i class="fas fa-undo"></i> Process Refund
                        </button>
                        <button id="refund-cancel-btn-${orderId}" 
                                style="background: #6c757d; color: white; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer; font-weight: 500;">
                            <i class="fas fa-times"></i> Cancel
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // Attach event listeners
            const fileInput = document.getElementById("refund-receipt-" + orderId);
            const confirmBtn = document.getElementById(
                "refund-confirm-btn-" + orderId
            );
            const cancelBtn = document.getElementById("refund-cancel-btn-" + orderId);

            if (fileInput) fileInput.addEventListener("change", handleFileSelect);
            if (confirmBtn) {
                confirmBtn.addEventListener("click", handleConfirm);
                // Initially disable confirm button until file is selected
                confirmBtn.disabled = true;
                confirmBtn.style.opacity = "0.5";
                confirmBtn.style.cursor = "not-allowed";
            }
            if (cancelBtn) cancelBtn.addEventListener("click", handleCancel);

            console.log("âœ… Refund modal appended to body");

            // Also add click handler to close on backdrop click
            modal.addEventListener("click", function (e) {
                if (e.target === modal) {
                    handleCancel();
                }
            });
        } catch (error) {
            console.error("Error showing refund modal:", error);
            alert("Error showing refund modal: " + error.message);
        }
    }

    // Show reject modal with cancel option
    showRejectModal(orderId) {
        const modal = document.createElement("div");
        modal.className = "modal-overlay";
        modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        `;

        modal.innerHTML = `
            <div style="background: white; border-radius: 8px; padding: 24px; max-width: 400px; width: 90%; box-shadow: 0 4px 20px rgba(0,0,0,0.15);">
                <div style="text-align: center; margin-bottom: 20px;">
                    <i class="fas fa-times" style="font-size: 48px; color: #f44336; margin-bottom: 12px;"></i>
                    <h3 style="margin: 0 0 8px 0; color: #333;">Reject Order</h3>
                    <p style="margin: 0; color: #666; line-height: 1.4;">Reject this order. You will need to provide a reason for rejection.</p>
                </div>
                <div style="display: flex; gap: 12px; justify-content: center;">
                    <button onclick="staffManager.rejectOrder('${orderId}'); this.closest('.modal-overlay').remove();" 
                            style="background: #f44336; color: white; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer; font-weight: 500;">
                        <i class="fas fa-times"></i> Reject Order
                    </button>
                    <button onclick="this.closest('.modal-overlay').remove();" 
                            style="background: #6c757d; color: white; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer; font-weight: 500;">
                        <i class="fas fa-times"></i> Cancel
                    </button>
                </div>
            </div>
        `;

        document.body.appendChild(modal);
    }

    // Show confirm order dialog
    showConfirmOrderDialog(orderId) {
        const modal = document.createElement("div");
        modal.className = "modal-overlay";
        modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        `;

        modal.innerHTML = `
            <div style="background: white; border-radius: 8px; padding: 24px; max-width: 400px; width: 90%; box-shadow: 0 4px 20px rgba(0,0,0,0.15);">
                <div style="text-align: center; margin-bottom: 20px;">
                    <i class="fas fa-check-circle" style="font-size: 48px; color: #4caf50; margin-bottom: 12px;"></i>
                    <h3 style="margin: 0 0 8px 0; color: #333;">Confirm Order</h3>
                    <p style="margin: 0; color: #666; line-height: 1.4;">Are you sure you want to confirm this order? This action cannot be undone or changed later on.</p>
                </div>
                <div style="display: flex; gap: 12px; justify-content: center;">
                    <button onclick="staffManager.confirmOrder('${orderId}'); this.closest('.modal-overlay').remove();" 
                            style="background: #4caf50; color: white; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer; font-weight: 500;">
                        <i class="fas fa-check"></i> Confirm
                    </button>
                    <button onclick="this.closest('.modal-overlay').remove();" 
                            style="background: #6c757d; color: white; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer; font-weight: 500;">
                        <i class="fas fa-times"></i> Cancel
                    </button>
                </div>
            </div>
        `;

        document.body.appendChild(modal);
    }

    // Cancel refund process and return to original state
    async cancelRefundProcess(orderId) {
        try {
            const confirmMsg =
                "Are you sure you want to cancel the refund process? This will return the order to its original state.";
            if (!confirm(confirmMsg)) return;

            const orderRef = dbRefs.orders.child(orderId);
            const snap = await orderRef.once("value");
            const order = snap.val() || {};

            // Revert the refund process by removing the cancellation flags
            const updates = {
                cancellationRequested: false,
                cancellationConfirmed: false,
                cancellationInitiatedBy: null,
                updatedAt: FirebaseUtils.getTimestamp(),
            };

            // Restore reserved quantities since we're canceling the refund
            try {
                await this.restoreReservedQuantities(order);
            } catch (err) {
                console.log("Could not restore reserved quantities:", err);
            }

            await orderRef.update(updates);

            this.showSuccessMessage(
                "Refund process cancelled. Order returned to original state."
            );
            this.loadPendingOrders();
            this.loadStats();
            this.loadProducts(); // Refresh product listing
        } catch (error) {
            console.error("Error canceling refund process:", error);
            alert("Error canceling refund process: " + error.message);
        }
    }

    async releaseReservedQuantities(order) {
        try {
            if (!order.items || !Array.isArray(order.items)) {
                console.log("No items to release from reserved for order");
                return;
            }

            for (const item of order.items) {
                if (item.productId && item.quantity) {
                    const product =
                        (await ProductHelpers.getProduct(item.productId)) || {};

                    const currentReserved = Number(product.currentReserved ?? 0) || 0;
                    const baseQty =
                        Number(product.availableQuantity ?? product.quantity ?? 0) || 0;
                    const qty = Number(item.quantity || 0);

                    // For rejected pending orders: increase available_quantity (add back) AND decrease current_reserved
                    const newReserved = Math.max(0, currentReserved - qty);
                    const newBase = baseQty + qty; // Add back to available quantity

                    await ProductHelpers.updateProduct(item.productId, {
                        availableQuantity: newBase,
                        currentReserved: newReserved,
                        updatedAt: Date.now(),
                    });

                    console.log(
                        `Released reserved for product ${product.name || item.productId
                        }: available_quantity ${baseQty}->${newBase} (+${qty}), current_reserved ${currentReserved}->${newReserved} (-${qty})`
                    );
                }
            }
        } catch (error) {
            console.error("Error releasing reserved quantities:", error);
            throw error;
        }
    }

    async restoreReservedQuantities(order) {
        try {
            if (!order.items || !Array.isArray(order.items)) {
                console.log("No items to restore reserved for order");
                return;
            }

            for (const item of order.items) {
                if (item.productId && item.quantity) {
                    const product =
                        (await ProductHelpers.getProduct(item.productId)) || {};

                    const currentReserved = Number(product.currentReserved ?? 0) || 0;
                    const newReserved = currentReserved + Number(item.quantity || 0);

                    await ProductHelpers.updateProduct(item.productId, {
                        currentReserved: newReserved,
                        updatedAt: Date.now(),
                    });

                    console.log(
                        `Restored reserved for product ${product.name || item.productId
                        }: ${currentReserved} -> ${newReserved} (restored: ${item.quantity
                        })`
                    );
                }
            }
        } catch (error) {
            console.error("Error restoring reserved quantities:", error);
            throw error;
        }
    }

    // Decrease reserved quantity only (for reschedule/confirm) - available quantity unchanged
    async decreaseReservedQuantities(order) {
        try {
            if (!order.items || !Array.isArray(order.items)) {
                console.log("No items to decrease reserved for order");
                return;
            }

            for (const item of order.items) {
                if (item.productId && item.quantity) {
                    const product =
                        (await ProductHelpers.getProduct(item.productId)) || {};

                    const currentReserved = Number(product.currentReserved ?? 0) || 0;
                    const baseQty =
                        Number(product.availableQuantity ?? product.quantity ?? 0) || 0;
                    const qty = Number(item.quantity || 0);

                    // For reschedule/confirm: decrease current_reserved only, available_quantity unchanged
                    const newReserved = Math.max(0, currentReserved - qty);

                    await ProductHelpers.updateProduct(item.productId, {
                        currentReserved: newReserved,
                        // availableQuantity stays the same (not updated)
                        updatedAt: Date.now(),
                    });

                    console.log(
                        `Decreased reserved for product ${product.name || item.productId
                        }: current_reserved ${currentReserved}->${newReserved} (-${qty}), available_quantity ${baseQty} (unchanged)`
                    );
                }
            }
        } catch (error) {
            console.error("Error decreasing reserved quantities:", error);
            throw error;
        }
    }

    async restoreProductQuantities(order) {
        try {
            if (!order.items || !Array.isArray(order.items)) {
                console.log("No items to restore in order");
                return;
            }

            for (const item of order.items) {
                if (item.productId && item.quantity) {
                    const product = await ProductHelpers.getProduct(item.productId);

                    if (product) {
                        const currentQuantity =
                            product.availableQuantity || product.quantity || 0;
                        const restoredQuantity = currentQuantity + item.quantity;

                        await ProductHelpers.updateProduct(item.productId, {
                            availableQuantity: restoredQuantity,
                            updatedAt: Date.now(),
                        });

                        console.log(
                            `Restored product ${product.name}: ${currentQuantity} -> ${restoredQuantity} (restored: ${item.quantity})`
                        );
                    }
                }
            }
        } catch (error) {
            console.error("Error restoring product quantities:", error);
            throw error;
        }
    }

    async sendRejectionNotification(orderId, reason, orderOverride = null) {
        try {
            let order = orderOverride;
            if (!order) {
                order = (this._ordersCache && this._ordersCache[orderId]) || null;
            }
            if (!order && window.OrderSupabaseAdapter) {
                order = await OrderSupabaseAdapter.fetchOrderById(orderId);
            }
            if (!order) return;

            const customerId = order.customerId || order.customer_id || null;
            if (!customerId) return;

            const supabase = OrderSupabaseAdapter.getSupabaseClient
                ? OrderSupabaseAdapter.getSupabaseClient()
                : null;
            if (!supabase) {
                console.error(
                    "Supabase client not available; cannot write rejection notification"
                );
                return;
            }

            const timestamp = Date.now();
            const payload = {
                id: `notif_${timestamp}_${Math.random().toString(36).slice(2, 8)}`,
                customer_id: customerId,
                order_id: orderId,
                title: "Order Rejected",
                message: `Your order #${orderId
                    .substr(-8)
                    .toUpperCase()} has been rejected. Reason: ${reason}`,
                type: "order_rejected",
                is_read: false,
                created_at: timestamp,
                metadata: {
                    reason: reason,
                    status: order.status || "rejected",
                },
            };

            const { error } = await supabase.from("notifications").insert([payload]);
            if (error) {
                console.error("Supabase notifications insert failed:", error);
            }
        } catch (error) {
            console.error("Error sending rejection notification:", error);
        }
    }

    async loadSectionData(sectionId) {
        switch (sectionId) {
            case "staff-overview":
                console.log("Loading dashboard overview data...");
                try {
                    // Load all dashboard data: stats, products, and pending orders
                    // Use resilient API call for slow connections
                    const loadPromises = [];

                    if (typeof window.resilientApiCall === "function") {
                        loadPromises.push(
                            window.resilientApiCall(() => this.loadStats(), sectionId)
                        );
                        loadPromises.push(
                            window.resilientApiCall(() => this.loadProducts(), sectionId)
                        );
                        loadPromises.push(
                            window.resilientApiCall(() => this.loadPendingOrders(), sectionId)
                        );
                    } else {
                        loadPromises.push(this.loadStats());
                        loadPromises.push(this.loadProducts());
                        loadPromises.push(this.loadPendingOrders());
                    }

                    // Wait for all data to load
                    await Promise.all(loadPromises);

                    // Refresh system health status (especially for admin users to show Supabase status)
                    if (typeof this.refreshSystemHealth === "function") {
                        this.refreshSystemHealth();
                    }

                    // Wait a bit more to ensure DOM updates are complete
                    await new Promise((resolve) => setTimeout(resolve, 100));

                    console.log("Dashboard overview data loaded completely");

                    // Hide loading message after stats actually load (ensures minimum 2-second display)
                    if (typeof window.hideSectionLoading === "function") {
                        window.hideSectionLoading(sectionId);
                    }
                } catch (error) {
                    console.error("Error loading dashboard overview:", error);
                    // Check if it's a network error
                    if (
                        typeof window.isNetworkError === "function" &&
                        window.isNetworkError(error)
                    ) {
                        if (typeof window.showNetworkError === "function") {
                            window.showNetworkError(sectionId);
                        }
                    } else {
                        if (typeof window.hideSectionLoading === "function") {
                            window.hideSectionLoading(sectionId);
                        }
                    }
                }
                break;
            case "product-listing":
                console.log("Loading products...");
                try {
                    // Use resilient API call for slow connections
                    if (typeof window.resilientApiCall === "function") {
                        await window.resilientApiCall(() => this.loadProducts(), sectionId);
                    } else {
                        await this.loadProducts();
                    }
                    // Hide loading message after products actually load
                    if (typeof window.hideSectionLoading === "function") {
                        window.hideSectionLoading(sectionId);
                    }
                } catch (error) {
                    console.error("Error loading products:", error);
                    // Check if it's a network error
                    if (
                        typeof window.isNetworkError === "function" &&
                        window.isNetworkError(error)
                    ) {
                        if (typeof window.showNetworkError === "function") {
                            window.showNetworkError(sectionId);
                        }
                    } else {
                        if (typeof window.hideSectionLoading === "function") {
                            window.hideSectionLoading(sectionId);
                        }
                    }
                }
                break;
            case "order-management":
                console.log("Loading orders...");
                try {
                    // Use resilient API call for slow connections
                    if (typeof window.resilientApiCall === "function") {
                        await window.resilientApiCall(
                            () => this.loadPendingOrders(),
                            sectionId
                        );
                    } else {
                        await this.loadPendingOrders();
                    }
                    // Loading interface removed - no hideSectionLoading call needed
                } catch (error) {
                    console.error("Error loading orders:", error);
                    // Loading interface removed - no error message display
                }
                break;
            case "assign-orders":
                console.log("Loading assigned orders...");
                try {
                    // Use resilient API call for slow connections
                    if (typeof window.resilientApiCall === "function") {
                        await window.resilientApiCall(
                            () => this.loadAssignedOrders(),
                            sectionId
                        );
                    } else {
                        await this.loadAssignedOrders();
                    }
                    setTimeout(() => {
                        if (!this.__assignTabsBound) {
                            this.bindAssignTabs();
                        }
                        this.switchAssignTab("confirmed");
                    }, 0);
                    // Loading interface removed - no hideSectionLoading call needed
                } catch (error) {
                    console.error("Error loading assigned orders:", error);
                    // Loading interface removed - no error message display
                }
                break;
            case "user-management":
                console.log("Loading user management data...");
                try {
                    // Use resilient API call for slow connections (loading message removed)
                    const loadUserData = () => {
                        if (this.currentTab) {
                            return this.loadUserManagementData(this.currentTab);
                        } else {
                            return this.loadUserManagementData("farmer-users");
                        }
                    };

                    if (typeof window.resilientApiCall === "function") {
                        await window.resilientApiCall(loadUserData, sectionId);
                    } else {
                        await loadUserData();
                    }
                    // Loading message removed for user-management module
                } catch (error) {
                    console.error("Error loading user management data:", error);
                    // Loading message and network error display removed for user-management module
                }
                break;
            case "sales-monitor":
                try {
                    // Use resilient API call for slow connections
                    if (typeof window.resilientApiCall === "function") {
                        await window.resilientApiCall(
                            () => this.loadSalesData(),
                            sectionId
                        );
                    } else {
                        await this.loadSalesData();
                    }
                    if (typeof window.hideSectionLoading === "function") {
                        window.hideSectionLoading(sectionId);
                    }
                } catch (error) {
                    console.error("Error loading sales data:", error);
                    // Check if it's a network error
                    if (
                        typeof window.isNetworkError === "function" &&
                        window.isNetworkError(error)
                    ) {
                        if (typeof window.showNetworkError === "function") {
                            window.showNetworkError(sectionId);
                        }
                    } else {
                        if (typeof window.hideSectionLoading === "function") {
                            window.hideSectionLoading(sectionId);
                        }
                    }
                }
                break;
            case "reports-analytics":
                try {
                    // Use resilient API call for slow connections
                    const loadAnalytics = async () => {
                        await this.loadAnalyticsData("weekly");
                        // Refresh system health status when viewing analytics
                        if (typeof this.refreshSystemHealth === "function") {
                            this.refreshSystemHealth();
                        }
                    };

                    if (typeof window.resilientApiCall === "function") {
                        await window.resilientApiCall(loadAnalytics, sectionId);
                    } else {
                        await loadAnalytics();
                    }
                    // Hide loading message after analytics actually load
                    if (typeof window.hideSectionLoading === "function") {
                        window.hideSectionLoading(sectionId);
                    }
                } catch (error) {
                    console.error("Error loading analytics:", error);
                    // Check if it's a network error
                    if (
                        typeof window.isNetworkError === "function" &&
                        window.isNetworkError(error)
                    ) {
                        if (typeof window.showNetworkError === "function") {
                            window.showNetworkError(sectionId);
                        }
                    } else {
                        if (typeof window.hideSectionLoading === "function") {
                            window.hideSectionLoading(sectionId);
                        }
                    }
                }
                break;
            case "delivery-settings":
                try {
                    // Use resilient API call for slow connections
                    const loadDeliverySettings = async () => {
                        await Promise.all([
                            this.reloadDeliverySettings(),
                            // Load pickup areas using the pickupArea system (like backup)
                            this.loadPickupAreaRecords(),
                            // Also try loadPickupArea as fallback
                            this.loadPickupArea().catch(() => { }), // Ignore errors for fallback
                        ]);
                    };

                    if (typeof window.resilientApiCall === "function") {
                        await window.resilientApiCall(loadDeliverySettings, sectionId);
                    } else {
                        await loadDeliverySettings();
                    }
                    // Hide loading message after delivery settings actually load
                    if (typeof window.hideSectionLoading === "function") {
                        window.hideSectionLoading(sectionId);
                    }
                } catch (error) {
                    console.error("Error loading delivery settings:", error);
                    // Check if it's a network error
                    if (
                        typeof window.isNetworkError === "function" &&
                        window.isNetworkError(error)
                    ) {
                        if (typeof window.showNetworkError === "function") {
                            window.showNetworkError(sectionId);
                        }
                    } else {
                        if (typeof window.hideSectionLoading === "function") {
                            window.hideSectionLoading(sectionId);
                        }
                    }
                }
                break;
        }
    }

    bindAssignTabs() {
        this.__assignTabsBound = true;
        document.querySelectorAll(".assign-tab-btn").forEach((btn) => {
            btn.addEventListener("click", () => {
                const tab = btn.getAttribute("data-assign-tab");
                this.switchAssignTab(tab);
            });
        });
    }

    switchAssignTab(tabKey) {
        // Loading interface removed - tabs switch immediately without loading message

        document
            .querySelectorAll(".assign-tab-btn")
            .forEach((b) => b.classList.remove("active"));
        const activeBtn = document.querySelector(
            `.assign-tab-btn[data-assign-tab="${tabKey}"]`
        );
        if (activeBtn) activeBtn.classList.add("active");
        document
            .querySelectorAll("#assign-orders .tab-content")
            .forEach((tc) => tc.classList.remove("active"));
        const activeEl = document.getElementById(`assign-tab-${tabKey}`);
        if (activeEl) {
            activeEl.classList.add("active");
        }

        // Reload data when switching to confirmed tab to ensure filter is applied
        // This ensures cancelled orders are filtered out even if they were previously displayed
        if (tabKey === "confirmed") {
            console.log(
                "ðŸ”„ Switching to confirmed tab - reloading assigned orders to apply filter"
            );
            setTimeout(() => {
                this.loadAssignedOrders && this.loadAssignedOrders();
            }, 100);
        }
    }

    switchSuccessfulSubTab(subTabKey) {
        document
            .querySelectorAll(".successful-subtab-btn")
            .forEach((b) => b.classList.remove("active"));
        const activeBtn = document.querySelector(
            `.successful-subtab-btn[data-successful-subtab="${subTabKey}"]`
        );
        if (activeBtn) activeBtn.classList.add("active");
        document
            .querySelectorAll(".successful-subtab-content")
            .forEach((tc) => tc.classList.remove("active"));
        const activeEl = document.getElementById(`successful-subtab-${subTabKey}`);
        if (activeEl) activeEl.classList.add("active");
    }

    switchConfirmedSubTab(subTabKey) {
        document
            .querySelectorAll(".confirmed-subtab-btn")
            .forEach((b) => b.classList.remove("active"));
        const activeBtn = document.querySelector(
            `.confirmed-subtab-btn[data-confirmed-subtab="${subTabKey}"]`
        );
        if (activeBtn) activeBtn.classList.add("active");
        document
            .querySelectorAll(".confirmed-subtab-content")
            .forEach((tc) => tc.classList.remove("active"));
        const activeEl = document.getElementById(`confirmed-subtab-${subTabKey}`);
        if (activeEl) activeEl.classList.add("active");
    }

    switchFailedSubTab(subTabKey) {
        document
            .querySelectorAll(".failed-subtab-btn")
            .forEach((b) => b.classList.remove("active"));
        const activeBtn = document.querySelector(
            `.failed-subtab-btn[data-failed-tab="failed-${subTabKey}"]`
        );
        if (activeBtn) activeBtn.classList.add("active");
        document
            .querySelectorAll(".failed-subtab-content")
            .forEach((tc) => tc.classList.remove("active"));
        const activeEl = document.getElementById(`failed-subtab-${subTabKey}`);
        if (activeEl) activeEl.classList.add("active");
    }

    switchToReceiveSubTab(subTabKey) {
        document
            .querySelectorAll(".to-receive-subtab-btn")
            .forEach((b) => b.classList.remove("active"));
        const activeBtn = document.querySelector(
            `.to-receive-subtab-btn[data-to-receive-subtab="${subTabKey}"]`
        );
        if (activeBtn) activeBtn.classList.add("active");
        document
            .querySelectorAll(".to-receive-subtab-content")
            .forEach((tc) => tc.classList.remove("active"));
        const activeEl = document.getElementById(`to-receive-subtab-${subTabKey}`);
        if (activeEl) activeEl.classList.add("active");
    }

    async loadSalesData() {
        try {
            const snapshot = await dbRefs.sales.once("value");
            const sales = snapshot.val() || {};

            // Process sales data for charts and analytics
            this.renderSalesCharts(sales);
        } catch (error) {
            console.error("Error loading sales data:", error);
        }
    }

    renderSalesCharts(salesData) {
        // Implementation for charts would go here
        // Using Chart.js to create visualizations
        const container = document.getElementById("salesOverview");
        container.innerHTML = `
            <div class="sales-charts">
                <div class="chart-container">
                    <canvas id="salesChart"></canvas>
                </div>
                <div class="sales-summary">
                    <h4>Sales Summary</h4>
                    <p>Total Sales: â‚±${Object.values(salesData)
                .reduce((sum, sale) => sum + (sale.amount || 0), 0)
                .toLocaleString()}</p>
                    <p>Total Orders: ${Object.keys(salesData).length}</p>
                </div>
            </div>
        `;
    }

    // Automatic cleanup of rejected customer accounts every Monday
    async cleanupRejectedCustomers() {
        try {
            console.log("Starting Monday cleanup of rejected customer accounts...");

            const today = new Date();
            const dayOfWeek = today.getDay(); // 0 = Sunday, 1 = Monday, etc.

            // Only run on Mondays (day 1)
            if (dayOfWeek !== 1) {
                console.log("Not Monday, skipping rejected customer cleanup");
                return;
            }

            // Check if we already ran cleanup today
            const lastCleanupKey = "lastRejectedCustomerCleanup";
            const lastCleanup = localStorage.getItem(lastCleanupKey);
            const todayString = today.toDateString();

            if (lastCleanup === todayString) {
                console.log("Rejected customer cleanup already ran today");
                return;
            }

            // Rejected customers now remain in Supabase for auditing.
            // Cleanup is limited to ensuring their Firebase Auth accounts are removed.
            console.log(
                "Rejected customers remain archived in Supabase; no row deletion needed."
            );

            let deletedCount = 0;
            console.log(
                "No automated Firebase Auth cleanup list available; ensure accounts are deleted when rejection happens."
            );

            // Mark cleanup as completed for today
            localStorage.setItem(lastCleanupKey, todayString);

            console.log(
                `Monday cleanup completed. (No rejected customers in Supabase to clean up)`
            );
        } catch (error) {
            console.error(
                "Error during Monday cleanup of rejected customers:",
                error
            );
        }
    }
    setupRealtimeListeners() {
        // Note: Customer data is now in Supabase, so Firebase listeners are removed
        // Real-time updates for customers are handled via polling in loadCustomersManagementData()
        // and loadCustomerManagementVerificationData() functions

        // Listen for farmers updates
        this.listeners.push(
            dbRefs.farmers.on("value", () => {
                // Always keep header stats fresh
                this.loadStats();
                if (
                    this.currentSection === "user-management" &&
                    this.currentTab === "farmer-users"
                ) {
                    this.loadFarmersManagementData();
                }
            })
        );
    }

    // Dedicated listener for pending orders that triggers UI refresh on any change
    attachPendingOrdersListener() {
        try {
            if (!window.dbRefs || !window.dbRefs.orders) return;

            // Avoid multiple bindings
            if (this.__pendingListenerBound) return;
            this.__pendingListenerBound = true;

            const pendingQuery = window.dbRefs.orders
                .orderByChild("status")
                .equalTo("pending");
            let lastRefresh = 0;
            const doRefresh = () => {
                const now = Date.now();
                if (now - lastRefresh < 100) return; // throttle
                lastRefresh = now;
                this.loadPendingOrders();
            };

            // Primary: single value listener on the filtered query (fires on any pending change)
            const onPendingValue = () => doRefresh();
            pendingQuery.on("value", onPendingValue);

            // Fallback: global child_added/changed to catch orders before status is set
            const onAnyChildAdded = () => doRefresh();
            const onAnyChildChanged = () => doRefresh();
            window.dbRefs.orders.on("child_added", onAnyChildAdded);
            window.dbRefs.orders.on("child_changed", onAnyChildChanged);

            // Keep references for cleanup (unused now but handy for future detachment)
            this.__pendingOrdersHandlers = {
                pendingQuery,
                onPendingValue,
                onAnyChildAdded,
                onAnyChildChanged,
            };
        } catch (err) {
            console.error("Failed to attach pending orders listener:", err);
        }
    }

    // Additional methods for viewing details, editing, etc.

    viewOrderDetails(id) {
        console.log("View order details:", id);
        // Implementation for viewing order details
    }

    viewInventoryDetails(id) {
        console.log("View inventory details:", id);
        // Implementation for viewing inventory details
    }
    async loadFarmerAnalytics(farmerId, farmer) {
        try {
            const [ordersSnap, productsObj, inventorySnap] = await Promise.all([
                dbRefs.orders.once("value"),
                ProductHelpers.getProductsByFarmerId(farmerId),
                dbRefs.inventory
                    .orderByChild("farmerId")
                    .equalTo(farmerId)
                    .once("value"),
            ]);

            const orders = ordersSnap.val() || {};
            const farmerOrders = Object.values(orders).filter(
                (o) => o.items && o.items.some((it) => it.farmerId === farmerId)
            );
            const totalOrders = farmerOrders.length;

            // Earnings per week/month from confirmed orders items matching farmerId
            const now = new Date();
            const startOfWeek = new Date(now);
            startOfWeek.setDate(now.getDate() - now.getDay());
            startOfWeek.setHours(0, 0, 0, 0);
            const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);

            const earningsWeek = farmerOrders.reduce((sum, o) => {
                const d = new Date(o.createdAt);
                if (o.status === "confirmed" && d >= startOfWeek) {
                    const share = o.items
                        .filter((it) => it.farmerId === farmerId)
                        .reduce((s, it) => s + (it.quantity * it.price || 0), 0);
                    return sum + share;
                }
                return sum;
            }, 0);

            const earningsMonth = farmerOrders.reduce((sum, o) => {
                const d = new Date(o.createdAt);
                if (o.status === "confirmed" && d >= startOfMonth) {
                    const share = o.items
                        .filter((it) => it.farmerId === farmerId)
                        .reduce((s, it) => s + (it.quantity * it.price || 0), 0);
                    return sum + share;
                }
                return sum;
            }, 0);

            const products = productsObj || {};
            const productList = Object.values(products)
                .map((p) => p.name)
                .slice(0, 50);

            const inventory = inventorySnap.val() || {};
            const approvedInventory = Object.values(inventory).filter(
                (i) => i.status === "approved"
            );

            const statsEl = document.getElementById(`farmerStats_${farmerId}`);
            const productsEl = document.getElementById(`farmerProducts_${farmerId}`);
            const inventoryEl = document.getElementById(
                `farmerInventory_${farmerId}`
            );

            if (statsEl) {
                statsEl.innerHTML = `
                    <div class="stats-grid">
                        <div class="stat-card"><div class="stat-info"><h3>${totalOrders}</h3><p>Total Orders</p></div></div>
                        <div class="stat-card"><div class="stat-info"><h3>â‚±${earningsWeek.toLocaleString()}</h3><p>Earnings (This Week)</p></div></div>
                        <div class="stat-card"><div class="stat-info"><h3>â‚±${earningsMonth.toLocaleString()}</h3><p>Earnings (This Month)</p></div></div>
                        <div class="stat-card"><div class="stat-info"><h3>${productList.length
                    }</h3><p>Products</p></div></div>
                    </div>
                `;
            }

            if (productsEl) {
                productsEl.innerHTML = `
                    <h4>Products</h4>
                    <ul>${productList.map((n) => `<li>${n}</li>`).join("")}</ul>
                `;
            }

            if (inventoryEl) {
                inventoryEl.innerHTML = `
                    <h4>Approved Inventory Records</h4>
                    ${approvedInventory.length === 0
                        ? '<p class="no-data">No approved inventory records</p>'
                        : `
                        <ul>
                            ${approvedInventory
                            .map(
                                (i) =>
                                    `<li>${i.productName} - ${i.quantity} ${i.unit
                                    } (${new Date(
                                        i.harvestDate
                                    ).toLocaleDateString()})</li>`
                            )
                            .join("")}
                        </ul>
                    `
                    }
                `;
            }
        } catch (error) {
            console.error("Error loading farmer analytics:", error);
        }
    }
    async viewOrderCustomerDetails(
        orderId,
        customerName,
        customerPhone,
        deliveryAddress
    ) {
        try {
            let order = (this._ordersCache && this._ordersCache[orderId]) || null;

            if (!order && window.OrderSupabaseAdapter) {
                order = await OrderSupabaseAdapter.fetchOrderById(orderId);
                if (order) {
                    if (!this._ordersCache) this._ordersCache = {};
                    this._ordersCache[orderId] = order;
                }
            }

            if (!order) {
                alert("Order not found");
                return;
            }

            let customer = null;
            let isPending = false;

            try {
                customer = await CustomerHelpers.getCustomer(order.customerId);
                if (customer) {
                    return this.viewCustomerDetailsInManagement(order.customerId);
                }
            } catch (e) {
                console.warn("Supabase customer lookup failed for order", orderId, e);
            }

            const customerSnapshot = await dbRefs.verifications
                .child("customers")
                .child(order.customerId)
                .once("value");
            customer = customerSnapshot.val();
            if (!customer) {
                alert("Customer not found");
                return;
            }
            isPending = true;

            // Build ID photos section if available
            let idPhotosSection = "";
            if (customer.idFrontPhoto || customer.idBackPhoto) {
                // Supabase configuration
                const SUPABASE_URL = "https://afkwexvvuxwbpioqnelp.supabase.co";
                const SUPABASE_BUCKET = "customerid_image";

                // Helper function to determine if URL is base64, Supabase URL, or file path
                const getImageUrl = (photoUrl) => {
                    if (!photoUrl) return null;

                    // Trim whitespace
                    photoUrl = photoUrl.trim();

                    console.log("ðŸ” Processing image URL:", photoUrl);

                    // Check if it's already a full URL (starts with http/https)
                    if (
                        photoUrl.startsWith("http://") ||
                        photoUrl.startsWith("https://")
                    ) {
                        // If it's already a Supabase public URL, use it directly
                        if (
                            photoUrl.includes("supabase.co") &&
                            photoUrl.includes("/storage/v1/object/public/")
                        ) {
                            console.log("âœ… Using existing Supabase public URL:", photoUrl);
                            // Fix duplicate bucket name if present: /customerid_image/customerid_image/ -> /customerid_image/
                            let cleanUrl = photoUrl.replace(
                                `/${SUPABASE_BUCKET}/${SUPABASE_BUCKET}/`,
                                `/${SUPABASE_BUCKET}/`
                            );
                            // Ensure URL is properly formatted - make sure there are no double slashes except after http(s):/
                            cleanUrl = cleanUrl.replace(/([^:]\/)\/+/g, "$1");
                            if (cleanUrl !== photoUrl) {
                                console.log("ðŸ”§ Fixed duplicate bucket name in URL:", cleanUrl);
                            }
                            return cleanUrl;
                        }
                        // If it's a Supabase URL but not in public format, try to fix it
                        if (
                            photoUrl.includes("supabase.co") &&
                            !photoUrl.includes("/storage/v1/object/public/")
                        ) {
                            // Extract file path from existing URL and reconstruct
                            const pathMatch = photoUrl.match(/customerid_image\/(.+)$/);
                            if (pathMatch) {
                                const filePath = pathMatch[1];
                                const publicUrl = `${SUPABASE_URL}/storage/v1/object/public/${SUPABASE_BUCKET}/${filePath}`;
                                console.log("ðŸ”§ Reconstructed Supabase public URL:", publicUrl);
                                return publicUrl;
                            }
                        }
                        console.log("âœ… Using existing full URL:", photoUrl);
                        return photoUrl;
                    }

                    // Check if it's base64 (starts with data:)
                    if (photoUrl.startsWith("data:image/")) {
                        console.log("âœ… Using base64 data URL");
                        return photoUrl;
                    }

                    // Check if it looks like a file path (contains / but no ://)
                    // Example: "customerId/front_1234567890.jpg" or "customerid_image/customerId/front_1234567890.jpg"
                    if (photoUrl.includes("/") && !photoUrl.includes("://")) {
                        // Remove bucket name from path if it's already there (multiple times if needed)
                        let filePath = photoUrl;
                        while (filePath.startsWith(`${SUPABASE_BUCKET}/`)) {
                            filePath = filePath.substring(SUPABASE_BUCKET.length + 1);
                            console.log(
                                "ðŸ”§ Removed bucket prefix from path, remaining:",
                                filePath
                            );
                        }

                        // Remove storage/v1/object/public/customerid_image/ if somehow present
                        const storagePrefix = "storage/v1/object/public/customerid_image/";
                        if (filePath.includes(storagePrefix)) {
                            filePath = filePath.substring(
                                filePath.indexOf(storagePrefix) + storagePrefix.length
                            );
                            console.log("ðŸ”§ Removed storage prefix, remaining:", filePath);
                        }

                        // Construct Supabase public URL
                        // Split path and encode each segment separately, then join with /
                        const pathSegments = filePath.split("/");
                        const encodedSegments = pathSegments.map((segment) =>
                            encodeURIComponent(segment)
                        );
                        const encodedPath = encodedSegments.join("/");
                        const publicUrl = `${SUPABASE_URL}/storage/v1/object/public/${SUPABASE_BUCKET}/${encodedPath}`;
                        console.log("ðŸ”§ Constructed Supabase URL from path:", publicUrl);
                        return publicUrl;
                    }

                    // Check if it's a long base64 string (no http, no slashes, long length)
                    if (
                        photoUrl.length > 100 &&
                        !photoUrl.includes("://") &&
                        !photoUrl.includes("/")
                    ) {
                        console.log("âœ… Detected base64 string");
                        return `data:image/jpeg;base64,${photoUrl}`;
                    }

                    // If it's a simple filename without path, construct URL
                    // Example: "front_123.jpg"
                    const publicUrl = `${SUPABASE_URL}/storage/v1/object/public/${SUPABASE_BUCKET}/${photoUrl}`;
                    console.log("ðŸ”§ Constructed Supabase URL from filename:", publicUrl);
                    return publicUrl;
                };

                idPhotosSection = `
                    <div class="info-section">
                        <h4><i class="fas fa-id-card"></i> ID Photos</h4>
                        <div class="id-photo-display">
                            <div class="id-photo-item">
                                <strong>Front Side:</strong>
                                ${customer.idFrontPhoto
                        ? (() => {
                            const frontImageUrl = getImageUrl(
                                customer.idFrontPhoto
                            );
                            // Escape quotes for use in HTML attributes
                            const escapedUrl = frontImageUrl
                                .replace(/'/g, "\\'")
                                .replace(/"/g, "&quot;");
                            console.log(
                                "ðŸ–¼ï¸ Front ID Photo URL:",
                                frontImageUrl
                            );
                            return `
                                    <div class="id-photo-container" style="margin-top: 10px;">
                                        <img src="${frontImageUrl}" 
                                             alt="ID Front" 
                                             style="max-width: 100%; max-height: 250px; width: auto; height: auto; border-radius: 8px; display: block; border: 1px solid #e2e8f0; cursor: pointer; object-fit: contain;"
                                             loading="lazy"
                                             crossorigin="anonymous"
                                             referrerpolicy="no-referrer"
                                             onload="console.log('âœ… Front ID photo loaded successfully from:', '${escapedUrl}'); this.style.borderColor = '#4CAF50';"
                                             onerror="(function(img, url) {
                                                 console.error('âŒ Failed to load front ID photo');
                                                 console.error('URL:', url);
                                                 console.error('Error event:', event);
                                                 img.onerror = null;
                                                 img.style.display = 'none';
                                                 const errorDiv = img.parentNode.querySelector('.image-error') || document.createElement('div');
                                                 errorDiv.className = 'image-error';
                                                 errorDiv.innerHTML = '<div style=\\'color: red; padding: 10px; border: 1px solid #ffcdd2; border-radius: 4px; background: #ffebee;\\'><p style=\\'margin: 0 0 8px 0;\\'>âš ï¸ Image failed to load</p><a href=\\'' + url + '\\' target=\\'_blank\\' style=\\'color: #4CAF50; text-decoration: underline;\\'>Try opening URL directly</a><br><small style=\\'color: #666; word-break: break-all; display: block; margin-top: 8px;\\'>' + url + '</small></div>';
                                                 if (!img.parentNode.querySelector('.image-error')) {
                                                     img.parentNode.appendChild(errorDiv);
                                                 }
                                             })(this, '${escapedUrl}');"
                                             onclick="window.open('${frontImageUrl}', '_blank');" />
                                        <div style="margin-top: 8px; font-size: 11px; color: #666; word-break: break-all;">
                                            <a href="${frontImageUrl}" target="_blank" style="color: #4CAF50; text-decoration: underline;" onclick="event.stopPropagation();">Open in new tab</a>
                                        </div>
                                    </div>
                                `;
                        })()
                        : '<div class="id-photo-not-uploaded">Not uploaded</div>'
                    }
                            </div>
                            <div class="id-photo-item">
                                <strong>Back Side:</strong>
                                ${customer.idBackPhoto
                        ? (() => {
                            const backImageUrl = getImageUrl(
                                customer.idBackPhoto
                            );
                            // Escape quotes for use in HTML attributes
                            const escapedUrl = backImageUrl
                                .replace(/'/g, "\\'")
                                .replace(/"/g, "&quot;");
                            console.log(
                                "ðŸ–¼ï¸ Back ID Photo URL:",
                                backImageUrl
                            );
                            return `
                                    <div class="id-photo-container" style="margin-top: 10px;">
                                        <img src="${backImageUrl}" 
                                             alt="ID Back" 
                                             style="max-width: 100%; max-height: 250px; width: auto; height: auto; border-radius: 8px; display: block; border: 1px solid #e2e8f0; cursor: pointer; object-fit: contain;"
                                             loading="lazy"
                                             crossorigin="anonymous"
                                             referrerpolicy="no-referrer"
                                             onload="console.log('âœ… Back ID photo loaded successfully from:', '${escapedUrl}'); this.style.borderColor = '#4CAF50';"
                                             onerror="(function(img, url) {
                                                 console.error('âŒ Failed to load back ID photo');
                                                 console.error('URL:', url);
                                                 console.error('Error event:', event);
                                                 img.onerror = null;
                                                 img.style.display = 'none';
                                                 const errorDiv = img.parentNode.querySelector('.image-error') || document.createElement('div');
                                                 errorDiv.className = 'image-error';
                                                 errorDiv.innerHTML = '<div style=\\'color: red; padding: 10px; border: 1px solid #ffcdd2; border-radius: 4px; background: #ffebee;\\'><p style=\\'margin: 0 0 8px 0;\\'>âš ï¸ Image failed to load</p><a href=\\'' + url + '\\' target=\\'_blank\\' style=\\'color: #4CAF50; text-decoration: underline;\\'>Try opening URL directly</a><br><small style=\\'color: #666; word-break: break-all; display: block; margin-top: 8px;\\'>' + url + '</small></div>';
                                                 if (!img.parentNode.querySelector('.image-error')) {
                                                     img.parentNode.appendChild(errorDiv);
                                                 }
                                             })(this, '${escapedUrl}');"
                                             onclick="window.open('${backImageUrl}', '_blank');" />
                                        <div style="margin-top: 8px; font-size: 11px; color: #666; word-break: break-all;">
                                            <a href="${backImageUrl}" target="_blank" style="color: #4CAF50; text-decoration: underline;" onclick="event.stopPropagation();">Open in new tab</a>
                                        </div>
                                    </div>
                                `;
                        })()
                        : '<div class="id-photo-not-uploaded">Not uploaded</div>'
                    }
                            </div>
                        </div>
                    </div>
                `;
            }

            const modalContent = `
                <div class="modal-header">
                    <h3><i class="fas fa-user-circle"></i> Customer Details</h3>
                    <button class="close-modal">&times;</button>
                </div>
                <div class="modern-customer-details">
                    <div class="form-grid">
                        <!-- Customer Information Section -->
                        <div class="form-field">
                            <label class="required">Full Name</label>
                            <input type="text" value="${customer.fullName || customer.name || "N/A"
                }" readonly>
                        </div>
                        <div class="form-field">
                            <label class="required">Email Address</label>
                            <input type="email" value="${customer.email || "N/A"
                }" readonly>
                        </div>
                        <div class="form-field">
                            <label>Phone Number</label>
                            <input type="tel" value="${customer.phoneNumber || "N/A"
                }" readonly>
                        </div>
                        <div class="form-field">
                            <label>Age</label>
                            <input type="text" value="${customer.age || "Not provided"
                }" readonly>
                        </div>
                        <div class="form-field">
                            <label>Gender</label>
                            <input type="text" value="${customer.gender || "Not provided"
                }" readonly>
                        </div>
                        <div class="form-field">
                            <label>Account Status</label>
                            <input type="text" value="${customer.accountStatus ||
                customer.status ||
                "Active"
                }" readonly>
                        </div>
                        
                        <!-- Address Information Section -->
                        <div class="form-field">
                            <label class="required">Sitio/Purok/Street</label>
                            <input type="text" value="${(
                    (customer.address || "")
                        .toString()
                        .split(",")[0] || ""
                ).trim() || "N/A"
                }" readonly>
                        </div>
                        <div class="form-field">
                            <label class="required">Barangay</label>
                            <input type="text" value="${(
                    (customer.address || "")
                        .toString()
                        .split(",")[1] ||
                    verification.barangay ||
                    ""
                ).trim() || "N/A"
                }" readonly>
                        </div>
                        <div class="form-field">
                            <label class="required">City</label>
                            <input type="text" value="${customer.city ||
                (
                    (customer.address || "")
                        .toString()
                        .split(",")[2] || ""
                ).trim() ||
                "Ormoc"
                }" readonly>
                        </div>
                        <div class="form-field">
                            <label class="required">Province</label>
                            <input type="text" value="${customer.state ||
                customer.province ||
                (
                    (customer.address || "")
                        .toString()
                        .split(",")[3] || ""
                )
                    .toString()
                    .trim() ||
                "Leyte"
                }" readonly>
                        </div>
                        
                        ${isPending
                    ? `
                            <!-- Verification Status Section -->
                            <div class="form-field">
                                <label>Verification Status</label>
                                <input type="text" value="Pending Verification" readonly style="background-color: #fff3cd; color: #856404; border-color: #ffc107;">
                            </div>
                            <div class="form-field">
                                <label>Submitted At</label>
                                <input type="text" value="${customer.submittedAt
                        ? new Date(
                            customer.submittedAt
                        ).toLocaleString()
                        : "N/A"
                    }" readonly>
                            </div>
                        `
                    : `
                            <!-- Order Information Section -->
                            <div class="form-field">
                                <label class="required">Order ID</label>
                                <input type="text" value="#${orderId
                        .substr(-8)
                        .toUpperCase()}" readonly style="font-weight: bold; color: #2c3e50;">
                            </div>
                            <div class="form-field">
                                <label class="required">Order Status</label>
                                <input type="text" value="${order.status
                    }" readonly style="background-color: #d4edda; color: #155724; border-color: #c3e6cb; font-weight: 500;">
                            </div>
                            <div class="form-field">
                                <label>Payment Method</label>
                                <input type="text" value="${order.paymentMethod || "N/A"
                    }" readonly>
                            </div>
                            <div class="form-field">
                                <label class="required">Total Amount</label>
                                <input type="text" value="â‚±${(
                        order.total ||
                        order.totalAmount ||
                        0
                    ).toLocaleString()}" readonly style="font-weight: bold; color: #27ae60; font-size: 1.1rem;">
                            </div>
                            
                            <!-- Delivery Information Section -->
                            <div class="form-field">
                                <label class="required">Delivery Option</label>
                                <input type="text" value="${(order.deliveryOption || "delivery") ===
                        "delivery"
                        ? "Delivery"
                        : "Pick-up"
                    }" readonly 
                                       style="background-color: ${(order.deliveryOption ||
                        "delivery") === "delivery"
                        ? "#d4edda"
                        : "#f8d7da"
                    }; 
                                              color: ${(order.deliveryOption ||
                        "delivery") === "delivery"
                        ? "#155724"
                        : "#721c24"
                    }; 
                                              border-color: ${(order.deliveryOption ||
                        "delivery") === "delivery"
                        ? "#c3e6cb"
                        : "#f5c6cb"
                    }; 
                                              font-weight: 500;">
                            </div>
                            <div class="form-field full-width">
                                <label class="required">${(order.deliveryOption || "delivery") ===
                        "delivery"
                        ? "Delivery Address"
                        : "Pick-up Information"
                    }</label>
                                <textarea rows="3" readonly style="background-color: #e3f2fd; border-color: #2196f3; color: #2c3e50; font-weight: 500; resize: none;">
${(order.deliveryOption || "delivery") === "delivery"
                        ? this.removeDuplicateCityProvince(order.deliveryAddress ||
                        order.customerAddress ||
                        "No delivery address specified")
                        : this.removeDuplicateCityProvince(order.pickupAddress || "No pick-up information specified")
                    }
                                </textarea>
                            </div>
                            ${(() => {
                        const rawNotes = order.deliveryNotes || order.delivery_notes || order.order_notes || order.orderNotes || "";
                        const filteredNotes = this.filterCustomerNotes(rawNotes);
                        return filteredNotes ? `
                                <div class="form-field full-width">
                                    <label>${((order.deliveryOption || "").toLowerCase() === "pickup") ? "Order/Pickup Notes" : "Order/Delivery Notes"} (Customer)</label>
                                    <textarea rows="2" readonly style="background-color: #fff3e0; border-color: #ff9800; color: #856404; font-style: italic; resize: none;">${this.esc(filteredNotes)}</textarea>
                                </div>
                            `
                        : "";
                    })()}
                            <div id="staff-notes-modal-container-${orderId}" class="form-field full-width" style="margin-top: 20px;"></div>
                            <script>
                                setTimeout(async () => {
                                    if (window.staffManager && typeof window.staffManager.loadStaffNotesIntoModal === 'function') {
                                        await window.staffManager.loadStaffNotesIntoModal('${orderId}');
                                    }
                                }, 100);
                            </script>
                        `
                }
                    </div>
                </div>
                
            `;

            this.showModal(modalContent);
        } catch (error) {
            console.error("Error loading customer details:", error);
            alert("Error loading customer details: " + error.message);
        }
    }


    async showRiderSelectionModal(selectedOrderIds) {
        try {
            // Fetch active riders from Supabase
            let supabase = null;
            if (typeof window.getSupabaseClient === "function") {
                supabase = window.getSupabaseClient();
            } else if (window.supabaseClient) {
                supabase = window.supabaseClient;
            }

            if (!supabase) {
                alert("Database connection error. Please refresh the page.");
                return;
            }

            const { data: ridersData, error: ridersError } = await supabase
                .from("riders")
                .select("uid, full_name, phone_number, vehicle_type, is_active")
                .eq("is_active", true);

            if (ridersError) {
                console.error("Error fetching riders:", ridersError);
                alert("Failed to load riders. Please try again.");
                return;
            }

            console.log(
                "DEBUG: Fetched riders from Supabase:",
                ridersData?.length || 0,
                "riders"
            );

            // Filter active riders with full_name
            const activeRiders = (ridersData || []).filter(
                (rider) => rider && rider.full_name && rider.is_active === true
            );

            console.log("DEBUG: Active riders after filtering:", activeRiders.length);

            if (activeRiders.length === 0) {
                alert(
                    "No active riders available. Please add riders through the admin panel."
                );
                return;
            }

            const modalContent = `
                <div class="modal-header">
                    <h3>Assign Rider for ${selectedOrderIds.length
                } Order(s)</h3>
                    <button class="close-modal" onclick="staffManager.closeModal()">&times;</button>
                </div>
                <div class="rider-selection-content" style="padding: 20px;">
                    <p style="margin-bottom: 20px; color: #666;">
                        Select a rider to assign to the selected orders. The orders will be marked as "Out for Delivery" and assigned to the selected rider.
                    </p>
                    
                    <div class="form-field" style="margin-bottom: 20px;">
                        <label for="riderSelect" style="display: block; margin-bottom: 8px; font-weight: 600;">Select Rider:</label>
                        <select id="riderSelect" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                            <option value="">Choose a rider...</option>
                            ${activeRiders
                    .map(
                        (rider) => `
                                <option value="${rider.uid}" data-name="${rider.full_name
                            }" data-phone="${rider.phone_number || ""}">
                                    ${rider.full_name} (${rider.vehicle_type || "N/A"
                            }) - ${rider.phone_number || "No phone"}
                                </option>
                            `
                    )
                    .join("")}
                        </select>
                    </div>

                    <div class="selected-orders-info" style="margin-bottom: 20px;">
                        <h4 style="margin-bottom: 10px; color: #333;">Selected Orders:</h4>
                        <div style="max-height: 150px; overflow-y: auto; border: 1px solid #eee; padding: 10px; border-radius: 4px;">
                            ${selectedOrderIds
                    .map(
                        (id) => `
                                <div style="padding: 5px 0; border-bottom: 1px solid #f0f0f0;">
                                    Order #${id
                                .substring(id.length - 8)
                                .toUpperCase()}
                                </div>
                            `
                    )
                    .join("")}
                        </div>
                    </div>

                    <div class="modal-actions" style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                        <button type="button" class="secondary-btn" onclick="staffManager.closeModal()">Cancel</button>
                        <button type="button" class="primary-btn" id="assignRiderBtn" disabled>
                            <i class="fas fa-user-check"></i> Assign Rider
                        </button>
                    </div>
                </div>
            `;

            this.showModal(modalContent);

            // Set up event listeners
            const riderSelect = document.getElementById("riderSelect");
            const assignBtn = document.getElementById("assignRiderBtn");

            riderSelect.addEventListener("change", () => {
                assignBtn.disabled = !riderSelect.value;
            });

            assignBtn.addEventListener("click", async () => {
                const selectedRiderId = riderSelect.value;
                const selectedRiderName = riderSelect.selectedOptions[0]?.dataset.name;
                const selectedRiderPhone =
                    riderSelect.selectedOptions[0]?.dataset.phone;

                if (!selectedRiderId || !selectedRiderName) {
                    alert("Please select a rider");
                    return;
                }

                if (
                    !confirm(
                        `Assign ${selectedRiderName} to ${selectedOrderIds.length} order(s)?`
                    )
                ) {
                    return;
                }

                try {
                    assignBtn.disabled = true;
                    assignBtn.innerHTML =
                        '<i class="fas fa-spinner fa-spin"></i> Assigning...';

                    const nowTs = Date.now();

                    // Get Supabase client
                    let supabase = null;
                    if (typeof window.getSupabaseClient === "function") {
                        supabase = window.getSupabaseClient();
                    } else if (window.supabaseClient) {
                        supabase = window.supabaseClient;
                    }

                    if (!supabase) {
                        throw new Error("Supabase client not available");
                    }

                    // Update orders and create delivery_orders records in Supabase
                    try {
                        console.log("DEBUG: Starting Supabase order updates...");

                        for (const id of selectedOrderIds) {
                            console.log(
                                `DEBUG: Updating order ${id} with riderId: ${selectedRiderId}, riderName: ${selectedRiderName}`
                            );

                            // Fetch order from Supabase first
                            const order = await OrderSupabaseAdapter.fetchOrderById(id);
                            if (!order) {
                                console.error(`DEBUG: Order ${id} not found in Supabase`);
                                continue;
                            }

                            // Update order in Supabase with rider assignment
                            const orderUpdates = {
                                status: "out_for_delivery",
                                riderId: selectedRiderId,
                                riderName: selectedRiderName,
                                riderPhone: selectedRiderPhone,
                                outForDeliveryAt: nowTs,
                                assignedAt: nowTs,
                                updatedAt: nowTs,
                            };

                            await OrderSupabaseAdapter.updateOrder(id, orderUpdates);
                            console.log(`DEBUG: Order ${id} updated in Supabase`);

                            // Create/update delivery_orders record in Supabase
                            // Ensure items is properly formatted as array
                            let itemsArray = [];
                            if (Array.isArray(order.items)) {
                                itemsArray = order.items;
                            } else if (order.items && typeof order.items === "object") {
                                // Convert object to array
                                itemsArray = Object.values(order.items);
                            }

                            const deliveryRecord = {
                                id: id,
                                status: "pending", // Always set to pending for delivery app
                                rider_id: selectedRiderId,
                                rider_name: selectedRiderName,
                                rider_phone: selectedRiderPhone || null,
                                assigned_at: nowTs,
                                out_for_delivery_at: nowTs,
                                updated_at: nowTs,
                                customer_id: order.customerId || order.customer_id || "",
                                customer_name: order.customerName || order.customer_name || "",
                                customer_phone:
                                    order.customerPhone || order.customer_phone || "",
                                payment_method:
                                    order.paymentMethod || order.payment_method || "",
                                total_amount:
                                    order.totalAmount != null
                                        ? order.totalAmount
                                        : order.total != null
                                            ? order.total
                                            : order.total_amount || 0,
                                delivery_fee:
                                    order.deliveryFee != null
                                        ? order.deliveryFee
                                        : order.delivery_fee != null
                                            ? order.delivery_fee
                                            : 0,
                                created_at: order.createdAt || order.created_at || nowTs,
                                pickup_location:
                                    order.pickupLocation || order.pickup_location || null,
                                delivery_location:
                                    order.deliveryLocation || order.delivery_location || null,
                                pickup_address:
                                    order.pickupAddress || order.pickup_address || null,
                                delivery_address:
                                    order.deliveryAddress ||
                                    order.delivery_address ||
                                    order.customerAddress ||
                                    order.customer_address ||
                                    "",
                                customer_address:
                                    order.customerAddress || order.customer_address || null,
                                notes: order.notes || null,
                                items: itemsArray, // JSONB array
                                delivery_proof: null, // Field for proof of delivery images (will be set when rider submits proof)
                                gcash_receipt_url:
                                    order.gcashReceiptUrl || order.gcash_receipt_url || null,
                            };

                            console.log(`DEBUG: Creating delivery_order for ${id}:`, {
                                rider_id: deliveryRecord.rider_id,
                                rider_name: deliveryRecord.rider_name,
                                status: deliveryRecord.status,
                                items_count: itemsArray.length,
                            });

                            // Use upsert to insert or update delivery_orders
                            const { data: deliveryData, error: deliveryError } =
                                await supabase
                                    .from("delivery_orders")
                                    .upsert(deliveryRecord, { onConflict: "id" })
                                    .select();

                            if (deliveryError) {
                                console.error(
                                    `DEBUG: Error creating delivery_order for ${id}:`,
                                    deliveryError
                                );
                                console.error(
                                    `DEBUG: Delivery record attempted:`,
                                    deliveryRecord
                                );
                            } else {
                                console.log(
                                    `DEBUG: âœ… Delivery order created/updated in Supabase for ${id}:`,
                                    deliveryData
                                );
                            }
                        }

                        console.log("DEBUG: All Supabase updates completed");
                    } catch (updateError) {
                        console.error("DEBUG: Supabase update failed:", updateError);
                        throw updateError;
                    }

                    this.showSuccessMessage(
                        `${selectedOrderIds.length} order(s) assigned to ${selectedRiderName}`
                    );
                    this.closeModal();

                    // Clear checkboxes and update UI
                    document
                        .querySelectorAll(".to-receive-checkbox:checked")
                        .forEach((cb) => {
                            cb.checked = false;
                        });

                    // Store assignment in localStorage for persistence across refreshes
                    selectedOrderIds.forEach((id) => {
                        const assignment = {
                            riderId: selectedRiderId,
                            riderName: selectedRiderName,
                            assignedAt: Date.now(),
                        };
                        localStorage.setItem(
                            `order_assignment_${id}`,
                            JSON.stringify(assignment)
                        );
                        console.log(
                            `DEBUG: Stored assignment in localStorage for order ${id}:`,
                            assignment
                        );
                    });

                    // Immediately reflect assignment in DOM without waiting for listeners
                    selectedOrderIds.forEach((id) => {
                        // Find the checkbox by data-order-id attribute (most reliable)
                        const checkbox = document.querySelector(
                            `.to-receive-checkbox[data-order-id="${id}"]`
                        );
                        if (checkbox) {
                            const checkboxWrapper = checkbox.closest("div");
                            if (checkboxWrapper && checkboxWrapper.parentElement) {
                                checkboxWrapper.remove();
                                console.log(`âœ… Removed checkbox for order ${id}`);
                            }
                        }

                        // Find the order card by order ID text content
                        const allCards = document.querySelectorAll(".order-card");
                        let orderCard = null;

                        for (let card of allCards) {
                            const orderIdEl = card.querySelector(".order-id");
                            if (
                                orderIdEl &&
                                orderIdEl.textContent.includes(id.substr(-8).toUpperCase())
                            ) {
                                orderCard = card;
                                break;
                            }
                        }

                        if (orderCard) {
                            const statusEl = orderCard.querySelector(".order-status");
                            if (statusEl) {
                                // Update label to "Out for delivery" but keep the same
                                // visual style as "Pickup Ready" for consistency
                                statusEl.textContent = this.formatStatus("out_for_delivery");
                                statusEl.classList.remove(
                                    "status-shipped",
                                    "status-to_receive",
                                    "status-out_for_delivery"
                                );
                                statusEl.classList.add("status-pickup-ready");
                            }
                        }

                        // Update order details and show assigned banner
                        const details = document.getElementById(`order-details-${id}`);
                        if (details) {
                            // Add assigned banner if not present
                            const existingBanner = details.querySelector(
                                '[style*="background:#e8f5e8"]'
                            );
                            if (!existingBanner) {
                                const banner = document.createElement("div");
                                banner.style.cssText =
                                    "display:flex; flex-direction:column; gap:8px; margin-bottom:16px; padding:12px; background:#e8f5e8; border:1px solid #4caf50; border-radius:8px;";
                                banner.innerHTML = `
                                    <div style="display:flex; align-items:center; gap:8px;">
                                        <i class="fas fa-user-check" style="color:#2e7d32;"></i>
                                        <span style="font-weight:600; color:#2e7d32; font-size:14px;">Assigned to: ${selectedRiderName}</span>
                                    </div>
                                    <div style="display:flex; align-items:center; gap:8px; margin-left:24px;">
                                        <span style="font-weight:600; color:#2e7d32; font-size:13px;">Delivery Status:</span>
                                        <span style="color:#2e7d32; font-size:13px;">Pending</span>
                                    </div>`;
                                details.insertBefore(banner, details.firstChild);
                            }
                        }

                        // Update QR status indicator
                        setTimeout(() => {
                            this.updateQrStatus(id, {
                                riderId: selectedRiderId,
                                riderName: selectedRiderName,
                                rider_id: selectedRiderId,
                                rider_name: selectedRiderName,
                                status: "out_for_delivery",
                            });
                        }, 100);
                    });

                    // Update bulk bar visibility
                    const bulkBar = document.getElementById("bulk-ood-bar");
                    if (bulkBar) {
                        bulkBar.style.display = "none";
                    }

                    // Clear order cache and reload orders to ensure UI is fully updated
                    if (this._ordersCache) {
                        selectedOrderIds.forEach((id) => {
                            delete this._ordersCache[id];
                        });
                    }
                    if (
                        window.OrderSupabaseAdapter &&
                        window.OrderSupabaseAdapter._cache
                    ) {
                        selectedOrderIds.forEach((id) => {
                            delete window.OrderSupabaseAdapter._cache[id];
                        });
                    }

                    // Reload orders to ensure UI is fully updated
                    setTimeout(() => {
                        // Refresh both pending and assigned orders so the
                        // "To Receive" tab reflects Out for delivery status
                        this.loadAssignedOrders && this.loadAssignedOrders();
                        this.loadPendingOrders && this.loadPendingOrders();
                        this.loadStats && this.loadStats();
                    }, 500);
                } catch (e) {
                    console.error("Error assigning rider:", e);
                    alert("Failed to assign rider to orders");
                    assignBtn.disabled = false;
                    assignBtn.innerHTML =
                        '<i class="fas fa-user-check"></i> Assign Rider';
                }
            });
        } catch (error) {
            console.error("Error showing rider selection modal:", error);
            alert("Failed to load riders. Please try again.");
        }
    }

    showModal(content) {
        const modalOverlay = document.getElementById("modalOverlay");
        const modalContent = document.getElementById("modalContent");

        // Check if modal elements exist
        if (!modalOverlay || !modalContent) {
            console.error("Modal elements not found. Creating modal elements...");
            // Create modal elements if they don't exist
            if (!modalOverlay) {
                const overlay = document.createElement("div");
                overlay.id = "modalOverlay";
                overlay.className = "modal-overlay";
                document.body.appendChild(overlay);
            }
            if (!modalContent) {
                const contentDiv = document.createElement("div");
                contentDiv.id = "modalContent";
                contentDiv.className = "modal-content";
                const overlay = document.getElementById("modalOverlay");
                if (overlay) {
                    overlay.appendChild(contentDiv);
                } else {
                    console.error("Cannot create modalContent: modalOverlay not found");
                    return;
                }
            }
        }

        // Get fresh references after potential creation
        const finalModalOverlay = document.getElementById("modalOverlay");
        const finalModalContent = document.getElementById("modalContent");

        if (!finalModalOverlay || !finalModalContent) {
            console.error("Failed to get modal elements");
            return;
        }

        // Clear any existing content and event listeners
        finalModalContent.innerHTML = "";

        // Remove any existing event listeners by cloning the overlay
        if (finalModalOverlay.parentNode) {
            const newOverlay = finalModalOverlay.cloneNode(true);
            finalModalOverlay.parentNode.replaceChild(newOverlay, finalModalOverlay);
        }

        // Get the new references after cloning
        const newModalOverlay = document.getElementById("modalOverlay");
        const newModalContent = document.getElementById("modalContent");

        if (!newModalOverlay || !newModalContent) {
            console.error("Failed to get modal elements after cloning");
            return;
        }

        newModalContent.innerHTML = content;

        // Initialize carousels if method exists
        if (typeof this._initializeCarouselsWithin === "function") {
            this._initializeCarouselsWithin(newModalContent);
        }

        // Add scrollable classes for product details modals, customer details, and other tall modals
        if (
            content.includes("Product Details") ||
            content.includes("product-details-view") ||
            content.includes("Customer Details") ||
            content.includes("modern-customer-details") ||
            content.includes("farmer-details-view") ||
            content.includes("Verification Details") ||
            content.includes("Edit Farmer") ||
            content.includes("editFarmerForm")
        ) {
            newModalContent.classList.add("scrollable-modal");
            newModalOverlay.classList.add("scrollable-overlay");
        }

        newModalOverlay.classList.add("show");
        this.currentModal = newModalOverlay;

        // Set up close button event listener
        const closeBtn = newModalContent.querySelector(".close-modal");
        if (closeBtn) {
            closeBtn.addEventListener("click", () => {
                this.closeModal();
            });
        }

        // Set up overlay click to close
        newModalOverlay.addEventListener("click", (e) => {
            if (e.target === newModalOverlay) {
                this.closeModal();
            }
        });
    }

    closeModal() {
        console.log("Closing modal...");
        const modalOverlay = document.getElementById("modalOverlay");
        const modalContent = document.getElementById("modalContent");

        if (modalOverlay) {
            modalOverlay.classList.remove("show");
            // Ensure the overlay is completely hidden
            modalOverlay.style.display = "none";
            modalOverlay.style.visibility = "hidden";
            modalOverlay.style.opacity = "0";
        }

        if (modalContent) {
            modalContent.innerHTML = "";
            modalContent.classList.remove(
                "farmer-modal",
                "compact-farmer-edit",
                "uniform-farmer-modal",
                "scrollable-modal"
            );
        }

        // Remove any additional classes that might be interfering
        if (modalOverlay) {
            modalOverlay.classList.remove("farmer-modal-open", "scrollable-overlay");
        }

        // Reset current modal reference
        this.currentModal = null;

        // Force a small delay to ensure the modal is completely closed
        setTimeout(() => {
            if (modalOverlay) {
                modalOverlay.style.display = "";
                modalOverlay.style.visibility = "";
                modalOverlay.style.opacity = "";
            }
            console.log("Modal closed, checking products grid...");
            const productsGrid = document.getElementById("productsGrid");
            if (productsGrid) {
                console.log("Products grid found, refreshing...");
                // Check if the products grid is visible and has content
                if (
                    productsGrid.style.display === "none" ||
                    productsGrid.innerHTML.trim() === ""
                ) {
                    console.log("Products grid is empty or hidden, reloading...");
                    this.loadProducts();
                } else {
                    console.log("Products grid has content, no need to reload");
                }
            } else {
                console.error("Products grid not found after modal close");
            }
        }, 200);
    }

    // Show enlarged image in lightbox
    showEnlargedImage(imageUrl, label = "") {
        // Remove existing lightbox if present
        const existingLightbox = document.getElementById("imageLightboxOverlay");
        if (existingLightbox) {
            existingLightbox.remove();
        }

        // Create lightbox overlay
        const overlay = document.createElement("div");
        overlay.id = "imageLightboxOverlay";
        overlay.className = "image-lightbox-overlay";

        // Create container
        const container = document.createElement("div");
        container.className = "image-lightbox-container";

        // Create image
        const img = document.createElement("img");
        img.src = imageUrl;
        img.alt = label || "Enlarged Image";

        // Create label if provided
        let labelElement = null;
        if (label) {
            labelElement = document.createElement("div");
            labelElement.className = "image-lightbox-label";
            labelElement.textContent = label;
        }

        // Create close button first
        const closeBtn = document.createElement("button");
        closeBtn.className = "image-lightbox-close";
        closeBtn.innerHTML = "&times;";
        closeBtn.setAttribute("aria-label", "Close");

        // Close function (defined after closeBtn)
        const closeLightbox = function (e) {
            overlay.classList.remove("show");
            setTimeout(() => {
                if (overlay.parentNode) {
                    overlay.parentNode.removeChild(overlay);
                }
            }, 300);
        };

        // Set close button handler
        closeBtn.onclick = closeLightbox;

        // Set image error handler after closeLightbox is defined
        img.onerror = function () {
            console.error("Failed to load enlarged image:", imageUrl);
            alert("Failed to load image. Please try again.");
            closeLightbox();
        };

        // Close on overlay click (but not on image/container/buttons)
        overlay.onclick = function (e) {
            if (e.target === overlay) {
                closeLightbox(e);
            }
        };

        // Prevent clicks on container/image from bubbling to overlay
        container.onclick = function (e) {
            e.stopPropagation();
        };
        img.onclick = function (e) {
            e.stopPropagation();
        };
        if (labelElement) {
            labelElement.onclick = function (e) {
                e.stopPropagation();
            };
        }

        // Close on ESC key
        const escHandler = function (e) {
            if (e.key === "Escape" || e.keyCode === 27) {
                closeLightbox(e);
                document.removeEventListener("keydown", escHandler);
            }
        };
        document.addEventListener("keydown", escHandler);

        // Assemble structure
        container.appendChild(img);
        container.appendChild(closeBtn);
        if (labelElement) {
            container.appendChild(labelElement);
        }
        overlay.appendChild(container);

        // Add to body
        document.body.appendChild(overlay);

        // Show with animation
        setTimeout(() => {
            overlay.classList.add("show");
        }, 10);
    }

    // Force refresh products grid (useful when modal issues occur)
    forceRefreshProducts() {
        console.log("Force refreshing products grid...");
        const productsGrid = document.getElementById("productsGrid");
        if (productsGrid) {
            productsGrid.innerHTML = "";
            this.loadProducts();
        }
    }

    showSuccessMessage(message) {
        // Create and show success notification
        const notification = document.createElement("div");
        notification.className = "success-notification";
        notification.textContent = message;
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #4CAF50;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1001;
            animation: slideIn 0.3s ease-out;
        `;

        document.body.appendChild(notification);

        setTimeout(() => {
            notification.remove();
        }, 3000);
    }

    showErrorMessage(message) {
        // Create and show error notification
        const notification = document.createElement("div");
        notification.className = "error-notification";
        notification.textContent = message;
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #f44336;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1001;
            animation: slideIn 0.3s ease-out;
        `;

        document.body.appendChild(notification);

        setTimeout(() => {
            notification.remove();
        }, 5000); // Error messages stay longer
    }

    switchTimePeriod(period) {
        // Update time period buttons
        document.querySelectorAll(".time-btn").forEach((btn) => {
            btn.classList.remove("active");
        });
        document.querySelector(`[data-period="${period}"]`).classList.add("active");

        // Load sales data for the selected period
        this.loadAnalyticsData(period);
    }
    async loadAnalyticsData(period = "weekly") {
        try {
            // Fetch orders from Supabase instead of Firebase
            // Use OrderSupabaseAdapter which already has the Supabase client
            if (!window.OrderSupabaseAdapter) {
                console.error("OrderSupabaseAdapter not available");
                return;
            }

            const ordersData = await OrderSupabaseAdapter.fetchOrders();
            if (ordersData === null) {
                console.error("Failed to fetch orders from Supabase");
                return;
            }

            // OrderSupabaseAdapter.fetchOrders() returns an object with uid as key
            const ordersObj = ordersData || {};

            // Track range for top lists based on selected period
            const now = new Date();
            let rangeStart;
            if (period === "weekly") {
                // Last 8 weeks window
                rangeStart = new Date(now);
                rangeStart.setDate(now.getDate() - 7 * 7);
                rangeStart.setHours(0, 0, 0, 0);
            } else {
                // Last 12 months window
                rangeStart = new Date(
                    now.getFullYear(),
                    now.getMonth() - 11,
                    1,
                    0,
                    0,
                    0,
                    0
                );
            }
            this._analyticsRange = { start: rangeStart, end: now, period };
            this._analyticsOrders = ordersObj;

            const salesData = this.processAnalyticsSalesData({}, ordersObj, period);
            this.renderAnalyticsChart(salesData, period);
            this.updateAnalyticsTable(salesData);
            this.updateAnalyticsSummary(salesData);
            this.loadAnalyticsTopPerformers();

            // Store for export
            this._analyticsData = salesData;
            this._analyticsPeriod = period;

            // Update weekly sales total on dashboard
            this.updateWeeklySalesTotal(salesData, period);
        } catch (error) {
            console.error("Error loading analytics data:", error);
        }
    }
    processAnalyticsSalesData(sales, orders, period) {
        const now = new Date();
        const data = [];

        if (period === "weekly") {
            // Find the Monday of the current week
            const today = new Date(now);
            today.setHours(0, 0, 0, 0);
            const dayOfWeek = today.getDay(); // 0 = Sunday, 1 = Monday, etc.
            const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1; // If Sunday, go back 6 days; otherwise go back to Monday

            const currentMonday = new Date(today);
            currentMonday.setDate(today.getDate() - daysFromMonday);
            currentMonday.setHours(0, 0, 0, 0);

            // Generate last 8 weeks of data (Monday to Sunday)
            for (let i = 7; i >= 0; i--) {
                // Calculate Monday of this week (going back i weeks from current Monday)
                const weekStart = new Date(currentMonday);
                weekStart.setDate(currentMonday.getDate() - i * 7);
                weekStart.setHours(0, 0, 0, 0);

                // Calculate Sunday of this week (6 days after Monday)
                const weekEnd = new Date(weekStart);
                weekEnd.setDate(weekStart.getDate() + 6);
                weekEnd.setHours(23, 59, 59, 999);

                const weekSales = this.getAnalyticsSalesInPeriod(
                    sales,
                    orders,
                    weekStart,
                    weekEnd
                );

                // Format week indicator as date range (e.g., "Jan 1 - Jan 7")
                const startMonth = weekStart.toLocaleString("default", {
                    month: "short",
                });
                const endMonth = weekEnd.toLocaleString("default", { month: "short" });
                const startDay = weekStart.getDate();
                const endDay = weekEnd.getDate();

                let periodLabel;
                if (startMonth === endMonth) {
                    // Same month: "Jan 1 - 7"
                    periodLabel = `${startMonth} ${startDay} - ${endDay}`;
                } else {
                    // Different months: "Jan 28 - Feb 3"
                    periodLabel = `${startMonth} ${startDay} - ${endMonth} ${endDay}`;
                }

                data.push({
                    period: periodLabel,
                    sales: weekSales.total,
                    orders: weekSales.count,
                    average: weekSales.count > 0 ? weekSales.total / weekSales.count : 0,
                    productKilos: weekSales.productKilos || {},
                });
            }
        } else {
            // Generate last 12 months of data
            for (let i = 11; i >= 0; i--) {
                const monthStart = new Date(now.getFullYear(), now.getMonth() - i, 1);
                const monthEnd = new Date(now.getFullYear(), now.getMonth() - i + 1, 0);
                monthEnd.setHours(23, 59, 59, 999);

                const monthSales = this.getAnalyticsSalesInPeriod(
                    sales,
                    orders,
                    monthStart,
                    monthEnd
                );
                data.push({
                    period: monthStart.toLocaleString("default", {
                        month: "short",
                        year: "numeric",
                    }),
                    sales: monthSales.total,
                    orders: monthSales.count,
                    average:
                        monthSales.count > 0 ? monthSales.total / monthSales.count : 0,
                    productKilos: monthSales.productKilos || {},
                });
            }
        }

        return data;
    }

    getAnalyticsSalesInPeriod(sales, orders, startDate, endDate) {
        // Include orders that are:
        // 1. Pending orders (status = 'pending')
        // 2. Confirmed tab (status = 'confirmed')
        // 3. To Receive tab (status = 'to_receive' or 'out_for_delivery')
        // 4. Successful orders (status = 'delivered' or 'picked_up')
        // 5. Failed GCash orders (status = 'failed' AND payment_method = 'gcash')
        //
        // Exclude orders that are:
        // 1. Rejected (status = 'rejected')
        // 2. Cancelled (status = 'cancelled' OR cancellation flags) - ALL cancelled orders excluded, refunded or not
        // 3. Failed cash orders (status = 'failed' AND payment_method != 'gcash')
        // 4. Other failed statuses (delivery_failed, failed_pickup)
        let total = 0;
        let count = 0;
        const productKilos = {}; // Track product kilograms (for Sales Data Table)

        const toNumber = (v) => {
            const n = Number(v);
            return isFinite(n) ? n : 0;
        };

        const getOrderTimestamp = (o) => {
            // Use the most appropriate timestamp based on order status
            return (
                o.confirmedAt ||
                o.confirmed_at ||
                o.deliveredAt ||
                o.delivered_at ||
                o.pickedUpAt ||
                o.picked_up_at ||
                o.completedAt ||
                o.completed_at ||
                o.updatedAt ||
                o.updated_at ||
                o.createdAt ||
                o.created_at ||
                0
            );
        };

        const isIncludedOrder = (o) => {
            const s = String(o.status || "").toLowerCase();
            const paymentMethod = String(o.paymentMethod || o.payment_method || "").toLowerCase();

            // Include: pending, confirmed, to_receive, out_for_delivery, delivered, picked_up
            // Also include failed orders but only if they are GCash orders
            const isFailedGcash = s === "failed" && paymentMethod === "gcash";
            const isValidStatus = (
                s === "pending" ||
                s === "confirmed" ||
                s === "to_receive" ||
                s === "out_for_delivery" ||
                s === "delivered" ||
                s === "picked_up"
            );

            return isValidStatus || isFailedGcash;
        };

        const isExcludedOrder = (o) => {
            const s = String(o.status || "").toLowerCase();
            const paymentMethod = String(o.paymentMethod || o.payment_method || "").toLowerCase();

            // Exclude ALL rejected orders (GCash/Cash)
            if (s === "rejected") {
                return true;
            }

            // Exclude ALL cancelled orders (GCash/Cash) - refunded or not
            if (s === "cancelled") {
                return true;
            }

            // Exclude failed cash orders (failed GCash orders are included)
            if (s === "failed" && paymentMethod !== "gcash") {
                return true;
            }

            // Exclude other failed statuses (delivery_failed, failed_pickup)
            if (s === "delivery_failed" || s === "failed_pickup") {
                return true;
            }

            // Exclude orders with cancellation flags (cancelled/rejected by staff)
            // This catches orders that are cancelled but status field might not be updated to "cancelled"
            // ALL cancelled orders are excluded regardless of refund status
            const isCancellationRequested =
                o.cancellationRequested === true ||
                o.cancellation_requested === true ||
                o.cancellation_requested === 1 ||
                o.cancellation_requested === "true";
            const isCancellationConfirmed =
                o.cancellationConfirmed === true ||
                o.cancellation_confirmed === true ||
                o.cancellation_confirmed === 1 ||
                o.cancellation_confirmed === "true";
            const hasRefundConfirmed =
                o.refundConfirmedAt ||
                o.refund_confirmed_at ||
                o.refundConfirmedAt > 0 ||
                o.refund_confirmed_at > 0;
            const hasRefundDenied =
                o.refundDenied === true ||
                o.refund_denied === true ||
                o.refundDenied === 1 ||
                o.refund_denied === "true";
            const hasRefundReceipt = o.refundReceiptUrl || o.refund_receipt_url;

            // Exclude if order has any cancellation indicators (regardless of refund status)
            if (
                isCancellationRequested ||
                isCancellationConfirmed ||
                hasRefundConfirmed ||
                hasRefundDenied ||
                hasRefundReceipt
            ) {
                return true;
            }

            return false;
        };

        Object.values(orders).forEach((order) => {
            if (!order || isExcludedOrder(order)) return;

            const ts = getOrderTimestamp(order);
            const d = new Date(ts);
            if (!(d >= startDate && d <= endDate)) return;

            const s = String(order.status || "").toLowerCase();

            // 1) Total Sales / Orders
            // Count orders: pending, confirmed, to_receive, out_for_delivery, delivered, picked_up, and failed GCash orders
            if (isIncludedOrder(order)) {
                const amount = toNumber(order.total || 0);
                total += amount;
                count++;
            }

            // 2) Product kilos (Sales Data Table â†’ "Product Kilos Yielded" column)
            //
            // Include products from orders that are:
            //   * pending
            //   * confirmed (cash / GCash)
            //   * to_receive
            //   * out_for_delivery
            //   * pickup_ready
            //   * delivered
            //   * picked_up
            //   * failed (but only GCash orders - failed cash orders are excluded)
            //
            // Excluded orders are already filtered by isExcludedOrder:
            //   * rejected (GCash/Cash)
            //   * cancelled (GCash/Cash)
            //   * failed (cash only)
            const orderPaymentMethod = String(order.paymentMethod || order.payment_method || "").toLowerCase();
            const isFailedGcash = s === "failed" && orderPaymentMethod === "gcash";
            const includeForKilos =
                s === "pending" ||
                s === "confirmed" ||
                s === "to_receive" ||
                s === "out_for_delivery" ||
                s === "pickup_ready" ||
                s === "ready_to_pickup" ||
                s === "delivered" ||
                s === "picked_up" ||
                isFailedGcash;

            if (includeForKilos) {
                const items = order.items || order.orderItems || [];
                if (Array.isArray(items)) {
                    items.forEach((item) => {
                        const productName =
                            item.productName || item.product_name || item.name || "Unknown";
                        const quantity = toNumber(item.quantity || item.qty || 0);

                        if (productName && quantity > 0) {
                            productKilos[productName] =
                                (productKilos[productName] || 0) + quantity;
                        }
                    });
                }
            }
        });

        return { total, count, productKilos };
    }

    renderAnalyticsChart(data, period) {
        const ctx = document.getElementById("salesChart");
        if (!ctx) return;

        // Destroy existing chart if it exists
        if (this.salesChart) {
            this.salesChart.destroy();
        }

        this.salesChart = new Chart(ctx, {
            type: "line",
            data: {
                labels: data.map((item) => item.period),
                datasets: [
                    {
                        label: "Sales (â‚±)",
                        data: data.map((item) => item.sales),
                        borderColor: "#4CAF50",
                        backgroundColor: "rgba(76, 175, 80, 0.1)",
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                    },
                ],
            },
            options: {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: `Organization Sales - ${period.charAt(0).toUpperCase() + period.slice(1)
                            } View`,
                    },
                    legend: {
                        display: false,
                    },
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            callback: function (value) {
                                return "â‚±" + value.toLocaleString();
                            },
                        },
                    },
                },
            },
        });
    }
    updateAnalyticsTable(data) {
        const tbody = document.getElementById("salesTableBody");
        if (!tbody) return;

        tbody.innerHTML = data
            .map((item, index) => {
                // Format product kilos display
                const productKilos = item.productKilos || {};
                let productKilosDisplay = "";

                const productEntries = Object.entries(productKilos);
                if (productEntries.length > 0) {
                    // Sort by kilos descending
                    productEntries.sort((a, b) => b[1] - a[1]);

                    // Create a nice display with each product on a new line
                    productKilosDisplay = productEntries
                        .map(([product, kilos]) => {
                            const kiloValue = Number(kilos || 0).toFixed(2);
                            return `<div style="margin-bottom: 4px;"><strong>${product}:</strong> ${kiloValue} kg</div>`;
                        })
                        .join("");
                } else {
                    productKilosDisplay =
                        '<div style="color: #999; font-style: italic;">No data</div>';
                }

                return `
                <tr>
                    <td>${item.period}</td>
                    <td>â‚±${Number(item.sales || 0).toLocaleString(undefined, {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2,
                })}</td>
                    <td>${item.orders}</td>
                    <td style="padding: 12px; line-height: 1.6;">${productKilosDisplay}</td>
                </tr>
            `;
            })
            .join("");
    }

    updateAnalyticsSummary(data) {
        const totalSales = data.reduce((sum, item) => sum + item.sales, 0);
        const totalOrders = data.reduce((sum, item) => sum + item.orders, 0);

        document.getElementById("totalSales").textContent =
            "â‚±" + totalSales.toLocaleString();
        document.getElementById("totalOrders").textContent =
            totalOrders.toLocaleString();
    }

    updateWeeklySalesTotal(data, period) {
        // Update the weekly sales total display on the dashboard
        const weeklySalesTotalElement = document.getElementById("weeklySalesTotal");
        if (!weeklySalesTotalElement) return;

        if (period === "weekly" && data.length > 0) {
            // Get the current week (most recent week in the data)
            const currentWeekData = data[data.length - 1];
            const weeklySales = currentWeekData.sales || 0;

            weeklySalesTotalElement.textContent =
                "â‚±" +
                weeklySales.toLocaleString(undefined, {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2,
                });
        } else {
            weeklySalesTotalElement.textContent = "â‚±0.00";
        }
    }
    async loadAnalyticsTopPerformers() {
        try {
            // This would load top products, customers, and farmer performance
            // For now, we'll show placeholder data
            this.updateAnalyticsTopProducts();
            this.updateAnalyticsTopCustomers();
            this.updateAnalyticsFarmerPerformance();
            this.updateAnalyticsSystemHealth();
        } catch (error) {
            console.error("Error loading top performers:", error);
        }
    }

    updateAnalyticsTopProducts() {
        const container = document.getElementById("topProductsList");
        if (!container) return;

        const orders = this._analyticsOrders || {};

        // NO DATE RANGE FILTER - Show all-time top products (cumulative)
        // This helps identify best-selling products

        // Count delivered, picked_up, failed_delivery, and failed_pickup orders
        const isIncludedStatus = (o) => {
            const s = String(o.status || "").toLowerCase();
            return (
                s === "delivered" ||
                s === "picked_up" ||
                s === "failed" ||
                s === "delivery_failed" ||
                s === "failed_pickup"
            );
        };

        const isExcludedOrder = (o) => {
            const s = String(o.status || "").toLowerCase();

            // Exclude cancelled orders
            if (s === "cancelled") {
                return true;
            }

            // Exclude orders with cancellation flags
            const isCancellationConfirmed =
                o.cancellationConfirmed === true ||
                o.cancellation_confirmed === true ||
                o.cancellation_confirmed === 1 ||
                o.cancellation_confirmed === "true";
            const hasRefundConfirmed =
                o.refundConfirmedAt ||
                o.refund_confirmed_at ||
                o.refundConfirmedAt > 0 ||
                o.refund_confirmed_at > 0;
            const hasRefundDenied =
                o.refundDenied === true ||
                o.refund_denied === true ||
                o.refundDenied === 1 ||
                o.refund_denied === "true";
            const hasRefundReceipt = o.refundReceiptUrl || o.refund_receipt_url;

            if (
                isCancellationConfirmed ||
                hasRefundConfirmed ||
                hasRefundDenied ||
                hasRefundReceipt
            ) {
                return true;
            }

            return false;
        };

        // Track product data: { orderCount, totalAmount }
        const productData = new Map();

        Object.values(orders).forEach((o) => {
            if (!o || isExcludedOrder(o) || !isIncludedStatus(o)) return;

            const items = Array.isArray(o.items)
                ? o.items
                : Array.isArray(o.orderItems)
                    ? o.orderItems
                    : [];
            items.forEach((it) => {
                const name = it.productName || it.product_name || it.name || "Unknown";
                const lineTotal = (Number(it.quantity) || 0) * (Number(it.price) || 0);

                if (!productData.has(name)) {
                    productData.set(name, { orderCount: 0, totalAmount: 0 });
                }

                const data = productData.get(name);
                data.orderCount += 1;
                data.totalAmount += isFinite(lineTotal) ? lineTotal : 0;
            });
        });

        // Get top 5 products sorted by total amount
        const topProducts = Array.from(productData.entries())
            .sort((a, b) => b[1].totalAmount - a[1].totalAmount)
            .slice(0, 5);

        if (topProducts.length === 0) {
            container.innerHTML =
                '<div class="top-item" style="color: #999; font-style: italic;">No data available</div>';
            return;
        }

        container.innerHTML = topProducts
            .map(
                ([name, data]) => `
            <div class="top-item" style="flex-direction: column; align-items: flex-start; padding: 12px; border-bottom: 1px solid #e5e7eb;">
                <div style="display: flex; justify-content: space-between; width: 100%; margin-bottom: 6px;">
                    <span class="item-name" style="font-weight: 600;">${name}</span>
                    <span class="item-value" style="font-weight: 700; color: #4caf50;">â‚±${Number(
                    data.totalAmount
                ).toLocaleString(undefined, {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2,
                })}</span>
                </div>
                <div style="font-size: 12px; color: #666;">
                    ${data.orderCount} order${data.orderCount !== 1 ? "s" : ""}
                </div>
            </div>
        `
            )
            .join("");
    }

    updateAnalyticsTopCustomers() {
        const container = document.getElementById("topCustomersList");
        if (!container) return;

        const orders = this._analyticsOrders || {};
        const customerTotals = new Map();

        // NO DATE RANGE FILTER - Show all-time top customers (cumulative)
        // This helps identify loyal customers regardless of when a new week starts

        // Count: delivered, picked_up, AND failed GCash orders
        const isIncludedOrder = (o) => {
            const s = String(o.status || "").toLowerCase();

            // Include successful orders
            if (s === "delivered" || s === "picked_up") {
                return true;
            }

            // Include failed orders ONLY if GCash payment
            if (s === "failed" || s === "delivery_failed" || s === "failed_pickup") {
                const paymentMethod = String(
                    o.paymentMethod || o.payment_method || ""
                ).toLowerCase();
                return paymentMethod === "gcash";
            }

            return false;
        };

        const isExcludedOrder = (o) => {
            const s = String(o.status || "").toLowerCase();

            // Exclude cancelled orders
            if (s === "cancelled") {
                return true;
            }

            // Exclude orders with cancellation flags
            const isCancellationConfirmed =
                o.cancellationConfirmed === true ||
                o.cancellation_confirmed === true ||
                o.cancellation_confirmed === 1 ||
                o.cancellation_confirmed === "true";
            const hasRefundConfirmed =
                o.refundConfirmedAt ||
                o.refund_confirmed_at ||
                o.refundConfirmedAt > 0 ||
                o.refund_confirmed_at > 0;
            const hasRefundDenied =
                o.refundDenied === true ||
                o.refund_denied === true ||
                o.refundDenied === 1 ||
                o.refund_denied === "true";
            const hasRefundReceipt = o.refundReceiptUrl || o.refund_receipt_url;

            if (
                isCancellationConfirmed ||
                hasRefundConfirmed ||
                hasRefundDenied ||
                hasRefundReceipt
            ) {
                return true;
            }

            return false;
        };

        Object.values(orders).forEach((o) => {
            // Count delivered, picked_up, and failed GCash orders
            if (!o || isExcludedOrder(o) || !isIncludedOrder(o)) return;

            // NO DATE CHECK - Count all-time orders to identify loyal customers

            // Get customer name
            const name =
                o.customerName ||
                o.customer_name ||
                o.customerFullName ||
                o.customer_full_name ||
                "Unknown";

            // Use 'total' column from orders table
            const amount = Number(o.total || 0);
            if (amount > 0) {
                customerTotals.set(name, (customerTotals.get(name) || 0) + amount);
            }
        });

        // Get top 5 customers sorted by total amount (all-time)
        const topCustomers = Array.from(customerTotals.entries())
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5);

        if (topCustomers.length === 0) {
            container.innerHTML =
                '<div class="top-item" style="color: #999; font-style: italic;">No data available</div>';
            return;
        }

        container.innerHTML = topCustomers
            .map(
                ([name, value]) => `
            <div class="top-item">
                <span class="item-name">${name}</span>
                <span class="item-value">â‚±${Number(value).toLocaleString(
                    undefined,
                    { minimumFractionDigits: 2, maximumFractionDigits: 2 }
                )}</span>
            </div>
        `
            )
            .join("");
    }

    async updateAnalyticsFarmerPerformance() {
        const container = document.getElementById("farmerPerformanceList");
        if (!container) return;

        try {
            const orders = this._analyticsOrders || {};

            // NO DATE RANGE FILTER - Show all-time contributions (cumulative)
            // This makes farmer contributions cumulative and never resets

            // Count successfully delivered, picked_up, failed_delivery, and failed_pickup orders
            const isIncludedStatus = (o) => {
                const s = String(o.status || "").toLowerCase();
                return (
                    s === "delivered" ||
                    s === "picked_up" ||
                    s === "failed" ||
                    s === "delivery_failed" ||
                    s === "failed_pickup"
                );
            };

            const isExcludedOrder = (o) => {
                const s = String(o.status || "").toLowerCase();

                // Exclude cancelled orders
                if (s === "cancelled") {
                    return true;
                }

                // Exclude orders with cancellation flags
                const isCancellationConfirmed =
                    o.cancellationConfirmed === true ||
                    o.cancellation_confirmed === true ||
                    o.cancellation_confirmed === 1 ||
                    o.cancellation_confirmed === "true";
                const hasRefundConfirmed =
                    o.refundConfirmedAt ||
                    o.refund_confirmed_at ||
                    o.refundConfirmedAt > 0 ||
                    o.refund_confirmed_at > 0;
                const hasRefundDenied =
                    o.refundDenied === true ||
                    o.refund_denied === true ||
                    o.refundDenied === 1 ||
                    o.refund_denied === "true";
                const hasRefundReceipt = o.refundReceiptUrl || o.refund_receipt_url;

                if (
                    isCancellationConfirmed ||
                    hasRefundConfirmed ||
                    hasRefundDenied ||
                    hasRefundReceipt
                ) {
                    return true;
                }

                return false;
            };

            // Load all QR contribution records once from Supabase
            // Check if cache exists and has data, otherwise fetch
            if (!this._qrCodesCache || Object.keys(this._qrCodesCache).length === 0) {
                try {
                    await this.fetchAllSupabaseQrRecords();
                } catch (qrError) {
                    console.error("Error fetching QR codes for farmer contributions:", qrError);
                    container.innerHTML =
                        '<div style="padding:12px;color:#c62828;">Failed to load QR codes. Please refresh the page.</div>';
                    return;
                }
            }
            const qrCodes = this._qrCodesCache || {};

            // Aggregate kilograms contributed per farmer by product (all-time, cumulative)
            // Structure: Map<farmerId, { name: string, products: Map<productName, kg> }>
            const farmerContributions = new Map();

            Object.entries(orders).forEach(([orderId, order]) => {
                // Count delivered, picked_up, failed_delivery, and failed_pickup orders
                if (!order || isExcludedOrder(order) || !isIncludedStatus(order))
                    return;

                const qr = qrCodes[orderId];
                if (!qr) {
                    // Order doesn't have a QR code yet - skip silently
                    return;
                }
                
                const contributions = Array.isArray(qr.contributions)
                    ? qr.contributions
                    : [];

                if (contributions.length === 0) {
                    // Order has QR code but no contributions - skip silently
                    return;
                }

                contributions.forEach((c) => {
                    const farmerId = c.farmerId || c.farmerName || "unknown";
                    const farmerName = c.farmerName || c.farmerId || "Unknown Farmer";
                    const productName =
                        c.productName || c.product_name || c.product || "Unknown Product";
                    const qty = Number(c.quantity) || 0;

                    // Skip if quantity is 0 or invalid
                    if (!qty || qty <= 0) {
                        return;
                    }

                    if (!farmerContributions.has(farmerId)) {
                        farmerContributions.set(farmerId, {
                            name: farmerName,
                            products: new Map(),
                        });
                    }

                    const farmer = farmerContributions.get(farmerId);
                    farmer.name = farmerName || farmer.name; // Update name if available

                    const currentQty = farmer.products.get(productName) || 0;
                    farmer.products.set(productName, currentQty + qty);
                });
            });

            // Convert to array and sort by total kg (all products combined)
            const farmersArray = Array.from(farmerContributions.entries())
                .map(([id, data]) => {
                    const totalKg = Array.from(data.products.values()).reduce(
                        (sum, kg) => sum + kg,
                        0
                    );
                    return {
                        id,
                        name: data.name,
                        products: data.products,
                        totalKg,
                    };
                })
                .sort((a, b) => b.totalKg - a.totalKg);

            if (farmersArray.length === 0) {
                // Check why no data is available for better error message
                const totalOrders = Object.keys(orders).length;
                const includedOrders = Object.entries(orders).filter(([orderId, order]) => {
                    return order && !isExcludedOrder(order) && isIncludedStatus(order);
                });
                const ordersWithQr = includedOrders.filter(([orderId]) => qrCodes[orderId]);
                const ordersWithContributions = includedOrders.filter(([orderId]) => {
                    const qr = qrCodes[orderId];
                    return qr && Array.isArray(qr.contributions) && qr.contributions.length > 0;
                });

                let message = '<div style="padding:12px;color:#666;font-style:italic;">';
                if (totalOrders === 0) {
                    message += 'No orders found.';
                } else if (includedOrders.length === 0) {
                    message += 'No eligible orders found (orders need to be delivered, picked up, or failed).';
                } else if (ordersWithQr.length === 0) {
                    message += 'No QR codes found for eligible orders. QR codes need to be generated first.';
                } else if (ordersWithContributions.length === 0) {
                    message += 'No farmer contributions found. Contributions need to be added to QR codes.';
                } else {
                    message += 'No contribution data available.';
                }
                message += '</div>';
                container.innerHTML = message;
                return;
            }

            // Display all farmers with their product contributions
            container.innerHTML = farmersArray
                .map((farmer) => {
                    // Sort products by kg for this farmer
                    const productsList = Array.from(farmer.products.entries())
                        .sort((a, b) => b[1] - a[1])
                        .map(([product, kg]) => {
                            return `<div style="font-size: 12px; color: #666; margin-left: 12px; margin-top: 4px;">â€¢ ${product}: ${Number(
                                kg
                            ).toLocaleString(undefined, {
                                minimumFractionDigits: 2,
                                maximumFractionDigits: 2,
                            })} kg</div>`;
                        })
                        .join("");

                    return `
                    <div style="padding: 12px; border-bottom: 1px solid #e5e7eb; margin-bottom: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                            <span style="font-weight: 600; color: #333;">${farmer.name
                        }</span>
                            <span style="font-weight: 700; color: #4caf50; font-size: 14px;">${Number(
                            farmer.totalKg
                        ).toLocaleString(undefined, {
                            minimumFractionDigits: 2,
                            maximumFractionDigits: 2,
                        })} kg</span>
                        </div>
                        ${productsList}
                    </div>
                `;
                })
                .join("");
        } catch (e) {
            console.error("updateAnalyticsFarmerPerformance error:", e);
            container.innerHTML =
                '<div style="padding:12px;color:#c62828;">Failed to load farmer contributions.</div>';
        }
    }
    updateAnalyticsSystemHealth() {
        const activeUsersCount = document.getElementById("activeUsersCount");
        if (activeUsersCount) {
            // This would count actual active users
            activeUsersCount.textContent = "25";
        }
    }

    // System Health & Heartbeat Monitoring
    async refreshSystemHealth() {
        const HEARTBEAT_STALE_THRESHOLD_MS = 30 * 1000; // 30 seconds - heartbeat is stale if older
        const HEARTBEAT_DOWN_THRESHOLD_MS = 60 * 1000; // 60 seconds - heartbeat is down if older

        function getSupabaseClientSafe() {
            try {
                if (typeof window !== "undefined") {
                    if (typeof window.getSupabaseClient === "function") {
                        return window.getSupabaseClient();
                    }
                    if (window.supabaseClient) {
                        return window.supabaseClient;
                    }
                }
            } catch (error) {
                console.warn("Supabase client unavailable:", error);
            }
            return null;
        }

        function formatTimeAgo(timestampMs) {
            if (!timestampMs) return "Never";
            const now = Date.now();
            const diff = now - timestampMs;
            const seconds = Math.floor(diff / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);

            if (seconds < 30) return "Just now";
            if (seconds < 60) return `${seconds}s ago`;
            if (minutes < 60) return `${minutes}m ago`;
            if (hours < 24) return `${hours}h ago`;
            return new Date(timestampMs).toLocaleString();
        }

        function updateStatusIndicator(elementId, status, timeText) {
            const element = document.getElementById(elementId);
            if (!element) return;

            const statusDot = element.querySelector(".status-dot");
            const statusText = element.querySelector(".status-text");
            const timeElement = document.getElementById(
                elementId.replace("Status", "Time")
            );

            if (!statusDot || !statusText) return;

            // Remove all status classes
            statusDot.className = "status-dot";
            element.setAttribute("data-status", status);

            switch (status) {
                case "online":
                    statusDot.style.backgroundColor = "#10b981"; // green
                    statusDot.style.boxShadow = "0 0 8px rgba(16, 185, 129, 0.5)";
                    statusText.textContent = "Online";
                    break;
                case "warning":
                    statusDot.style.backgroundColor = "#f59e0b"; // amber
                    statusDot.style.boxShadow = "0 0 8px rgba(245, 158, 11, 0.5)";
                    statusText.textContent = "Warning";
                    break;
                case "offline":
                    statusDot.style.backgroundColor = "#ef4444"; // red
                    statusDot.style.boxShadow = "0 0 8px rgba(239, 68, 68, 0.5)";
                    statusText.textContent = "Offline";
                    break;
                default:
                    statusDot.style.backgroundColor = "#6b7280"; // gray
                    statusDot.style.boxShadow = "none";
                    statusText.textContent = "Checking...";
            }

            if (timeElement) {
                timeElement.textContent = timeText || "-";
            }
        }

        try {
            const supabase = getSupabaseClientSafe();
            const now = Date.now();

            // Check Supabase connectivity first
            let supabaseStatus = "offline";
            let supabaseTime = "Never";
            let systemData = null;

            if (supabase) {
                try {
                    const { data, error } = await supabase
                        .from("system_data")
                        .select("*")
                        .eq("id", "coopTime")
                        .maybeSingle();

                    if (!error && data) {
                        systemData = data;
                        supabaseStatus = "online";
                        supabaseTime = formatTimeAgo(data.updated_at);
                    } else if (error) {
                        console.warn("Supabase query error:", error);
                        supabaseStatus = "offline";
                        supabaseTime = "Error";
                    }
                } catch (e) {
                    console.error("Supabase connectivity check failed:", e);
                    supabaseStatus = "offline";
                    supabaseTime = "Connection failed";
                }
            } else {
                supabaseStatus = "offline";
                supabaseTime = "Client unavailable";
            }

            // Update Supabase status
            updateStatusIndicator("supabaseStatus", supabaseStatus, supabaseTime);

            // Store Supabase status for main dashboard display
            this._lastSupabaseStatus = supabaseStatus;
            this._lastSupabaseTime = supabaseTime;

            // Check Web Dashboard heartbeat (source: 'staff-admin-desktop')
            // AUTHORITATIVE SOURCE: Web dashboard heartbeat is the primary time source
            let webStatus = "offline";
            let webTime = "Never";
            if (systemData && systemData.source === "staff-admin-desktop") {
                const age = now - (systemData.updated_at || 0);
                if (age < HEARTBEAT_STALE_THRESHOLD_MS) {
                    webStatus = "online";
                } else if (age < HEARTBEAT_DOWN_THRESHOLD_MS) {
                    webStatus = "warning";
                } else {
                    webStatus = "offline";
                }
                webTime = formatTimeAgo(systemData.updated_at);
            } else {
                // Check if we have a local heartbeat connection status (queued/fallback)
                if (typeof window.getCoopTimeConnectionStatus === "function") {
                    const connStatus = window.getCoopTimeConnectionStatus();
                    if (connStatus.lastSuccessfulPublish) {
                        const age = now - connStatus.lastSuccessfulPublish;
                        if (age < HEARTBEAT_STALE_THRESHOLD_MS) {
                            webStatus = connStatus.isConnected ? "online" : "warning"; // Warning if queued
                        } else if (age < HEARTBEAT_DOWN_THRESHOLD_MS) {
                            webStatus = "warning";
                        } else {
                            webStatus = "offline";
                        }
                        // Show queued status if not connected
                        if (!connStatus.isConnected && connStatus.hasFallback) {
                            webTime =
                                formatTimeAgo(connStatus.lastSuccessfulPublish) + " (queued)";
                        } else {
                            webTime = formatTimeAgo(connStatus.lastSuccessfulPublish);
                        }
                    } else {
                        // Check localStorage fallback
                        if (typeof window.getCoopTimeFallback === "function") {
                            const fallback = window.getCoopTimeFallback();
                            if (fallback && fallback.storedAt) {
                                const age = now - fallback.storedAt;
                                if (age < 10 * 60 * 1000) {
                                    // 10 minutes
                                    webStatus = "warning";
                                    webTime = formatTimeAgo(fallback.storedAt) + " (local)";
                                } else {
                                    webStatus = "offline";
                                    webTime = "Stale fallback";
                                }
                            } else {
                                webStatus = "offline";
                                webTime = "No heartbeat";
                            }
                        } else {
                            webStatus = "offline";
                            webTime = "No heartbeat";
                        }
                    }
                } else {
                    webStatus = "offline";
                    webTime = "Not initialized";
                }
            }
            updateStatusIndicator("webHeartbeatStatus", webStatus, webTime);

            // Show authoritative badge and validate time (Admin Only) - on main dashboard
            if (this.isAdmin && this.isAdmin()) {
                // Show the authoritative time container on main dashboard
                const timeContainer = document.getElementById(
                    "authoritativeTimeContainer"
                );
                if (timeContainer) {
                    timeContainer.style.display = "block";
                }

                // Show authoritative badge
                const badge = document.getElementById("authoritativeTimeBadge");
                if (badge) {
                    badge.style.display = "inline-flex";
                }

                // Show current PC time display (on main dashboard)
                const pcTimeDisplay = document.getElementById("currentPCTimeDisplay");
                const pcTimeValue = document.getElementById("currentPCTimeValue");
                if (pcTimeDisplay) {
                    pcTimeDisplay.style.display = "block";
                }
                if (pcTimeValue) {
                    const pcDate = new Date(now);
                    const timeString = pcDate.toLocaleString("en-US", {
                        weekday: "short",
                        year: "numeric",
                        month: "short",
                        day: "numeric",
                        hour: "2-digit",
                        minute: "2-digit",
                        second: "2-digit",
                        timeZoneName: "short",
                    });
                    pcTimeValue.textContent = timeString;
                }

                // Show Supabase status (on main dashboard)
                const supabaseDisplay = document.getElementById(
                    "supabaseStatusDisplay"
                );
                const supabaseStatusDot = document.getElementById("supabaseStatusDot");
                const supabaseStatusText =
                    document.getElementById("supabaseStatusText");
                const supabaseStatusTime =
                    document.getElementById("supabaseStatusTime");
                if (supabaseDisplay) {
                    supabaseDisplay.style.display = "block";
                }
                if (supabaseStatusDot && supabaseStatusText && supabaseStatusTime) {
                    // Get Supabase status from refreshSystemHealth
                    const supabaseStatus = this._lastSupabaseStatus || "offline";
                    const supabaseTime = this._lastSupabaseTime || "Unknown";

                    // Update status dot color
                    if (supabaseStatus === "online") {
                        supabaseStatusDot.style.background = "#10b981";
                        supabaseStatusDot.style.boxShadow =
                            "0 0 6px rgba(16, 185, 129, 0.5)";
                        supabaseStatusText.textContent = "Active";
                        supabaseStatusText.style.color = "#059669";
                    } else if (supabaseStatus === "warning") {
                        supabaseStatusDot.style.background = "#f59e0b";
                        supabaseStatusDot.style.boxShadow =
                            "0 0 6px rgba(245, 158, 11, 0.5)";
                        supabaseStatusText.textContent = "Warning";
                        supabaseStatusText.style.color = "#d97706";
                    } else {
                        supabaseStatusDot.style.background = "#ef4444";
                        supabaseStatusDot.style.boxShadow =
                            "0 0 6px rgba(239, 68, 68, 0.5)";
                        supabaseStatusText.textContent = "Inactive";
                        supabaseStatusText.style.color = "#dc2626";
                    }

                    supabaseStatusTime.textContent = supabaseTime;
                }

                // Validate PC time
                this.validatePCTime(now, systemData);
            } else {
                // Hide time container and all elements for non-admin users
                const timeContainer = document.getElementById(
                    "authoritativeTimeContainer"
                );
                if (timeContainer) {
                    timeContainer.style.display = "none";
                }
                const badge = document.getElementById("authoritativeTimeBadge");
                if (badge) {
                    badge.style.display = "none";
                }
                const pcTimeDisplay = document.getElementById("currentPCTimeDisplay");
                if (pcTimeDisplay) {
                    pcTimeDisplay.style.display = "none";
                }
                const warning = document.getElementById("timeValidationWarning");
                if (warning) {
                    warning.style.display = "none";
                }
            }

            // Check Customer App heartbeat
            // Note: Customer app may not be publishing heartbeats yet, so we check Supabase connectivity
            // In the future, customer app should publish with source: 'customer-app-mobile'
            let customerAppStatus = "offline";
            let customerAppTime = "Never";

            // For now, if Supabase is online, assume customer app can connect
            // In production, customer app should publish its own heartbeat
            if (supabaseStatus === "online") {
                // Try to check if customer app is reading from Supabase
                // This is a proxy check - ideally customer app should publish heartbeats
                customerAppStatus = "warning"; // Warning because we can't directly verify
                customerAppTime = "Supabase accessible";
            } else {
                customerAppStatus = "offline";
                customerAppTime = "Supabase unavailable";
            }
            updateStatusIndicator(
                "customerAppHeartbeatStatus",
                customerAppStatus,
                customerAppTime
            );

            // Check Delivery App heartbeat
            // Note: Delivery app may not be publishing heartbeats yet
            let deliveryAppStatus = "offline";
            let deliveryAppTime = "Never";

            if (supabaseStatus === "online") {
                // Try to check if delivery app is reading from Supabase
                deliveryAppStatus = "warning"; // Warning because we can't directly verify
                deliveryAppTime = "Supabase accessible";
            } else {
                deliveryAppStatus = "offline";
                deliveryAppTime = "Supabase unavailable";
            }
            updateStatusIndicator(
                "deliveryAppHeartbeatStatus",
                deliveryAppStatus,
                deliveryAppTime
            );

            // Calculate overall system status
            const statuses = [
                supabaseStatus,
                webStatus,
                customerAppStatus,
                deliveryAppStatus,
            ];
            const onlineCount = statuses.filter((s) => s === "online").length;
            const warningCount = statuses.filter((s) => s === "warning").length;
            const offlineCount = statuses.filter((s) => s === "offline").length;

            let overallStatus = "offline";
            if (offlineCount === 0 && warningCount === 0) {
                overallStatus = "online";
            } else if (offlineCount === 0) {
                overallStatus = "warning";
            } else {
                overallStatus = "offline";
            }

            updateStatusIndicator("overallSystemStatus", overallStatus, "");

            console.log("âœ… System health check completed:", {
                supabase: supabaseStatus,
                web: webStatus,
                customerApp: customerAppStatus,
                deliveryApp: deliveryAppStatus,
                overall: overallStatus,
            });
        } catch (error) {
            console.error("âŒ Error refreshing system health:", error);
            // Set all to offline on error
            updateStatusIndicator("supabaseStatus", "offline", "Error");
            updateStatusIndicator("webHeartbeatStatus", "offline", "Error");
            updateStatusIndicator("customerAppHeartbeatStatus", "offline", "Error");
            updateStatusIndicator("deliveryAppHeartbeatStatus", "offline", "Error");
            updateStatusIndicator("overallSystemStatus", "offline", "");
        }
    }

    // Validate PC time for potential issues (Admin Only)
    validatePCTime(currentTimeMs, systemData) {
        const warning = document.getElementById("timeValidationWarning");
        const warningMessage = document.getElementById("timeValidationMessage");

        if (!warning || !warningMessage) return;

        const now = new Date(currentTimeMs);
        const issues = [];

        // Check 1: Year is reasonable (not in past, not too far in future)
        const currentYear = now.getFullYear();
        const expectedYear = new Date().getFullYear(); // This should match, but check anyway
        if (currentYear < 2020 || currentYear > 2100) {
            issues.push(
                `PC year is ${currentYear}, which appears incorrect. Expected year around ${expectedYear}.`
            );
        }

        // Check 2: Month is valid
        const month = now.getMonth() + 1; // getMonth() returns 0-11
        if (month < 1 || month > 12) {
            issues.push(`PC month is invalid (${month}).`);
        }

        // Check 3: Day is valid for the month
        const day = now.getDate();
        const daysInMonth = new Date(
            now.getFullYear(),
            now.getMonth() + 1,
            0
        ).getDate();
        if (day < 1 || day > daysInMonth) {
            issues.push(`PC day (${day}) is invalid for month ${month}.`);
        }

        // Check 4: Compare with last known good time from Supabase (if available)
        if (systemData && systemData.updated_at) {
            const lastKnownTime = new Date(systemData.updated_at);
            const timeDiff = Math.abs(currentTimeMs - systemData.updated_at);

            // If current time is more than 5 minutes behind the last known time, warn
            if (currentTimeMs < systemData.updated_at - 5 * 60 * 1000) {
                issues.push(
                    `PC time appears to be behind the last known good time by ${Math.floor(
                        timeDiff / 60000
                    )} minutes.`
                );
            }

            // If current time is more than 1 hour ahead of last known time, warn
            if (currentTimeMs > systemData.updated_at + 60 * 60 * 1000) {
                issues.push(
                    `PC time appears to be ahead of the last known good time by ${Math.floor(
                        timeDiff / 60000
                    )} minutes.`
                );
            }
        }

        // Check 5: Time appears to be in the past compared to typical system time
        // This is a heuristic check - if time is before 2020, it's definitely wrong
        if (currentTimeMs < new Date("2020-01-01").getTime()) {
            issues.push(
                `PC time appears to be set to a date before 2020, which is likely incorrect.`
            );
        }

        // Check 6: Timezone offset seems extreme (more than 12 hours from UTC)
        const timezoneOffset = now.getTimezoneOffset();
        if (Math.abs(timezoneOffset) > 12 * 60) {
            issues.push(
                `PC timezone offset is ${timezoneOffset / 60
                } hours from UTC, which seems unusual.`
            );
        }

        // Display warnings if any issues found
        if (issues.length > 0) {
            warningMessage.innerHTML = issues
                .map((issue) => `â€¢ ${issue}`)
                .join("<br>");
            warning.style.display = "block";
            console.warn("âš ï¸ PC Time Validation Issues:", issues);
        } else {
            warning.style.display = "none";
        }
    }

    // Set up real-time monitoring for system health
    setupSystemHealthMonitoring() {
        // Refresh immediately
        this.refreshSystemHealth();

        // Refresh every 10 seconds
        if (this._healthMonitoringInterval) {
            clearInterval(this._healthMonitoringInterval);
        }

        this._healthMonitoringInterval = setInterval(() => {
            this.refreshSystemHealth();
        }, 10000);

        // Set up Supabase real-time listener for system_data changes
        const supabase =
            typeof window.getSupabaseClient === "function"
                ? window.getSupabaseClient()
                : window.supabaseClient || null;

        if (supabase && !this._healthChannel) {
            try {
                this._healthChannel = supabase
                    .channel("system_health_monitor")
                    .on(
                        "postgres_changes",
                        {
                            event: "*",
                            schema: "public",
                            table: "system_data",
                            filter: "id=eq.coopTime",
                        },
                        (payload) => {
                            console.log("ðŸ“¡ System data heartbeat update received:", payload);
                            // Refresh health status when heartbeat updates
                            this.refreshSystemHealth();
                        }
                    )
                    .subscribe();

                console.log("âœ… System health real-time monitoring started");
            } catch (e) {
                console.warn("âš ï¸ Failed to set up real-time health monitoring:", e);
            }
        }
    }

    // Export sales report as PDF
    async exportSalesReport() {
        try {
            // Ensure analytics data is loaded for the current period
            const activeBtn = document.querySelector(".time-btn.active");
            const period = (activeBtn && activeBtn.dataset.period) || "weekly";
            if (
                !this._analyticsRange ||
                this._analyticsRange.period !== period ||
                !this._analyticsOrders
            ) {
                await this.loadAnalyticsData(period);
            }

            const orders = this._analyticsOrders || {};
            const range = this._analyticsRange;

            // Use same filter logic as display functions (cumulative, all-time)
            const isIncludedStatus = (o) => {
                const s = String(o.status || "").toLowerCase();
                return (
                    s === "delivered" ||
                    s === "picked_up" ||
                    s === "failed" ||
                    s === "delivery_failed" ||
                    s === "failed_pickup"
                );
            };

            const isExcludedOrder = (o) => {
                const s = String(o.status || "").toLowerCase();

                // Exclude cancelled orders
                if (s === "cancelled") {
                    return true;
                }

                // Exclude orders with cancellation flags
                const isCancellationConfirmed =
                    o.cancellationConfirmed === true ||
                    o.cancellation_confirmed === true ||
                    o.cancellation_confirmed === 1 ||
                    o.cancellation_confirmed === "true";
                const hasRefundConfirmed =
                    o.refundConfirmedAt ||
                    o.refund_confirmed_at ||
                    o.refundConfirmedAt > 0 ||
                    o.refund_confirmed_at > 0;
                const hasRefundDenied =
                    o.refundDenied === true ||
                    o.refund_denied === true ||
                    o.refundDenied === 1 ||
                    o.refund_denied === "true";
                const hasRefundReceipt = o.refundReceiptUrl || o.refund_receipt_url;

                if (
                    isCancellationConfirmed ||
                    hasRefundConfirmed ||
                    hasRefundDenied ||
                    hasRefundReceipt
                ) {
                    return true;
                }

                return false;
            };

            // Prepare aggregate data table (Period, Total Sales, Orders)
            const formatCurrency = (amount) => {
                const n = Number(amount) || 0;
                // Use text prefix to avoid missing glyphs (â‚±) in core PDF fonts
                return `PHP ${n.toLocaleString(undefined, {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2,
                })}`;
            };
            const series = Array.isArray(this._analyticsData)
                ? this._analyticsData
                : [];
            const bodyRows = series.map((item, idx) => {
                return [
                    item.period,
                    formatCurrency(item.sales),
                    (item.orders || 0).toLocaleString(),
                ];
            });
            const grandTotal = series.reduce((s, i) => s + (i.sales || 0), 0);

            // Build Top Products (cumulative, all-time) - matches display logic
            const topProductsData = new Map();
            Object.values(orders).forEach((o) => {
                if (!o || isExcludedOrder(o) || !isIncludedStatus(o)) return;
                // NO DATE FILTER - cumulative all-time
                const items = Array.isArray(o.items)
                    ? o.items
                    : Array.isArray(o.orderItems)
                        ? o.orderItems
                        : [];
                items.forEach((it) => {
                    const name =
                        it.productName || it.product_name || it.name || "Unknown";
                    const line = (Number(it.quantity) || 0) * (Number(it.price) || 0);
                    if (!topProductsData.has(name)) {
                        topProductsData.set(name, { orderCount: 0, totalAmount: 0 });
                    }
                    const data = topProductsData.get(name);
                    data.orderCount += 1;
                    data.totalAmount += isFinite(line) ? line : 0;
                });
            });
            const topProducts = Array.from(topProductsData.entries())
                .sort((a, b) => b[1].totalAmount - a[1].totalAmount)
                .slice(0, 5)
                .map(([name, data]) => [name, data.totalAmount]);

            // Build Top Customers (cumulative, all-time) - matches display logic
            // Include: delivered, picked_up, AND failed GCash orders
            const topCustomersMap = new Map();
            Object.values(orders).forEach((o) => {
                if (!o || isExcludedOrder(o)) return;

                // Include delivered/picked_up orders
                const s = String(o.status || "").toLowerCase();
                let shouldInclude = s === "delivered" || s === "picked_up";

                // Include failed orders ONLY if GCash payment
                if (
                    s === "failed" ||
                    s === "delivery_failed" ||
                    s === "failed_pickup"
                ) {
                    const paymentMethod = String(
                        o.paymentMethod || o.payment_method || ""
                    ).toLowerCase();
                    shouldInclude = paymentMethod === "gcash";
                }

                if (!shouldInclude) return;

                // NO DATE FILTER - cumulative all-time
                const cust =
                    o.customerName ||
                    o.customer_name ||
                    o.customerFullName ||
                    o.customer_full_name ||
                    "Unknown";
                const amt = Number(o.total || 0);
                if (amt > 0) {
                    topCustomersMap.set(cust, (topCustomersMap.get(cust) || 0) + amt);
                }
            });
            const topCustomers = Array.from(topCustomersMap.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);

            // Prepare dynamic highlights for narrative
            const maxItem = series.reduce(
                (best, it) =>
                    !best || (it.sales || 0) > (best.sales || 0) ? it : best,
                null
            );
            const highestLabel = maxItem ? maxItem.period : "";
            const topProductName = (topProducts[0] && topProducts[0][0]) || "N/A";
            const topCustomerName = (topCustomers[0] && topCustomers[0][0]) || "N/A";
            const topCustomerAmt =
                topCustomers[0] && topCustomers[0][1]
                    ? formatCurrency(topCustomers[0][1])
                    : formatCurrency(0);
            const totalSalesText = formatCurrency(grandTotal);
            const monthYear = range
                ? range.end.toLocaleString("default", {
                    month: "long",
                    year: "numeric",
                })
                : "";

            // Generate PDF using jsPDF + autoTable
            const { jsPDF } = window.jspdf || {};
            if (!jsPDF || !window.jspdf || !("autoTable" in (jsPDF.API || {}))) {
                this.showErrorMessage(
                    "PDF libraries not loaded. Please refresh and try again."
                );
                return;
            }

            const doc = new jsPDF({
                orientation: "portrait",
                unit: "pt",
                format: "a4",
            });
            // Layout constants (bumped for readability)
            const FONT_HEADER = 16;
            const FONT_SUBHEADER = 13;
            const FONT_BODY = 11;
            const MM = 2.834645669;
            const marginLeft = Math.round(25 * MM),
                marginRight = Math.round(25 * MM),
                marginTop = 40,
                marginBottom = 40;
            const pageWidth = doc.internal.pageSize.getWidth();
            const pageHeight = doc.internal.pageSize.getHeight();
            const contentWidth = pageWidth - marginLeft - marginRight;
            const tableMargins = {
                left: marginLeft,
                right: marginRight,
                top: 28,
                bottom: 40,
            }; // slightly larger top margin on new pages, reserve footer space
            const maxTextWidth = Math.min(180 * MM, contentWidth); // 180mm cap
            let y = marginTop;

            // Helpers
            const ensureSpace = (needed) => {
                if (y + needed > pageHeight - marginBottom) {
                    doc.addPage();
                    y = marginTop;
                }
            };
            const writeParagraph = (text, fontSize = FONT_BODY) => {
                doc.setFont("times", "normal");
                doc.setFontSize(fontSize);
                const lineHeight = fontSize * 1.5;
                // Support multi-paragraph input separated by blank lines
                const paragraphs = String(text).split(/\n\n+/);
                paragraphs.forEach((p, idx) => {
                    const lines = doc.splitTextToSize(p.trim(), maxTextWidth);
                    // spacing before each paragraph
                    y += idx === 0 ? 10 : 8;
                    // Ensure there is enough space for the whole paragraph block
                    ensureSpace(lines.length * lineHeight);
                    // Pass the whole lines array at once to enable true justification
                    doc.text(lines, marginLeft, y, {
                        maxWidth: maxTextWidth,
                        align: "justify",
                    });
                    // advance y by total height of the lines
                    y += lines.length * lineHeight;
                    // spacing after paragraph
                    y += 8;
                });
            };
            const formatNumber = (n) =>
                Number(n || 0).toLocaleString(undefined, {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2,
                });
            const centerText = (text, fontSize, isBold = false) => {
                doc.setFont("times", isBold ? "bold" : "normal");
                doc.setFontSize(fontSize);
                const lineHeight = fontSize * 1.5;
                ensureSpace(lineHeight);
                doc.text(text, pageWidth / 2, y, { align: "center" });
                y += lineHeight;
            };

            // Header
            centerText("AgriCart Sales Report", FONT_HEADER, true);
            centerText(
                `${period.charAt(0).toUpperCase() + period.slice(1)} Sales Report`,
                FONT_SUBHEADER,
                false
            );
            doc.setFont("times", "normal");
            doc.setFontSize(FONT_BODY);
            ensureSpace(FONT_BODY * 1.5);
            doc.text(`Date: ${new Date().toLocaleDateString()}`, marginLeft, y);
            y += FONT_BODY * 1.5;
            doc.setDrawColor(180);
            doc.line(marginLeft, y, pageWidth - marginRight, y);
            y += 14;

            // Sales graph (chart image)
            try {
                const canvas = document.getElementById("salesChart");
                // Use this.salesChart directly - it's the Chart.js instance
                const chart = this.salesChart;
                let imgData = "";
                if (chart && typeof chart.toBase64Image === "function") {
                    // Ensure latest render, then capture
                    try {
                        chart.update(0);
                    } catch (_) { }
                    await new Promise(requestAnimationFrame);
                    imgData = chart.toBase64Image("image/png", 1.0);
                } else if (canvas && canvas.toDataURL) {
                    imgData = canvas.toDataURL("image/png", 1.0);
                }
                if (imgData) {
                    const imgMaxWidth = contentWidth;
                    const imgWidth = Math.min(imgMaxWidth, contentWidth);
                    const ratio =
                        canvas && canvas.height > 0 ? canvas.width / canvas.height : 2;
                    const imgHeight = Math.min(240, imgWidth / ratio); // cap height to keep layout tight
                    ensureSpace(imgHeight);
                    const imgX = (pageWidth - imgWidth) / 2;
                    doc.addImage(
                        imgData,
                        "PNG",
                        imgX,
                        y,
                        imgWidth,
                        imgHeight,
                        undefined,
                        "FAST"
                    );
                    y += imgHeight + 35;
                }
            } catch (_) {
                // If capture fails, continue without the image
            }

            // No description text - removed as per requirements
            // Key Metrics removed as per requirements

            // Add separator line before Sales by Period
            doc.setDrawColor(220, 220, 220);
            doc.setLineWidth(0.5);
            doc.line(marginLeft, y, pageWidth - marginRight, y);
            y += 20;

            // Sales by Period
            doc.setFont("times", "bold");
            doc.setFontSize(FONT_SUBHEADER);
            ensureSpace(FONT_SUBHEADER * 1.2);
            doc.setTextColor(33);
            doc.text("Sales by Period", marginLeft, y);
            doc.setTextColor(0);
            y += 10;
            doc.setFont("times", "normal");
            doc.autoTable({
                startY: y + 8,
                head: [["Period", "Total Sales", "Orders"]],
                body: bodyRows,
                styles: {
                    font: "times",
                    fontSize: FONT_BODY,
                    cellPadding: 7,
                    valign: "top",
                    overflow: "linebreak",
                },
                headStyles: {
                    font: "times",
                    fontStyle: "bold",
                    fillColor: [120, 170, 125],
                    textColor: 255,
                },
                alternateRowStyles: { fillColor: [243, 249, 244] },
                tableWidth: contentWidth,
                columnStyles: {
                    0: { halign: "left" },
                    1: { halign: "center", fontStyle: "bold" },
                    2: { halign: "center" },
                },
                margin: tableMargins,
                pageBreak: "auto",
                didParseCell: (data) => {
                    if (
                        (data.section === "head" || data.section === "body") &&
                        data.column &&
                        data.column.index > 0
                    ) {
                        data.cell.styles.halign = "center";
                    }
                },
                didDrawPage: (data) => {
                    // Footer with page numbers
                    const pageCount = doc.internal.getNumberOfPages();
                    const pageSize = doc.internal.pageSize;
                    const pageWidth = pageSize.getWidth();
                    doc.setFont("times", "normal");
                    doc.setFontSize(FONT_BODY);
                    doc.setTextColor(120);
                    doc.text(
                        `Page ${data.pageNumber} of ${pageCount}`,
                        pageWidth - marginRight,
                        pageSize.getHeight() - 20,
                        { align: "right" }
                    );
                },
            });

            // Top Products and Top Customers as bold lists
            // Increased spacing for modern look
            let postY = doc.lastAutoTable ? doc.lastAutoTable.finalY + 35 : y + 35;
            const writeList = (title, items) => {
                // Add subtle separator line for modern look
                if (postY > marginTop + 50) {
                    doc.setDrawColor(220, 220, 220);
                    doc.setLineWidth(0.5);
                    doc.line(marginLeft, postY - 15, pageWidth - marginRight, postY - 15);
                }

                // Render Top Products/Customers as a neat table with Rank
                doc.setFont("times", "bold");
                doc.setFontSize(FONT_SUBHEADER);
                ensureSpace(FONT_SUBHEADER * 1.2);
                doc.text(title, marginLeft, postY);
                postY += 14;
                const label = /product/i.test(title)
                    ? "Product"
                    : /customer/i.test(title)
                        ? "Customer"
                        : "Item";
                const rows = items.map(([name, value], idx) => ({
                    rank: String(idx + 1),
                    name,
                    amount: formatCurrency(value),
                }));
                doc.autoTable({
                    startY: postY,
                    columns: [
                        { header: "Rank", dataKey: "rank" },
                        { header: label, dataKey: "name" },
                        { header: "Amount", dataKey: "amount" },
                    ],
                    body: rows,
                    styles: {
                        font: "times",
                        fontSize: FONT_BODY,
                        cellPadding: 7,
                        overflow: "linebreak",
                    },
                    headStyles: {
                        font: "times",
                        fontStyle: "bold",
                        fillColor: [204, 232, 207],
                        textColor: 33,
                    },
                    didParseCell: (data) => {
                        // Center the Amount column cells (both header and body)
                        if (
                            (data.section === "head" || data.section === "body") &&
                            data.column &&
                            data.column.dataKey === "amount"
                        ) {
                            data.cell.styles.halign = "center";
                        }
                    },
                    margin: tableMargins,
                    tableWidth: contentWidth,
                    columnStyles: {
                        rank: { halign: "center", cellWidth: 50 },
                        name: { halign: "left" },
                        amount: { halign: "center", cellWidth: 140 },
                    },
                });
                postY = (doc.lastAutoTable ? doc.lastAutoTable.finalY : postY) + 30;
            };
            writeList("Top Products", topProducts);
            writeList("Top Customers", topCustomers);

            // Farmer Contributions (by kg) - cumulative, all-time with product breakdown
            try {
                if (!this._qrCodesCache) {
                    await this.fetchAllSupabaseQrRecords();
                }
                const qrCodes = this._qrCodesCache || {};

                // Structure: Map<farmerId, { name: string, products: Map<productName, kg> }>
                const farmerContributions = new Map();

                Object.entries(orders).forEach(([orderId, order]) => {
                    // Use same filter as display: delivered, picked_up, failed orders (NO DATE FILTER)
                    if (!order || isExcludedOrder(order) || !isIncludedStatus(order))
                        return;

                    const qr = qrCodes[orderId];
                    const contribs = Array.isArray(qr?.contributions)
                        ? qr.contributions
                        : [];

                    contribs.forEach((c) => {
                        const farmerId = c.farmerId || c.farmerName || "unknown";
                        const farmerName = c.farmerName || c.farmerId || "Unknown Farmer";
                        const productName =
                            c.productName || c.product_name || c.product || "Unknown Product";
                        const qty = Number(c.quantity) || 0;

                        if (!farmerContributions.has(farmerId)) {
                            farmerContributions.set(farmerId, {
                                name: farmerName,
                                products: new Map(),
                            });
                        }

                        const farmer = farmerContributions.get(farmerId);
                        farmer.name = farmerName || farmer.name;

                        const currentQty = farmer.products.get(productName) || 0;
                        farmer.products.set(productName, currentQty + qty);
                    });
                });

                // Convert to array and sort by total kg
                const farmersArray = Array.from(farmerContributions.entries())
                    .map(([id, data]) => {
                        const totalKg = Array.from(data.products.values()).reduce(
                            (sum, kg) => sum + kg,
                            0
                        );
                        return {
                            id,
                            name: data.name,
                            products: data.products,
                            totalKg,
                        };
                    })
                    .sort((a, b) => b.totalKg - a.totalKg);

                // Build table rows with product breakdown
                const farmerRows = [];
                farmersArray.forEach((farmer, idx) => {
                    // Add farmer row with total
                    farmerRows.push({
                        rank: String(idx + 1),
                        farmer: farmer.name,
                        contribution: `${formatNumber(farmer.totalKg)} kg (Total)`,
                        _isHeader: true,
                    });

                    // Add product rows (indented)
                    const productsList = Array.from(farmer.products.entries()).sort(
                        (a, b) => b[1] - a[1]
                    );

                    productsList.forEach(([product, kg]) => {
                        farmerRows.push({
                            rank: "",
                            farmer: `  â€¢ ${product}`,
                            contribution: `${formatNumber(kg)} kg`,
                            _isHeader: false,
                        });
                    });
                });

                if (farmerRows.length > 0) {
                    // If little space remains, move to a fresh page
                    if (postY > pageHeight - marginBottom - 140) {
                        doc.addPage();
                        postY = marginTop;
                    }

                    // Add subtle separator line for modern look
                    doc.setDrawColor(220, 220, 220);
                    doc.setLineWidth(0.5);
                    doc.line(marginLeft, postY - 15, pageWidth - marginRight, postY - 15);

                    doc.setFont("times", "bold");
                    doc.setFontSize(FONT_SUBHEADER);
                    doc.setTextColor(33);
                    ensureSpace(FONT_SUBHEADER * 1.2);
                    doc.text("Farmer Contributions (by kg)", marginLeft, postY);
                    doc.setTextColor(0);
                    postY += 14;
                    doc.autoTable({
                        startY: postY,
                        columns: [
                            { header: "Rank", dataKey: "rank" },
                            { header: "Farmer / Product", dataKey: "farmer" },
                            { header: "Contribution", dataKey: "contribution" },
                        ],
                        body: farmerRows,
                        styles: {
                            font: "times",
                            fontSize: FONT_BODY,
                            cellPadding: 7,
                            overflow: "linebreak",
                        },
                        headStyles: {
                            font: "times",
                            fontStyle: "bold",
                            fillColor: [204, 232, 207],
                            textColor: 33,
                        },
                        didParseCell: (data) => {
                            if (data.section === "body") {
                                const isHeader = data.row.raw && data.row.raw._isHeader;
                                if (isHeader) {
                                    data.cell.styles.fontStyle = "bold";
                                    data.cell.styles.fillColor = [243, 249, 244];
                                }
                            }
                            // Center the Contribution column
                            if (
                                (data.section === "head" || data.section === "body") &&
                                data.column &&
                                data.column.dataKey === "contribution"
                            ) {
                                data.cell.styles.halign = "center";
                            }
                        },
                        margin: tableMargins,
                        tableWidth: contentWidth,
                        columnStyles: {
                            rank: { halign: "center", cellWidth: 50 },
                            farmer: { halign: "left" },
                            contribution: { halign: "center" },
                        },
                    });
                    postY = (doc.lastAutoTable ? doc.lastAutoTable.finalY : postY) + 14;
                }
            } catch (_) { }

            // Save with correct local date format
            const now = new Date();
            const months = [
                "Jan",
                "Feb",
                "Mar",
                "Apr",
                "May",
                "Jun",
                "Jul",
                "Aug",
                "Sep",
                "Oct",
                "Nov",
                "Dec",
            ];
            const dateStr = `${months[now.getMonth()]
                } ${now.getDate()} ${now.getFullYear()}`;
            const periodLabel = period === "weekly" ? "weekly" : "monthly";
            const filename = `agricart-calcoa-${periodLabel} (${dateStr}) - report.pdf`;
            doc.save(filename);

            this.showSuccessMessage("Sales report PDF exported");
        } catch (e) {
            console.error("Export report failed:", e);
            this.showErrorMessage("Failed to export PDF report");
        }
    }

    // startSimpleAutoRefresh removed - using real-time listeners instead

    // Auto-refresh is now handled by real-time Firebase listeners
    // This provides instant updates when new orders are placed
    // without the need for polling intervals

    destroy() {
        // Clean up listeners
        this.listeners.forEach((listener) => {
            if (typeof listener === "function") listener();
        });

        // Clean up charts
        Object.values(this.charts).forEach((chart) => {
            if (chart && chart.destroy) {
                chart.destroy();
            }
        });
    }
    async loadAssignedOrders() {
        try {
            console.log("DEBUG: loadAssignedOrders function called");
            if (!window.OrderSupabaseAdapter) {
                console.error(
                    "OrderSupabaseAdapter not available; cannot load assigned orders"
                );
                this.renderAssignedOrdersError(
                    "Supabase orders adapter not available. Please refresh the page."
                );
                return;
            }

            const orders = await OrderSupabaseAdapter.fetchOrders();
            if (orders === null) {
                console.error("Failed to load assigned orders from Supabase");
                this.renderAssignedOrdersError(
                    "Unable to load confirmed orders from Supabase. Please try again shortly."
                );
                return;
            }

            // Debug: Check what orders we loaded
            console.log(
                "DEBUG loadAssignedOrders: Loaded orders from database:",
                Object.keys(orders).length
            );

            // Debug: Log all order statuses to see what we have
            const statusCounts = {};
            Object.entries(orders).forEach(([id, order]) => {
                const status = order.status || "undefined";
                statusCounts[status] = (statusCounts[status] || 0) + 1;
            });
            console.log("DEBUG: Order status counts:", statusCounts);

            // Debug: Check for delivered and failed orders specifically
            const deliveredOrders = Object.entries(orders).filter(
                ([id, order]) => order.status === "delivered"
            );
            const failedOrders = Object.entries(orders).filter(
                ([id, order]) => order.status === "failed"
            );
            const failedPickupOrders = Object.entries(orders).filter(
                ([id, order]) => order.status === "failed_pickup"
            );
            console.log("DEBUG: Found delivered orders:", deliveredOrders.length);
            console.log("DEBUG: Found failed orders:", failedOrders.length);
            console.log(
                "DEBUG: Found failed_pickup orders:",
                failedPickupOrders.length
            );

            // Debug: Log details of failed_pickup orders
            if (failedPickupOrders.length > 0) {
                console.log("DEBUG: Failed pickup order details:", failedPickupOrders);
            }
            Object.keys(orders).forEach((id) => {
                const o = orders[id];
                if (o.status === "to_receive" || o.status === "out_for_delivery") {
                    console.log(
                        `DEBUG loadAssignedOrders: Order ${id} - status: ${o.status}, riderId: ${o.riderId}, riderName: ${o.riderName}`
                    );
                }
            });

            // Note: No Firebase fallback - all rider assignments are stored in Supabase orders table

            const containerConfirmed = document.getElementById(
                "assignedOrdersContainerConfirmed"
            );
            const containerConfirmedDelivery = document.getElementById(
                "assignedOrdersContainerConfirmedDelivery"
            );
            const containerConfirmedPickup = document.getElementById(
                "assignedOrdersContainerConfirmedPickup"
            );
            const containerToReceive = document.getElementById(
                "assignedOrdersContainerToReceive"
            );
            const containerSuccessful = document.getElementById(
                "assignedOrdersContainerSuccessful"
            );
            const containerFailed = document.getElementById(
                "assignedOrdersContainerFailed"
            );
            const containerCancelled = document.getElementById(
                "assignedOrdersContainerCancelled"
            );

            const countElement = document.getElementById("assignedOrdersCount");
            const inProgressElement = document.getElementById("inProgressCount");

            if (containerConfirmed) containerConfirmed.innerHTML = "";
            if (containerConfirmedDelivery) containerConfirmedDelivery.innerHTML = "";
            if (containerConfirmedPickup) containerConfirmedPickup.innerHTML = "";
            if (containerToReceive) containerToReceive.innerHTML = "";
            if (containerSuccessful) containerSuccessful.innerHTML = "";
            if (containerFailed) containerFailed.innerHTML = "";
            if (containerCancelled) containerCancelled.innerHTML = "";

            // Filter orders for delivery management (post-confirmation lifecycle)
            // Exclude cancelled orders - they should only appear in the cancelled tab
            // IMPORTANT: Check cancellation flags FIRST, before checking status
            // This ensures orders that have been cancelled (even if status hasn't updated yet) are excluded
            console.log(
                "ðŸ” FILTERING ORDERS - Total orders before filter:",
                Object.keys(orders).length
            );
            const assignedOrders = Object.entries(orders).filter(([id, order]) => {
                // PRIORITY 1: Check cancellation flags FIRST - these take precedence over status
                // Check both camelCase and snake_case versions to be safe
                const isCancellationConfirmed =
                    order.cancellationConfirmed === true ||
                    order.cancellation_confirmed === true ||
                    order.cancellation_confirmed === 1 ||
                    order.cancellation_confirmed === "true";
                const hasRefundConfirmed =
                    order.refundConfirmedAt ||
                    order.refund_confirmed_at ||
                    order.refundConfirmedAt > 0 ||
                    order.refund_confirmed_at > 0;
                const hasRefundDenied =
                    order.refundDenied === true ||
                    order.refund_denied === true ||
                    order.refundDenied === 1 ||
                    order.refund_denied === 1 ||
                    order.refundDenied === "true" ||
                    order.refund_denied === "true";

                // Also check if order has a refund receipt URL - this indicates cancellation was processed
                // This catches cases where cancellation flags might not be set but refund was processed
                const hasRefundReceipt =
                    order.refundReceiptUrl || order.refund_receipt_url;

                // If ANY cancellation flag is set OR refund receipt exists, exclude the order regardless of status
                // Note: confirmedAt/confirmedBy are from ORIGINAL confirmation, NOT cancellation confirmation
                if (
                    isCancellationConfirmed ||
                    hasRefundConfirmed ||
                    hasRefundDenied ||
                    hasRefundReceipt
                ) {
                    console.log(
                        `ðŸš« FILTERING OUT cancelled order ${id} (cancellation flags detected):`,
                        {
                            status: order.status,
                            cancellationConfirmed: isCancellationConfirmed,
                            cancellation_confirmed: order.cancellation_confirmed,
                            refundConfirmedAt: hasRefundConfirmed,
                            refund_confirmed_at: order.refund_confirmed_at,
                            refundDenied: hasRefundDenied,
                            refund_denied: order.refund_denied,
                            refundReceiptUrl: hasRefundReceipt,
                            confirmedAt: order.confirmedAt, // This is from original confirmation, NOT cancellation
                            confirmedBy: order.confirmedBy, // This is from original confirmation, NOT cancellation
                            fullOrder: order, // Log full order for debugging
                        }
                    );
                    return false;
                }

                // PRIORITY 2: Check status field
                const s = (order.status || "").toLowerCase();
                if (s === "cancelled") {
                    console.log(
                        `ðŸš« FILTERING OUT cancelled order ${id} (status is cancelled):`,
                        {
                            status: s,
                            cancellationConfirmed: isCancellationConfirmed,
                            refundConfirmedAt: hasRefundConfirmed,
                            refundDenied: hasRefundDenied,
                        }
                    );
                    return false;
                }

                // Debug: Log orders that are being included to verify they're not cancelled
                if (s === "confirmed") {
                    console.log(`âœ… INCLUDING confirmed order ${id}:`, {
                        status: s,
                        cancellationConfirmed: isCancellationConfirmed,
                        cancellation_confirmed: order.cancellation_confirmed,
                        refundConfirmedAt: hasRefundConfirmed,
                        refundDenied: hasRefundDenied,
                        confirmedAt: order.confirmedAt, // This is OK - it's from original confirmation
                        confirmedBy: order.confirmedBy, // This is OK - it's from original confirmation
                    });
                }

                return (
                    s === "confirmed" ||
                    s === "packed" ||
                    s === "to_receive" ||
                    s === "out_for_delivery" ||
                    s === "delivered" ||
                    s === "picked_up" ||
                    s === "failed" ||
                    s === "delivery_failed" ||
                    s === "failed_pickup"
                );
            });
            console.log(
                "ðŸ” FILTERING ORDERS - Total orders after filter:",
                assignedOrders.length
            );
            console.log(
                "ðŸ” FILTERED OUT:",
                Object.keys(orders).length - assignedOrders.length,
                "orders"
            );

            // Debug: Log filtered orders count
            console.log("DEBUG: Total orders loaded:", Object.keys(orders).length);
            console.log(
                "DEBUG: Orders passing assigned filter:",
                assignedOrders.length
            );
            console.log(
                "DEBUG: Assigned orders statuses:",
                assignedOrders.map(([id, order]) => order.status)
            );

            const assignedCount = assignedOrders.filter(([id, order]) => {
                return order.assignedToStaff && order.assignedToStaff !== "";
            }).length;

            // Calculate Order Records count: only successful and failed orders
            // This happens after groups are populated, so we'll update it later

            // Calculate Total Order (Weekly): orders from confirmed to to_receive tabs within current week
            // Helper function to get current week key (Monday-Sunday)
            const getCurrentWeekKey = () => {
                const now = new Date();
                const year = now.getFullYear();
                const date = new Date(now);
                date.setHours(0, 0, 0, 0);
                const dayOfWeek = date.getDay();
                const daysToMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
                const monday = new Date(date);
                monday.setDate(date.getDate() - daysToMonday);
                const jan1 = new Date(year, 0, 1);
                jan1.setHours(0, 0, 0, 0);
                const jan1DayOfWeek = jan1.getDay();
                const firstMonday = new Date(jan1);
                if (jan1DayOfWeek === 0) {
                    firstMonday.setDate(2);
                } else if (jan1DayOfWeek === 1) {
                    // firstMonday is already Jan 1
                } else {
                    const daysToFirstMonday = 8 - jan1DayOfWeek;
                    firstMonday.setDate(1 + daysToFirstMonday);
                }
                const daysDiff = Math.floor(
                    (monday.getTime() - firstMonday.getTime()) / (1000 * 60 * 60 * 24)
                );
                const weekNumber = Math.floor(daysDiff / 7) + 1;
                if (daysDiff < 0) {
                    return `${year}-W1`;
                }
                return `${year}-W${weekNumber}`;
            };

            const getOrderWeekKey = (ts) => {
                const d = new Date(Number(ts || 0));
                const year = d.getFullYear();
                const date = new Date(d);
                date.setHours(0, 0, 0, 0);
                const dayOfWeek = date.getDay();
                const daysToMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
                const monday = new Date(date);
                monday.setDate(date.getDate() - daysToMonday);
                const jan1 = new Date(year, 0, 1);
                jan1.setHours(0, 0, 0, 0);
                const jan1DayOfWeek = jan1.getDay();
                const firstMonday = new Date(jan1);
                if (jan1DayOfWeek === 0) {
                    firstMonday.setDate(2);
                } else if (jan1DayOfWeek === 1) {
                    // firstMonday is already Jan 1
                } else {
                    const daysToFirstMonday = 8 - jan1DayOfWeek;
                    firstMonday.setDate(1 + daysToFirstMonday);
                }
                const daysDiff = Math.floor(
                    (monday.getTime() - firstMonday.getTime()) / (1000 * 60 * 60 * 24)
                );
                const weekNumber = Math.floor(daysDiff / 7) + 1;
                if (daysDiff < 0) {
                    return `${year}-W1`;
                }
                return `${year}-W${weekNumber}`;
            };

            const currentWeekKey = getCurrentWeekKey();
            const inProgressCount = assignedOrders.filter(([id, order]) => {
                const s = (order.status || "").toLowerCase();
                // Only count orders from confirmed to to_receive tabs
                if (
                    s === "confirmed" ||
                    s === "to_receive" ||
                    s === "out_for_delivery"
                ) {
                    // Check if order is within current week based on createdAt
                    const orderWeekKey = getOrderWeekKey(
                        order.createdAt ||
                        order.created_at ||
                        order.orderDate ||
                        order.order_date ||
                        Date.now()
                    );
                    return orderWeekKey === currentWeekKey;
                }
                return false;
            }).length;

            // Count will be updated after groups are populated
            // Set initial values
            countElement.textContent = 0;
            inProgressElement.textContent = inProgressCount;

            if (assignedOrders.length === 0) {
                const emptyHtml = `
                    <div style="text-align: center; padding: 40px 20px; color: #666;">
                        <i class=\"fas fa-tasks\" style=\"font-size: 3rem; color: #ff9800; margin-bottom: 16px;\"></i>
                        <h3 style=\"margin-bottom: 8px; color: #ff9800;\">No Orders in Management</h3>
                        <div style=\"background: #fff3e0; padding: 12px; border-radius: 8px; border-left: 4px solid #ff9800;\">
                            <p style=\"margin: 0; font-size: 0.9rem; color: #e65100;\">
                                <i class=\"fas fa-info-circle\"></i> 
                                <strong>Note:</strong> Orders are moved here automatically after confirmation from the \"Orders\" module. 
                                Use this module to mark orders as out for delivery and manage completion.
                            </p>
                        </div>
                    </div>`;
                if (containerConfirmed) containerConfirmed.innerHTML = emptyHtml;
                if (containerConfirmedDelivery)
                    containerConfirmedDelivery.innerHTML = emptyHtml;
                if (containerConfirmedPickup)
                    containerConfirmedPickup.innerHTML = emptyHtml;
                if (containerToReceive) containerToReceive.innerHTML = emptyHtml;
                if (containerSuccessful) containerSuccessful.innerHTML = emptyHtml;
                if (containerFailed) containerFailed.innerHTML = emptyHtml;
                // Still update counts and tabs
                const tabCounts = {
                    confirmed: 0,
                    "to-receive": 0,
                    successful: 0,
                    failed: 0,
                };
                const setTabCount = (tabKey, label, count) => {
                    const btn = document.querySelector(
                        `.assign-tab-btn[data-assign-tab=\"${tabKey}\"]`
                    );
                    if (btn) {
                        btn.innerHTML = `${label} <span style=\"background:#eee; border-radius:10px; padding:2px 8px; margin-left:6px; font-size:12px;\">${count}</span>`;
                    }
                };
                setTabCount("confirmed", "Confirmed", tabCounts.confirmed);
                setTabCount("to-receive", "To Receive", tabCounts["to-receive"]);
                setTabCount("successful", "Successful", tabCounts.successful);
                setTabCount("failed", "Failed", tabCounts.failed);
                return;
            }

            // Add info note about assigned orders
            const infoNote = document.createElement("div");
            infoNote.style.cssText = `
                background: #fff3e0;
                border: 1px solid #ff9800;
                border-radius: 8px;
                padding: 12px;
                margin-bottom: 20px;
                font-size: 0.9rem;
                color: #e65100;
            `;
            infoNote.innerHTML = `
                <i class="fas fa-info-circle"></i> 
                <strong>Order Management Module:</strong> This module handles confirmed orders and delivery management. 
                Flow: Confirmed â†’ Out for Delivery â†’ Delivered (auto when customer confirms receipt). 
                Use this module to manage delivery.
            `;
            if (containerConfirmed && containerConfirmed.children.length === 0) {
                containerConfirmed.appendChild(infoNote.cloneNode(true));
            }

            // Group orders by phases in required order
            const groups = {
                confirmed: [],
                to_receive: [], // includes packed and out_for_delivery
                delivered: [],
                pickedup: [],
                failed: [],
                failedDelivery: [], // failed delivery orders
                failedPickup: [], // failed pickup orders
                cancelled: [],
            };

            for (const [id, order] of assignedOrders) {
                // PRIORITY 1: Check cancellation flags FIRST - these take precedence over status
                // IMPORTANT: confirmedAt/confirmedBy are from ORIGINAL confirmation, NOT cancellation confirmation
                const isCancellationConfirmed =
                    order.cancellationConfirmed === true ||
                    order.cancellation_confirmed === true;
                const hasRefundConfirmed =
                    order.refundConfirmedAt || order.refund_confirmed_at;
                const hasRefundDenied =
                    order.refundDenied === true || order.refund_denied === true;

                // If ANY cancellation flag is set, exclude the order regardless of status
                // This is critical - cancellation flags override status field
                if (isCancellationConfirmed || hasRefundConfirmed || hasRefundDenied) {
                    console.log(
                        `ðŸš« Excluding cancelled order ${id} from confirmed tab (cancellation flags detected):`,
                        {
                            status: order.status,
                            cancellationConfirmed: isCancellationConfirmed,
                            refundConfirmedAt: hasRefundConfirmed,
                            refundDenied: hasRefundDenied,
                            confirmedAt: order.confirmedAt, // This is from original confirmation, NOT cancellation
                            confirmedBy: order.confirmedBy, // This is from original confirmation, NOT cancellation
                        }
                    );
                    continue;
                }

                // PRIORITY 2: Check status field
                const s = (order.status || "").toLowerCase();
                if (s === "cancelled") {
                    console.log(
                        `ðŸš« Excluding cancelled order ${id} from confirmed tab (status is cancelled):`,
                        {
                            status: s,
                        }
                    );
                    continue;
                }

                // Debug logging for failed orders
                if (
                    s === "failed" ||
                    s === "delivery_failed" ||
                    s === "failed_pickup"
                ) {
                    console.log(`ðŸ” DEBUG Failed Order Processing: Order ${id}`);
                    console.log(`  - Status: ${s}`);
                    console.log(`  - Delivery Option: ${order.deliveryOption}`);
                    console.log(`  - Full Order:`, order);
                }

                // Double-check: Even if order passed the filter, exclude it if it has cancellation flags
                // This is a safety check in case the filter didn't catch it
                if (isCancellationConfirmed || hasRefundConfirmed || hasRefundDenied) {
                    console.log(
                        `ðŸš« DOUBLE-CHECK: Excluding order ${id} from confirmed group - has cancellation flags`
                    );
                    continue;
                }

                if (s === "confirmed") {
                    groups.confirmed.push([id, order]);
                } else if (s === "to_receive" || s === "out_for_delivery") {
                    groups.to_receive.push([id, order]);
                } else if (s === "delivered") {
                    groups.delivered.push([id, order]);
                } else if (s === "picked_up") {
                    groups.pickedup.push([id, order]);
                } else if (s === "failed" || s === "delivery_failed") {
                    // Check if it's a pickup order to determine if it's failed delivery or failed pickup
                    if (
                        order.deliveryOption &&
                        order.deliveryOption.toLowerCase() === "pickup"
                    ) {
                        console.log(
                            `âœ… Adding order ${id} to failedPickup group (failed delivery order with pickup option)`
                        );
                        groups.failedPickup.push([id, order]);
                    } else {
                        console.log(
                            `âœ… Adding order ${id} to failedDelivery group (failed delivery order)`
                        );
                        groups.failedDelivery.push([id, order]);
                    }
                    // Keep the original failed group for backward compatibility
                    groups.failed.push([id, order]);
                } else if (s === "failed_pickup") {
                    console.log(
                        `âœ… Adding order ${id} to failedPickup group (failed_pickup status)`
                    );
                    groups.failedPickup.push([id, order]);
                    // Also add to general failed group for backward compatibility
                    groups.failed.push([id, order]);
                }
            }

            const orderByDateDesc = (a, b) => {
                const dateA =
                    a[1].assignedAt || a[1].confirmedAt || a[1].createdAt || 0;
                const dateB =
                    b[1].assignedAt || b[1].confirmedAt || b[1].createdAt || 0;
                return dateB - dateA;
            };

            const renderListInto = (list, target) => {
                if (!target || !list || list.length === 0) return;
                list.sort(orderByDateDesc).forEach(([id, order]) => {
                    const item = this.createAssignedOrderCard(id, order);
                    target.appendChild(item);
                });
            };

            // Render Confirmed sub-tabs: Delivery vs Pickup
            if (containerConfirmedDelivery || containerConfirmedPickup) {
                // Clear containers first
                if (containerConfirmedDelivery)
                    containerConfirmedDelivery.innerHTML = "";
                if (containerConfirmedPickup) containerConfirmedPickup.innerHTML = "";

                // Filter confirmed orders by delivery option
                const allConfirmed = groups.confirmed.slice();
                const confirmedPickup = allConfirmed.filter(([id, o]) => {
                    const deliveryOption = String(o.deliveryOption || "").toLowerCase();
                    return deliveryOption === "pickup";
                });
                const confirmedDelivery = allConfirmed.filter(([id, o]) => {
                    const deliveryOption = String(o.deliveryOption || "").toLowerCase();
                    return deliveryOption !== "pickup"; // Everything that's not pickup is delivery
                });

                // Render delivery orders
                if (containerConfirmedDelivery) {
                    confirmedDelivery.sort(orderByDateDesc).forEach(([id, order]) => {
                        const item = this.createAssignedOrderCard(id, order);
                        containerConfirmedDelivery.appendChild(item);
                    });
                }

                // Render pickup orders
                if (containerConfirmedPickup) {
                    confirmedPickup.sort(orderByDateDesc).forEach(([id, order]) => {
                        const item = this.createAssignedOrderCard(id, order);
                        containerConfirmedPickup.appendChild(item);
                    });
                }

                // Ensure bulk action bars exist for each Confirmed sub-tab
                const ensureConfirmedBulkBars = () => {
                    // Delivery bulk bar
                    if (
                        containerConfirmedDelivery &&
                        !document.getElementById("confirmed-delivery-bulk")
                    ) {
                        const bar = document.createElement("div");
                        bar.id = "confirmed-delivery-bulk";
                        bar.style.cssText =
                            "display:flex; justify-content:flex-end; width:100%; gap:8px; align-items:center; margin:8px 0 12px 0; flex-wrap:wrap;";
                        const btn = document.createElement("button");
                        btn.className = "primary-btn";
                        btn.style.cssText =
                            "background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; color: white; font-weight: 600; padding: 10px 20px; border-radius: 6px; cursor: pointer; transition: all 0.3s ease;";
                        btn.innerHTML =
                            '<i class="fas fa-shipping-fast"></i> Mark as To Receive';
                        btn.addEventListener("click", async () => {
                            const selected = Array.from(
                                containerConfirmedDelivery.querySelectorAll(
                                    ".confirmed-checkbox:checked"
                                )
                            )
                                .map((cb) => cb.getAttribute("data-order-id"))
                                .filter(Boolean);
                            if (selected.length === 0) {
                                alert("Please select at least one order to mark as To Receive");
                                return;
                            }
                            await this.bulkMarkOrderAsToReceive(selected);
                        });
                        bar.appendChild(btn);
                        const host = containerConfirmedDelivery.parentElement; // sub-tab wrapper
                        if (host) host.insertBefore(bar, containerConfirmedDelivery);
                    }

                    // Pickup bulk bar
                    if (
                        containerConfirmedPickup &&
                        !document.getElementById("confirmed-pickup-bulk")
                    ) {
                        const bar = document.createElement("div");
                        bar.id = "confirmed-pickup-bulk";
                        bar.style.cssText =
                            "display:flex; justify-content:flex-end; width:100%; gap:8px; align-items:center; margin:8px 0 12px 0; flex-wrap:wrap;";
                        const btn = document.createElement("button");
                        btn.className = "primary-btn";
                        btn.style.cssText =
                            "background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; color: white; font-weight: 600; padding: 10px 20px; border-radius: 6px; cursor: pointer; transition: all 0.3s ease;";
                        btn.innerHTML =
                            '<i class="fas fa-shipping-fast"></i> Mark as To Receive';
                        btn.addEventListener("click", async () => {
                            const selected = Array.from(
                                containerConfirmedPickup.querySelectorAll(
                                    ".confirmed-checkbox:checked"
                                )
                            )
                                .map((cb) => cb.getAttribute("data-order-id"))
                                .filter(Boolean);
                            if (selected.length === 0) {
                                alert("Please select at least one order to mark as To Receive");
                                return;
                            }
                            await this.bulkMarkOrderAsToReceive(selected);
                        });
                        bar.appendChild(btn);
                        const host = containerConfirmedPickup.parentElement; // sub-tab wrapper
                        if (host) host.insertBefore(bar, containerConfirmedPickup);
                    }
                };

                // Create bulk action bars
                ensureConfirmedBulkBars();
            } else {
                // Fallback to legacy single container
                renderListInto(groups.confirmed, containerConfirmed);
            }
            // To Receive: render as two fixed sub-tabs (Pickup Orders, Delivery Orders)
            const containerToReceiveDelivery = document.getElementById(
                "assignedOrdersContainerToReceiveDelivery"
            );
            const containerToReceivePickup = document.getElementById(
                "assignedOrdersContainerToReceivePickup"
            );
            if (containerToReceiveDelivery || containerToReceivePickup) {
                if (containerToReceiveDelivery)
                    containerToReceiveDelivery.innerHTML = "";
                if (containerToReceivePickup) containerToReceivePickup.innerHTML = "";
                const allToReceive = groups.to_receive.slice();
                // Filter pickup orders - only show orders where deliveryOption is explicitly 'pickup'
                const pickupList = allToReceive.filter(([id, o]) => {
                    const deliveryOption = String(
                        o.deliveryOption || o.delivery_option || ""
                    )
                        .toLowerCase()
                        .trim();
                    return deliveryOption === "pickup";
                });
                // Filter delivery orders - show all orders that are NOT pickup (including null/undefined which defaults to delivery)
                const deliveryList = allToReceive.filter(([id, o]) => {
                    const deliveryOption = String(
                        o.deliveryOption || o.delivery_option || ""
                    )
                        .toLowerCase()
                        .trim();
                    return deliveryOption !== "pickup";
                });
                deliveryList.sort(orderByDateDesc).forEach(([id, order]) => {
                    const item = this.createAssignedOrderCard(id, order);
                    if (containerToReceiveDelivery)
                        containerToReceiveDelivery.appendChild(item);
                });
                pickupList.sort(orderByDateDesc).forEach(([id, order]) => {
                    const item = this.createAssignedOrderCard(id, order);
                    if (containerToReceivePickup)
                        containerToReceivePickup.appendChild(item);
                });

                // Ensure bulk action bars exist for each To Receive sub-tab
                const ensureToReceiveBulkBars = () => {
                    // Delivery bulk bar (Out for Delivery + Assign Rider)
                    if (
                        containerToReceiveDelivery &&
                        !document.getElementById("to-receive-delivery-bulk")
                    ) {
                        const bar = document.createElement("div");
                        bar.id = "to-receive-delivery-bulk";
                        bar.style.cssText =
                            "display:flex; justify-content:flex-end; width:100%; gap:8px; align-items:center; margin:8px 0 12px 0; flex-wrap:wrap;";
                        const btn = document.createElement("button");
                        btn.className = "primary-btn";
                        btn.innerHTML =
                            '<i class="fas fa-shipping-fast"></i> Out for Delivery + Assign Rider';
                        btn.addEventListener("click", async () => {
                            const selected = Array.from(
                                containerToReceiveDelivery.querySelectorAll(
                                    ".to-receive-checkbox:checked"
                                )
                            )
                                .map((cb) => cb.getAttribute("data-order-id"))
                                .filter(Boolean);
                            if (selected.length === 0) return;

                            // Check QR codes for all selected orders
                            const ordersWithoutQr = [];
                            for (const orderId of selected) {
                                const qrCode = await this.fetchSupabaseQrRecord(orderId);
                                if (!qrCode) {
                                    ordersWithoutQr.push(orderId);
                                }
                            }

                            if (ordersWithoutQr.length > 0) {
                                const orderCodes = ordersWithoutQr.map((orderId) =>
                                    orderId.substr(-8).toUpperCase()
                                );
                                alert(
                                    `The following orders need QR codes generated first before marking for delivery:\n\nOrder Codes: ${orderCodes.join(
                                        ", "
                                    )}\n\nPlease generate QR codes for these orders first.`
                                );
                                return;
                            }

                            await this.showRiderSelectionModal(selected);
                        });
                        bar.appendChild(btn);
                        const host = containerToReceiveDelivery.parentElement; // sub-tab wrapper
                        if (host) host.insertBefore(bar, containerToReceiveDelivery);
                    }

                    // Pickup bulk bar (Ready to Pick Up)
                    if (
                        containerToReceivePickup &&
                        !document.getElementById("to-receive-pickup-bulk")
                    ) {
                        const bar = document.createElement("div");
                        bar.id = "to-receive-pickup-bulk";
                        bar.style.cssText =
                            "display:flex; justify-content:flex-end; width:100%; gap:8px; align-items:center; margin:8px 0 12px 0; flex-wrap:wrap;";
                        const btn = document.createElement("button");
                        btn.className = "confirm-btn";
                        btn.innerHTML = '<i class="fas fa-handshake"></i> Ready to Pick Up';
                        btn.addEventListener("click", async () => {
                            const selected = Array.from(
                                containerToReceivePickup.querySelectorAll(
                                    ".pickup-ready-checkbox:checked"
                                )
                            )
                                .map((cb) => cb.getAttribute("data-order-id"))
                                .filter(Boolean);
                            if (selected.length === 0) return;

                            // Check QR codes for all selected orders
                            const ordersWithoutQr = [];
                            for (const orderId of selected) {
                                const qrCode = await this.fetchSupabaseQrRecord(orderId);
                                if (!qrCode) {
                                    ordersWithoutQr.push(orderId);
                                }
                            }

                            if (ordersWithoutQr.length > 0) {
                                const orderCodes = ordersWithoutQr.map((orderId) =>
                                    orderId.substr(-8).toUpperCase()
                                );
                                alert(
                                    `The following orders need QR codes generated first before marking ready for pickup:\n\nOrder Codes: ${orderCodes.join(
                                        ", "
                                    )}\n\nPlease generate QR codes for these orders first.`
                                );
                                return;
                            }

                            for (const orderId of selected) {
                                await this.markReadyForPickup(orderId);
                            }
                        });
                        bar.appendChild(btn);
                        const host = containerToReceivePickup.parentElement; // sub-tab wrapper
                        if (host) host.insertBefore(bar, containerToReceivePickup);
                    }
                };

                ensureToReceiveBulkBars();
            }

            // Removed sticky bulk bar; actions are now inside each group header
            // Records grouping state (weekly/monthly) and expand state
            if (!this._recordsSortMode) this._recordsSortMode = "weekly"; // 'weekly' | 'monthly'
            if (!this._expandedRecordGroups) this._expandedRecordGroups = {}; // key -> bool

            // Payment sort mode: 'none' | 'payment'
            if (!this._paymentSortMode) this._paymentSortMode = {};

            // Search query storage
            if (!this._searchQuery) this._searchQuery = {};

            // Helper function to get payment method for sorting
            const getPaymentMethodForSort = (order) => {
                const pm = String(order.paymentMethod || order.payment_method || "").toLowerCase();
                // If GCash and has payment_proof (rider upload), it's COD paid through GCash
                if (pm === "gcash" && (order.payment_proof || order.paymentProof)) {
                    return "cod_paid_gcash";
                }
                if (pm === "cash_on_delivery" || pm === "cod") {
                    return "cash_on_delivery";
                }
                if (pm === "cash") {
                    return "cash";
                }
                if (pm === "gcash") {
                    return "gcash";
                }
                return "other";
            };

            // Helper function to filter orders by search query
            const filterBySearch = (orders, searchQuery) => {
                if (!searchQuery || searchQuery.trim() === "") return orders;
                const query = searchQuery.toLowerCase().trim();
                return orders.filter(([id, order]) => {
                    const customerName = String(order.customerName || order.customer_name || "").toLowerCase();
                    const customerPhone = String(order.customerPhone || order.customer_phone || "").toLowerCase();
                    const orderId = String(id || "").toLowerCase();
                    const address = String(order.deliveryAddress || order.delivery_address || order.customerAddress || order.customer_address || "").toLowerCase();
                    const paymentMethod = getPaymentMethodForSort(order);
                    const paymentDisplay = paymentMethod === "cod_paid_gcash" ? "cod paid through gcash" :
                        paymentMethod === "cash_on_delivery" ? "cash on delivery" :
                            paymentMethod === "gcash" ? "gcash" : paymentMethod;

                    return customerName.includes(query) ||
                        customerPhone.includes(query) ||
                        orderId.includes(query) ||
                        address.includes(query) ||
                        paymentDisplay.includes(query);
                });
            };

            // Helper function to sort orders by payment method
            const sortByPayment = (orders) => {
                const paymentOrder = {
                    "cash": 1,
                    "cash_on_delivery": 2,
                    "cod_paid_gcash": 3,
                    "gcash": 4,
                    "other": 5
                };
                return [...orders].sort((a, b) => {
                    const aPayment = getPaymentMethodForSort(a[1]);
                    const bPayment = getPaymentMethodForSort(b[1]);
                    const aOrder = paymentOrder[aPayment] || 999;
                    const bOrder = paymentOrder[bPayment] || 999;
                    if (aOrder !== bOrder) {
                        return aOrder - bOrder;
                    }
                    // If same payment method, sort by date descending
                    const at = a[1].createdAt || 0;
                    const bt = b[1].createdAt || 0;
                    return bt - at;
                });
            };

            const ensureSortToolbar = (container, tabKeyLabel) => {
                // Initialize payment sort mode for this tab if not exists
                if (!this._paymentSortMode[tabKeyLabel]) this._paymentSortMode[tabKeyLabel] = "none";
                // Initialize search query for this tab if not exists
                if (!this._searchQuery[tabKeyLabel]) this._searchQuery[tabKeyLabel] = "";
                if (!container) return;
                const toolbarId = `${tabKeyLabel}-records-toolbar`;
                let toolbar = document.getElementById(toolbarId);
                if (!toolbar) {
                    toolbar = document.createElement("div");
                    toolbar.id = toolbarId;
                    toolbar.style.cssText =
                        "display:flex; align-items:center; justify-content:space-between; gap:12px; margin:6px 0 10px; flex-wrap:wrap;";
                    toolbar.innerHTML = `
                        <div style="display:flex; align-items:center; gap:8px; flex:1; min-width:200px;">
                            <i class="fas fa-search" style="color:#666; font-size:14px;"></i>
                            <input type="text" id="${tabKeyLabel}-search-input" placeholder="Search orders..." 
                                   style="flex:1; padding:6px 10px; border:1px solid #ddd; border-radius:6px; font-size:12px; min-width:150px;"
                                   value="${this._searchQuery[tabKeyLabel] || ''}">
                        </div>
                        <div style="display:flex; align-items:center; gap:8px;">
                            <label style="font-size:12px; color:#666;">Payment (sort)</label>
                            <select id="${tabKeyLabel}-payment-sort-select" style="padding:6px 8px; border:1px solid #ddd; border-radius:6px; font-size:12px;">
                                <option value="none">All</option>
                                <option value="cash">Cash</option>
                                <option value="cash_on_delivery">Cash on Delivery</option>
                                <option value="cod_paid_gcash">COD - Paid via GCash</option>
                                <option value="gcash">GCash</option>
                                <option value="other">Other</option>
                            </select>
                            <label style="font-size:12px; color:#666;">Group by</label>
                            <select id="${tabKeyLabel}-sort-select" style="padding:6px 8px; border:1px solid #ddd; border-radius:6px; font-size:12px;">
                                <option value="weekly">Weekly</option>
                                <option value="monthly">Monthly</option>
                            </select>
                        </div>
                    `;
                    container.parentElement?.insertBefore(toolbar, container);

                    // Payment sort select
                    const paymentSortSelect = toolbar.querySelector(`#${tabKeyLabel}-payment-sort-select`);
                    if (paymentSortSelect) {
                        paymentSortSelect.value = this._paymentSortMode[tabKeyLabel] || "none";
                        paymentSortSelect.addEventListener("change", (e) => {
                            this._paymentSortMode[tabKeyLabel] = e.target.value;
                            // re-render only the specific tab
                            if (tabKeyLabel === "successful") {
                                const combinedSuccessful = [
                                    ...groups.delivered,
                                    ...groups.pickedup,
                                ];
                                renderGroupedSuccessful(
                                    "successful",
                                    combinedSuccessful,
                                    containerSuccessful
                                );
                            } else if (tabKeyLabel === "failed") {
                                const combinedFailed = [
                                    ...groups.failedDelivery,
                                    ...groups.failedPickup,
                                ];
                                renderGrouped("failed", combinedFailed, containerFailed);
                            } else {
                                renderGrouped("failed", groups.failed, containerFailed);
                            }
                        });
                    }

                    // Search input
                    const searchInput = toolbar.querySelector(`#${tabKeyLabel}-search-input`);
                    if (searchInput) {
                        let searchTimeout;
                        searchInput.addEventListener("input", (e) => {
                            clearTimeout(searchTimeout);
                            searchTimeout = setTimeout(() => {
                                this._searchQuery[tabKeyLabel] = e.target.value.trim();
                                // re-render only the specific tab
                                if (tabKeyLabel === "successful") {
                                    const combinedSuccessful = [
                                        ...groups.delivered,
                                        ...groups.pickedup,
                                    ];
                                    renderGroupedSuccessful(
                                        "successful",
                                        combinedSuccessful,
                                        containerSuccessful
                                    );
                                } else if (tabKeyLabel === "failed") {
                                    const combinedFailed = [
                                        ...groups.failedDelivery,
                                        ...groups.failedPickup,
                                    ];
                                    renderGrouped("failed", combinedFailed, containerFailed);
                                } else {
                                    renderGrouped("failed", groups.failed, containerFailed);
                                }
                            }, 300);
                        });
                    }

                    // Group by select
                    const selectEl = toolbar.querySelector(`#${tabKeyLabel}-sort-select`);
                    if (selectEl) {
                        selectEl.value = this._recordsSortMode;
                        selectEl.addEventListener("change", (e) => {
                            this._recordsSortMode = e.target.value;
                            // re-render only the specific tab
                            if (tabKeyLabel === "successful") {
                                const combinedSuccessful = [
                                    ...groups.delivered,
                                    ...groups.pickedup,
                                ];
                                renderGroupedSuccessful(
                                    "successful",
                                    combinedSuccessful,
                                    containerSuccessful
                                );
                            } else if (tabKeyLabel === "failed") {
                                const combinedFailed = [
                                    ...groups.failedDelivery,
                                    ...groups.failedPickup,
                                ];
                                renderGrouped("failed", combinedFailed, containerFailed);
                            } else {
                                renderGrouped("failed", groups.failed, containerFailed);
                            }
                        });
                    }
                } else {
                    const selectEl = toolbar.querySelector(`#${tabKeyLabel}-sort-select`);
                    if (selectEl) selectEl.value = this._recordsSortMode;
                    const paymentSortSelect = toolbar.querySelector(`#${tabKeyLabel}-payment-sort-select`);
                    if (paymentSortSelect) paymentSortSelect.value = this._paymentSortMode[tabKeyLabel] || "none";
                    const searchInput = toolbar.querySelector(`#${tabKeyLabel}-search-input`);
                    if (searchInput) searchInput.value = this._searchQuery[tabKeyLabel] || "";
                }
            };

            // Calculate which Monday-Sunday week a date belongs to
            // Returns a unique key like "2025-W48" where weeks start on Monday
            const getWeekKey = (ts) => {
                const d = new Date(Number(ts || 0));
                const year = d.getFullYear();

                // Create a copy of the date to avoid mutating the original
                const date = new Date(d);
                date.setHours(0, 0, 0, 0);

                // Get the date's day of week (0=Sunday, 1=Monday, ..., 6=Saturday)
                const dayOfWeek = date.getDay();

                // Calculate days to subtract to get to Monday (start of week)
                // If Sunday (0), go back 6 days; otherwise go back (dayOfWeek - 1) days
                const daysToMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;

                // Get the Monday of the week containing this date
                const monday = new Date(date);
                monday.setDate(date.getDate() - daysToMonday);

                // Get January 1st of the same year
                const jan1 = new Date(year, 0, 1);
                jan1.setHours(0, 0, 0, 0);
                const jan1DayOfWeek = jan1.getDay();

                // Find the first Monday of the year
                const firstMonday = new Date(jan1);
                if (jan1DayOfWeek === 0) {
                    // Jan 1 is Sunday, first Monday is Jan 2
                    firstMonday.setDate(2);
                } else if (jan1DayOfWeek === 1) {
                    // Jan 1 is Monday, use it
                    // firstMonday is already Jan 1
                } else {
                    // Jan 1 is Tuesday-Saturday, find the first Monday
                    const daysToFirstMonday = 8 - jan1DayOfWeek;
                    firstMonday.setDate(1 + daysToFirstMonday);
                }

                // Calculate days difference between this Monday and first Monday
                const daysDiff = Math.floor(
                    (monday.getTime() - firstMonday.getTime()) / (1000 * 60 * 60 * 24)
                );

                // Week number (1-indexed)
                const weekNumber = Math.floor(daysDiff / 7) + 1;

                // Handle edge case: if the date is before the first Monday, it belongs to week 1
                if (daysDiff < 0) {
                    return `${year}-W1`;
                }

                return `${year}-W${weekNumber}`;
            };

            const getGroupKey = (ts) => {
                const d = new Date(Number(ts || 0));
                if (this._recordsSortMode === "monthly") {
                    const mm = String(d.getMonth() + 1).padStart(2, "0");
                    return `${d.getFullYear()}-${mm}`;
                }
                return getWeekKey(ts);
            };

            const getGroupTitle = (key) => {
                if (this._recordsSortMode === "monthly") {
                    const [year, mm] = key.split("-");
                    const monthNames = [
                        "",
                        "January",
                        "February",
                        "March",
                        "April",
                        "May",
                        "June",
                        "July",
                        "August",
                        "September",
                        "October",
                        "November",
                        "December",
                    ];
                    return `${monthNames[Number(mm)]} ${year}`;
                }
                return getWeekTitle(key);
            };

            // Always format a weekly key (YYYY-WN) into a date range, regardless of current sort mode
            const getWeekTitle = (wKey) => {
                const [year, wStr] = String(wKey || "").split("-W");
                const week = Number(wStr);

                // Get January 1st of the year
                const jan1 = new Date(Number(year), 0, 1);
                jan1.setHours(0, 0, 0, 0);
                const jan1DayOfWeek = jan1.getDay();

                // Find the first Monday of the year
                const firstMonday = new Date(jan1);
                if (jan1DayOfWeek === 0) {
                    // Jan 1 is Sunday, first Monday is Jan 2
                    firstMonday.setDate(2);
                } else if (jan1DayOfWeek === 1) {
                    // Jan 1 is Monday, use it
                    // firstMonday is already Jan 1
                } else {
                    // Jan 1 is Tuesday-Saturday, find the first Monday
                    const daysToFirstMonday = 8 - jan1DayOfWeek;
                    firstMonday.setDate(1 + daysToFirstMonday);
                }

                // Calculate the Monday of the requested week
                const weekStart = new Date(firstMonday);
                weekStart.setDate(firstMonday.getDate() + (week - 1) * 7);

                // Calculate the Sunday (end of week)
                const weekEnd = new Date(weekStart);
                weekEnd.setDate(weekStart.getDate() + 6);

                const fmt = (d) => {
                    const day = String(d.getDate()).padStart(2, "0");
                    const month = String(d.getMonth() + 1).padStart(2, "0");
                    return `${day}/${month}/${d.getFullYear()}`;
                };
                return `Week of ${fmt(weekStart)} - ${fmt(weekEnd)}`;
            };

            const buildGroupHeader = (key, count, tabType) => {
                const isExpanded = !!this._expandedRecordGroups[key];
                const header = document.createElement("div");
                header.style.cssText =
                    "display:flex; align-items:center; gap:10px; padding:10px 12px; background:#f5f9ff; border:1px solid #e3f2fd; border-radius:8px; cursor:pointer;";
                header.innerHTML = `
                    <i class="fas ${this._recordsSortMode === "monthly"
                        ? "fa-calendar-alt"
                        : "fa-calendar-week"
                    }" style="color:#1976d2;"></i>
                    <div style="flex:1;">
                        <div style="font-weight:600; color:#1976d2;">${getGroupTitle(
                        key
                    )}</div>
                        <div style="font-size:12px; color:#5c6bc0;">${this._recordsSortMode === "monthly"
                        ? "Monthly View"
                        : "Weekly View"
                    }</div>
                    </div>
                    <div style="display:flex; align-items:center; gap:10px;">
                        <span style="font-size:12px; color:#555;">${count} orders</span>
                        <i class="fas ${isExpanded ? "fa-chevron-up" : "fa-chevron-down"
                    }" style="color:#1976d2;"></i>
                    </div>
                `;
                header.addEventListener("click", () => {
                    this._expandedRecordGroups[key] = !isExpanded;
                    // re-render only the specific tab
                    if (tabType === "successful") {
                        const combinedSuccessful = [
                            ...groups.delivered,
                            ...groups.pickedup,
                        ];
                        renderGroupedSuccessful(
                            "successful",
                            combinedSuccessful,
                            containerSuccessful
                        );
                    } else if (tabType === "failed") {
                        const combinedFailed = [
                            ...groups.failedDelivery,
                            ...groups.failedPickup,
                        ];
                        renderGrouped("failed", combinedFailed, containerFailed);
                    } else {
                        renderGrouped("failed", groups.failed, containerFailed);
                    }
                });
                return header;
            };

            const renderGroupedDelivered = (label, list, target) => {
                if (!target) return;
                console.log(
                    "DEBUG renderGroupedDelivered: Target container ID:",
                    target.id
                );
                console.log(
                    "DEBUG renderGroupedDelivered: Orders being rendered:",
                    list.map(([id, o]) => ({ id, status: o.status }))
                );
                // Clear target completely first
                target.innerHTML = "";
                // Ensure toolbar present
                ensureSortToolbar(target, label);
                if (!list || list.length === 0) return;
                // Build group map - only use deliveredAt for delivered orders
                const map = new Map();
                list.forEach(([id, o]) => {
                    const ts =
                        o.deliveredAt ||
                        o.updatedAt ||
                        o.assignedAt ||
                        o.createdAt ||
                        Date.now();
                    const key = getGroupKey(ts);
                    if (!map.has(key)) map.set(key, []);
                    map.get(key).push([id, o]);
                });
                // Sort groups by key desc
                const keys = Array.from(map.keys()).sort((a, b) => b.localeCompare(a));
                keys.forEach((key) => {
                    const groupDiv = document.createElement("div");
                    groupDiv.style.cssText = "margin:8px 0;";
                    const items = map.get(key) || [];
                    groupDiv.appendChild(
                        buildGroupHeader(key, items.length, "delivered")
                    );
                    if (this._expandedRecordGroups[key]) {
                        // Monthly: show week subgroups to choose; Weekly: show items directly
                        if (this._recordsSortMode === "monthly") {
                            const weekMap = new Map();
                            items.forEach(([id, o]) => {
                                const ts =
                                    o.deliveredAt ||
                                    o.updatedAt ||
                                    o.assignedAt ||
                                    o.createdAt ||
                                    Date.now();
                                const wKey = getWeekKey(ts);
                                if (!weekMap.has(wKey)) weekMap.set(wKey, []);
                                weekMap.get(wKey).push([id, o]);
                            });
                            const weekKeys = Array.from(weekMap.keys()).sort((a, b) =>
                                b.localeCompare(a)
                            );
                            weekKeys.forEach((wKey) => {
                                const composite = `${key}::${wKey}`;
                                const wkHeader = document.createElement("div");
                                const isWExpanded = !!this._expandedRecordGroups[composite];
                                wkHeader.style.cssText =
                                    "margin:8px 0 4px; padding:8px 10px; background:#eef4ff; border:1px dashed #c5d7fe; border-radius:6px; cursor:pointer; display:flex; align-items:center; gap:8px;";
                                wkHeader.innerHTML = `
                                    <i class="fas fa-calendar-week" style="color:#3f51b5;"></i>
                                    <div style="flex:1; color:#3f51b5; font-weight:600;">${getWeekTitle(
                                    wKey
                                )}</div>
                                    <i class="fas ${isWExpanded
                                        ? "fa-chevron-up"
                                        : "fa-chevron-down"
                                    }" style="color:#3f51b5;"></i>
                                `;
                                wkHeader.addEventListener("click", () => {
                                    this._expandedRecordGroups[composite] = !isWExpanded;
                                    renderGroupedDelivered(label, list, target);
                                });
                                groupDiv.appendChild(wkHeader);
                                if (isWExpanded) {
                                    const listDiv = document.createElement("div");
                                    listDiv.style.cssText = "margin:4px 0; padding:0 8px;";
                                    weekMap
                                        .get(wKey)
                                        .sort(orderByDateDesc)
                                        .forEach(([id, order]) => {
                                            const item = this.createAssignedOrderCard(id, order);
                                            listDiv.appendChild(item);
                                        });
                                    groupDiv.appendChild(listDiv);
                                }
                            });
                        } else {
                            // Weekly: show items directly
                            const listDiv = document.createElement("div");
                            listDiv.style.cssText = "margin:4px 0; padding:0 8px;";
                            items.sort(orderByDateDesc).forEach(([id, order]) => {
                                const item = this.createAssignedOrderCard(id, order);
                                listDiv.appendChild(item);
                            });
                            groupDiv.appendChild(listDiv);
                        }
                    }
                    target.appendChild(groupDiv);
                });
            };

            const renderGroupedPickedup = (label, list, target) => {
                if (!target) return;
                console.log(
                    "DEBUG renderGroupedPickedup: Target container ID:",
                    target.id
                );
                console.log(
                    "DEBUG renderGroupedPickedup: Orders being rendered:",
                    list.map(([id, o]) => ({ id, status: o.status }))
                );
                // Clear target completely first
                target.innerHTML = "";
                // Ensure toolbar present
                ensureSortToolbar(target, label);
                if (!list || list.length === 0) return;
                // Build group map - only use pickedUpAt for pickedup orders
                const map = new Map();
                list.forEach(([id, o]) => {
                    const ts =
                        o.pickedUpAt ||
                        o.updatedAt ||
                        o.assignedAt ||
                        o.createdAt ||
                        Date.now();
                    const key = getGroupKey(ts);
                    if (!map.has(key)) map.set(key, []);
                    map.get(key).push([id, o]);
                });
                // Sort groups by key desc
                const keys = Array.from(map.keys()).sort((a, b) => b.localeCompare(a));
                keys.forEach((key) => {
                    const groupDiv = document.createElement("div");
                    groupDiv.style.cssText = "margin:8px 0;";
                    const items = map.get(key) || [];
                    groupDiv.appendChild(buildGroupHeader(key, items.length, "pickedup"));
                    if (this._expandedRecordGroups[key]) {
                        // Monthly: show week subgroups to choose; Weekly: show items directly
                        if (this._recordsSortMode === "monthly") {
                            const weekMap = new Map();
                            items.forEach(([id, o]) => {
                                const ts =
                                    o.pickedUpAt ||
                                    o.updatedAt ||
                                    o.assignedAt ||
                                    o.createdAt ||
                                    Date.now();
                                const wKey = getWeekKey(ts);
                                if (!weekMap.has(wKey)) weekMap.set(wKey, []);
                                weekMap.get(wKey).push([id, o]);
                            });
                            const weekKeys = Array.from(weekMap.keys()).sort((a, b) =>
                                b.localeCompare(a)
                            );
                            weekKeys.forEach((wKey) => {
                                const composite = `${key}::${wKey}`;
                                const wkHeader = document.createElement("div");
                                const isWExpanded = !!this._expandedRecordGroups[composite];
                                wkHeader.style.cssText =
                                    "margin:8px 0 4px; padding:8px 10px; background:#eef4ff; border:1px dashed #c5d7fe; border-radius:6px; cursor:pointer; display:flex; align-items:center; gap:8px;";
                                wkHeader.innerHTML = `
                                    <i class="fas fa-calendar-week" style="color:#3f51b5;"></i>
                                    <div style="flex:1; color:#3f51b5; font-weight:600;">${getWeekTitle(
                                    wKey
                                )}</div>
                                    <i class="fas ${isWExpanded
                                        ? "fa-chevron-up"
                                        : "fa-chevron-down"
                                    }" style="color:#3f51b5;"></i>
                                `;
                                wkHeader.addEventListener("click", () => {
                                    this._expandedRecordGroups[composite] = !isWExpanded;
                                    renderGroupedPickedup(label, list, target);
                                });
                                groupDiv.appendChild(wkHeader);
                                if (isWExpanded) {
                                    const listDiv = document.createElement("div");
                                    listDiv.style.cssText = "margin:4px 0; padding:0 8px;";
                                    weekMap
                                        .get(wKey)
                                        .sort(orderByDateDesc)
                                        .forEach(([id, order]) => {
                                            const item = this.createAssignedOrderCard(id, order);
                                            listDiv.appendChild(item);
                                        });
                                    groupDiv.appendChild(listDiv);
                                }
                            });
                        } else {
                            // Weekly: show items directly
                            const listDiv = document.createElement("div");
                            listDiv.style.cssText = "margin:4px 0; padding:0 8px;";
                            items.sort(orderByDateDesc).forEach(([id, order]) => {
                                const item = this.createAssignedOrderCard(id, order);
                                listDiv.appendChild(item);
                            });
                            groupDiv.appendChild(listDiv);
                        }
                    }
                    target.appendChild(groupDiv);
                });
            };

            const renderGroupedSuccessful = (label, list, target) => {
                if (!target) return;
                console.log(
                    "DEBUG renderGroupedSuccessful: Target container ID:",
                    target.id
                );
                console.log(
                    "DEBUG renderGroupedSuccessful: Orders being rendered:",
                    list.map(([id, o]) => ({ id, status: o.status }))
                );
                // Clear target completely first
                target.innerHTML = "";
                // Ensure toolbar present
                ensureSortToolbar(target, label);
                if (!list || list.length === 0) return;

                // Apply search filter
                const searchQuery = this._searchQuery[label] || "";
                let filteredList = filterBySearch(list, searchQuery);

                // Apply payment filter if enabled
                const paymentSort = this._paymentSortMode[label] || "none";
                if (paymentSort !== "none") {
                    filteredList = filteredList.filter(([id, order]) => {
                        const orderPayment = getPaymentMethodForSort(order);
                        return orderPayment === paymentSort;
                    });
                    // Sort by date descending within the filtered payment method
                    filteredList.sort((a, b) => {
                        const at = a[1].createdAt || 0;
                        const bt = b[1].createdAt || 0;
                        return bt - at;
                    });
                } else {
                    // If no payment filter, sort by payment method then by date
                    filteredList = sortByPayment(filteredList);
                }
                // Build group map - USE createdAt (when order was placed) for successful tab
                const map = new Map();
                filteredList.forEach(([id, o]) => {
                    const ts = o.createdAt || Date.now();
                    const key = getGroupKey(ts);
                    if (!map.has(key)) map.set(key, []);
                    map.get(key).push([id, o]);
                });
                // Sort groups by key desc
                const keys = Array.from(map.keys()).sort((a, b) => b.localeCompare(a));
                keys.forEach((key) => {
                    const groupDiv = document.createElement("div");
                    groupDiv.style.cssText = "margin:8px 0;";
                    const items = map.get(key) || [];
                    groupDiv.appendChild(
                        buildGroupHeader(key, items.length, "successful")
                    );
                    if (this._expandedRecordGroups[key]) {
                        // Monthly: show week subgroups to choose; Weekly: show items directly
                        if (this._recordsSortMode === "monthly") {
                            const weekMap = new Map();
                            items.forEach(([id, o]) => {
                                const ts = o.createdAt || Date.now();
                                const wKey = getWeekKey(ts);
                                if (!weekMap.has(wKey)) weekMap.set(wKey, []);
                                weekMap.get(wKey).push([id, o]);
                            });
                            const weekKeys = Array.from(weekMap.keys()).sort((a, b) =>
                                b.localeCompare(a)
                            );
                            weekKeys.forEach((wKey) => {
                                const composite = `${key}::${wKey}`;
                                const wkHeader = document.createElement("div");
                                const isWExpanded = !!this._expandedRecordGroups[composite];
                                wkHeader.style.cssText =
                                    "margin:8px 0 4px; padding:8px 10px; background:#eef4ff; border:1px dashed #c5d7fe; border-radius:6px; cursor:pointer; display:flex; align-items:center; gap:8px;";
                                wkHeader.innerHTML = `
                                    <i class="fas fa-calendar-week" style="color:#3f51b5;"></i>
                                    <div style="flex:1; color:#3f51b5; font-weight:600;">${getWeekTitle(
                                    wKey
                                )}</div>
                                    <i class="fas ${isWExpanded
                                        ? "fa-chevron-up"
                                        : "fa-chevron-down"
                                    }" style="color:#3f51b5;"></i>
                                `;
                                wkHeader.addEventListener("click", () => {
                                    this._expandedRecordGroups[composite] = !isWExpanded;
                                    renderGroupedSuccessful(label, list, target);
                                });
                                groupDiv.appendChild(wkHeader);
                                if (isWExpanded) {
                                    const listDiv = document.createElement("div");
                                    listDiv.style.cssText = "margin:4px 0; padding:0 8px;";
                                    // Sort by createdAt (when order was placed) - descending
                                    weekMap
                                        .get(wKey)
                                        .sort((a, b) => {
                                            const at = a[1].createdAt || 0;
                                            const bt = b[1].createdAt || 0;
                                            return bt - at;
                                        })
                                        .forEach(([id, order]) => {
                                            const item = this.createAssignedOrderCard(id, order);
                                            listDiv.appendChild(item);
                                        });
                                    groupDiv.appendChild(listDiv);
                                }
                            });
                        } else {
                            // Weekly: show items directly - Sort by createdAt (when order was placed) - descending
                            const listDiv = document.createElement("div");
                            listDiv.style.cssText = "margin:4px 0; padding:0 8px;";
                            items
                                .sort((a, b) => {
                                    const at = a[1].createdAt || 0;
                                    const bt = b[1].createdAt || 0;
                                    return bt - at;
                                })
                                .forEach(([id, order]) => {
                                    const item = this.createAssignedOrderCard(id, order);
                                    listDiv.appendChild(item);
                                });
                            groupDiv.appendChild(listDiv);
                        }
                    }
                    target.appendChild(groupDiv);
                });
            };

            const renderGrouped = (label, list, target) => {
                if (!target) return;
                // Ensure toolbar present
                ensureSortToolbar(target, label);
                // Clear target
                target.innerHTML = "";
                if (!list || list.length === 0) return;

                // Apply search filter
                const searchQuery = this._searchQuery[label] || "";
                let filteredList = filterBySearch(list, searchQuery);

                // Apply payment filter if enabled
                const paymentSort = this._paymentSortMode[label] || "none";
                if (paymentSort !== "none") {
                    filteredList = filteredList.filter(([id, order]) => {
                        const orderPayment = getPaymentMethodForSort(order);
                        return orderPayment === paymentSort;
                    });
                    // Sort by date descending within the filtered payment method
                    filteredList.sort((a, b) => {
                        const at = a[1].createdAt || 0;
                        const bt = b[1].createdAt || 0;
                        return bt - at;
                    });
                } else {
                    // If no payment filter, sort by payment method then by date
                    filteredList = sortByPayment(filteredList);
                }

                // Build group map - USE createdAt (when order was placed) for failed tab
                const map = new Map();
                filteredList.forEach(([id, o]) => {
                    const ts = o.createdAt || Date.now();
                    const key = getGroupKey(ts);
                    if (!map.has(key)) map.set(key, []);
                    map.get(key).push([id, o]);
                });
                // Sort groups by key desc
                const keys = Array.from(map.keys()).sort((a, b) => b.localeCompare(a));
                keys.forEach((key) => {
                    const groupDiv = document.createElement("div");
                    groupDiv.style.cssText = "margin:8px 0;";
                    const items = map.get(key) || [];
                    groupDiv.appendChild(buildGroupHeader(key, items.length, "failed"));
                    if (this._expandedRecordGroups[key]) {
                        // Monthly: show week subgroups to choose; Weekly: show items directly
                        if (this._recordsSortMode === "monthly") {
                            const weekMap = new Map();
                            items.forEach(([id, o]) => {
                                const ts = o.createdAt || Date.now();
                                const wKey = getWeekKey(ts);
                                if (!weekMap.has(wKey)) weekMap.set(wKey, []);
                                weekMap.get(wKey).push([id, o]);
                            });
                            const weekKeys = Array.from(weekMap.keys()).sort((a, b) =>
                                b.localeCompare(a)
                            );
                            weekKeys.forEach((wKey) => {
                                const composite = `${key}::${wKey}`;
                                const wkHeader = document.createElement("div");
                                const isWExpanded = !!this._expandedRecordGroups[composite];
                                wkHeader.style.cssText =
                                    "margin:8px 0 4px; padding:8px 10px; background:#eef4ff; border:1px dashed #c5d7fe; border-radius:6px; cursor:pointer; display:flex; align-items:center; gap:8px;";
                                wkHeader.innerHTML = `
                                    <i class="fas fa-calendar-week" style="color:#3f51b5;"></i>
                                    <div style="flex:1; color:#3f51b5; font-weight:600;">${getWeekTitle(
                                    wKey
                                )}</div>
                                    <i class="fas ${isWExpanded
                                        ? "fa-chevron-up"
                                        : "fa-chevron-down"
                                    }" style="color:#3f51b5;"></i>
                                `;
                                wkHeader.addEventListener("click", () => {
                                    this._expandedRecordGroups[composite] = !isWExpanded;
                                    renderGrouped(label, list, target);
                                });
                                groupDiv.appendChild(wkHeader);
                                if (isWExpanded) {
                                    const listDiv = document.createElement("div");
                                    listDiv.style.cssText =
                                        "margin-top:4px; display:flex; flex-direction:column; gap:8px;";
                                    const weekItems = weekMap.get(wKey) || [];
                                    // Sort by createdAt (when order was placed) - descending
                                    weekItems.sort((a, b) => {
                                        const at = a[1].createdAt || 0;
                                        const bt = b[1].createdAt || 0;
                                        return bt - at;
                                    });
                                    weekItems.forEach(([id, o]) => {
                                        const card = this.createAssignedOrderCard(id, o);
                                        listDiv.appendChild(card);
                                        // Load staff notes after card is created
                                        setTimeout(() => this.loadStaffNotesIntoCard(id), 100);
                                    });
                                    groupDiv.appendChild(listDiv);
                                }
                            });
                        } else {
                            const listDiv = document.createElement("div");
                            listDiv.style.cssText =
                                "margin-top:8px; display:flex; flex-direction:column; gap:8px;";
                            // Sort by createdAt (when order was placed) - descending
                            items.sort((a, b) => {
                                const at = a[1].createdAt || 0;
                                const bt = b[1].createdAt || 0;
                                return bt - at;
                            });
                            items.forEach(([id, o]) => {
                                const card = this.createAssignedOrderCard(id, o);
                                listDiv.appendChild(card);
                            });
                            groupDiv.appendChild(listDiv);
                        }
                    }
                    target.appendChild(groupDiv);
                });
            };

            // Render grouped Successful (combined Delivered and Pickedup), Failed, and Cancelled lists
            const combinedSuccessful = [...groups.delivered, ...groups.pickedup];
            renderGroupedSuccessful(
                "successful",
                combinedSuccessful,
                containerSuccessful
            );

            // Debug: Log group counts
            console.log(`ðŸ” DEBUG Group Counts:`);
            console.log(`  - Failed Delivery: ${groups.failedDelivery.length}`);
            console.log(`  - Failed Pickup: ${groups.failedPickup.length}`);
            console.log(`  - Total Failed: ${groups.failed.length}`);

            // Render failed orders (combined delivery and pickup)
            const combinedFailed = [...groups.failedDelivery, ...groups.failedPickup];
            renderGrouped("failed", combinedFailed, containerFailed);

            renderGrouped("cancelled", groups.cancelled, containerCancelled);

            // Update Order Records count: only successful and failed orders
            const orderRecordsCount =
                groups.delivered.length +
                groups.pickedup.length +
                groups.failedDelivery.length +
                groups.failedPickup.length;
            if (countElement) {
                countElement.textContent = orderRecordsCount;
            }

            // Setup tab switching (once)
            if (!this.__assignTabsBound) {
                this.__assignTabsBound = true;
                document.querySelectorAll(".assign-tab-btn").forEach((btn) => {
                    btn.addEventListener("click", () => {
                        document
                            .querySelectorAll(".assign-tab-btn")
                            .forEach((b) => b.classList.remove("active"));
                        btn.classList.add("active");
                        const tab = btn.getAttribute("data-assign-tab");
                        document
                            .querySelectorAll("#assign-orders .tab-content")
                            .forEach((tc) => tc.classList.remove("active"));
                        const activeEl = document.getElementById(`assign-tab-${tab}`);
                        if (activeEl) activeEl.classList.add("active");
                    });
                });
            }

            // Update tab counts (exclude cancelled from counts)
            const setTabCount = (tabKey, label, count) => {
                const btn = document.querySelector(
                    `.assign-tab-btn[data-assign-tab="${tabKey}"]`
                );
                if (btn) {
                    btn.innerHTML = `${label} <span style="background:#eee; border-radius:10px; padding:2px 8px; margin-left:6px; font-size:12px;">${count}</span>`;
                }
            };
            const countNonCancelled = (list) =>
                list.filter(([id, o]) => (o.status || "").toLowerCase() !== "cancelled")
                    .length;
            setTabCount(
                "confirmed",
                "Confirmed",
                countNonCancelled(groups.confirmed)
            );
            setTabCount(
                "to-receive",
                "To Receive",
                countNonCancelled(groups.to_receive)
            );
            setTabCount(
                "successful",
                "Successful",
                countNonCancelled(groups.delivered) + countNonCancelled(groups.pickedup)
            );
            setTabCount("failed", "Failed", groups.failed.length);
            // Removed manual refresh button (realtime updates enabled below)

            // Attach lightweight live listeners so status flips to "delivered" without manual refresh
            if (!this.__assignedRealtimeBound) {
                this.__assignedRealtimeBound = true;
                const debouncedRepaint = (() => {
                    let t = null;
                    return () => {
                        clearTimeout(t);
                        t = setTimeout(() => {
                            console.log("DEBUG: Debounced repaint triggered");
                            // Always update assigned orders to reflect delivery status changes
                            this.loadAssignedOrders();
                            // Also update stats to reflect new counts
                            this.loadStats();
                        }, 150);
                    };
                })();

                dbRefs.orders.on("child_changed", (snapshot) => {
                    console.log(
                        "DEBUG: Assigned orders - child_changed detected:",
                        snapshot.key,
                        snapshot.val()
                    );
                    debouncedRepaint();
                });
                dbRefs.orders.on("child_added", (snapshot) => {
                    console.log(
                        "DEBUG: Assigned orders - child_added detected:",
                        snapshot.key,
                        snapshot.val()
                    );
                    debouncedRepaint();
                });
                dbRefs.orders.on("child_removed", (snapshot) => {
                    console.log(
                        "DEBUG: Assigned orders - child_removed detected:",
                        snapshot.key
                    );
                    debouncedRepaint();
                });
            }
        } catch (error) {
            console.error("Error loading assigned orders:", error);
        }
    }
    createAssignedOrderCard(id, order) {
        // Check localStorage for assignment data
        const storedAssignment = localStorage.getItem(`order_assignment_${id}`);
        let assignmentData = null;
        if (storedAssignment) {
            try {
                assignmentData = JSON.parse(storedAssignment);
                console.log(
                    `DEBUG createAssignedOrderCard: Found localStorage assignment for order ${id}:`,
                    assignmentData
                );
            } catch (e) {
                console.warn(
                    "DEBUG createAssignedOrderCard: Failed to parse stored assignment:",
                    e
                );
            }
        }

        // Ensure order is properly normalized (handle both camelCase and snake_case)
        // This ensures consistency after refresh
        order.riderId = order.riderId || order.rider_id || "";
        order.riderName = order.riderName || order.rider_name || "";
        order.riderPhone = order.riderPhone || order.rider_phone || "";
        order.status = order.status || order.order_status || "pending";

        // Merge assignment data if available (localStorage fallback)
        if (assignmentData) {
            order.riderId = order.riderId || assignmentData.riderId || "";
            order.riderName = order.riderName || assignmentData.riderName || "";
        }

        // Create wrapper container for checkbox outside order card
        const wrapper = document.createElement("div");
        wrapper.style.cssText =
            "display: flex; align-items: flex-start; gap: 12px; margin-bottom: 16px;";

        const div = document.createElement("div");
        div.className = "order-card fade-in";
        div.style.cssText =
            "min-height: auto !important; overflow: visible !important; position: relative !important; flex: 1;";

        let statusClass = "status-confirmed";
        const orderStatusLower = String(order.status || "").toLowerCase();

        // Check if pickup order is ready for pickup - use different status class
        const isPickupReady =
            String(order.deliveryOption || "").toLowerCase() === "pickup" &&
            (order.readyForPickup === true || order.ready_for_pickup === true) &&
            orderStatusLower === "to_receive";

        if (
            isPickupReady ||
            orderStatusLower === "pickup_ready" ||
            orderStatusLower === "out_for_delivery"
        ) {
            // Use the same visual style for "Pickup Ready" and "Out for delivery"
            statusClass = "status-pickup-ready";
        } else if (orderStatusLower === "to_receive") {
            // Plain "To Receive" keeps the shipped style
            statusClass = "status-shipped";
        } else if (orderStatusLower === "delivered") {
            statusClass = "status-delivered";
        }
        if (
            orderStatusLower === "failed" ||
            orderStatusLower === "delivery_failed" ||
            orderStatusLower === "failed_pickup"
        ) {
            statusClass = "status-failed";
        }
        if (orderStatusLower === "cancelled") {
            statusClass = "status-cancelled";
        }

        // Handle pending orders with cancellation requests
        if (
            (order.status || "").toLowerCase() === "pending" &&
            order.cancellationRequested === true
        ) {
            statusClass = "status-cancellation-requested";
        }

        // Handle confirmed orders with cancellation requests
        if (
            (order.status || "").toLowerCase() === "confirmed" &&
            order.cancellationRequested === true
        ) {
            statusClass = "status-cancellation-requested";
        }

        // Check if order is cancelled (has cancellation flags) - these orders should NOT show "Confirmed Date" and "Confirmed By"
        // These fields are for orders that were confirmed (pending -> confirmed), not for cancelled orders
        const isCancelled =
            order.cancellationConfirmed === true ||
            order.cancellation_confirmed === true ||
            order.cancellation_confirmed === 1 ||
            order.cancellation_confirmed === "true" ||
            order.refundConfirmedAt ||
            order.refund_confirmed_at ||
            order.refundDenied === true ||
            order.refund_denied === true ||
            order.refundDenied === 1 ||
            order.refund_denied === 1 ||
            order.refundDenied === "true" ||
            order.refund_denied === "true" ||
            order.refundReceiptUrl ||
            order.refund_receipt_url ||
            (order.status || "").toLowerCase() === "cancelled";

        // Get confirmed date from multiple possible fields
        const confirmedAtValue =
            order.confirmedAt ||
            order.confirmed_at ||
            order.confirmedAtTimestamp ||
            null;
        let confirmedDate = "N/A";
        if (confirmedAtValue) {
            try {
                // Handle both timestamp (number) and date string formats
                const dateValue =
                    typeof confirmedAtValue === "number"
                        ? confirmedAtValue
                        : confirmedAtValue;
                const date = new Date(dateValue);
                // Check if date is valid
                if (!isNaN(date.getTime())) {
                    confirmedDate = date.toLocaleString();
                }
            } catch (e) {
                console.warn("Error parsing confirmedAt date:", e);
            }
        }
        // Get confirmed by information
        const confirmedByUid = order.confirmedBy || order.confirmed_by || null;
        const confirmedByName =
            order.confirmedByName || order.confirmed_by_name || null;
        const confirmedByRole =
            order.confirmedByRole ||
            order.confirmed_by_role ||
            null;
        // Helper function to get initial display value
        const getConfirmedByDisplay = () => {
            if (confirmedByName) {
                if (confirmedByRole) {
                    return `${confirmedByName} - (Role: ${confirmedByRole})`;
                }
                // Fallback to heuristic only if role not provided
                const isAdmin =
                    confirmedByUid &&
                    (confirmedByUid.includes("admin") ||
                        confirmedByName.toLowerCase().includes("admin") ||
                        confirmedByName.toLowerCase().includes("administrator") ||
                        sessionStorage.getItem("userRole") === "admin" ||
                        sessionStorage.getItem("adminRole") === "admin");
                const role = isAdmin ? "Admin" : "Staff";
                return `${confirmedByName} - (Role: ${role})`;
            }
            if (confirmedByUid) {
                // Will be resolved asynchronously
                return "Loading...";
            }
            return "N/A";
        };
        const totalDisplay = (() => {
            const val =
                order.totalAmount != null
                    ? order.totalAmount
                    : order.total != null
                        ? order.total
                        : 0;
            const num = typeof val === "number" ? val : parseFloat(val) || 0;
            return num.toLocaleString();
        })();
        const subtotalDisplay = (() => {
            const val = order.subtotal != null ? order.subtotal : 0;
            const num = typeof val === "number" ? val : parseFloat(val) || 0;
            return num.toLocaleString();
        })();
        const deliveryFeeDisplay = (() => {
            const val =
                order.deliveryFee != null
                    ? order.deliveryFee
                    : order.delivery_fee != null
                        ? order.delivery_fee
                        : 0;
            const num = typeof val === "number" ? val : parseFloat(val) || 0;
            return num.toLocaleString();
        })();
        const itemsSafe = Array.isArray(order.items) ? order.items : [];

        const statusText =
            (order.cancellationRequested === true &&
                String(order.status || "").toLowerCase() === "confirmed") ||
                (String(order.status || "").toLowerCase() === "pending" &&
                    order.cancellationRequested === true)
                ? "Cancellation Requested"
                : this.formatStatus(order.status, order);

        const statusStyle = "";
        const statusLower = String(order.status || "").toLowerCase();

        // Create checkbox outside for to-receive orders
        const isToReceive =
            String(order.status || "").toLowerCase() === "to_receive";
        const isPickup =
            String(order.deliveryOption || "").toLowerCase() === "pickup";
        // Check both camelCase and snake_case for rider assignment (Supabase compatibility)
        const hasRider = !!(
            order.riderId ||
            order.rider_id ||
            order.riderName ||
            order.rider_name
        );
        const needsCheckbox =
            isToReceive && (!isPickup ? !hasRider : !order.readyForPickup);

        if (needsCheckbox) {
            const checkboxWrapper = document.createElement("div");
            checkboxWrapper.style.cssText =
                "display: flex; align-items: center; padding-top: 20px;";
            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.className = isPickup
                ? "pickup-ready-checkbox"
                : "to-receive-checkbox";
            checkbox.setAttribute("data-order-id", id);
            checkbox.style.cssText =
                "cursor: pointer; width: 20px; height: 20px; flex-shrink: 0;";
            checkboxWrapper.appendChild(checkbox);
            wrapper.appendChild(checkboxWrapper);
        } else {
            // Add empty spacer to maintain alignment
            const spacer = document.createElement("div");
            spacer.style.cssText = "width: 20px; flex-shrink: 0;";
            wrapper.appendChild(spacer);
        }

        div.innerHTML = `
            <div class="order-header collapsible" onclick="staffManager.toggleOrderManagementDetails('${id}')" style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
                <div style="display:flex; align-items:center; gap:12px; flex:1;">
                    ${String(order.status || "").toLowerCase() === "confirmed"
                ? `
                    <input type="checkbox" class="confirmed-checkbox" data-order-id="${id}" onclick="event.stopPropagation();" style="cursor:pointer; width:18px; height:18px; flex-shrink:0;" />
                    `
                : ""
            }
                    <div class="order-id">Order #${id
                .substr(-8)
                .toUpperCase()} ${order.rescheduledNextWeek
                    ? (() => {
                        const status = orderStatusLower;
                        const shouldShowDates = status === "to_receive" ||
                            status === "out_for_delivery" ||
                            status === "pickup_ready" ||
                            status === "delivered" ||
                            status === "picked_up" ||
                            status === "failed" ||
                            status === "delivery_failed" ||
                            status === "failed_pickup";
                        if (shouldShowDates) {
                            const { saturday, sunday } = getNextWeekendDates();
                            const satDate = formatDateMMDDYY(saturday);
                            const sunDate = formatDateMMDDYY(sunday);
                            return `<span style="margin-left:8px; padding:2px 8px; background:#ffebee; color:#c62828; border-radius:999px; font-weight:700; font-size:11px; letter-spacing:.5px;">Reschedule - ${satDate} - ${sunDate}</span>`;
                        }
                        return '<span style="margin-left:8px; padding:2px 8px; background:#ffebee; color:#c62828; border-radius:999px; font-weight:700; font-size:11px; letter-spacing:.5px;">RESCHEDULED</span>';
                    })()
                    : ""
            }${(() => {
                // Rating status indicator for delivered/picked_up orders
                const isRated = order.isRated || order.is_rated || false;
                const status = (order.status || "").toLowerCase();
                if (status === "delivered" || status === "picked_up") {
                    if (isRated) {
                        return '<span style="margin-left:8px; padding:2px 8px; background:#dcfce7; color:#166534; border-radius:999px; font-weight:700; font-size:11px; letter-spacing:.5px; display:inline-flex; align-items:center; gap:4px;"><i class="fas fa-star" style="font-size:9px;"></i>RATED</span>';
                    } else {
                        return '<span style="margin-left:8px; padding:2px 8px; background:#fef3c7; color:#92400e; border-radius:999px; font-weight:700; font-size:11px; letter-spacing:.5px; display:inline-flex; align-items:center; gap:4px;"><i class="far fa-star" style="font-size:9px;"></i>NOT RATED</span>';
                    }
                }
                return "";
            })()}</div>
                    <div class="order-status ${statusClass}" style="${statusStyle}">${statusText}</div>
                </div>
                ${order.riderId
                ? `<!-- DEBUG: Order ${id} has riderId: ${order.riderId}, riderName: ${order.riderName} -->`
                : `<!-- DEBUG: Order ${id} has no riderId -->`
            }
                ${["to_receive", "delivered", "failed"].includes(
                String(order.status || "").toLowerCase()
            ) &&
                String(order.status || "").toLowerCase() !== "delivered" &&
                String(order.status || "").toLowerCase() !== "failed" &&
                String(order.status || "").toLowerCase() !==
                "delivery_failed" &&
                String(order.status || "").toLowerCase() !== "failed_pickup"
                ? `
                <div style="display:flex; align-items:center; gap:6px; justify-content:flex-end; margin-left:auto;" onclick="event.stopPropagation();">
                    <div id="qr-status-${id}" style="display:flex; align-items:center; gap:4px; padding:4px 8px; background:#f5f5f5; border:1px solid #ddd; border-radius:4px; font-size:11px;">
                        <i class="fas fa-qrcode" style="color:#999; font-size:10px;"></i>
                        <span style="color:#666;">Checking...</span>
                    </div>
                </div>
                `
                : ""
            }
                <i class="fas fa-chevron-right toggle-icon" id="toggle-icon-${id}" style="flex-shrink:0;"></i>
            </div>
            <div class="order-details collapsed" id="order-details-${id}" style="overflow: visible !important; max-height: none !important; min-height: auto !important;">
                ${String(order.status || "").toLowerCase() === "to_receive" &&
                String(order.deliveryOption || "").toLowerCase() === "pickup"
                ? `
                ${order.readyForPickup
                    ? `
                <!-- Pickup Order Container -->
                <div style="background:#ffffff; border:2px solid #e0e7ff; border-radius:12px; padding:20px; margin:16px 0; box-shadow:0 2px 8px rgba(0,0,0,0.08);">
                    <div style="display:flex; align-items:center; gap:10px; margin-bottom:16px; padding-bottom:12px; border-bottom:2px solid #e0e7ff;">
                        <i class="fas fa-store" style="font-size:20px; color:#667eea;"></i>
                        <h3 style="margin:0; font-size:16px; font-weight:600; color:#4c51bf;">Pickup Order Status</h3>
                    </div>
                    
                    <div style="display:flex; flex-direction:column; gap:16px;">
                        <!-- Order Status Indicator -->
                        <div style="display:flex; align-items:center; gap:10px; padding:12px; background:#e8f5e9; border:1px solid #4caf50; border-radius:8px;">
                            <i class="fas fa-check-circle" style="color:#4caf50; font-size:18px;"></i>
                            <span style="font-weight:600; color:#2e7d32; font-size:14px;">Order awaiting to be picked-up by customer</span>
                        </div>
                        
                        <!-- Pickup Date Schedule -->
                        <div style="display:flex; align-items:center; gap:10px; padding:12px; background:#fff3e0; border:1px solid #ffb74d; border-radius:8px;">
                            <i class="fas fa-calendar-alt" style="color:#f57c00; font-size:18px;"></i>
                            <div style="display:flex; flex-direction:column; gap:2px;">
                                <span style="font-weight:600; color:#e65100; font-size:13px;">Pickup Date Schedule</span>
                                <span style="color:#e65100; font-size:14px;">${new Date().toLocaleDateString()}</span>
                            </div>
                        </div>
                        
                        <!-- Action Buttons -->
                        <div style="display:flex; gap:12px; flex-wrap:wrap;">
                            <button class="btn btn-success" onclick="staffManager.markOrderAsPickedUp('${id}')" style="flex:1; min-width:150px; padding:12px 20px; border-radius:8px; border:none; background:#4caf50; color:white; font-weight:600; font-size:14px; cursor:pointer; display:flex; align-items:center; justify-content:center; gap:8px;">
                                <i class="fas fa-check"></i> Order Pickup
                            </button>
                            <button class="btn btn-danger" onclick="staffManager.markOrderAsFailedPickup('${id}')" style="flex:1; min-width:150px; padding:12px 20px; border-radius:8px; border:none; background:#f44336; color:white; font-weight:600; font-size:14px; cursor:pointer; display:flex; align-items:center; justify-content:center; gap:8px;">
                                <i class="fas fa-times-circle"></i> Failed Pickup
                            </button>
                        </div>
                    </div>
                </div>
                `
                    : ""
                }
                `
                : ""
            }
                ${order.riderId &&
                String(order.status || "").toLowerCase() !== "delivered" &&
                String(order.status || "").toLowerCase() !== "failed" &&
                String(order.status || "").toLowerCase() !==
                "delivery_failed" &&
                String(order.status || "").toLowerCase() !== "failed_pickup"
                ? `
                <div style="display:flex; flex-direction:column; gap:8px; margin-bottom:16px; padding:12px; background:#e8f5e8; border:1px solid #4caf50; border-radius:8px;">
                    <div style="display:flex; align-items:center; gap:8px;">
                        <i class="fas fa-user-check" style="color:#2e7d32;"></i>
                        <span style="font-weight:600; color:#2e7d32; font-size:14px;">Assigned to: ${order.riderName || "Unknown Rider"
                }</span>
                    </div>
                    <div style="display:flex; align-items:center; gap:8px; margin-left:24px;">
                        <span style="font-weight:600; color:#2e7d32; font-size:13px;">Delivery Status:</span>
                        <span style="color:#2e7d32; font-size:13px;">${(() => {
                    const statusLower = String(
                        order.status || ""
                    ).toLowerCase();
                    if (statusLower === "delivered") return "Delivered";
                    if (
                        statusLower === "failed" ||
                        statusLower === "delivery_failed" ||
                        statusLower === "failed_pickup"
                    )
                        return "Failed";
                    return "Pending";
                })()}</span>
                    </div>
                </div>`
                : ""
            }
                
                ${String(order.status || "").toLowerCase() === "confirmed" ||
                String(order.status || "").toLowerCase() === "to_receive" ||
                String(order.status || "").toLowerCase() ===
                "out_for_delivery" ||
                String(order.status || "").toLowerCase() === "delivered" ||
                String(order.status || "").toLowerCase() === "picked_up" ||
                String(order.status || "").toLowerCase() === "failed" ||
                String(order.status || "").toLowerCase() ===
                "delivery_failed" ||
                String(order.status || "").toLowerCase() === "failed_pickup"
                ? `
                <!-- Order Details - Redesigned Layout (Confirmed & To Receive) -->
                <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(280px, 1fr)); gap:20px; margin:16px 0;">
                    
                    <!-- Customer Information Card -->
                    <div style="background:#f9fafb; padding:16px; border-radius:8px; border:1px solid #e5e7eb;">
                        <h5 style="margin:0 0 12px 0; font-size:12px; font-weight:700; color:#6b7280; text-transform:uppercase; letter-spacing:0.8px;">Customer Information</h5>
                        <div style="display:flex; flex-direction:column; gap:8px;">
                            <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Name</span><span style="color:#111827; font-weight:500; font-size:13px;">${order.customerName || "N/A"
                }</span></div>
                            <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Contact</span><span style="color:#111827; font-weight:500; font-size:13px;">${order.customerPhone || "N/A"
                }</span></div>
                            <div style="display:flex; flex-direction:column; gap:10px; margin-top:12px;">
                                <button class="secondary-btn" onclick="staffManager.viewOrderCustomerDetails('${id}', '${order.customerName || ""
                }', '${order.customerPhone || ""}', '${order.deliveryAddress || ""
                }')" style="padding:10px 20px; border-radius:6px; font-size:13px; font-weight:500;">
                                    <i class="fas fa-user"></i> Customer Details
                                </button>
                                <button class="secondary-btn" onclick="(async function(){ try { const customerId = '${(
                    order.customerId ||
                    order.customer_id ||
                    id
                )
                    .toString()
                    .replace(/'/g, "\\'")}'; let customerName = '${(
                        order.customerName || "Customer"
                    )
                        .replace(/'/g, "\\'")
                        .replace(
                            /"/g,
                            "&quot;"
                        )}'; if(typeof openChatWithCustomer === 'function') { await openChatWithCustomer(customerId, customerName); } else if(typeof window.openChatWithCustomer === 'function') { await window.openChatWithCustomer(customerId, customerName); } else { console.error('openChatWithCustomer function not found'); } } catch(e) { console.error('Error opening chat:', e); } })();" style="padding:10px 20px; border-radius:6px; font-size:13px; font-weight:500; background:linear-gradient(135deg, #4CAF50, #45a049); color:white; border:none; box-shadow:0 2px 8px rgba(76, 175, 80, 0.3);">
                                    <i class="fas fa-comments"></i> Contact Customer
                                </button>
                        </div>
                        </div>
                    </div>
                    
                    <!-- Audit Trail Card -->
                    <div style="background:#f9fafb; padding:16px; border-radius:8px; border:1px solid #e5e7eb;">
                        <h5 style="margin:0 0 12px 0; font-size:12px; font-weight:700; color:#6b7280; text-transform:uppercase; letter-spacing:0.8px;">Audit Trail</h5>
                        <div style="display:flex; flex-direction:column; gap:8px;">
                            <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Order Date</span><span style="color:#111827; font-weight:500; font-size:13px;">${order.createdAt
                    ? new Date(order.createdAt).toLocaleString()
                    : "N/A"
                }</span></div>
                            ${(order.deliveryOption || "").toLowerCase() === "pickup" &&
                    (order.readyForPickup === true || order.ready_for_pickup === true) &&
                    (order.ready_for_pickup_at || order.readyForPickupAt)
                    ? `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Pickup Schedule</span><span style="color:#111827; font-weight:500; font-size:13px;">${new Date(
                        order.ready_for_pickup_at || order.readyForPickupAt
                    ).toLocaleDateString()}</span></div>`
                    : ""
                }
                            ${(String(order.status || "").toLowerCase() ===
                    "failed" ||
                    String(order.status || "").toLowerCase() ===
                    "delivery_failed") &&
                    order.deliverySchedule
                    ? `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Delivery Schedule</span><span style="color:#111827; font-weight:500; font-size:13px;">${new Date(
                        order.deliverySchedule
                    ).toLocaleDateString()}</span></div>`
                    : ""
                }
                            ${(String(order.status || "").toLowerCase() ===
                    "failed" ||
                    String(order.status || "").toLowerCase() ===
                    "delivery_failed") &&
                    order.failedAt
                    ? `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Failed At</span><span style="color:#111827; font-weight:500; font-size:13px;">${new Date(
                        order.failedAt
                    ).toLocaleString()}</span></div>`
                    : ""
                }
                            ${(() => {
                    // Check if order is rescheduled
                    const isRescheduled =
                        order.rescheduledNextWeek === true ||
                        order.rescheduled_next_week === true;

                    if (isRescheduled) {
                        // For rescheduled orders: show Rescheduled At, Rescheduled By, and Reschedule Dates
                        const rescheduledAt =
                            order.rescheduledAt || order.rescheduled_at;
                        const rescheduledByName =
                            order.rescheduledByName ||
                            order.rescheduled_by_name ||
                            "";
                        const rescheduledByRole =
                            order.rescheduledByRole ||
                            order.rescheduled_by_role ||
                            "";
                        const rescheduledByDisplay = rescheduledByName
                            ? rescheduledByRole
                                ? `${rescheduledByName} - ${rescheduledByRole}`
                                : rescheduledByName
                            : "Staff";

                        // Calculate next week's Saturday and Sunday dates
                        const { saturday, sunday } = getNextWeekendDates();
                        const satDate = formatDateMMDDYY(saturday);
                        const sunDate = formatDateMMDDYY(sunday);

                        const statusLower = String(order.status || "").toLowerCase();
                        const pickedUpTs = order.pickedUpAt || order.picked_up_at;
                        const failedPickupTs = order.failedPickupAt || order.failed_pickup_at;
                        const deliveredTs = order.deliveredAt || order.delivered_at;
                        const deliverySchedule = order.outForDeliveryAt || order.out_for_delivery_at || order.deliverySchedule;
                        const pickupVerifier = (() => {
                            const name =
                                order.pickup_verified_by_name ||
                                order.pickupVerifiedByName ||
                                order.picked_up_by_name ||
                                order.pickedUpByName ||
                                order.updated_by_name ||
                                order.updatedByName ||
                                (order.customerName ? order.customerName : "Staff/Customer");
                            const role =
                                order.pickup_verified_by_role ||
                                order.pickupVerifiedByRole ||
                                order.picked_up_by_role ||
                                order.pickedUpByRole ||
                                order.updated_by_role ||
                                order.updatedByRole ||
                                (order.customerName ? "Customer" : "");
                            return role ? `${name} - ${role}` : name;
                        })();

                        return `
                                        ${rescheduledAt
                                ? `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Rescheduled At</span><span style="color:#111827; font-weight:500; font-size:13px;">${new Date(
                                    rescheduledAt
                                ).toLocaleString()}</span></div>`
                                : ""
                            }
                                        <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Rescheduled By</span><span style="color:#111827; font-weight:500; font-size:13px;">${rescheduledByDisplay}</span></div>
                                        <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Reschedule</span><span style="color:#111827; font-weight:500; font-size:13px;">${satDate} - ${sunDate}</span></div>
                                        ${statusLower === "picked_up" && pickedUpTs
                                ? `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Pickup At</span><span style="color:#111827; font-weight:500; font-size:13px;">${new Date(
                                    pickedUpTs
                                ).toLocaleString()}</span></div>
                                        <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Pickup Verified By</span><span style="color:#111827; font-weight:500; font-size:13px;">${pickupVerifier}</span></div>`
                                : ""
                            }
                                        ${statusLower === "failed_pickup" && failedPickupTs
                                ? `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Failed Pickup At</span><span style="color:#111827; font-weight:500; font-size:13px;">${new Date(
                                    failedPickupTs
                                ).toLocaleString()}</span></div>
                                        <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Pickup Verified By</span><span style="color:#111827; font-weight:500; font-size:13px;">${pickupVerifier}</span></div>`
                                : ""
                            }
                                        ${statusLower === "delivered"
                                ? `${deliverySchedule
                                    ? `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Delivery Schedule</span><span style="color:#111827; font-weight:500; font-size:13px;">${new Date(
                                        deliverySchedule
                                    ).toLocaleDateString()}</span></div>`
                                    : ""
                                }
                                        ${deliveredTs
                                    ? `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Delivered Date and Time</span><span style="color:#111827; font-weight:500; font-size:13px;">${new Date(
                                        deliveredTs
                                    ).toLocaleString()}</span></div>`
                                    : ""
                                }`
                                : ""
                            }
                                    `;
                    } else {
                        // For non-rescheduled orders: show normal fields
                        // Don't show Confirmed Date for rescheduled orders in any status
                        const shouldShowConfirmed = !isRescheduled;
                        const statusLower = String(order.status || "").toLowerCase();
                        const pickedUpTs = order.pickedUpAt || order.picked_up_at;
                        const failedPickupTs = order.failedPickupAt || order.failed_pickup_at;
                        const deliveredTs = order.deliveredAt || order.delivered_at;
                        const deliverySchedule = order.outForDeliveryAt || order.out_for_delivery_at || order.deliverySchedule;
                        
                        return `
                                        ${(() => {
                                // Check conditions directly without storing booleans
                                // Only show Confirmed Date and Confirmed By for GCash orders that got confirmed
                                // COD orders are already confirmed upon placement, so these fields don't apply
                                // COD orders paid through GCash (has payment_proof) should also not show these fields
                                const paymentMethod = String(order.paymentMethod || order.payment_method || "cash").toLowerCase();
                                const isGcash = paymentMethod === "gcash";
                                const hasPaymentProof = !!(order.payment_proof || order.paymentProof);
                                // Show only for original GCash orders (not COD orders, not COD paid through GCash)
                                const isOriginalGcashOrder = isGcash && !hasPaymentProof;
                                const shouldShow = !isCancelled && shouldShowConfirmed && isOriginalGcashOrder;
                                if (!shouldShow) {
                                    return "";
                                }
                                // Build the HTML string directly - ensure no booleans are rendered
                                let result = `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Confirmed Date</span><span style="color:#111827; font-weight:500; font-size:13px;">${confirmedDate}</span></div>`;
                                // Only add Confirmed By if conditions are met
                                const hasConfirmedByInfo = shouldShowConfirmed && isOriginalGcashOrder && (confirmedByUid || confirmedByName);
                                if (hasConfirmedByInfo) {
                                    result += `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Confirmed By</span><span style="color:#111827; font-weight:500; font-size:13px;" id="confirmed-by-${id}">${getConfirmedByDisplay()}</span></div>`;
                                }
                                return result;
                            })()}
                                        ${statusLower === "picked_up" &&
                                    (order.pickedUpAt || order.picked_up_at)
                                    ? `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Pickup At</span><span style="color:#111827; font-weight:500; font-size:13px;">${new Date(
                                        order.pickedUpAt || order.picked_up_at
                                    ).toLocaleString()}</span></div>`
                                    : ""
                                }
                                        ${statusLower === "failed_pickup" &&
                                    (order.failedPickupAt || order.failed_pickup_at)
                                    ? `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Failed Pickup At</span><span style="color:#111827; font-weight:500; font-size:13px;">${new Date(
                                        order.failedPickupAt || order.failed_pickup_at
                                    ).toLocaleString()}</span></div>`
                                    : ""
                                }
                                        ${(statusLower === "picked_up" ||
                                    statusLower === "failed_pickup")
                                    ? (() => {
                                        const name =
                                            order.pickupVerifiedByName ||
                                            order.pickup_verified_by_name ||
                                            order.pickedUpByName ||
                                            order.picked_up_by_name ||
                                            order.updatedByName ||
                                            order.updated_by_name ||
                                            order.customerName ||
                                            "Staff/Customer";
                                        const role =
                                            order.pickupVerifiedByRole ||
                                            order.pickup_verified_by_role ||
                                            order.pickedUpByRole ||
                                            order.picked_up_by_role ||
                                            order.updatedByRole ||
                                            order.updated_by_role ||
                                            (order.customerName ? "Customer" : "");
                                        const display = role ? `${name} - ${role}` : name;
                                        return `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Pickup Verified By</span><span style="color:#111827; font-weight:500; font-size:13px;">${display}</span></div>`;
                                    })()
                                    : ""
                                }
                                        ${String(
                                    order.status || ""
                                ).toLowerCase() === "delivered" &&
                                    order.outForDeliveryAt
                                    ? `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Delivery Schedule</span><span style="color:#111827; font-weight:500; font-size:13px;">${new Date(
                                        order.outForDeliveryAt
                                    ).toLocaleDateString()}</span></div>`
                                    : ""
                                }
                                        ${String(
                                    order.status || ""
                                ).toLowerCase() === "delivered" &&
                                    order.deliveredAt
                                    ? `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Delivered Date and Time</span><span style="color:#111827; font-weight:500; font-size:13px;">${new Date(
                                        order.deliveredAt
                                    ).toLocaleString()}</span></div>`
                                    : ""
                                }
                                        ${String(
                                    order.status || ""
                                ).toLowerCase() === "confirmed" &&
                                    order.cancellationRequested ===
                                    true &&
                                    String(
                                        order.paymentMethod || ""
                                    ).toLowerCase() === "gcash" &&
                                    order.cancellationRequestedAt
                                    ? `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Cancellation Requested At</span><span style="color:#111827; font-weight:500; font-size:13px;">${new Date(
                                        order.cancellationRequestedAt
                                    ).toLocaleString()}</span></div>`
                                    : ""
                                }
                                        ${String(
                                    order.status || ""
                                ).toLowerCase() === "to_receive" &&
                                    order.toReceiveAt &&
                                    !isRescheduled
                                    ? `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">To Receive Date</span><span style="color:#111827; font-weight:500; font-size:13px;">${new Date(
                                        order.toReceiveAt
                                    ).toLocaleString()}</span></div>`
                                    : ""
                                }
                                        `;
                    }
                })()}
                        </div>
                    </div>
                    
                    <!-- Payment Information Card -->
                    <div style="background:#f9fafb; padding:16px; border-radius:8px; border:1px solid #e5e7eb;">
                        <h5 style="margin:0 0 12px 0; font-size:12px; font-weight:700; color:#6b7280; text-transform:uppercase; letter-spacing:0.8px;">Payment</h5>
                        <div style="display:flex; flex-direction:column; gap:8px;">
                            <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Method</span><span style="color:#111827; font-weight:600; font-size:13px; text-transform:uppercase;">${(() => {
                    const pm = String(order.paymentMethod || "N/A").toLowerCase();
                    // If GCash and has payment_proof (rider upload), it's COD paid through GCash
                    if (pm === "gcash" && (order.payment_proof || order.paymentProof)) {
                        return "COD - PAID THROUGH GCASH";
                    }
                    return (order.paymentMethod || "N/A").replace("_", " ");
                })()}</span></div>
                            <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Subtotal</span><span style="color:#111827; font-weight:500; font-size:13px;">â‚±${subtotalDisplay}</span></div>
                                    ${Number(deliveryFeeDisplay) > 0
                    ? `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Delivery Fee</span><span style="color:#111827; font-weight:500; font-size:13px;">â‚±${deliveryFeeDisplay}</span></div>`
                    : ""
                }
                            <div style="display:flex; justify-content:space-between; padding:6px 0;"><span style="color:#111827; font-weight:700; font-size:15px;">Total Amount</span><span style="color:#059669; font-weight:700; font-size:16px;">â‚±${totalDisplay}</span></div>
                        </div>
                    </div>
                    
                </div>
                
                <!-- Order Details Container (Combined Delivery/Pickup Information and Order Items) -->
                <div style="background:#f9fafb; border:1px solid #e5e7eb; border-radius:8px; padding:16px; margin:20px 0;">
                    <h5 style="margin:0 0 16px 0; font-size:12px; font-weight:700; color:#6b7280; text-transform:uppercase; letter-spacing:0.8px; text-align:center;">Order Details</h5>
                    
                    <!-- Delivery/Pickup Information Group -->
                    <div style="margin-bottom:20px; padding:12px; background:#ffffff; border:1px solid #e5e7eb; border-radius:6px;">
                        <div style="font-size:13px; font-weight:600; color:#374151; margin-bottom:8px; display:flex; align-items:center; justify-content:center; gap:6px;">
                            <i class="fas ${String(order.deliveryOption || "").toLowerCase() === "pickup" ? "fa-map-marker-alt" : "fa-truck"}" style="color:#6b7280; font-size:12px;"></i>
                            ${String(order.deliveryOption || "").toLowerCase() === "pickup" ? "Pickup Address" : "Delivery Address"}
                    </div>
                        <div style="font-size:14px; color:#111827; line-height:1.6;">${this.buildAddressSection(order)}</div>
                </div>
                
                    <!-- Order Items Group -->
                    <div style="margin-bottom:20px; padding:12px; background:#ffffff; border:1px solid #e5e7eb; border-radius:6px;">
                        <div style="font-size:13px; font-weight:600; color:#374151; margin-bottom:12px; display:flex; align-items:center; justify-content:center; gap:6px;">
                            <i class="fas fa-shopping-cart" style="color:#6b7280; font-size:12px;"></i>
                            Order Items
                    </div>
                        <div style="display:table; width:100%; border-collapse:collapse;">
                            <div style="display:table-row; border-bottom:1px solid #e5e7eb; font-weight:600; color:#374151; font-size:13px;">
                                <div style="display:table-cell; padding:10px; border-right:1px solid #e5e7eb;">Product</div>
                                <div style="display:table-cell; padding:10px; border-right:1px solid #e5e7eb; text-align:center;">Kilo Ã— Price</div>
                                <div style="display:table-cell; padding:10px; text-align:right;">Total</div>
                            </div>
                        ${itemsSafe
                    .map((item) => `
                            <div style="display:table-row; border-bottom:1px solid #e5e7eb;">
                                <div style="display:table-cell; padding:10px; border-right:1px solid #e5e7eb; font-weight:600; color:#111827; font-size:14px;">${item.productName || "Item"
                            }</div>
                                <div style="display:table-cell; padding:10px; border-right:1px solid #e5e7eb; text-align:center; color:#6b7280; font-size:13px;">${item.quantity || 0
                            } ${item.unit || ""} Ã— â‚±${(
                                item.price || 0
                            ).toLocaleString()}</div>
                                <div style="display:table-cell; padding:10px; text-align:right; font-weight:700; color:#059669; font-size:15px;">â‚±${(
                                (item.quantity || 0) * (item.price || 0)
                            ).toLocaleString()}</div>
                            </div>
                            `)
                    .join("")}
                        </div>
                </div>
                    
                    <!-- Order/Delivery Notes Group -->
                    <div id="order-notes-container-${id}" style="margin-bottom:20px;">
                        ${(() => {
                            const rawNotes = order.order_notes || order.orderNotes || order.deliveryNotes || order.delivery_notes || "";
                            const filteredNotes = this.filterCustomerNotes(rawNotes);
                            const deliveryOption = (order.deliveryOption || "").toLowerCase();
                            const isPickup = deliveryOption === "pickup";
                            const isDelivery = !isPickup;
                            const orderStatus = String(order.status || "").toLowerCase();
                            const isToReceiveTab = orderStatus === "to_receive" || orderStatus === "out_for_delivery";
                            
                            // Check if rider is assigned (for delivery orders)
                            const hasRider = !!(order.riderId || order.rider_id || order.riderName || order.rider_name);
                            
                            // Customer notes - always show if they exist
                            let customerNotesHtml = '';
                            if (filteredNotes) {
                                customerNotesHtml = `
                        <div style="padding:12px; background:#ffffff; border:1px solid #e5e7eb; border-radius:6px;">
                            <div style="font-size:13px; font-weight:600; color:#374151; margin-bottom:8px; display:flex; align-items:center; gap:6px;">
                                <i class="fas fa-sticky-note" style="color:#6b7280; font-size:12px;"></i>
                                ${isPickup ? "Order/Pickup Notes" : "Order/Delivery Notes"} (Customer)
                            </div>
                            <div style="font-size:13px; line-height:1.5; font-style:italic; color:#111827;">
                                "${this.esc(filteredNotes)}"
                            </div>
                        </div>
                        `;
                            }
                            
                            // Staff notes container - always for delivery orders (regardless of status or rider assignment)
                            let staffNotesContainerHtml = '';
                            if (isDelivery) {
                                // Show container for all delivery orders
                                staffNotesContainerHtml = `<div id="staff-notes-container-${id}" data-is-to-receive="${isToReceiveTab}" data-order-id="${id}"></div>`;
                            }
                            
                            return customerNotesHtml + staffNotesContainerHtml;
                        })()}
                    </div>
                
                    <!-- Delivered Details Group -->
                ${order.status === "delivered"
                ? `
                    <div style="margin-bottom:20px; padding:12px; background:#ffffff; border:1px solid #e5e7eb; border-radius:6px;">
                        <div style="font-size:13px; font-weight:600; color:#374151; margin-bottom:8px; display:flex; align-items:center; justify-content:center; gap:6px;">
                            <i class="fas fa-check-circle" style="color:#4caf50; font-size:12px;"></i>
                            Delivered Details
                        </div>
                        <div style="display:flex; flex-direction:column; gap:8px;">
                            <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Rider Name</span><span style="color:#111827; font-weight:500; font-size:13px;">${order.deliveredByName ||
                order.delivered_by_name ||
                order.deliveryRiderName ||
                order.riderName ||
                "Unknown"
                }</span></div>
                        ${order.paymentMethod === "cash_on_delivery" ||
                    order.cashReceived
                    ? `
                                <div style="padding:12px; background:#f9fafb; border:1px solid #e5e7eb; border-radius:6px; margin-top:8px;">
                                    <div style="font-size:13px; font-weight:600; color:#374151; margin-bottom:8px; display:flex; align-items:center; gap:6px;">
                                        <i class="fas fa-money-bill-wave" style="color:#6b7280; font-size:12px;"></i>
                                        Cash on Delivery
                                    </div>
                                    <div style="display:flex; flex-direction:column; gap:6px;">
                                        <div style="display:flex; justify-content:space-between; padding:4px 0;"><span style="color:#6b7280; font-size:13px;">Total Amount</span><span style="color:#111827; font-weight:500; font-size:13px;">â‚±${order.totalAmount || order.total || 0
                    }</span></div>
                                        <div style="display:flex; justify-content:space-between; padding:4px 0;"><span style="color:#6b7280; font-size:13px;">Cash Received</span><span style="color:#111827; font-weight:500; font-size:13px;">â‚±${order.cashReceived || 0
                    }</span></div>
                                        <div style="display:flex; justify-content:space-between; padding:4px 0;"><span style="color:#6b7280; font-size:13px;">Change</span><span style="color:#111827; font-weight:500; font-size:13px;">â‚±${order.change || 0
                    }</span></div>
                                    </div>
                            </div>
                        `
                    : ""
                }
                            ${(() => {
                    const proofImages =
                        order.deliveryProof ||
                        order.delivery_proof ||
                        order.proofImages ||
                        [];
                    const imageArray = Array.isArray(proofImages)
                        ? proofImages
                        : proofImages
                            ? [proofImages]
                            : [];
                    if (imageArray.length > 0) {
                        const formatDeliveryProofUrl = (urlStr) => {
                            if (!urlStr || typeof urlStr !== "string")
                                return urlStr;
                            const trimmed = urlStr.trim();
                            if (!trimmed) return trimmed;

                            const SUPABASE_URL =
                                "https://afkwexvvuxwbpioqnelp.supabase.co";
                            const BUCKET_NAME = "delivery_proof";

                            if (
                                trimmed.startsWith("http://") ||
                                trimmed.startsWith("https://")
                            ) {
                                if (
                                    trimmed.includes(
                                        `/${BUCKET_NAME}/${BUCKET_NAME}/`
                                    )
                                ) {
                                    return trimmed.replace(
                                        `/${BUCKET_NAME}/${BUCKET_NAME}/`,
                                        `/${BUCKET_NAME}/`
                                    );
                                }
                                if (
                                    trimmed.includes(
                                        `supabase.co/storage/v1/object/public/${BUCKET_NAME}/`
                                    )
                                ) {
                                    return trimmed;
                                }
                                if (trimmed.includes("supabase.co")) {
                                    const pathMatch = trimmed.match(
                                        /delivery_proof\/(.+?)(?:\?|$)/
                                    );
                                    if (pathMatch && pathMatch[1]) {
                                        let filePath = decodeURIComponent(
                                            pathMatch[1]
                                        );
                                        if (
                                            filePath.startsWith(BUCKET_NAME + "/")
                                        ) {
                                            filePath = filePath.substring(
                                                BUCKET_NAME.length + 1
                                            );
                                        }
                                        return `${SUPABASE_URL}/storage/v1/object/public/${BUCKET_NAME}/${filePath}`;
                                    }
                                }
                                return trimmed;
                            }

                            let cleanPath = trimmed;
                            cleanPath = cleanPath.startsWith("/")
                                ? cleanPath.substring(1)
                                : cleanPath;
                            if (cleanPath.startsWith(BUCKET_NAME + "/")) {
                                cleanPath = cleanPath.substring(
                                    BUCKET_NAME.length + 1
                                );
                            }
                            return `${SUPABASE_URL}/storage/v1/object/public/${BUCKET_NAME}/${cleanPath}`;
                        };

                        return `
                                        <div style="margin-top:12px;">
                                            <div style="font-size:13px; font-weight:600; color:#374151; margin-bottom:8px;">Proof of Delivery Images</div>
                                            <div style="display:flex; gap:12px; flex-wrap:wrap;">
                                                ${imageArray
                                .map((imgUrl, idx) => {
                                    const rawUrl = String(
                                        imgUrl || ""
                                    ).trim();
                                    if (!rawUrl) return "";
                                    const url =
                                        formatDeliveryProofUrl(
                                            rawUrl
                                        );
                                    const escapedUrl = url
                                        .replace(/'/g, "\\'")
                                        .replace(/"/g, "&quot;");
                                    return `
                                                        <div style="position:relative; width:120px; height:120px; border:2px solid #e5e7eb; border-radius:8px; overflow:hidden; cursor:pointer; transition:transform 0.2s ease; background:#f5f5f5;" 
                                                             onclick="event.preventDefault(); event.stopPropagation(); if(window.staffManager && typeof window.staffManager.showEnlargedImage === 'function') { window.staffManager.showEnlargedImage('${escapedUrl}', 'Proof of Delivery ${idx + 1
                                        }'); }"
                                                             onmouseenter="this.style.transform='scale(1.05)';"
                                                             onmouseleave="this.style.transform='scale(1)';"
                                                             title="Click to view full size">
                                                            <img src="${url}" 
                                                                 alt="Proof of Delivery ${idx + 1
                                        }" 
                                                                 style="width:100%; height:100%; object-fit:cover; display:block;"
                                                                 onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                                                                 loading="lazy" />
                                                            <div style="display:none; width:100%; height:100%; align-items:center; justify-content:center; background:#ffebee; color:#c62828; font-size:11px; text-align:center; padding:4px;">
                                                                <div>
                                                                    <i class="fas fa-exclamation-triangle" style="display:block; margin-bottom:4px; font-size:16px;"></i>
                                                                    <span>Failed to load</span>
                                    </div>
                            </div>
                                                        </div>
                                                    `;
                                })
                                .join("")}
                                            </div>
                                        </div>
                                    `;
                    }
                    return "";
                })()}
                            ${(() => {
                    const paymentProof =
                        order.paymentProof ||
                        order.payment_proof ||
                        null;
                    if (
                        paymentProof &&
                        (order.payment_method === "gcash" ||
                            order.paymentMethod === "gcash" ||
                            String(order.payment_method || "")
                                .toLowerCase() === "gcash" ||
                            String(order.paymentMethod || "")
                                .toLowerCase() === "gcash")
                    ) {
                        const formatPaymentProofUrl = (urlStr) => {
                            if (!urlStr || typeof urlStr !== "string")
                                return urlStr;
                            const trimmed = urlStr.trim();
                            if (!trimmed) return trimmed;

                            const SUPABASE_URL =
                                "https://afkwexvvuxwbpioqnelp.supabase.co";
                            const BUCKET_NAME = "delivery_proof_payment";

                            if (
                                trimmed.startsWith("http://") ||
                                trimmed.startsWith("https://")
                            ) {
                                if (
                                    trimmed.includes(
                                        `/${BUCKET_NAME}/${BUCKET_NAME}/`
                                    )
                                ) {
                                    return trimmed.replace(
                                        `/${BUCKET_NAME}/${BUCKET_NAME}/`,
                                        `/${BUCKET_NAME}/`
                                    );
                                }
                                if (
                                    trimmed.includes(
                                        `supabase.co/storage/v1/object/public/${BUCKET_NAME}/`
                                    )
                                ) {
                                    return trimmed;
                                }
                                if (trimmed.includes("supabase.co")) {
                                    const pathMatch = trimmed.match(
                                        /delivery_proof_payment\/(.+?)(?:\?|$)/
                                    );
                                    if (pathMatch && pathMatch[1]) {
                                        let filePath = decodeURIComponent(
                                            pathMatch[1]
                                        );
                                        if (
                                            filePath.startsWith(
                                                BUCKET_NAME + "/"
                                            )
                                        ) {
                                            filePath = filePath.substring(
                                                BUCKET_NAME.length + 1
                                            );
                                        }
                                        return `${SUPABASE_URL}/storage/v1/object/public/${BUCKET_NAME}/${filePath}`;
                                    }
                                }
                                return trimmed;
                            }

                            let cleanPath = trimmed;
                            cleanPath = cleanPath.startsWith("/")
                                ? cleanPath.substring(1)
                                : cleanPath;
                            if (
                                cleanPath.startsWith(BUCKET_NAME + "/")
                            ) {
                                cleanPath = cleanPath.substring(
                                    BUCKET_NAME.length + 1
                                );
                            }
                            return `${SUPABASE_URL}/storage/v1/object/public/${BUCKET_NAME}/${cleanPath}`;
                        };

                        const url = formatPaymentProofUrl(paymentProof);
                        const escapedUrl = url
                            .replace(/'/g, "\\'")
                            .replace(/"/g, "&quot;");

                        return `
                                        <div style="margin-top:12px;">
                                            <div style="font-size:13px; font-weight:600; color:#374151; margin-bottom:8px;">GCash Payment Proof</div>
                                            <div style="position:relative; width:200px; height:200px; border:2px solid #e5e7eb; border-radius:8px; overflow:hidden; cursor:pointer; transition:transform 0.2s ease; background:#f5f5f5;" 
                                                 onclick="event.preventDefault(); event.stopPropagation(); if(window.staffManager && typeof window.staffManager.showEnlargedImage === 'function') { window.staffManager.showEnlargedImage('${escapedUrl}', 'GCash Payment Proof'); }"
                                                 onmouseenter="this.style.transform='scale(1.05)';"
                                                 onmouseleave="this.style.transform='scale(1)';"
                                                 title="Click to view full size">
                                                <img src="${url}" 
                                                     alt="GCash Payment Proof" 
                                                     style="width:100%; height:100%; object-fit:cover; display:block;"
                                                     onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                                                     loading="lazy" />
                                                <div style="display:none; width:100%; height:100%; align-items:center; justify-content:center; background:#ffebee; color:#c62828; font-size:11px; text-align:center; padding:4px;">
                                                    <div>
                                                        <i class="fas fa-exclamation-triangle" style="display:block; margin-bottom:4px; font-size:16px;"></i>
                                                        <span>Failed to load</span>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    `;
                    }
                    return "";
                })()}
                        </div>
                    </div>
                `
                : ""
            }
                    
                    <!-- Failed Details Group -->
                ${order.status === "failed" ||
                String(order.status || "").toLowerCase() === "delivery_failed"
                ? `
                    <div style="margin-bottom:20px; padding:12px; background:#ffffff; border:1px solid #e5e7eb; border-radius:6px;">
                        <div style="font-size:13px; font-weight:600; color:#374151; margin-bottom:8px; display:flex; align-items:center; justify-content:center; gap:6px;">
                            <i class="fas fa-exclamation-triangle" style="color:#d32f2f; font-size:12px;"></i>
                            Failed Delivery Details
                        </div>
                        <div style="display:flex; flex-direction:column; gap:8px;">
                            <div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid #e5e7eb;"><span style="color:#6b7280; font-size:13px;">Reasons of Failed Delivery</span><span style="color:#111827; font-weight:500; font-size:13px;">${order.failureReason || "No reason provided"
                }</span></div>
                            <div style="display:flex; justify-content:space-between; padding:6px 0;"><span style="color:#6b7280; font-size:13px;">Rider Name</span><span style="color:#111827; font-weight:500; font-size:13px;">${order.failureRiderName ||
                order.failedByName ||
                order.failed_by_name ||
                "Unknown"
                }</span></div>
                        </div>
                    </div>
                `
                : ""
            }
                </div>
                `
                : `
                <!-- Non-confirmed orders - Original Layout -->
                <p><strong>Customer:</strong> ${order.customerName}</p>
                <p><strong>Contact:</strong> ${order.customerPhone}</p>
                ${this.buildAddressSection(order)}
                <p><strong>Payment Method:</strong> ${order.paymentMethod || "N/A"
                }</p>
                <p><strong>Total Amount:</strong> â‚±${totalDisplay}</p>
                <p><strong>Order Date:</strong> ${new Date(
                    order.createdAt
                ).toLocaleString()}</p>
                ${(() => {
                    // Only show Confirmed Date for GCash orders that got confirmed
                    // COD orders are already confirmed upon placement, so this field doesn't apply
                    // COD orders paid through GCash (has payment_proof) should also not show this field
                    const paymentMethod = String(order.paymentMethod || order.payment_method || "cash").toLowerCase();
                    const isGcash = paymentMethod === "gcash";
                    const hasPaymentProof = !!(order.payment_proof || order.paymentProof);
                    // Show only for original GCash orders (not COD orders, not COD paid through GCash)
                    const isOriginalGcashOrder = isGcash && !hasPaymentProof;
                    return isOriginalGcashOrder ? `<p><strong>Confirmed Date:</strong> ${confirmedDate}</p>` : "";
                })()}
                `
            }
                
                ${String(order.status || "").toLowerCase() === "pending" &&
                order.cancellationRequested === true
                ? `
                <div class="cancel-requested-banner">
                  <strong>Cancellation and refund requested</strong>
                </div>
                `
                : ""
            }
                ${
            // Only show customer's GCash Receipt for original GCash orders (not COD orders paid through GCash)
            // If payment_proof exists, it means rider uploaded it (COD paid through GCash), so don't show customer receipt
            String(order.paymentMethod || "").toLowerCase() === "gcash" &&
                order.gcashReceiptUrl &&
                !order.payment_proof &&
                !order.paymentProof
                ? `
                <!-- GCash Receipt Card -->
                <div style="background:#ffffff; border:2px solid #e0e7ff; border-radius:12px; padding:16px; margin:16px 0; box-shadow:0 2px 8px rgba(0,0,0,0.08);">
                  <div style="display:flex; align-items:center; gap:10px; margin-bottom:12px; padding-bottom:12px; border-bottom:2px solid #e0e7ff;">
                    <i class="fas fa-receipt" style="font-size:20px; color:#4CAF50;"></i>
                    <h3 style="margin:0; font-size:16px; font-weight:600; color:#333;">GCash Receipt (Payment Proof)</h3>
                  </div>
                  ${(() => {
                    const rawUrl = order.gcashReceiptUrl || "";
                    const url = this.getGcashReceiptUrl(rawUrl);
                    if (!url) {
                        return `
                        <div style="border:2px dashed #ddd; border-radius:8px; padding:20px; background:#fafafa; display:flex; align-items:center; justify-content:center; gap:10px; min-height:100px;">
                          <i class="fas fa-receipt" style="color:#9e9e9e; font-size:24px;"></i>
                          <span style="color:#777; font-size:14px;">Receipt pending upload</span>
                        </div>`;
                    }
                    // Supabase URL from gcash_receipt bucket
                    const escapedUrl = url
                        .replace(/'/g, "\\'")
                        .replace(/"/g, "&quot;");
                    return `
                      <div style="display:flex; justify-content:center; align-items:center; padding:12px; background:#f9fafb; border-radius:8px; border:1px solid #e5e7eb;">
                        <div style="max-width:100%; max-height:400px; overflow:auto; border-radius:6px; background:#fff; padding:8px; box-shadow:0 2px 4px rgba(0,0,0,0.1);">
                          <img src="${url}" alt="GCash Receipt" 
                               style="max-width:100%; height:auto; max-height:380px; object-fit:contain; border-radius:4px; cursor:pointer; transition:transform 0.2s ease, box-shadow 0.2s ease; display:block; margin:0 auto;" 
                               onclick="event.preventDefault(); event.stopPropagation(); if(window.staffManager && typeof window.staffManager.showEnlargedImage === 'function') { window.staffManager.showEnlargedImage('${escapedUrl}', 'GCash Receipt'); }" 
                               onerror="this.style.display='none'; this.nextElementSibling.style.display='block';" 
                               onmouseenter="this.style.transform='scale(1.02)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)';"
                               onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='none';"
                               title="Click to view full size" 
                               loading="lazy" />
                          <div style="display:none; padding:16px; background:#ffebee; border:1px solid #ffcdd2; border-radius:6px; color:#c62828; text-align:center;">
                            <i class="fas fa-exclamation-triangle" style="margin-bottom:8px; display:block; font-size:20px;"></i>
                            <div>Failed to load image.</div>
                            <a href="${url}" target="_blank" rel="noopener" style="color:#c62828; text-decoration:underline; margin-top:8px; display:inline-block;">Click here to open receipt</a>
                          </div>
                        </div>
                      </div>`;
                })()}
                </div>
                `
                : ""
            }
                ${String(order.status || "").toLowerCase() === "confirmed" &&
                order.cancellationRequested === true &&
                String(order.paymentMethod || "").toLowerCase() === "gcash" &&
                !order.cancellationConfirmed &&
                !order.refundConfirmedAt
                ? `
                <!-- GCash Refund Management Container -->
                <div style="margin-top:16px; padding:16px; background:#fff9e6; border:2px solid #ffc107; border-radius:8px; box-shadow:0 2px 4px rgba(0,0,0,0.05);">
                  <div style="display:flex; align-items:center; gap:8px; margin-bottom:12px; padding-bottom:12px; border-bottom:1px solid #ffc107;">
                    <i class="fas fa-money-bill-wave" style="color:#f57c00; font-size:18px;"></i>
                    <strong style="color:#e65100; font-size:15px;">GCash Refund Management</strong>
                  </div>
                  
                  <!-- Customer Cancellation Reason -->
                  ${order.cancellationReason
                    ? `
                  <div style="margin-bottom:16px; padding:12px; background:#fff3e0; border:1px solid #ffb74d; border-radius:6px;">
                    <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                      <i class="fas fa-info-circle" style="color:#f57c00;"></i>
                      <strong style="color:#e65100;">Customer Cancellation Reason:</strong>
                    </div>
                    <div style="color:#bf360c; font-style:italic; line-height:1.4;">
                      "${order.cancellationReason}"
                    </div>
                  </div>
                  `
                    : ""
                }
                  
                  <!-- Refund Receipt Upload Section -->
                  <div style="margin-bottom:16px;">
                    <div style="display:flex; align-items:center; gap:12px; flex-wrap:wrap; margin-bottom:12px;">
                      <input type="file" accept="image/*" id="refund-receipt-${id}" style="display:none" onchange="staffManager.handleRefundReceiptUpload('${id}')" />
                      <button class="secondary-btn" onclick="document.getElementById('refund-receipt-${id}').click()" style="min-width:180px;">
                        <i class="fas fa-upload"></i> Upload Refund Receipt
                      </button>
                    </div>
                    
                    <!-- Uploaded Receipt Preview - Only shows when image is selected or already uploaded -->
                    ${(() => {
                    const rawRefundUrl = order.refundReceiptUrl || "";
                    let refundUrl = null;

                    // Process refund receipt URL
                    if (
                        rawRefundUrl &&
                        !rawRefundUrl.startsWith("pending:")
                    ) {
                        const urlStr = String(rawRefundUrl).trim();
                        const SUPABASE_URL =
                            "https://afkwexvvuxwbpioqnelp.supabase.co";
                        const BUCKET_NAME = "refund_receipt"; // Refund receipts bucket

                        // If it's already a full URL
                        if (
                            urlStr.startsWith("http://") ||
                            urlStr.startsWith("https://")
                        ) {
                            refundUrl = urlStr;
                        } else {
                            // It's a file path, construct Supabase URL
                            let cleanPath = urlStr.replace(/^\/+/, "");
                            // Remove bucket name if present (handle both refund_receipt and gcash_receipt for backward compatibility)
                            while (
                                cleanPath.startsWith("refund_receipt/") ||
                                cleanPath.startsWith("gcash_receipt/")
                            ) {
                                if (cleanPath.startsWith("refund_receipt/")) {
                                    cleanPath = cleanPath
                                        .substring("refund_receipt/".length)
                                        .replace(/^\/+/, "");
                                } else {
                                    cleanPath = cleanPath
                                        .substring("gcash_receipt/".length)
                                        .replace(/^\/+/, "");
                                }
                            }
                            refundUrl = `${SUPABASE_URL}/storage/v1/object/public/${BUCKET_NAME}/${cleanPath}`;
                        }
                    }

                    if (refundUrl) {
                        const escapedRefundUrl = refundUrl
                            .replace(/'/g, "\\'")
                            .replace(/"/g, "&quot;");
                        return `
                          <div id="refund-receipt-preview-${id}" style="margin-top:12px; padding:12px; background:#f8fff8; border:2px solid #4CAF50; border-radius:6px;">
                            <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                              <i class="fas fa-check-circle" style="color:#4CAF50;"></i>
                              <strong style="color:#2e7d32;">Refund Receipt Uploaded</strong>
                            </div>
                            <div style="position:relative; display:inline-block; width:fit-content;">
                              <img src="${refundUrl}" alt="Refund Receipt" style="max-width:260px; width:auto; height:auto; border:1px solid #e0e0e0; border-radius:6px; cursor:pointer; transition:transform 0.2s ease,box-shadow 0.2s ease; display:block;" 
                                   onclick="event.preventDefault(); event.stopPropagation(); if(window.staffManager && typeof window.staffManager.showEnlargedImage === 'function') { window.staffManager.showEnlargedImage('${escapedRefundUrl}', 'Refund Receipt'); }" 
                                   onerror="this.style.display='none';this.nextElementSibling.style.display='block';" 
                                   onmouseenter="this.style.transform='scale(1.02)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)';"
                                   onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)';"
                                   title="Click to view full size" />
                              <button onclick="event.preventDefault(); event.stopPropagation(); if(window.staffManager && typeof window.staffManager.removeRefundReceipt === 'function') { window.staffManager.removeRefundReceipt('${id}'); }" 
                                      style="position:absolute; top:8px; right:8px; background:#f44336; color:white; border:none; border-radius:50%; width:32px; height:32px; display:flex; align-items:center; justify-content:center; cursor:pointer; box-shadow:0 2px 8px rgba(0,0,0,0.3); transition:all 0.2s ease; z-index:10; margin:0; padding:0;" 
                                      onmouseenter="this.style.background='#d32f2f'; this.style.transform='scale(1.1)';" 
                                      onmouseleave="this.style.background='#f44336'; this.style.transform='scale(1)';" 
                                      title="Remove image">
                                <i class="fas fa-times" style="font-size:14px;"></i>
                              </button>
                            </div>
                            <div style="display:none; padding:12px; background:#ffebee; border:1px solid #ffcdd2; border-radius:6px; color:#c62828;">
                              <i class="fas fa-exclamation-triangle"></i> Failed to load image. <a href="${refundUrl}" target="_blank" rel="noopener" style="color:#c62828; text-decoration:underline;">Click here to open receipt</a>
                            </div>
                          </div>
                        `;
                    }
                    return `
                        <div id="refund-receipt-preview-${id}" style="display:none; margin-top:12px; padding:12px; background:#f8fff8; border:2px dashed #4CAF50; border-radius:6px;">
                          <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                            <i class="fas fa-check-circle" style="color:#4CAF50;"></i>
                            <strong style="color:#2e7d32;">Refund Receipt Selected</strong>
                          </div>
                          <div style="position:relative; display:inline-block; width:fit-content;">
                            <img id="refund-receipt-image-${id}" src="" alt="Refund Receipt Preview" style="max-width:260px; width:auto; height:auto; border:1px solid #e0e0e0; border-radius:6px; cursor:pointer; transition:transform 0.2s ease,box-shadow 0.2s ease; display:block;" 
                                 onmouseenter="this.style.transform='scale(1.02)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)';"
                                 onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)';"
                                 title="Refund receipt preview" />
                            <button onclick="event.preventDefault(); event.stopPropagation(); if(window.staffManager && typeof window.staffManager.removeRefundReceipt === 'function') { window.staffManager.removeRefundReceipt('${id}'); }" 
                                    style="position:absolute; top:8px; right:8px; background:#f44336; color:white; border:none; border-radius:50%; width:32px; height:32px; display:flex; align-items:center; justify-content:center; cursor:pointer; box-shadow:0 2px 8px rgba(0,0,0,0.3); transition:all 0.2s ease; z-index:10; margin:0; padding:0;" 
                                    onmouseenter="this.style.background='#d32f2f'; this.style.transform='scale(1.1)';" 
                                    onmouseleave="this.style.background='#f44336'; this.style.transform='scale(1)';" 
                                    title="Remove image">
                              <i class="fas fa-times" style="font-size:14px;"></i>
                            </button>
                          </div>
                        </div>
                      `;
                })()}
                  </div>
                  
                  <!-- Action Buttons Section -->
                  <div style="padding-top:12px; border-top:1px solid #ffc107;">
                    <div style="display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap; margin-bottom:8px;">
                      <button class="confirm-btn" onclick="staffManager.confirmCancelledRefund('${id}')" style="min-width:180px;">
                        <i class="fas fa-check-circle"></i> Confirm Cancel & Refund
                      </button>
                      <button class="danger-btn" onclick="staffManager.confirmCancelledNoRefund('${id}')" style="min-width:180px;">
                        <i class="fas fa-ban"></i> Confirm Cancel (No-refund)
                      </button>
                    </div>
                    <div style="margin-top:8px; padding:8px; background:#fff3e0; border-radius:4px;">
                      <p style="margin:0; color:#bf360c; font-size:0.85rem; line-height:1.4;">
                        <i class="fas fa-info-circle"></i> 
                        Upload the GCash refund receipt before confirming the cancellation. If no payment was received, confirm cancellation without refund and provide a reason.
                      </p>
                    </div>
                  </div>
                </div>
                `
                : ""
            }
                ${String(order.status || "").toLowerCase() === "pending" &&
                order.cancellationRequested === true
                ? `
                <div style="margin-top:12px; padding-top:12px; border-top:1px dashed #eee;">
                  <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
                    <input type="file" accept="image/*" id="refund-receipt-${id}" style="display:none" onchange="staffManager.handleRefundReceiptUpload('${id}')" />
                    <button class="secondary-btn" onclick="document.getElementById('refund-receipt-${id}').click()">
                      <i class="fas fa-upload"></i> Upload Refund Receipt
                    </button>
                    <span id="refund-receipt-name-${id}" style="color:#555; font-size:0.9rem;">No file selected</span>
                    <button class="confirm-btn" onclick="staffManager.confirmCancelledRefund('${id}')">
                      <i class="fas fa-check-circle"></i> Confirm Cancel & Refund
                    </button>
                  </div>
                  <div id="refund-receipt-preview-${id}" style="display:none; margin-top:8px;">
                    <div style="border:2px dashed #4CAF50; border-radius:8px; padding:12px; background:#f8fff8; display:flex; align-items:center; gap:10px;">
                      <i class="fas fa-check-circle" style="color:#4CAF50;"></i>
                      <span style="color:#2e7d32; font-weight:500;">Refund receipt uploaded successfully</span>
                    </div>
                  </div>
                  <div style="margin-top:8px; color:#666; font-size:0.85rem;">
                    Upload the GCash refund receipt before confirming the cancellation.
                  </div>
                </div>
                `
                : ""
            }
                <div class="order-actions">
                    ${String(order.status || "").toLowerCase() === "confirmed" &&
                this.isAfterWeeklyCutoff()
                ? `
                    <button type="button" class="secondary-btn reschedule-btn-cutoff" data-order-id="${id}" data-action="reschedule" style="margin-right:10px; position: relative !important; z-index: 10001 !important; pointer-events: auto !important; cursor: pointer !important; display: inline-block !important; background: white !important; color: #61a029 !important; border: 2px solid #ff9800 !important; padding: 10px 16px !important; border-radius: 8px !important; font-size: 0.9rem !important; font-weight: 600 !important;">
                        <i class="fas fa-calendar-week"></i> Reschedule
                    </button>
                    `
                : ""
            }
                </div>
                
                <!-- Saved QR Codes Display - Always visible -->
                ${["to_receive", "out_for_delivery", "pickup_ready"].includes(
                String(order.status || "").toLowerCase()
            )
                ? `
                <div id="saved-qr-container-${id}" style="background:#ffffff; border:2px solid #f0fdf4; border-radius:12px; padding:16px; margin:16px 0; box-shadow:0 2px 8px rgba(0,0,0,0.08);">
                    <div style="display:flex; align-items:center; gap:10px; margin-bottom:16px; padding-bottom:12px; border-bottom:2px solid #f0fdf4;">
                        <i class="fas fa-qrcode" style="font-size:20px; color:#10b981;"></i>
                        <h3 style="margin:0; font-size:16px; font-weight:600; color:#059669;">Saved QR Codes</h3>
                    </div>
                    <div id="saved-qr-display-${id}" class="saved-qr-section" style="display: block; max-height: 400px; overflow-y: auto; overflow-x: hidden; padding: 8px; pointer-events: auto; min-height:60px;">
                        <div style="text-align: center; padding: 20px; color: #666; font-size: 14px;">
                            <i class="fas fa-spinner fa-spin" style="margin-right:8px;"></i>Loading QR codes...
                        </div>
                    </div>
                    <div style="margin-top:12px; padding-top:12px; border-top:1px solid #e5e7eb; text-align:center;">
                        <button id="qr-generate-btn-footer-${id}" class="secondary-btn qr-generate-btn" data-order-id="${id}" style="font-size: 13px; padding: 10px 20px; position: relative; z-index: 10; pointer-events: auto; cursor: pointer; background:#10b981; color:white; border:none; border-radius:6px; font-weight:600;">
                            <i class="fas fa-plus"></i> Generate QR
                        </button>
                    </div>
                </div>
                `
                : ""
            }
                
                <!-- Rating Details Section (ONLY for delivered/picked_up orders) -->
                ${(() => {
                const statusLower = (order.status || "").toLowerCase();
                const isRated = order.isRated || order.is_rated || false;

                // Only show for delivered or picked_up orders that are rated
                if (
                    (statusLower !== "delivered" &&
                        statusLower !== "picked_up") ||
                    !isRated
                ) {
                    return "";
                }

                const orderRating =
                    order.orderRating || order.order_rating || 0;
                const orderComment =
                    order.orderComment || order.order_comment || "";
                const riderRating =
                    order.riderRating || order.rider_rating || 0;
                const riderComment =
                    order.riderComment || order.rider_comment || "";
                const orderRatedAt =
                    order.orderRatedAt || order.order_rated_at;
                const orderMedia = (() => {
                    try {
                        const media = order.orderMedia || order.order_media;
                        if (!media) return [];
                        return typeof media === "string"
                            ? JSON.parse(media)
                            : media;
                    } catch {
                        return [];
                    }
                })();

                const renderStars = (rating) => {
                    return Array(5)
                        .fill(0)
                        .map((_, i) =>
                            i < rating
                                ? '<i class="fas fa-star" style="color:#FFA500;"></i>'
                                : '<i class="far fa-star" style="color:#D1D5DB;"></i>'
                        )
                        .join("");
                };

                const pickupExperience =
                    order.pickupExperienceComment ||
                    order.pickup_experience_comment ||
                    "";
                const isPickupOrder =
                    (
                        order.deliveryOption ||
                        order.delivery_option ||
                        ""
                    ).toLowerCase() === "pickup";

                return `
                    <div style="margin-top:24px; padding:20px; background:linear-gradient(135deg, #FFF7ED 0%, #FEF3C7 100%); border:2px solid #F59E0B; border-radius:12px; box-shadow:0 4px 12px rgba(245, 158, 11, 0.15);">
                        <!-- Header -->
                        <div style="margin-bottom:20px; padding-bottom:16px; border-bottom:2px solid #F59E0B;">
                            <div style="display:flex; align-items:center; justify-content:space-between; flex-wrap:wrap; gap:12px;">
                                <div style="display:flex; align-items:center; gap:10px;">
                                    <div style="width:40px; height:40px; background:linear-gradient(135deg, #F59E0B, #D97706); border-radius:50%; display:flex; align-items:center; justify-content:center; box-shadow:0 2px 8px rgba(245, 158, 11, 0.3);">
                                        <i class="fas fa-star" style="color:#ffffff; font-size:18px;"></i>
                                    </div>
                                    <div>
                                        <div style="font-size:18px; font-weight:700; color:#92400E; line-height:1.2;">Customer Feedback</div>
                                        <div style="font-size:12px; color:#D97706; margin-top:2px;">
                                            ${orderRatedAt
                        ? `Rated on ${new Date(
                            orderRatedAt
                        ).toLocaleDateString()} at ${new Date(
                            orderRatedAt
                        ).toLocaleTimeString()}`
                        : "Order has been rated"
                    }
                                        </div>
                                    </div>
                                </div>
                                <div style="padding:6px 14px; background:#dcfce7; border:1px solid #16a34a; border-radius:20px; font-size:11px; font-weight:700; color:#15803d; text-transform:uppercase; letter-spacing:0.5px;">
                                    âœ“ Rated
                                </div>
                            </div>
                        </div>
                        
                        <!-- Content Grid -->
                        <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(280px, 1fr)); gap:16px;">
                            <!-- Order Rating Card -->
                            <div style="padding:16px; background:#ffffff; border-radius:10px; box-shadow:0 2px 8px rgba(0,0,0,0.08); border-left:4px solid #059669;">
                                <div style="margin-bottom:12px;">
                                    <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                                        <div style="width:32px; height:32px; background:linear-gradient(135deg, #059669, #047857); border-radius:8px; display:flex; align-items:center; justify-content:center;">
                                            <i class="fas fa-shopping-bag" style="color:#ffffff; font-size:14px;"></i>
                                        </div>
                                        <span style="font-size:15px; font-weight:700; color:#065f46;">Order Rating</span>
                                    </div>
                                    <div style="display:flex; align-items:center; gap:8px; padding:10px; background:#f0fdf4; border-radius:8px;">
                                        <div style="font-size:24px;">${renderStars(
                        orderRating
                    )}</div>
                                        <div style="font-size:20px; font-weight:700; color:#059669;">${orderRating}<span style="font-size:14px; color:#6b7280;">/5</span></div>
                                    </div>
                                </div>
                                ${orderComment
                        ? `
                                    <div style="margin-top:12px;">
                                        <div style="font-size:11px; font-weight:600; color:#6b7280; text-transform:uppercase; letter-spacing:0.5px; margin-bottom:6px;">Comment</div>
                                        <div style="font-size:13px; color:#111827; padding:10px; background:#f9fafb; border-radius:6px; border-left:3px solid #059669; line-height:1.5;">
                                            "${orderComment}"
                                        </div>
                                    </div>
                                `
                        : '<div style="font-size:12px; color:#9ca3af; font-style:italic; margin-top:8px;">No comment provided</div>'
                    }
                            </div>
                            
                            <!-- Rider/Pickup Rating Card -->
                            ${isPickupOrder && pickupExperience
                        ? `
                            <div style="padding:16px; background:#ffffff; border-radius:10px; box-shadow:0 2px 8px rgba(0,0,0,0.08); border-left:4px solid #f97316;">
                                <div style="margin-bottom:12px;">
                                    <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                                        <div style="width:32px; height:32px; background:linear-gradient(135deg, #f97316, #ea580c); border-radius:8px; display:flex; align-items:center; justify-content:center;">
                                            <i class="fas fa-store" style="color:#ffffff; font-size:14px;"></i>
                                        </div>
                                        <span style="font-size:15px; font-weight:700; color:#c2410c;">Pickup Experience</span>
                                    </div>
                                </div>
                                <div style="margin-top:12px;">
                                    <div style="font-size:11px; font-weight:600; color:#6b7280; text-transform:uppercase; letter-spacing:0.5px; margin-bottom:6px;">Comment</div>
                                    <div style="font-size:13px; color:#111827; padding:10px; background:#fff7ed; border-radius:6px; border-left:3px solid #f97316; line-height:1.5;">
                                        "${pickupExperience}"
                                    </div>
                                </div>
                            </div>
                            `
                        : riderRating > 0
                            ? `
                            <div style="padding:16px; background:#ffffff; border-radius:10px; box-shadow:0 2px 8px rgba(0,0,0,0.08); border-left:4px solid #2563eb;">
                                <div style="margin-bottom:12px;">
                                    <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                                        <div style="width:32px; height:32px; background:linear-gradient(135deg, #2563eb, #1d4ed8); border-radius:8px; display:flex; align-items:center; justify-content:center;">
                                            <i class="fas fa-motorcycle" style="color:#ffffff; font-size:14px;"></i>
                                        </div>
                                        <span style="font-size:15px; font-weight:700; color:#1e40af;">Rider Rating</span>
                                    </div>
                                    <div style="display:flex; align-items:center; gap:8px; padding:10px; background:#eff6ff; border-radius:8px;">
                                        <div style="font-size:24px;">${renderStars(
                                riderRating
                            )}</div>
                                        <div style="font-size:20px; font-weight:700; color:#2563eb;">${riderRating}<span style="font-size:14px; color:#6b7280;">/5</span></div>
                                    </div>
                                </div>
                                ${riderComment
                                ? `
                                    <div style="margin-top:12px;">
                                        <div style="font-size:11px; font-weight:600; color:#6b7280; text-transform:uppercase; letter-spacing:0.5px; margin-bottom:6px;">Comment</div>
                                        <div style="font-size:13px; color:#111827; padding:10px; background:#f9fafb; border-radius:6px; border-left:3px solid #2563eb; line-height:1.5;">
                                            "${riderComment}"
                                        </div>
                                    </div>
                                `
                                : '<div style="font-size:12px; color:#9ca3af; font-style:italic; margin-top:8px;">No comment provided</div>'
                            }
                            </div>
                            `
                            : ""
                    }
                        </div>
                        
                        <!-- Media Gallery -->
                        ${orderMedia.length > 0
                        ? `
                            <div style="margin-top:20px; padding:16px; background:#ffffff; border-radius:10px; box-shadow:0 2px 8px rgba(0,0,0,0.08);">
                                <div style="display:flex; align-items:center; gap:8px; margin-bottom:12px;">
                                    <div style="width:28px; height:28px; background:linear-gradient(135deg, #8b5cf6, #7c3aed); border-radius:6px; display:flex; align-items:center; justify-content:center;">
                                        <i class="fas fa-images" style="color:#ffffff; font-size:12px;"></i>
                                    </div>
                                    <span style="font-size:14px; font-weight:700; color:#5b21b6;">Customer Photos & Videos</span>
                                    <span style="font-size:12px; color:#6b7280; background:#f3f4f6; padding:2px 8px; border-radius:12px; font-weight:600;">${orderMedia.length
                        } ${orderMedia.length === 1 ? "file" : "files"
                        }</span>
                                </div>
                                <div style="display:grid; grid-template-columns:repeat(auto-fill, minmax(140px, 1fr)); gap:12px;">
                                    ${orderMedia
                            .map((mediaUrl, idx) => {
                                const isVideo =
                                    mediaUrl
                                        .toLowerCase()
                                        .includes(".mp4") ||
                                    mediaUrl
                                        .toLowerCase()
                                        .includes(".webm") ||
                                    mediaUrl
                                        .toLowerCase()
                                        .includes(".mov");
                                if (isVideo) {
                                    return `
                                            <div style="position:relative; border-radius:8px; overflow:hidden; box-shadow:0 2px 6px rgba(0,0,0,0.1); transition:transform 0.2s;" onmouseenter="this.style.transform='scale(1.02)'" onmouseleave="this.style.transform='scale(1)'">
                                                <video controls style="width:100%; height:140px; object-fit:cover; display:block; background:#000;">
                                                    <source src="${mediaUrl}" type="video/mp4">
                                                </video>
                                                <div style="position:absolute; top:8px; right:8px; background:rgba(0,0,0,0.7); color:white; padding:4px 8px; border-radius:4px; font-size:10px; font-weight:600;">
                                                    <i class="fas fa-video"></i> VIDEO
                                                </div>
                                            </div>
                                            `;
                                }
                                const escapedUrl = mediaUrl
                                    .replace(/'/g, "\\\\'")
                                    .replace(/"/g, "&quot;");
                                return `
                                        <div style="position:relative; border-radius:8px; overflow:hidden; box-shadow:0 2px 6px rgba(0,0,0,0.1); cursor:pointer; transition:transform 0.2s;" 
                                             onclick="event.preventDefault(); event.stopPropagation(); if(window.staffManager && typeof window.staffManager.showEnlargedImage === 'function') { window.staffManager.showEnlargedImage('${escapedUrl}', 'Customer Feedback ${idx + 1
                                    }'); }"
                                             onmouseenter="this.style.transform='scale(1.02)'" 
                                             onmouseleave="this.style.transform='scale(1)'">
                                            <img src="${mediaUrl}" alt="Customer feedback ${idx + 1
                                    }" 
                                                 style="width:100%; height:140px; object-fit:cover; display:block;" 
                                                 onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" />
                                            <div style="display:none; width:100%; height:140px; background:#f3f4f6; align-items:center; justify-content:center; color:#9ca3af;">
                                                <i class="fas fa-image-slash" style="font-size:24px;"></i>
                                            </div>
                                            <div style="position:absolute; top:8px; right:8px; background:rgba(0,0,0,0.7); color:white; padding:4px 8px; border-radius:4px; font-size:10px; font-weight:600;">
                                                <i class="fas fa-image"></i> ${idx + 1
                                    }
                                            </div>
                                        </div>
                                        `;
                            })
                            .join("")}
                                </div>
                            </div>
                        `
                        : ""
                    }
                    </div>
                    `;
            })()}
            </div>
        `;

        // Remove any duplicate Contact Customer buttons outside Customer Information container
        setTimeout(() => {
            // Find Customer Information container by looking for the h5 with "Customer Information" text
            const customerInfoHeaders = Array.from(div.querySelectorAll('h5')).filter(h5 => 
                h5.textContent && h5.textContent.includes('Customer Information')
            );
            if (customerInfoHeaders.length > 0) {
                const customerInfoContainer = customerInfoHeaders[0].closest('div[style*="background"]');
                if (customerInfoContainer) {
                    // Find all Contact Customer buttons in the entire card
                    const allButtons = div.querySelectorAll('button');
                    allButtons.forEach((btn) => {
                        const btnText = btn.textContent || '';
                        const btnOnclick = btn.getAttribute('onclick') || '';
                        // Check if this is a Contact Customer button
                        if ((btnText.includes('Contact Customer') || btnOnclick.includes('openChatWithCustomer')) && 
                            !customerInfoContainer.contains(btn)) {
                            // This Contact Customer button is NOT in Customer Information container - remove it
                            btn.remove();
                        }
                    });
                }
            }
        }, 50);

        // Always load saved QR codes for traceability
        // This ensures QR codes are visible even after page refresh
        setTimeout(() => {
            this.loadSavedQrForOrderCard(id);
        }, 100); // Small delay to ensure DOM is ready

        // Load staff notes after card is created
        setTimeout(() => {
            this.loadStaffNotesIntoCard(id);
        }, 150); // Slightly delayed to ensure DOM is ready

        // Update QR status for To Receive orders
        if (String(order.status || "").toLowerCase() === "to_receive") {
            setTimeout(() => {
                this.updateQrStatus(id, order);
            }, 200); // Small delay to ensure DOM is ready
        }

        // Attach event listeners directly to QR buttons after DOM is created
        setTimeout(() => {
            const qrFooterBtn = div.querySelector(`#qr-generate-btn-footer-${id}`);

            if (qrFooterBtn) {
                // Remove any existing listeners and add fresh one
                const newBtn = qrFooterBtn.cloneNode(true);
                qrFooterBtn.parentNode.replaceChild(newBtn, qrFooterBtn);
                newBtn.addEventListener(
                    "click",
                    function (e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log("QR footer button clicked for order:", id);
                        if (
                            window.staffManager &&
                            typeof window.staffManager.openQrModal === "function"
                        ) {
                            window.staffManager.openQrModal(id);
                        } else {
                            console.error("staffManager.openQrModal not available");
                            alert(
                                "QR modal function not available. Please refresh the page."
                            );
                        }
                    },
                    true
                );
                console.log(
                    "âœ… QR footer button event listener attached for order:",
                    id
                );
            }
        }, 50);

        // Resolve confirmed by name and role if needed (for confirmed and to_receive orders)
        if (
            String(order.status || "").toLowerCase() === "confirmed" ||
            String(order.status || "").toLowerCase() === "to_receive"
        ) {
            const confirmedByNameNode = div.querySelector(`#confirmed-by-${id}`);
            const currentDisplay = confirmedByNameNode
                ? confirmedByNameNode.textContent
                : "";
            // Resolve if we have UID but no name, or if display shows "N/A" or "Loading..."
            if (
                confirmedByNameNode &&
                confirmedByUid &&
                (!confirmedByName ||
                    confirmedByName === "Loading..." ||
                    currentDisplay === "N/A" ||
                    currentDisplay === "Loading...")
            ) {
                (async () => {
                    try {
                        let resolvedName = null;
                        let resolvedRole =
                            order.confirmedByRole || order.confirmed_by_role || "Staff";

                        // Try to get from Supabase staff table
                        if (window.getSupabaseClient) {
                            const supabase = window.getSupabaseClient();
                            if (supabase) {
                                // Check staff table first
                                const { data: staffData, error: staffError } = await supabase
                                    .from("staff")
                                    .select("full_name, fullName, name, email")
                                    .eq("uuid", confirmedByUid)
                                    .limit(1)
                                    .single();

                                if (!staffError && staffData) {
                                    resolvedName =
                                        staffData.full_name ||
                                        staffData.fullName ||
                                        staffData.name ||
                                        null;
                                    resolvedRole =
                                        order.confirmedByRole ||
                                        order.confirmed_by_role ||
                                        "Staff";
                                } else {
                                    // Check admins table
                                    const { data: adminData, error: adminError } = await supabase
                                        .from("admins")
                                        .select("fullname, username, email")
                                        .eq("uuid", confirmedByUid)
                                        .limit(1)
                                        .single();

                                    if (!adminError && adminData) {
                                        resolvedName =
                                            adminData.fullname || adminData.username || null;
                                        resolvedRole =
                                            order.confirmedByRole ||
                                            order.confirmed_by_role ||
                                            "Admin";
                                    }
                                }
                            }
                        }

                        // Fallback to Firebase if Supabase doesn't have it
                        if (!resolvedName && window.dbRefs && window.dbRefs.staff) {
                            const snap = await window.dbRefs.staff
                                .child(confirmedByUid)
                                .once("value");
                            const data = snap.val();
                            if (data) {
                                resolvedName = data.fullName || data.name || null;
                                resolvedRole = "Staff";
                            }
                        }

                        if (!resolvedName && window.dbRefs && window.dbRefs.users) {
                            const snap2 = await window.dbRefs.users
                                .child(confirmedByUid)
                                .once("value");
                            const data2 = snap2.val();
                            if (data2) {
                                resolvedName = data2.fullName || data2.name || null;
                                resolvedRole = "Staff";
                            }
                        }

                        // Update the display with name and role
                        if (resolvedName) {
                            confirmedByNameNode.textContent = `${resolvedName} - (Role: ${resolvedRole})`;
                        } else if (confirmedByName && confirmedByName !== "Loading...") {
                            // Use stored name if available, but try to determine role
                            const role =
                                order.confirmedByRole ||
                                order.confirmed_by_role ||
                                resolvedRole ||
                                "Staff";
                            confirmedByNameNode.textContent = `${confirmedByName} - (Role: ${role})`;
                        } else {
                            confirmedByNameNode.textContent = "Unknown - (Role: Staff)";
                        }
                    } catch (error) {
                        console.warn("Error resolving confirmed by name:", error);
                        // Fallback display - try to use stored name if available
                        if (confirmedByName && confirmedByName !== "Loading...") {
                            const role =
                                order.confirmedByRole ||
                                order.confirmed_by_role ||
                                "Staff";
                            confirmedByNameNode.textContent = `${confirmedByName} - (Role: ${role})`;
                        } else {
                            confirmedByNameNode.textContent = "Unknown - (Role: Staff)";
                        }
                    }
                })();
            } else if (confirmedByNameNode) {
                // If we have the name already, ensure role is displayed
                const currentText = confirmedByNameNode.textContent || "";
                // Only update if it doesn't already have role format
                if (!currentText.includes("(Role:")) {
                    const isAdmin =
                        confirmedByUid &&
                        (confirmedByUid.includes("admin") ||
                            (confirmedByName &&
                                confirmedByName.toLowerCase().includes("admin")) ||
                            (confirmedByName &&
                                confirmedByName.toLowerCase().includes("administrator")));
                    const role = isAdmin ? "Admin" : "Staff";
                    if (
                        confirmedByName &&
                        confirmedByName !== "Loading..." &&
                        confirmedByName !== "N/A"
                    ) {
                        confirmedByNameNode.textContent = `${confirmedByName} - (Role: ${role})`;
                    } else if (confirmedByUid) {
                        // Try to resolve asynchronously
                        (async () => {
                            try {
                                let resolvedName = null;
                                let resolvedRole = "Staff";

                                if (window.getSupabaseClient) {
                                    const supabase = window.getSupabaseClient();
                                    if (supabase) {
                                        const { data: staffData } = await supabase
                                            .from("staff")
                                            .select("full_name, fullName, name")
                                            .eq("uuid", confirmedByUid)
                                            .limit(1)
                                            .single();

                                        if (staffData) {
                                            resolvedName =
                                                staffData.full_name ||
                                                staffData.fullName ||
                                                staffData.name ||
                                                null;
                                            resolvedRole = "Staff";
                                        } else {
                                            const { data: adminData } = await supabase
                                                .from("admins")
                                                .select("fullname, username")
                                                .eq("uuid", confirmedByUid)
                                                .limit(1)
                                                .single();

                                            if (adminData) {
                                                resolvedName =
                                                    adminData.fullname || adminData.username || null;
                                                resolvedRole = "Admin";
                                            }
                                        }
                                    }
                                }

                                if (resolvedName) {
                                    confirmedByNameNode.textContent = `${resolvedName} - (Role: ${resolvedRole})`;
                                }
                            } catch (err) {
                                console.warn("Error in async resolution:", err);
                            }
                        })();
                    }
                }
            }
        }

        // Append div to wrapper before returning
        wrapper.appendChild(div);

        return wrapper;
    }

    // Get appropriate QR action buttons based on order status
    getQrActionButtons(orderId, qr) {
        // Get order status from the order card context
        const orderCard =
            document.querySelector(`[data-order-id="${orderId}"]`) ||
            document
                .querySelector(`#order-details-${orderId}`)
                ?.closest(".order-card");

        if (!orderCard) {
            // Fallback: assume it's a historical order if we can't determine status
            return `<button class="secondary-btn" onclick="staffManager.viewQrDetails('${orderId}')" style="font-size: 11px; padding: 8px 12px; min-width: 80px;"><i class="fas fa-eye"></i> View</button>`;
        }

        // Check if this is a historical order (delivered, picked_up, failed)
        const statusElement = orderCard.querySelector(".order-status");
        const statusText = statusElement
            ? statusElement.textContent.toLowerCase()
            : "";

        if (
            statusText.includes("delivered") ||
            statusText.includes("picked up") ||
            statusText.includes("failed")
        ) {
            // Historical order - show only VIEW button
            return `<button class="secondary-btn" onclick="staffManager.viewQrDetails('${orderId}')" style="font-size: 12px; padding: 10px 16px; min-width: 90px; background: #2196F3; color: white; border: none; border-radius: 4px; font-weight: 600;"><i class="fas fa-eye"></i> View</button>`;
        } else {
            // Active order - show Download, Print buttons (Edit removed - QR details cannot be edited)
            return [
                `<button class="secondary-btn" onclick="staffManager.downloadSavedQr('${orderId}', '${qr.header || "QR"
                }')" style="font-size: 12px; padding: 10px 16px; min-width: 90px; background: #FF9800; color: white; border: none; border-radius: 4px; font-weight: 600;"><i class="fas fa-download"></i> Download Packaging</button>`,
                `<button class="secondary-btn" onclick="staffManager.printSavedQr('${orderId}', '${qr.header || "QR"
                }')" style="font-size: 12px; padding: 10px 16px; min-width: 90px; background: #9C27B0; color: white; border: none; border-radius: 4px; font-weight: 600;"><i class="fas fa-print"></i> Print Packaging</button>`,
            ].join("");
        }
    }

    // View QR details for historical orders
    async viewQrDetails(orderId) {
        try {
            const qr = await this.fetchSupabaseQrRecord(orderId, {
                forceRefresh: true,
            });

            if (!qr) {
                alert("No QR code found for this order.");
                return;
            }

            const createdTxt = qr.createdAt
                ? new Date(qr.createdAt).toLocaleString()
                : "N/A";
            const updatedTxt = qr.updatedAt
                ? new Date(qr.updatedAt).toLocaleString()
                : null;
            const hasBeenUpdated =
                qr.updatedAt && qr.createdAt && qr.updatedAt !== qr.createdAt;

            const container = document.createElement("div");
            container.className = "modal-overlay";
            container.style.cssText =
                "position:fixed;inset:0;background:rgba(0,0,0,0.4);display:flex;align-items:center;justify-content:center;z-index:10000;";

            container.innerHTML = `
                <div class="modal" style="background:#fff;border-radius:12px;max-width:600px;width:100%;box-shadow:0 10px 30px rgba(0,0,0,.15);">
                    <div style="padding:16px 20px;border-bottom:1px solid #eee;display:flex;align-items:center;justify-content:space-between;">
                        <div style="font-weight:700;">QR Code Details - Order ${orderId
                    .substr(-8)
                    .toUpperCase()}</div>
                        <button onclick="this.closest('.modal-overlay').remove()" style="background:none;border:none;font-size:20px;cursor:pointer;">Ã—</button>
                    </div>
                    <div style="padding:16px 20px;max-height:70vh;overflow:auto;">
                        <div style="border: 1px solid #e0e0e0; border-radius: 6px; padding: 16px; background: #f9f9f9;">
                            <div style="margin-bottom: 12px;">
                                <div style="font-size:14px;color:#555;margin-bottom:4px;"><strong>Order Code:</strong> ${orderId
                    .substr(-8)
                    .toUpperCase()}</div>
                                <div style="font-size:14px;color:#555;margin-bottom:4px;"><strong>Generated At:</strong> ${createdTxt}</div>
                                ${hasBeenUpdated
                    ? `<div style="font-size:14px;color:#555;margin-bottom:4px;"><strong>Updated At:</strong> ${updatedTxt}</div>`
                    : ""
                }
                            </div>
                            ${qr.qrImageUrl
                    ? `<div style="margin: 12px 0; text-align: center;"><img src="${qr.qrImageUrl}" alt="QR" style="max-width:300px; max-height:300px; border:1px solid #e0e0e0; border-radius:6px;" onerror="this.style.display='none'" /></div>`
                    : ""
                }
                            ${qr.header
                    ? `<div style="font-weight:600; margin-top:8px; text-align: center; font-size:16px;">${qr.header}</div>`
                    : ""
                }
                            ${qr.notes
                    ? `<div style="font-size: 14px; color: #666; margin-top: 8px; white-space: pre-line; text-align: center; background: #fff; padding: 8px; border-radius: 4px;">${qr.notes}</div>`
                    : ""
                }
                            ${qr.contributions && qr.contributions.length > 0
                    ? `
                                <div style="margin-top: 12px;">
                                    <div style="font-weight:600; margin-bottom:8px; color:#333;">Contributions:</div>
                                    <div style="background: #fff; padding: 8px; border-radius: 4px; font-size: 12px;">
                                        ${qr.contributions
                        .map(
                            (contrib) =>
                                `${contrib.farmerName} - ${contrib.productName} (${contrib.quantity})`
                        )
                        .join("<br>")}
                                    </div>
                                </div>
                            `
                    : ""
                }
                        </div>
                    </div>
                    <div style="padding:12px 20px;border-top:1px solid #eee;display:flex;justify-content:flex-end;gap:8px;">
                        <button class="secondary-btn" onclick="this.closest('.modal-overlay').remove()">Close</button>
                    </div>
                </div>
            `;

            document.body.appendChild(container);
        } catch (error) {
            console.error("Error viewing QR details:", error);
            alert("Failed to load QR details");
        }
    }

    // Check and update QR status for an order card (SUPABASE ONLY - NO FIREBASE)
    async updateQrStatus(orderId, orderData = null) {
        try {
            const qrStatusElement = document.getElementById(`qr-status-${orderId}`);
            if (!qrStatusElement) return;

            // Fetch order data from Supabase if not provided (NO FIREBASE FALLBACK)
            let order = orderData;
            if (!order) {
                try {
                    if (
                        window.OrderSupabaseAdapter &&
                        typeof window.OrderSupabaseAdapter.fetchOrderById === "function"
                    ) {
                        order = await window.OrderSupabaseAdapter.fetchOrderById(orderId);
                        console.log(
                            "âœ… Fetched order from Supabase for QR status:",
                            orderId
                        );
                    } else {
                        console.error("âŒ OrderSupabaseAdapter not available");
                        order = {};
                    }
                } catch (e) {
                    console.error(
                        "âŒ Could not fetch order data from Supabase for QR status:",
                        e
                    );
                    order = {};
                }
            }

            // Only update for to_receive orders
            const orderStatus = order?.status || "";
            if (String(orderStatus).toLowerCase() !== "to_receive") {
                return;
            }

            const qrCode = await this.fetchSupabaseQrRecord(orderId);

            const deliveryOption = String(
                order?.deliveryOption || order?.delivery_option || ""
            ).toLowerCase();
            const isPickup = deliveryOption === "pickup";
            // Check both camelCase and snake_case for rider assignment (Supabase compatibility)
            const hasRider = !!(
                order?.riderId ||
                order?.rider_id ||
                order?.riderName ||
                order?.rider_name
            );

            if (!qrCode) {
                // No QR generated - show "NO QR PACKAGING"
                qrStatusElement.innerHTML = `
                    <i class="fas fa-times-circle" style="color:#f44336; font-size:10px;"></i>
                    <span style="color:#d32f2f; font-size:11px; font-weight:600;">NO QR PACKAGING</span>
                `;
                qrStatusElement.style.background = "#ffebee";
                qrStatusElement.style.border = "1px solid #f44336";
            } else {
                // QR exists - check delivery type and rider assignment
                if (isPickup) {
                    // Pickup order - hide status indicator (QR exists, no rider needed)
                    qrStatusElement.style.display = "none";
                } else {
                    // Delivery order - check if rider assigned
                    if (!hasRider) {
                        // No rider assigned - show "NO ASSIGNED RIDER" in red
                        qrStatusElement.innerHTML = `
                            <i class="fas fa-times-circle" style="color:#f44336; font-size:10px;"></i>
                            <span style="color:#d32f2f; font-size:11px; font-weight:600;">NO ASSIGNED RIDER</span>
                        `;
                        qrStatusElement.style.background = "#ffebee";
                        qrStatusElement.style.border = "1px solid #f44336";
                        qrStatusElement.style.display = "flex";
                    } else {
                        // Rider assigned - hide status indicator completely
                        qrStatusElement.style.display = "none";
                    }
                }
            }
        } catch (error) {
            console.error("Error checking QR status:", error);
            const qrStatusElement = document.getElementById(`qr-status-${orderId}`);
            if (qrStatusElement) {
                qrStatusElement.innerHTML = `
                    <i class="fas fa-exclamation-triangle" style="color:#ff9800; font-size:10px;"></i>
                    <span style="color:#f57c00; font-size:11px;">Error</span>
                `;
                qrStatusElement.style.background = "#fff3e0";
                qrStatusElement.style.border = "1px solid #ff9800";
                qrStatusElement.style.display = "flex";
            }
        }
    }

    // Multiple selection for rejected products
    updateRejectedSelection() {
        const checkboxes = document.querySelectorAll(".rejected-checkbox");
        const selectedCheckboxes = document.querySelectorAll(
            ".rejected-checkbox:checked"
        );
        const bulkDeleteContainer = document.querySelector(
            ".bulk-delete-container"
        );
        const selectedCountElement = document.querySelector(".selected-count");

        if (selectedCheckboxes.length > 0) {
            bulkDeleteContainer.style.display = "block";
            selectedCountElement.textContent = `${selectedCheckboxes.length} rejected products selected`;
        } else {
            bulkDeleteContainer.style.display = "none";
        }
    }

    toggleSelectAllRejectedProducts() {
        const checkboxes = document.querySelectorAll(".rejected-checkbox");
        const selectAllBtn = document.querySelector(".select-all-btn");
        const allChecked = Array.from(checkboxes).every((cb) => cb.checked);

        checkboxes.forEach((checkbox) => {
            checkbox.checked = !allChecked;
        });

        if (!allChecked) {
            selectAllBtn.innerHTML = '<i class="fas fa-square"></i> Deselect All';
        } else {
            selectAllBtn.innerHTML = '<i class="fas fa-check-square"></i> Select All';
        }

        this.updateRejectedSelection();
    }

    async deleteSelectedRejectedProducts() {
        const selectedCheckboxes = document.querySelectorAll(
            ".rejected-checkbox:checked"
        );

        if (selectedCheckboxes.length === 0) {
            alert("Please select at least one rejected product to delete.");
            return;
        }

        const confirmMessage =
            selectedCheckboxes.length === 1
                ? "Are you sure you want to delete this rejected product? This action cannot be undone."
                : `Are you sure you want to delete ${selectedCheckboxes.length} rejected products? This action cannot be undone.`;

        if (!confirm(confirmMessage)) {
            return;
        }

        try {
            const orderIds = Array.from(selectedCheckboxes).map((cb) =>
                cb.getAttribute("data-order-id")
            );

            // Update orders to 'cleared' status
            const updates = {};
            orderIds.forEach((orderId) => {
                updates[`orders/${orderId}/status`] = "cleared";
                updates[`orders/${orderId}/clearedAt`] = FirebaseUtils.getTimestamp();
                updates[`orders/${orderId}/clearedBy`] = "manual-staff";
            });

            await database.ref().update(updates);

            console.log(`Manually cleared ${orderIds.length} rejected products`);

            // Refresh the rejected products display
            this.loadRejectedProducts();

            const successMessage =
                orderIds.length === 1
                    ? "Rejected product has been cleared successfully."
                    : `${orderIds.length} rejected products have been cleared successfully.`;

            alert(successMessage);
        } catch (error) {
            console.error("Error clearing selected rejected products:", error);
            alert("Error clearing rejected products: " + error.message);
        }
    }

    // Toggle order details visibility
    toggleOrderDetails(orderId) {
        const detailsElement = document.getElementById(`order-details-${orderId}`);
        const toggleIcon = document.getElementById(`toggle-icon-${orderId}`);

        if (detailsElement && toggleIcon) {
            const isCollapsed = detailsElement.classList.contains("collapsed");

            if (isCollapsed) {
                // Expand details
                detailsElement.classList.remove("collapsed");
                toggleIcon.classList.remove("fa-chevron-right");
                toggleIcon.classList.add("fa-chevron-down");

                // Load saved QR codes when expanding order details
                // Only load if not already loaded to avoid duplicates
                const qrContainer = document.getElementById(
                    `saved-qr-display-${orderId}`
                );
                if (
                    qrContainer &&
                    (!qrContainer.innerHTML.includes("Saved QR Codes") ||
                        qrContainer.innerHTML.includes("Loading QR codes"))
                ) {
                    this.loadSavedQrForOrderCard(orderId);
                }
            } else {
                // Collapse details
                detailsElement.classList.add("collapsed");
                toggleIcon.classList.remove("fa-chevron-down");
                toggleIcon.classList.add("fa-chevron-right");
            }
        }
    }

    // Toggle order management details visibility
    toggleOrderManagementDetails(orderId) {
        const detailsElement = document.getElementById(`order-details-${orderId}`);
        const toggleIcon = document.getElementById(`toggle-icon-${orderId}`);

        if (detailsElement && toggleIcon) {
            const isCollapsed = detailsElement.classList.contains("collapsed");

            if (isCollapsed) {
                // Expand details
                detailsElement.classList.remove("collapsed");
                toggleIcon.classList.remove("fa-chevron-right");
                toggleIcon.classList.add("fa-chevron-down");
            } else {
                // Collapse details
                detailsElement.classList.add("collapsed");
                toggleIcon.classList.remove("fa-chevron-down");
                toggleIcon.classList.add("fa-chevron-right");
            }
        }
    }
    // Customer Verification Functions
    async loadVerificationData(type) {
        try {
            console.log(`Loading verification data for ${type}...`);

            let pendingVerifications = {};
            let rejectedVerifications = {};

            if (type === "customers") {
                // Read pending from Supabase customers table
                try {
                    // Get pending customers from Supabase
                    pendingVerifications =
                        await CustomerHelpers.getCustomersByVerificationStatus("pending");
                    rejectedVerifications =
                        await CustomerHelpers.getCustomersByVerificationStatus("rejected");
                    Object.values(rejectedVerifications).forEach((entry) => {
                        if (entry) entry.status = "rejected";
                    });
                } catch (error) {
                    console.error("Error loading customer verifications:", error);
                    pendingVerifications = {};
                    rejectedVerifications = {};
                }
            } else {
                // Fallback to legacy verifications table for non-customer types
                const snapshot = await dbRefs.verifications.child(type).once("value");
                const allVerifications = snapshot.val() || {};
                Object.entries(allVerifications).forEach(([id, verification]) => {
                    if (verification.status === "pending")
                        pendingVerifications[id] = verification;
                    if (verification.status === "rejected")
                        rejectedVerifications[id] = verification;
                });
            }

            console.log(`Pending verifications for ${type}:`, pendingVerifications);

            const pendingContainerId = `${type === "customers" ? "customer" : "farmer"
                }Verifications${type === "customers" ? "Management" : ""}`;
            const pendingContainer = document.getElementById(pendingContainerId);
            if (!pendingContainer) {
                console.error(`Container not found: ${pendingContainerId}`);
                return;
            }

            pendingContainer.innerHTML = "";

            if (Object.keys(pendingVerifications).length === 0) {
                pendingContainer.innerHTML =
                    '<p class="no-data">No pending verifications</p>';
                console.log(`No pending verifications found for ${type}`);
            } else {
                console.log(
                    `Found ${Object.keys(pendingVerifications).length
                    } pending verifications for ${type}`
                );
                Object.entries(pendingVerifications).forEach(([id, verification]) => {
                    console.log(`Creating verification item for ${id}:`, verification);
                    const item = this.createVerificationItem(id, verification, type);
                    pendingContainer.appendChild(item);
                });
            }

            // Rejected verifications already populated above

            console.log(`Rejected verifications for ${type}:`, rejectedVerifications);

            const rejectedContainerId = `${type === "customers" ? "customer" : "farmer"
                }Rejected${type === "customers" ? "Management" : ""}`;
            const rejectedContainer = document.getElementById(rejectedContainerId);
            if (!rejectedContainer) {
                console.error(`Container not found: ${rejectedContainerId}`);
                return;
            }

            rejectedContainer.innerHTML = "";

            const rejectedKeys = Object.keys(rejectedVerifications);
            if (rejectedKeys.length === 0) {
                rejectedContainer.innerHTML =
                    '<p class="no-data">No rejected verifications</p>';
                console.log(`No rejected verifications found for ${type}`);
            } else {
                // Controls bar for multi-remove
                const controls = document.createElement("div");
                controls.className = "rejected-controls";
                controls.style.cssText =
                    "display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:15px; padding:12px; background:#f8f9fa; border-radius:8px; border:1px solid #e9ecef;";
                controls.innerHTML = `
                    <div class="select-all-container" style="display:flex; align-items:center; gap:8px;">
                        <label class="modern-checkbox">
                            <input type="checkbox" id="selectAllRejectedStaff" onchange="staffManager.toggleSelectAllRejected()">
                            <span class="checkmark"></span>
                            <span class="checkbox-label">Select All</span>
                        </label>
                    </div>
                    <div class="action-buttons" style="display:flex; gap:8px;">
                        <button class="modern-remove-btn" onclick="staffManager.removeSelectedRejected('${type}')" disabled>
                        <i class="fas fa-trash"></i> Remove Selected
                    </button>
                    </div>
                `;
                rejectedContainer.appendChild(controls);

                // List items with checkboxes
                rejectedKeys.forEach((id) => {
                    const verification = rejectedVerifications[id];
                    const item = this.createRejectedVerificationItem(
                        id,
                        verification,
                        type
                    );
                    rejectedContainer.appendChild(item);
                });
            }
        } catch (error) {
            console.error("Error loading verification data:", error);
        }
    }

    createVerificationItem(id, verification, type) {
        const div = document.createElement("div");
        div.className = "verification-item fade-in";

        // Show only the full name initially
        const fullName = verification.fullName || verification.name || "Unknown";
        const getTs = (v) => {
            if (!v) return null;
            if (typeof v === "number") return v;
            const p = Date.parse(v);
            return isNaN(p) ? null : p;
        };
        const submissionTs =
            getTs(verification.submittedAt) ||
            getTs(verification.registrationDate) ||
            getTs(verification.createdAt) ||
            getTs(verification.submitted_at) ||
            getTs(verification.registeredAt);
        const submissionDate = submissionTs
            ? new Date(submissionTs).toLocaleString()
            : "Unknown";

        div.innerHTML = `
            <div class="verification-info">
                <h4>${fullName}</h4>
                <p><strong>Registration Date:</strong> ${submissionDate}</p>
            </div>
            <div class="verification-actions">
                <button class="approve-btn" onclick="staffManager.approveVerification('${id}', '${type}')">
                    <i class="fas fa-check"></i> Approve
                </button>
                <button class="reject-btn" onclick="staffManager.showRejectModal('${id}', '${type}')">
                    <i class="fas fa-times"></i> Reject
                </button>
                <button class="secondary-btn" onclick="staffManager.viewVerificationDetails('${id}', '${type}')">
                    <i class="fas fa-eye"></i> View Details
                </button>
            </div>
        `;
        // Store searchable text for robust filtering
        try {
            div.setAttribute(
                "data-searchable",
                `${fullName} ${submissionDate}`.toLowerCase()
            );
        } catch (_) { }
        return div;
    }

    createRejectedVerificationItem(id, verification, type) {
        const div = document.createElement("div");
        div.className = "verification-item fade-in";
        div.style.backgroundColor = "#ffebee"; // Light red background for rejected
        div.style.border = "1px solid #ef5350"; // Red border for rejected

        // Show name plus rejection metadata
        const name = verification.fullName || verification.name || "Unknown";
        const registrationDate = verification.submittedAt
            ? new Date(verification.submittedAt).toLocaleDateString()
            : "Unknown";
        const rejectionTimestamp =
            verification.rejectedAt || verification.rejectionDate || null;
        const rejectionDate = rejectionTimestamp
            ? new Date(rejectionTimestamp).toLocaleString()
            : "Not recorded";
        const rejectedByName =
            verification.rejectedByName ||
            verification.rejectedBy ||
            "Unknown reviewer";
        const rejectedByRole = verification.rejectedByRole || "";
        const rejectedByDisplay = rejectedByRole
            ? `${rejectedByName} Â· ${rejectedByRole}`
            : rejectedByName;
        const rejectionReason =
            verification.rejectionReason || "No reason provided";

        // Only admins can delete rejected customer accounts
        const isAdmin = this.isAdmin();
        const selectCheckbox = isAdmin
            ? `
                <label class="modern-checkbox" style="margin-right:10px;">
                    <input type="checkbox" class="reject-select" data-id="${id}" onchange="staffManager.updateRemoveButtonState()">
                    <span class="checkmark"></span>
                    <span class="checkbox-label">Select</span>
                </label>
        `
            : "";
        const removeButton = isAdmin
            ? `
                <button class="reject-btn" onclick="staffManager.removeRejectedVerification('${id}', '${type}')">
                    <i class="fas fa-trash"></i> Remove
                </button>
        `
            : "";

        div.innerHTML = `
            <div class="verification-info">
                <h4>${name}</h4>
                <p><strong>Registration Date:</strong> ${registrationDate}</p>
                <p><strong>Rejection Date:</strong> ${rejectionDate}</p>
                <p><strong>Rejected By:</strong> ${rejectedByDisplay}</p>
                <p><strong>Reason:</strong> <span style="color:#c62828;font-weight:600;">${rejectionReason}</span></p>
            </div>
            <div class="verification-actions">
                ${selectCheckbox}
                <button class="secondary-btn" onclick="staffManager.viewRejectedVerificationDetails('${id}', '${type}')">
                    <i class="fas fa-eye"></i> See Details
                </button>
                ${removeButton}
            </div>
        `;
        try {
            div.setAttribute(
                "data-searchable",
                `${name} ${rejectedByDisplay} ${rejectionReason}`.toLowerCase()
            );
        } catch (_) { }

        return div;
    }

    async approveVerification(id, type) {
        try {
            let verification;
            let verificationRef;

            if (type === "customers") {
                // For customers, read from Supabase customers table
                verification = await CustomerHelpers.getCustomer(id);
                if (!verification) {
                    alert("Verification not found");
                    return;
                }
                verificationRef = null; // Not needed for Supabase
            } else {
                // For other types (farmers), still use verifications table
                verificationRef = dbRefs.verifications.child(type).child(id);
                const snapshot = await verificationRef.once("value");
                verification = snapshot.val();
            }

            if (!verification) {
                alert("Verification not found");
                return;
            }

            // For customers, we'll update verification status in Supabase customers table
            // For other types, we'll update the status

            if (type === "customers") {
                // For customers, update existing customer record to approved status
                // Ensure email is always set - generate default if missing
                let customerEmail = verification.email;
                if (!customerEmail || customerEmail.trim() === "") {
                    // Generate a default email using phone number or username
                    if (
                        verification.phoneNumber &&
                        verification.phoneNumber.trim() !== ""
                    ) {
                        customerEmail = `${verification.phoneNumber}@agricart.local`;
                    } else if (
                        verification.username &&
                        verification.username.trim() !== ""
                    ) {
                        customerEmail = `${verification.username}@agricart.local`;
                    } else {
                        customerEmail = `${id}@agricart.local`;
                    }
                    console.log(
                        `Generated default email for customer ${verification.fullName}: ${customerEmail}`
                    );
                }

                // Update the existing customer record to approved status in Supabase
                const approvalTimestamp = Date.now();
                const staffUid =
                    sessionStorage.getItem("staffUid") ||
                    sessionStorage.getItem("adminUid") ||
                    "staff";
                const staffName =
                    sessionStorage.getItem("staffName") ||
                    sessionStorage.getItem("adminName") ||
                    "Staff";
                const staffRole =
                    sessionStorage.getItem("staffRole") ||
                    (this.isAdmin() ? "Administrator" : "Staff");

                const updateData = {
                    verificationStatus: "approved",
                    accountStatus: "active",
                    status: "active",
                    updatedAt: approvalTimestamp,
                    verificationDate: approvalTimestamp,
                    verifiedBy: staffUid,
                    verifiedByName: staffName,
                    verifiedByRole: staffRole,
                };

                // Update email if it was generated
                if (customerEmail !== verification.email) {
                    updateData.email = customerEmail;
                }

                // Update the customer record in Supabase customers table
                await CustomerHelpers.updateCustomer(id, updateData);

                // Also update the Firebase Auth user's email if it was generated
                if (customerEmail !== verification.email) {
                    try {
                        // Note: This requires admin privileges to update other users' emails
                        // For now, we'll just log this information
                        console.log(
                            `Customer ${verification.fullName} approved with generated email: ${customerEmail}`
                        );
                        console.log(
                            `Note: Firebase Auth email update may require manual intervention`
                        );
                    } catch (authError) {
                        console.warn("Could not update Firebase Auth email:", authError);
                    }
                }

                // Send in-app notification to customer (Supabase)
                await this.sendCustomerNotification(id, {
                    title: "Account Verified!",
                    message:
                        "You have been verified. Please log in your account. Enjoy shopping!",
                    type: "verification",
                });

                // Send approval email via EmailJS (if real email is available)
                if (
                    customerEmail &&
                    !customerEmail.includes("@agricart.local") &&
                    typeof emailjs !== "undefined"
                ) {
                    const approvalDate = new Date(approvalTimestamp).toLocaleDateString(
                        "en-US",
                        {
                            year: "numeric",
                            month: "long",
                            day: "numeric",
                        }
                    );

                    await this.sendApprovalEmail(
                        customerEmail,
                        verification.fullName || verification.name || "Customer",
                        staffName,
                        staffRole,
                        approvalDate
                    );
                }
            } else {
                // For other user types (farmers), update verification status and create user profile
                await verificationRef.update({
                    status: "approved",
                    approvedAt: FirebaseUtils.getTimestamp(),
                    approvedBy: sessionStorage.getItem("staffName") || "Staff",
                });
            }

            // Remove from pending verifications display immediately
            const approveButton = document.querySelector(
                `[onclick="staffManager.approveVerification('${id}', '${type}')"]`
            );
            if (approveButton && approveButton.closest(".verification-item")) {
                approveButton.closest(".verification-item").remove();

                // Check if there are any more pending verifications left
                const remainingItems = document.querySelectorAll(
                    "#customerVerificationsManagement .verification-item"
                );
                if (remainingItems.length === 0) {
                    const container = document.getElementById(
                        "customerVerificationsManagement"
                    );
                    if (container) {
                        container.innerHTML =
                            '<p class="no-data">No pending verifications</p>';
                    }
                }
            }

            this.showSuccessMessage(
                `${type.slice(0, -1)} verification approved successfully`
            );

            // Refresh customer records if currently viewing that tab
            if (this.currentCustomerManagementTab === "approved-customers") {
                console.log("Customer approved, refreshing customer records...");
                setTimeout(() => {
                    this.loadCustomersManagementData();
                }, 500);
            }
        } catch (error) {
            console.error("Error approving verification:", error);
            alert("Error approving verification: " + error.message);
        }
    }
    showRejectModal(id, type) {
        const modalContent = `
            <div class="modal-header">
                <h3>Reject Verification</h3>
                <button class="close-modal">&times;</button>
            </div>
            <form id="rejectForm">
                <div class="form-field full-width">
                    <label for="rejectionReason">Reason for Rejection:</label>
                    <textarea id="rejectionReason" placeholder="Please provide a detailed reason for rejection..." required></textarea>
                </div>
                <div class="modal-actions">
                    <button type="submit" class="reject-btn">
                        <i class="fas fa-times"></i> Reject Verification
                    </button>
                    <button type="button" class="secondary-btn" onclick="staffManager.closeModal()">Cancel</button>
                </div>
            </form>
        `;

        this.showModal(modalContent);

        document
            .getElementById("rejectForm")
            .addEventListener("submit", async (e) => {
                e.preventDefault();
                const reason = document.getElementById("rejectionReason").value.trim();
                if (reason) {
                    await this.rejectVerification(id, type, reason);
                    this.closeModal();
                }
            });
    }
    async rejectVerification(id, type, reason) {
        try {
            let verification;
            let verificationRef;

            if (type === "customers") {
                // For customers, read from Supabase customers table
                verification = await CustomerHelpers.getCustomer(id);
                if (!verification) {
                    alert("Verification not found");
                    return;
                }
                verificationRef = null; // Not needed for Supabase
            } else {
                // For other types (farmers), still use verifications table
                verificationRef = dbRefs.verifications.child(type).child(id);
                const snapshot = await verificationRef.once("value");
                verification = snapshot.val();
            }

            if (!verification) {
                alert("Verification not found");
                return;
            }

            if (type === "customers") {
                // For customers, update to rejected status in Supabase and then delete
                const staffUid =
                    sessionStorage.getItem("staffUid") ||
                    sessionStorage.getItem("adminUid") ||
                    "staff";
                const staffName =
                    sessionStorage.getItem("staffName") ||
                    sessionStorage.getItem("adminName") ||
                    "Staff";
                const staffRole =
                    sessionStorage.getItem("staffRole") ||
                    (this.isAdmin() ? "Administrator" : "Staff");
                const rejectionTimestamp = Date.now();

                // Update the customer record to rejected status in Supabase (retain record for auditing)
                await CustomerHelpers.updateCustomer(id, {
                    verificationStatus: "rejected",
                    accountStatus: "rejected",
                    status: "inactive",
                    rejectionReason: reason,
                    rejectedAt: rejectionTimestamp,
                    rejectedBy: staffUid,
                    rejectedByName: staffName,
                    rejectedByRole: staffRole,
                    updatedAt: rejectionTimestamp,
                });

                // Delete Firebase Auth account to free up email and phone number immediately
                try {
                    console.log(
                        `Attempting to delete Firebase Auth account for rejected customer: ${id}`
                    );
                    // Use Cloud Function to delete Firebase Auth account with admin privileges
                    const deleteUserFunction = firebase
                        .functions()
                        .httpsCallable("deleteUserAccount");
                    const result = await deleteUserFunction({ uid: id });

                    if (result.data.success) {
                        console.log(
                            "âœ“ Firebase Auth account deleted successfully via Cloud Function"
                        );
                    } else {
                        throw new Error(
                            result.data.message || "Failed to delete Firebase Auth account"
                        );
                    }
                    console.log(
                        "Successfully deleted Firebase Auth account for rejected customer"
                    );
                } catch (authError) {
                    console.error(
                        `CRITICAL: Could not delete Firebase Auth account for rejected customer ${id}:`,
                        authError
                    );
                    console.error(
                        "This means the email and phone number will NOT be available for reuse!"
                    );
                    // Continue even if auth deletion fails, but log it as an error
                }

                // Send in-app notification to customer (Supabase)
                await this.sendCustomerNotification(id, {
                    title: "Verification Failed",
                    message: `Verification failed. Reason: ${reason}`,
                    type: "verification",
                });

                // Send rejection email via EmailJS (if real email is available)
                const customerEmail = verification.email;
                if (
                    customerEmail &&
                    !customerEmail.includes("@agricart.local") &&
                    typeof emailjs !== "undefined"
                ) {
                    const rejectionDate = new Date(
                        rejectionTimestamp
                    ).toLocaleDateString("en-US", {
                        year: "numeric",
                        month: "long",
                        day: "numeric",
                    });

                    await this.sendRejectionEmail(
                        customerEmail,
                        verification.fullName || verification.name || "Customer",
                        staffName,
                        staffRole,
                        reason,
                        rejectionDate
                    );
                }
            } else {
                // For other types, update status in verifications table
                await verificationRef.update({
                    status: "rejected",
                    rejectedAt: FirebaseUtils.getTimestamp(),
                    rejectedBy: sessionStorage.getItem("staffUid") || "staff",
                    rejectionReason: reason,
                });
            }

            // Remove from pending verifications display immediately
            const rejectButton = document.querySelector(
                `[onclick="staffManager.showRejectModal('${id}', '${type}')"]`
            );
            if (rejectButton && rejectButton.closest(".verification-item")) {
                rejectButton.closest(".verification-item").remove();

                // Check if there are any more pending verifications left
                const remainingItems = document.querySelectorAll(
                    "#customerVerificationsManagement .verification-item"
                );
                if (remainingItems.length === 0) {
                    const container = document.getElementById(
                        "customerVerificationsManagement"
                    );
                    if (container) {
                        container.innerHTML =
                            '<p class="no-data">No pending verifications</p>';
                    }
                }
            }

            this.showSuccessMessage(`${type.slice(0, -1)} verification rejected`);

            // Refresh data so rejected tab picks up the new record
            if (type === "customers") {
                await this.loadCustomerManagementVerificationData();
            }

            // Pending list item already removed above; rejected tab refresh handled as needed.
        } catch (error) {
            console.error("Error rejecting verification:", error);
            alert("Error rejecting verification: " + error.message);
        }
    }

    async viewVerificationDetails(id, type) {
        try {
            let verification;

            if (type === "customers") {
                // For customers, read from Supabase customers table
                verification = await CustomerHelpers.getCustomer(id);
            } else {
                // For other types (farmers), still use verifications table
                const snapshot = await dbRefs.verifications
                    .child(type)
                    .child(id)
                    .once("value");
                verification = snapshot.val();
            }

            if (!verification) {
                alert("Verification not found");
                return;
            }

            // Use the same viewCustomerDetailsInManagement function for customers
            if (type === "customers") {
                return this.viewCustomerDetailsInManagement(id);
            }

            // Normalize submittedAt with fallbacks (some records store different keys)
            const getTimestamp = (val) => {
                if (!val) return null;
                if (typeof val === "number") return val;
                const parsed = Date.parse(val);
                return isNaN(parsed) ? null : parsed;
            };
            const submittedAtTs =
                getTimestamp(verification.submittedAt) ||
                getTimestamp(verification.registrationDate) ||
                getTimestamp(verification.createdAt) ||
                getTimestamp(verification.submitted_at) ||
                getTimestamp(verification.registeredAt);
            const submittedAtStr = submittedAtTs
                ? new Date(submittedAtTs).toLocaleString()
                : "N/A";

            // Derive structured address fields from combined address when possible
            const rawAddress = (verification.address || "").toString();
            const addressParts = rawAddress
                .split(",")
                .map((p) => p.trim())
                .filter((p) => p.length > 0);
            const sitioPurokStreet = addressParts[0] || "";
            const barangay = addressParts[1] || verification.barangay || "";
            const city = verification.city || addressParts[2] || "Ormoc";
            const province =
                verification.state ||
                verification.province ||
                addressParts[3] ||
                "Leyte";

            const modalContent = `
                <div class="modal-header">
                    <h3>Verification Details</h3>
                    <button class="close-modal">&times;</button>
                </div>
                <div class="farmer-details-view" style="padding-bottom: 0; max-height: none; overflow: visible;">
                    <div class="user-registration-grid" style="row-gap: 6px; column-gap: 12px;">
                        <div class="user-form-left">
                            <div class="form-field">
                                <label>Full Name</label>
                                <p>${verification.fullName ||
                verification.name ||
                "N/A"
                }</p>
                            </div>
                            <div class="form-field">
                                <label>Email</label>
                                <p>${verification.email || "N/A"}</p>
                            </div>
                            ${type === "customers"
                    ? `
                                <div class="form-field">
                                    <label>Age</label>
                                    <p>${verification.age || "Not provided"}</p>
                                </div>
                                <div class="form-field">
                                    <label>Gender</label>
                                    <p>${verification.gender || "Not provided"
                    }</p>
                                </div>
                                ${verification.phone
                        ? `
                                    <div class="form-field">
                                        <label>Phone</label>
                                        <p>${verification.phone}</p>
                                    </div>
                                `
                        : ""
                    }
                            `
                    : `
                                <div class="form-field">
                                    <label>Phone</label>
                                    <p>${verification.phone || "Not provided"
                    }</p>
                                </div>
                                <div class="form-field">
                                    <label>Date of Birth</label>
                                    <p>${verification.dateOfBirth || "Not provided"
                    }</p>
                                </div>
                            `
                }
                            <div class="form-field">
                                <label>Sitio/Purok/Street</label>
                                <p>${sitioPurokStreet || "Not provided"}</p>
                            </div>
                            <div class="form-field">
                                <label>Barangay</label>
                                <p>${barangay || "Not provided"}</p>
                            </div>
                            <div class="form-field">
                                <label>City</label>
                                <p>${city || "Not provided"}</p>
                            </div>
                            <div class="form-field">
                                <label>Province</label>
                                <p>${province || "Not provided"}</p>
                            </div>
                            <div class="form-field">
                                <label>Submitted At</label>
                                <p>${submittedAtStr}</p>
                            </div>
                        </div>
                        <div class="user-form-right">
                            ${type === "customers" &&
                    (verification.idFrontPhoto ||
                        verification.idBackPhoto)
                    ? `
                                <h4>Valid ID Photos</h4>
                                <div class="id-photos-grid">
                                    <div class="id-photo-item">
                                        <label>Front Side</label>
                                        ${verification.idFrontPhoto
                        ? (() => {
                            const SUPABASE_URL =
                                "https://afkwexvvuxwbpioqnelp.supabase.co";
                            const SUPABASE_BUCKET =
                                "customerid_image";
                            let frontUrl =
                                verification.idFrontPhoto
                                    ? verification.idFrontPhoto.trim()
                                    : "";

                            console.log(
                                "ðŸ” Raw front URL from Firebase:",
                                frontUrl
                            );

                            // Check if it's already a full URL
                            if (
                                frontUrl.startsWith(
                                    "http://"
                                ) ||
                                frontUrl.startsWith(
                                    "https://"
                                )
                            ) {
                                // Fix duplicate bucket name if present
                                if (
                                    frontUrl.includes(
                                        `/${SUPABASE_BUCKET}/${SUPABASE_BUCKET}/`
                                    )
                                ) {
                                    frontUrl = frontUrl.replace(
                                        `/${SUPABASE_BUCKET}/${SUPABASE_BUCKET}/`,
                                        `/${SUPABASE_BUCKET}/`
                                    );
                                    console.log(
                                        "ðŸ”§ Fixed duplicate bucket in full URL:",
                                        frontUrl
                                    );
                                }
                                // Clean up double slashes
                                frontUrl = frontUrl.replace(
                                    /([^:]\/)\/+/g,
                                    "$1"
                                );
                            } else if (
                                !frontUrl.startsWith(
                                    "data:image/"
                                )
                            ) {
                                // It's a path, not a full URL
                                console.log(
                                    "ðŸ” Detected path format, constructing URL"
                                );

                                // Remove bucket name from path if it's already there (multiple times if needed)
                                while (
                                    frontUrl.startsWith(
                                        `${SUPABASE_BUCKET}/`
                                    )
                                ) {
                                    frontUrl =
                                        frontUrl.substring(
                                            SUPABASE_BUCKET.length +
                                            1
                                        );
                                    console.log(
                                        "ðŸ”§ Removed bucket prefix, remaining:",
                                        frontUrl
                                    );
                                }

                                // Remove storage/v1/object/public/customerid_image/ if somehow present
                                const storagePrefix =
                                    "storage/v1/object/public/customerid_image/";
                                if (
                                    frontUrl.includes(
                                        storagePrefix
                                    )
                                ) {
                                    frontUrl =
                                        frontUrl.substring(
                                            frontUrl.indexOf(
                                                storagePrefix
                                            ) + storagePrefix.length
                                        );
                                    console.log(
                                        "ðŸ”§ Removed storage prefix, remaining:",
                                        frontUrl
                                    );
                                }

                                if (
                                    frontUrl.includes("/") ||
                                    frontUrl.length < 100
                                ) {
                                    frontUrl = `${SUPABASE_URL}/storage/v1/object/public/${SUPABASE_BUCKET}/${frontUrl}`;
                                    console.log(
                                        "ðŸ”§ Constructed full URL:",
                                        frontUrl
                                    );
                                } else {
                                    frontUrl = `data:image/jpeg;base64,${frontUrl}`;
                                }
                            }

                            const escapedUrl = frontUrl
                                .replace(/'/g, "\\'")
                                .replace(/"/g, "&quot;");
                            console.log(
                                "ðŸ–¼ï¸ Final Front ID Photo URL:",
                                frontUrl
                            );

                            return `<img src="${frontUrl}" alt="ID Front" 
                                                         style="max-width: 100%; max-height: 250px; width: auto; height: auto; border-radius: 8px; display: block; border: 1px solid #e2e8f0; object-fit: contain; background: #f9fafb; cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease;"
                                                         loading="lazy"
                                                         crossorigin="anonymous"
                                                         referrerpolicy="no-referrer"
                                                         onclick="event.preventDefault(); event.stopPropagation(); if(window.staffManager && typeof window.staffManager.showEnlargedImage === 'function') { window.staffManager.showEnlargedImage('${escapedUrl}', 'ID Front Photo'); }"
                                                         onload="console.log('âœ… Front ID photo loaded'); this.style.borderColor = '#4CAF50';"
                                                         onerror="console.error('âŒ Failed to load front ID photo from:', '${escapedUrl}'); this.onerror=null; this.style.display='none';"
                                                         onmouseenter="this.style.transform='scale(1.02)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)';"
                                                         onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='none';"
                                                         title="Click to view full size" />`;
                        })()
                        : '<div class="id-photo-not-uploaded">Not uploaded</div>'
                    }
                                    </div>
                                    <div class="id-photo-item">
                                        <label>Back Side</label>
                                        ${verification.idBackPhoto
                        ? (() => {
                            const SUPABASE_URL =
                                "https://afkwexvvuxwbpioqnelp.supabase.co";
                            const SUPABASE_BUCKET =
                                "customerid_image";
                            let backUrl =
                                verification.idBackPhoto
                                    ? verification.idBackPhoto.trim()
                                    : "";

                            console.log(
                                "ðŸ” Raw back URL from Firebase:",
                                backUrl
                            );

                            // Check if it's already a full URL
                            if (
                                backUrl.startsWith(
                                    "http://"
                                ) ||
                                backUrl.startsWith("https://")
                            ) {
                                // Fix duplicate bucket name if present
                                if (
                                    backUrl.includes(
                                        `/${SUPABASE_BUCKET}/${SUPABASE_BUCKET}/`
                                    )
                                ) {
                                    backUrl = backUrl.replace(
                                        `/${SUPABASE_BUCKET}/${SUPABASE_BUCKET}/`,
                                        `/${SUPABASE_BUCKET}/`
                                    );
                                    console.log(
                                        "ðŸ”§ Fixed duplicate bucket in full URL:",
                                        backUrl
                                    );
                                }
                                // Clean up double slashes
                                backUrl = backUrl.replace(
                                    /([^:]\/)\/+/g,
                                    "$1"
                                );
                            } else if (
                                !backUrl.startsWith(
                                    "data:image/"
                                )
                            ) {
                                // It's a path, not a full URL
                                console.log(
                                    "ðŸ” Detected path format, constructing URL"
                                );

                                // Remove bucket name from path if it's already there (multiple times if needed)
                                while (
                                    backUrl.startsWith(
                                        `${SUPABASE_BUCKET}/`
                                    )
                                ) {
                                    backUrl = backUrl.substring(
                                        SUPABASE_BUCKET.length + 1
                                    );
                                    console.log(
                                        "ðŸ”§ Removed bucket prefix, remaining:",
                                        backUrl
                                    );
                                }

                                // Remove storage/v1/object/public/customerid_image/ if somehow present
                                const storagePrefix =
                                    "storage/v1/object/public/customerid_image/";
                                if (
                                    backUrl.includes(
                                        storagePrefix
                                    )
                                ) {
                                    backUrl = backUrl.substring(
                                        backUrl.indexOf(
                                            storagePrefix
                                        ) + storagePrefix.length
                                    );
                                    console.log(
                                        "ðŸ”§ Removed storage prefix, remaining:",
                                        backUrl
                                    );
                                }

                                if (
                                    backUrl.includes("/") ||
                                    backUrl.length < 100
                                ) {
                                    backUrl = `${SUPABASE_URL}/storage/v1/object/public/${SUPABASE_BUCKET}/${backUrl}`;
                                    console.log(
                                        "ðŸ”§ Constructed full URL:",
                                        backUrl
                                    );
                                } else {
                                    backUrl = `data:image/jpeg;base64,${backUrl}`;
                                }
                            }

                            const escapedUrl = backUrl
                                .replace(/'/g, "\\'")
                                .replace(/"/g, "&quot;");
                            console.log(
                                "ðŸ–¼ï¸ Final Back ID Photo URL:",
                                backUrl
                            );

                            return `<img src="${backUrl}" alt="ID Back" 
                                                         style="max-width: 100%; max-height: 250px; width: auto; height: auto; border-radius: 8px; display: block; border: 1px solid #e2e8f0; object-fit: contain; background: #f9fafb; cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease;"
                                                         loading="lazy"
                                                         crossorigin="anonymous"
                                                         referrerpolicy="no-referrer"
                                                         onclick="event.preventDefault(); event.stopPropagation(); if(window.staffManager && typeof window.staffManager.showEnlargedImage === 'function') { window.staffManager.showEnlargedImage('${escapedUrl}', 'ID Back Photo'); }"
                                                         onload="console.log('âœ… Back ID photo loaded'); this.style.borderColor = '#4CAF50';"
                                                         onerror="console.error('âŒ Failed to load back ID photo from:', '${escapedUrl}'); this.onerror=null; this.style.display='none';"
                                                         onmouseenter="this.style.transform='scale(1.02)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)';"
                                                         onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='none';"
                                                         title="Click to view full size" />`;
                        })()
                        : '<div class="id-photo-not-uploaded">Not uploaded</div>'
                    }
                                    </div>
                                </div>
                            `
                    : ""
                }
                        </div>
                    </div>
                    ${verification.documents
                    ? `
                        <div class="documents-section">
                            <h4>Submitted Documents</h4>
                            <div class="documents-grid">
                                ${Object.entries(verification.documents)
                        .map(
                            ([key, url]) => `
                                    <div class="document-item">
                                        <p>${key
                                    .replace(/([A-Z])/g, " $1")
                                    .toLowerCase()}</p>
                                        <a href="${url}" target="_blank" class="secondary-btn">
                                            <i class="fas fa-external-link-alt"></i> View
                                        </a>
                                    </div>
                                `
                        )
                        .join("")}
                            </div>
                        </div>
                    `
                    : ""
                }
                </div>
            `;

            this.showModal(modalContent);
        } catch (error) {
            console.error("Error loading verification details:", error);
            alert("Error loading verification details: " + error.message);
        }
    }

    async viewRejectedVerificationDetails(id, type) {
        try {
            // For customers, rejected accounts are deleted from Supabase, so try to get from rejected table
            // But since rejected customers are deleted, we should check if it exists in rejected table first
            if (type === "customers") {
                // Try to get from Supabase first (in case it wasn't fully deleted)
                const customer = await CustomerHelpers.getCustomer(id);
                if (customer) {
                    // If found, use the same viewCustomerDetailsInManagement function
                    return this.viewCustomerDetailsInManagement(id);
                }
                // If not found in Supabase, it was deleted - show error
                alert("Rejected customer account has been removed from the system.");
                return;
            }

            const snapshot = await dbRefs.rejected
                .child(type)
                .child(id)
                .once("value");
            const verification = snapshot.val();

            if (!verification) {
                alert("Rejected verification not found");
                return;
            }

            const modalContent = `
                <div class="modal-header">
                    <h3>Rejected Verification Details</h3>
                    <button class="close-modal">&times;</button>
                </div>
                <div class="farmer-details-view">
                    <div class="user-registration-grid">
                        <div class="user-form-left">
                        <div class="form-field">
                                <label>Full Name</label>
                                <p>${verification.fullName ||
                verification.name ||
                "N/A"
                }</p>
                        </div>
                        <div class="form-field">
                                <label>Email</label>
                                <p>${verification.email || "N/A"}</p>
                        </div>
                        ${type === "customers"
                    ? `
                            <div class="form-field">
                                    <label>Age</label>
                                <p>${verification.age || "Not provided"}</p>
                            </div>
                            <div class="form-field">
                                    <label>Gender</label>
                                <p>${verification.gender || "Not provided"}</p>
                            </div>
                                ${verification.phoneNumber || verification.phone
                        ? `
                                <div class="form-field">
                                        <label>Phone</label>
                                        <p>${verification.phoneNumber ||
                        verification.phone
                        }</p>
                                </div>
                            `
                        : ""
                    }
                        `
                    : `
                            <div class="form-field">
                                    <label>Phone</label>
                                <p>${verification.phone || "Not provided"}</p>
                            </div>
                            <div class="form-field">
                                    <label>Date of Birth</label>
                                <p>${verification.dateOfBirth || "Not provided"
                    }</p>
                            </div>
                        `
                }
                        <div class="form-field">
                                <label>Sitio/Purok/Street</label>
                            <p>${(verification.address || "")
                    .toString()
                    .split(",")[0]
                    ?.trim() || "Not provided"
                }</p>
                        </div>
                        <div class="form-field">
                                <label>Barangay</label>
                            <p>${(
                    (verification.address || "")
                        .toString()
                        .split(",")[1] ||
                    verification.barangay ||
                    ""
                ).trim() || "Not provided"
                }</p>
                        </div>
                        <div class="form-field">
                                <label>City</label>
                            <p>${verification.city ||
                (verification.address || "")
                    .toString()
                    .split(",")[2]
                    ?.trim() ||
                "Ormoc"
                }</p>
                        </div>
                            <div class="form-field">
                                <label>Province</label>
                            <p>${verification.state ||
                verification.province ||
                (verification.address || "")
                    .toString()
                    .split(",")[3]
                    ?.trim() ||
                "Leyte"
                }</p>
                        </div>
                        <div class="form-field">
                                <label>Submitted At</label>
                                <p>${verification.submittedAt
                    ? new Date(
                        verification.submittedAt
                    ).toLocaleString()
                    : "N/A"
                }</p>
                        </div>
                        <div class="form-field">
                                <label>Rejected At</label>
                                <p>${verification.rejectedAt
                    ? new Date(
                        verification.rejectedAt
                    ).toLocaleString()
                    : "N/A"
                }</p>
                        </div>
                        <div class="form-field">
                                <label>Rejected By</label>
                            <p>${verification.rejectedBy || "Unknown"}</p>
                        </div>
                        <div class="form-field full-width">
                                <label>Rejection Reason</label>
                                <p style="color: #d32f2f; font-weight: bold;">${verification.rejectionReason || "N/A"
                }</p>
                        </div>
                    </div>
                        <div class="user-form-right">
                    ${type === "customers" &&
                    (verification.idFrontPhoto || verification.idBackPhoto)
                    ? `
                                <h4>Valid ID Photos</h4>
                                <div class="id-photos-grid">
                                <div class="id-photo-item">
                                        <label>Front Side</label>
                                        ${verification.idFrontPhoto
                        ? (() => {
                            const SUPABASE_URL =
                                "https://afkwexvvuxwbpioqnelp.supabase.co";
                            const SUPABASE_BUCKET =
                                "customerid_image";
                            let frontUrl =
                                verification.idFrontPhoto
                                    ? verification.idFrontPhoto.trim()
                                    : "";

                            console.log(
                                "ðŸ” Raw front URL from Firebase (rejected):",
                                frontUrl
                            );

                            // Check if it's already a full URL
                            if (
                                frontUrl.startsWith(
                                    "http://"
                                ) ||
                                frontUrl.startsWith(
                                    "https://"
                                )
                            ) {
                                // Fix duplicate bucket name if present
                                if (
                                    frontUrl.includes(
                                        `/${SUPABASE_BUCKET}/${SUPABASE_BUCKET}/`
                                    )
                                ) {
                                    frontUrl = frontUrl.replace(
                                        `/${SUPABASE_BUCKET}/${SUPABASE_BUCKET}/`,
                                        `/${SUPABASE_BUCKET}/`
                                    );
                                    console.log(
                                        "ðŸ”§ Fixed duplicate bucket in full URL:",
                                        frontUrl
                                    );
                                }
                                // Clean up double slashes
                                frontUrl = frontUrl.replace(
                                    /([^:]\/)\/+/g,
                                    "$1"
                                );
                            } else if (
                                !frontUrl.startsWith(
                                    "data:image/"
                                )
                            ) {
                                // It's a path, not a full URL
                                console.log(
                                    "ðŸ” Detected path format, constructing URL"
                                );

                                // Remove bucket name from path if it's already there (multiple times if needed)
                                while (
                                    frontUrl.startsWith(
                                        `${SUPABASE_BUCKET}/`
                                    )
                                ) {
                                    frontUrl =
                                        frontUrl.substring(
                                            SUPABASE_BUCKET.length +
                                            1
                                        );
                                    console.log(
                                        "ðŸ”§ Removed bucket prefix, remaining:",
                                        frontUrl
                                    );
                                }

                                // Remove storage/v1/object/public/customerid_image/ if somehow present
                                const storagePrefix =
                                    "storage/v1/object/public/customerid_image/";
                                if (
                                    frontUrl.includes(
                                        storagePrefix
                                    )
                                ) {
                                    frontUrl =
                                        frontUrl.substring(
                                            frontUrl.indexOf(
                                                storagePrefix
                                            ) + storagePrefix.length
                                        );
                                    console.log(
                                        "ðŸ”§ Removed storage prefix, remaining:",
                                        frontUrl
                                    );
                                }

                                if (
                                    frontUrl.includes("/") ||
                                    frontUrl.length < 100
                                ) {
                                    frontUrl = `${SUPABASE_URL}/storage/v1/object/public/${SUPABASE_BUCKET}/${frontUrl}`;
                                    console.log(
                                        "ðŸ”§ Constructed full URL:",
                                        frontUrl
                                    );
                                } else {
                                    frontUrl = `data:image/jpeg;base64,${frontUrl}`;
                                }
                            }

                            const escapedUrl = frontUrl
                                .replace(/'/g, "\\'")
                                .replace(/"/g, "&quot;");
                            console.log(
                                "ðŸ–¼ï¸ Final Front ID Photo URL (rejected):",
                                frontUrl
                            );

                            return `<img src="${frontUrl}" alt="ID Front" 
                                                         style="max-width: 100%; max-height: 250px; width: auto; height: auto; border-radius: 8px; display: block; border: 1px solid #e2e8f0; object-fit: contain; background: #f9fafb; cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease;"
                                                         loading="lazy"
                                                         crossorigin="anonymous"
                                                         referrerpolicy="no-referrer"
                                                         onclick="event.preventDefault(); event.stopPropagation(); if(window.staffManager && typeof window.staffManager.showEnlargedImage === 'function') { window.staffManager.showEnlargedImage('${escapedUrl}', 'ID Front Photo'); }"
                                                         onload="console.log('âœ… Front ID photo loaded (rejected)'); this.style.borderColor = '#4CAF50';"
                                                         onerror="console.error('âŒ Failed to load front ID photo from:', '${escapedUrl}'); this.onerror=null; this.style.display='none';"
                                                         onmouseenter="this.style.transform='scale(1.02)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)';"
                                                         onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='none';"
                                                         title="Click to view full size" />`;
                        })()
                        : '<div class="id-photo-not-uploaded">Not uploaded</div>'
                    }
                                </div>
                                <div class="id-photo-item">
                                        <label>Back Side</label>
                                        ${verification.idBackPhoto
                        ? (() => {
                            const SUPABASE_URL =
                                "https://afkwexvvuxwbpioqnelp.supabase.co";
                            const SUPABASE_BUCKET =
                                "customerid_image";
                            let backUrl =
                                verification.idBackPhoto
                                    ? verification.idBackPhoto.trim()
                                    : "";

                            console.log(
                                "ðŸ” Raw back URL from Firebase (rejected):",
                                backUrl
                            );

                            // Check if it's already a full URL
                            if (
                                backUrl.startsWith(
                                    "http://"
                                ) ||
                                backUrl.startsWith("https://")
                            ) {
                                // Fix duplicate bucket name if present
                                if (
                                    backUrl.includes(
                                        `/${SUPABASE_BUCKET}/${SUPABASE_BUCKET}/`
                                    )
                                ) {
                                    backUrl = backUrl.replace(
                                        `/${SUPABASE_BUCKET}/${SUPABASE_BUCKET}/`,
                                        `/${SUPABASE_BUCKET}/`
                                    );
                                    console.log(
                                        "ðŸ”§ Fixed duplicate bucket in full URL:",
                                        backUrl
                                    );
                                }
                                // Clean up double slashes
                                backUrl = backUrl.replace(
                                    /([^:]\/)\/+/g,
                                    "$1"
                                );
                            } else if (
                                !backUrl.startsWith(
                                    "data:image/"
                                )
                            ) {
                                // It's a path, not a full URL
                                console.log(
                                    "ðŸ” Detected path format, constructing URL"
                                );

                                // Remove bucket name from path if it's already there (multiple times if needed)
                                while (
                                    backUrl.startsWith(
                                        `${SUPABASE_BUCKET}/`
                                    )
                                ) {
                                    backUrl = backUrl.substring(
                                        SUPABASE_BUCKET.length + 1
                                    );
                                    console.log(
                                        "ðŸ”§ Removed bucket prefix, remaining:",
                                        backUrl
                                    );
                                }

                                // Remove storage/v1/object/public/customerid_image/ if somehow present
                                const storagePrefix =
                                    "storage/v1/object/public/customerid_image/";
                                if (
                                    backUrl.includes(
                                        storagePrefix
                                    )
                                ) {
                                    backUrl = backUrl.substring(
                                        backUrl.indexOf(
                                            storagePrefix
                                        ) + storagePrefix.length
                                    );
                                    console.log(
                                        "ðŸ”§ Removed storage prefix, remaining:",
                                        backUrl
                                    );
                                }

                                if (
                                    backUrl.includes("/") ||
                                    backUrl.length < 100
                                ) {
                                    backUrl = `${SUPABASE_URL}/storage/v1/object/public/${SUPABASE_BUCKET}/${backUrl}`;
                                    console.log(
                                        "ðŸ”§ Constructed full URL:",
                                        backUrl
                                    );
                                } else {
                                    backUrl = `data:image/jpeg;base64,${backUrl}`;
                                }
                            }

                            const escapedUrl = backUrl
                                .replace(/'/g, "\\'")
                                .replace(/"/g, "&quot;");
                            console.log(
                                "ðŸ–¼ï¸ Final Back ID Photo URL (rejected):",
                                backUrl
                            );

                            return `<img src="${backUrl}" alt="ID Back" 
                                                         style="max-width: 100%; max-height: 250px; width: auto; height: auto; border-radius: 8px; display: block; border: 1px solid #e2e8f0; object-fit: contain; background: #f9fafb; cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease;"
                                                         loading="lazy"
                                                         crossorigin="anonymous"
                                                         referrerpolicy="no-referrer"
                                                         onclick="event.preventDefault(); event.stopPropagation(); if(window.staffManager && typeof window.staffManager.showEnlargedImage === 'function') { window.staffManager.showEnlargedImage('${escapedUrl}', 'ID Back Photo'); }"
                                                         onload="console.log('âœ… Back ID photo loaded (rejected)'); this.style.borderColor = '#4CAF50';"
                                                         onerror="console.error('âŒ Failed to load back ID photo from:', '${escapedUrl}'); this.onerror=null; this.style.display='none';"
                                                         onmouseenter="this.style.transform='scale(1.02)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)';"
                                                         onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='none';"
                                                         title="Click to view full size" />`;
                        })()
                        : '<div class="id-photo-not-uploaded">Not uploaded</div>'
                    }
                                        </div>
                                </div>
                            `
                    : ""
                }
                            </div>
                        </div>
                </div>
            `;

            this.showModal(modalContent);
        } catch (error) {
            console.error("Error loading rejected verification details:", error);
            alert("Error loading rejected verification details: " + error.message);
        }
    }

    async removeRejectedVerification(id, type) {
        try {
            // Only admins can delete rejected customer accounts
            if (!this.isAdmin()) {
                alert("Only administrators can delete rejected customer accounts.");
                return;
            }

            const confirmRemoval = window.confirm(
                "Remove this rejected verification permanently? This cannot be undone."
            );
            if (!confirmRemoval) return;

            // FIXED: Remove from the correct table - rejected table, not verifications table
            await dbRefs.rejected.child(type).child(id).remove();

            // Also remove from users table if exists
            try {
                await dbRefs.users.child(id).remove();
            } catch (error) {
                console.warn("User record not found:", error);
            }

            // Delete Firebase Auth account to free up email and phone number
            try {
                console.log(
                    `Attempting to delete Firebase Auth account for rejected customer: ${id}`
                );

                // Use Cloud Function to delete Firebase Auth account with admin privileges
                const deleteUserFunction = firebase
                    .functions()
                    .httpsCallable("deleteUserAccount");
                const result = await deleteUserFunction({ uid: id });

                if (result.data.success) {
                    console.log(
                        "âœ… Firebase Auth account deleted successfully via Cloud Function"
                    );
                } else {
                    throw new Error(
                        result.data.message || "Failed to delete Firebase Auth account"
                    );
                }
            } catch (authError) {
                console.error(
                    `âŒ CRITICAL: Could not delete Firebase Auth account for rejected customer ${id}:`,
                    authError
                );
                console.error(
                    "This means the email and phone number will NOT be available for reuse!"
                );
            }

            // Remove from UI if present
            const removeBtn = document.querySelector(
                `[onclick="staffManager.removeRejectedVerification('${id}', '${type}')"]`
            );
            if (removeBtn && removeBtn.closest(".verification-item")) {
                removeBtn.closest(".verification-item").remove();
            }

            this.showSuccessMessage(
                "Rejected verification removed successfully. Email and phone number are now available for reuse."
            );
        } catch (error) {
            console.error("Error removing rejected verification:", error);
            alert("Error removing rejected verification: " + error.message);
        }
    }

    removeSelectedRejected(type) {
        try {
            // Only admins can delete rejected customer accounts
            if (!this.isAdmin()) {
                alert("Only administrators can delete rejected customer accounts.");
                return;
            }

            // Try both possible container IDs for staff side
            let container = document.getElementById("customerRejectedManagement");
            if (!container) {
                container = document.getElementById("customerRejected");
            }
            if (!container) {
                console.error("Rejected container not found");
                return;
            }
            const checkboxes = Array.from(
                container.querySelectorAll(".reject-select:checked")
            );
            if (checkboxes.length === 0) {
                alert("Please select at least one rejected record to remove.");
                return;
            }
            const confirmRemoval = window.confirm(
                `Remove ${checkboxes.length} rejected record(s) permanently? This cannot be undone.`
            );
            if (!confirmRemoval) return;

            // FIXED: Remove from the correct table - rejected table, not verifications table
            const removals = checkboxes.map(async (cb) => {
                const customerId = cb.dataset.id;

                // Remove from rejected table
                await dbRefs.rejected.child(type).child(customerId).remove();

                // Also remove from users table if exists
                try {
                    await dbRefs.users.child(customerId).remove();
                } catch (error) {
                    console.warn("User record not found:", error);
                }

                // Delete Firebase Auth account to free up email and phone number
                try {
                    console.log(
                        `Attempting to delete Firebase Auth account for rejected customer: ${customerId}`
                    );

                    // Check if Firebase Functions are available
                    if (!firebase.functions) {
                        throw new Error(
                            "Firebase Functions not initialized. Please check Firebase Functions setup."
                        );
                    }

                    // Use Cloud Function to delete Firebase Auth account with admin privileges
                    const deleteUserFunction = firebase
                        .functions()
                        .httpsCallable("deleteUserAccount");
                    console.log("Calling deleteUserAccount Cloud Function...");

                    const result = await deleteUserFunction({ uid: customerId });
                    console.log("Cloud Function result:", result);

                    if (result.data && result.data.success) {
                        console.log(
                            "âœ… Firebase Auth account deleted successfully via Cloud Function"
                        );
                    } else {
                        throw new Error(
                            result.data?.message || "Failed to delete Firebase Auth account"
                        );
                    }
                } catch (authError) {
                    console.error(
                        `âŒ CRITICAL: Could not delete Firebase Auth account for rejected customer ${customerId}:`,
                        authError
                    );
                    console.error("Error details:", {
                        code: authError.code,
                        message: authError.message,
                        details: authError.details,
                    });
                    console.error(
                        "This means the email and phone number will NOT be available for reuse!"
                    );
                    console.error("Please check:");
                    console.error("1. Firebase Functions are deployed");
                    console.error("2. Firebase Functions are initialized in the client");
                    console.error("3. User has admin/staff privileges");
                }
            });
            Promise.all(removals)
                .then(() => {
                    this.showSuccessMessage(
                        "Selected rejected verifications removed successfully. Email and phone numbers are now available for reuse."
                    );
                    this.loadVerificationData(type);
                })
                .catch((error) => {
                    console.error(
                        "Error removing selected rejected verifications:",
                        error
                    );
                    alert(
                        "Error removing selected rejected verifications: " + error.message
                    );
                });
        } catch (error) {
            console.error("Error in removeSelectedRejected:", error);
            alert("Error removing selected rejected verifications: " + error.message);
        }
    }
    // Toggle select all functionality for staff
    toggleSelectAllRejected() {
        const selectAllCheckbox =
            document.getElementById("selectAllRejectedStaff") ||
            document.getElementById("selectAllRejectedStaffManagement") ||
            document.getElementById("selectAllRejectedStaffRefresh");
        if (!selectAllCheckbox) return;

        const isChecked = selectAllCheckbox.checked;

        // Try both possible container IDs
        let container = document.getElementById("customerRejectedManagement");
        if (!container) {
            container = document.getElementById("customerRejected");
        }
        if (!container) return;

        // Update all individual checkboxes
        const checkboxes = container.querySelectorAll(".reject-select");
        checkboxes.forEach((checkbox) => {
            checkbox.checked = isChecked;
        });

        // Update remove button state
        this.updateRemoveButtonState();
    }

    // Update remove button state based on selected items for staff
    updateRemoveButtonState() {
        // Try both possible container IDs
        let container = document.getElementById("customerRejectedManagement");
        if (!container) {
            container = document.getElementById("customerRejected");
        }
        if (!container) return;

        const checkboxes = container.querySelectorAll(".reject-select:checked");
        const removeButton = container.querySelector(".modern-remove-btn");
        const selectAllCheckbox =
            document.getElementById("selectAllRejectedStaff") ||
            document.getElementById("selectAllRejectedStaffManagement") ||
            document.getElementById("selectAllRejectedStaffRefresh");

        if (removeButton) {
            removeButton.disabled = checkboxes.length === 0;
            if (checkboxes.length > 0) {
                removeButton.style.opacity = "1";
                removeButton.style.cursor = "pointer";
            } else {
                removeButton.style.opacity = "0.5";
                removeButton.style.cursor = "not-allowed";
            }
        }

        // Update select all checkbox state
        if (selectAllCheckbox) {
            const allCheckboxes = container.querySelectorAll(".reject-select");
            if (checkboxes.length === 0) {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
            } else if (checkboxes.length === allCheckboxes.length) {
                selectAllCheckbox.checked = true;
                selectAllCheckbox.indeterminate = false;
            } else {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = true;
            }
        }
    }

    // Load verification data specifically for customer management tabs (exactly like admin side)
    async loadCustomerManagementVerificationData() {
        console.log("ðŸ”„ loadCustomerManagementVerificationData called");
        try {
            // Show loading state for pending verifications
            const pendingManagementContainer = document.getElementById(
                "customerVerificationsManagement"
            );
            if (pendingManagementContainer) {
                pendingManagementContainer.innerHTML =
                    '<p class="loading">Loading pending verifications...</p>';
            } else {
                console.error(
                    "Pending management container not found: customerVerificationsManagement"
                );
            }

            // Show loading state for rejected verifications
            const rejectedManagementContainer = document.getElementById(
                "customerRejectedManagement"
            );
            if (rejectedManagementContainer) {
                rejectedManagementContainer.innerHTML =
                    '<p class="loading">Loading rejected verifications...</p>';
            } else {
                console.error(
                    "âŒ Rejected management container not found: customerRejectedManagement"
                );
            }

            // Note: Real-time listeners are set up separately to avoid infinite loops

            // Load all customers from Supabase and filter for pending ones
            console.log("ðŸ“¡ Fetching all customers from Supabase...");
            const allCustomers = await CustomerHelpers.getAllCustomers();

            // Separate pending and rejected customers for their respective tabs
            const pendingVerifications = {};
            const rejectedVerifications = {};

            Object.entries(allCustomers).forEach(([id, customer]) => {
                if (!customer) return;
                const verificationStatus = (
                    customer.verificationStatus || ""
                ).toLowerCase();

                // Convert customer data to verification format for compatibility
                const baseData = {
                    uid: id,
                    fullName: customer.fullName || "",
                    email: customer.email || "",
                    phoneNumber: customer.phoneNumber || "",
                    address: customer.address || "",
                    city: customer.city || "Ormoc",
                    state: customer.state || "Leyte",
                    zipCode: customer.zipCode || "",
                    age: customer.age || 0,
                    gender: customer.gender || "",
                    username: customer.username || "",
                    idType: customer.idType || "Not specified",
                    idFrontPhoto: customer.idFrontPhoto || customer.profileImageUrl || "",
                    idBackPhoto: customer.idBackPhoto || "",
                    submittedAt:
                        customer.createdAt || customer.registrationDate || Date.now(),
                    createdAt:
                        customer.createdAt || customer.registrationDate || Date.now(),
                };

                if (verificationStatus === "pending") {
                    pendingVerifications[id] = {
                        ...baseData,
                        status: "pending",
                    };
                    return;
                }

                if (verificationStatus === "rejected") {
                    const rejectionTimestampRaw =
                        customer.rejectedAt || customer.updatedAt || Date.now();
                    let rejectionTimestamp = rejectionTimestampRaw;
                    if (typeof rejectionTimestampRaw === "string") {
                        const parsed = Date.parse(rejectionTimestampRaw);
                        rejectionTimestamp = Number.isNaN(parsed) ? Date.now() : parsed;
                    }
                    if (typeof rejectionTimestamp !== "number") {
                        rejectionTimestamp = Date.now();
                    }
                    const rejectedByName =
                        customer.rejectedByName ||
                        customer.rejectedBy ||
                        "Unknown reviewer";
                    const rejectedByRole =
                        customer.rejectedByRole ||
                        customer.accountRole ||
                        (this.isAdmin() ? "Administrator" : "Staff");

                    rejectedVerifications[id] = {
                        ...baseData,
                        status: "rejected",
                        rejectedAt: rejectionTimestamp,
                        rejectionReason: customer.rejectionReason || "No reason provided",
                        rejectedBy: customer.rejectedBy || null,
                        rejectedByName,
                        rejectedByRole,
                        rejectionDateFormatted: new Date(
                            rejectionTimestamp
                        ).toLocaleString(),
                    };
                }
            });

            console.log("ðŸ“¡ Database query results:", {
                totalCustomers: Object.keys(allCustomers).length,
                pendingCount: Object.keys(pendingVerifications).length,
                rejectedCount: Object.keys(rejectedVerifications).length,
                pendingData: pendingVerifications,
                rejectedData: rejectedVerifications,
            });

            if (pendingManagementContainer) {
                pendingManagementContainer.innerHTML = "";

                if (Object.keys(pendingVerifications).length === 0) {
                    console.log(
                        "ðŸ“ No pending verifications found, showing no-data message"
                    );
                    pendingManagementContainer.innerHTML =
                        '<p class="no-data">No pending verifications</p>';
                } else {
                    console.log(
                        `ðŸ“ Found ${Object.keys(pendingVerifications).length
                        } pending verifications, creating items...`
                    );
                    Object.entries(pendingVerifications).forEach(([id, verification]) => {
                        const item = this.createVerificationItem(
                            id,
                            verification,
                            "customers"
                        );
                        pendingManagementContainer.appendChild(item);
                    });

                    // Apply current search query immediately after render
                    const input = document.getElementById("pendingCustomerSearchInput");
                    if (input) {
                        this.searchPendingVerifications(input.value || "");
                    } else {
                        console.warn("âŒ Search input not found!");
                    }
                }
            }

            if (rejectedManagementContainer) {
                rejectedManagementContainer.innerHTML = "";

                const rejectedKeys = Object.keys(rejectedVerifications);
                if (rejectedKeys.length === 0) {
                    rejectedManagementContainer.innerHTML =
                        '<p class="no-data">No rejected verifications</p>';
                } else {
                    // Only show controls bar for admins
                    if (this.isAdmin()) {
                        // Controls bar for multi-remove
                        const controls = document.createElement("div");
                        controls.className = "rejected-controls";
                        controls.style.cssText =
                            "display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:15px; padding:12px; background:#f8f9fa; border-radius:8px; border:1px solid #e9ecef;";
                        controls.innerHTML = `
                            <div class="select-all-container" style="display:flex; align-items:center; gap:8px;">
                                <label class="modern-checkbox">
                                    <input type="checkbox" id="selectAllRejectedStaffManagement" onchange="staffManager.toggleSelectAllRejected()">
                                    <span class="checkmark"></span>
                                    <span class="checkbox-label">Select All</span>
                                </label>
                            </div>
                            <div class="action-buttons" style="display:flex; gap:8px;">
                                <button class="modern-remove-btn" onclick="staffManager.removeSelectedRejected('customers')" disabled>
                                <i class="fas fa-trash"></i> Remove Selected
                            </button>
                            </div>
                        `;
                        rejectedManagementContainer.appendChild(controls);
                    }

                    // List items with checkboxes
                    rejectedKeys.forEach((id) => {
                        const verification = rejectedVerifications[id];
                        const item = this.createRejectedVerificationItem(
                            id,
                            verification,
                            "customers"
                        );
                        rejectedManagementContainer.appendChild(item);
                    });
                }
            }
        } catch (error) {
            console.error(
                "Error loading customer management verification data:",
                error
            );
            console.error("Error stack:", error.stack);
            // Show error to user if there's a container available
            const rejectedContainer = document.getElementById(
                "customerRejectedManagement"
            );
            if (rejectedContainer) {
                rejectedContainer.innerHTML =
                    '<p class="no-data" style="color: #c62828;">Error loading data: ' +
                    error.message +
                    "</p>";
            }
            const pendingContainer = document.getElementById(
                "customerVerificationsManagement"
            );
            if (pendingContainer) {
                pendingContainer.innerHTML =
                    '<p class="no-data" style="color: #c62828;">Error loading data: ' +
                    error.message +
                    "</p>";
            }
        }
    }

    // Note: Real-time listeners are set up in setupListeners() to avoid infinite loops

    // Refresh pending verifications display
    refreshPendingVerifications(pendingVerifications) {
        const pendingManagementContainer = document.getElementById(
            "customerVerificationsManagement"
        );
        if (!pendingManagementContainer) {
            console.warn(
                "âŒ Pending management container not found in refreshPendingVerifications"
            );
            return;
        }

        pendingManagementContainer.innerHTML = "";

        const pendingKeys = Object.keys(pendingVerifications);
        if (pendingKeys.length === 0) {
            console.log(
                "ðŸ“ No pending verifications in refresh - showing no-data message"
            );
            pendingManagementContainer.innerHTML =
                '<p class="no-data">No pending verifications</p>';
        } else {
            // Add verification items directly (search is handled by the top-right search bar)
            pendingKeys.forEach((id) => {
                const verification = pendingVerifications[id];
                const item = this.createVerificationItem(id, verification, "customers");
                pendingManagementContainer.appendChild(item);
            });

            // Apply current search query immediately after render (from top-right search bar)
            const input = document.getElementById("pendingCustomerSearchInput");
            console.log(
                "Pending verifications refreshed, applying search:",
                input ? input.value : "no input found"
            );
            if (input) {
                this.searchPendingVerifications(input.value || "");
            } else {
                console.warn("Pending customer search input not found!");
            }
        }
    }
    // Refresh rejected verifications display
    refreshRejectedVerifications(rejectedVerifications) {
        const rejectedManagementContainer = document.getElementById(
            "customerRejectedManagement"
        );
        if (!rejectedManagementContainer) return;

        rejectedManagementContainer.innerHTML = "";

        const rejectedKeys = Object.keys(rejectedVerifications);
        if (rejectedKeys.length === 0) {
            rejectedManagementContainer.innerHTML =
                '<p class="no-data">No rejected verifications</p>';
        } else {
            // Only show controls bar for admins
            if (this.isAdmin()) {
                // Controls bar for multi-remove
                const controls = document.createElement("div");
                controls.className = "rejected-controls";
                controls.style.cssText =
                    "display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:15px; padding:12px; background:#f8f9fa; border-radius:8px; border:1px solid #e9ecef;";
                controls.innerHTML = `
                    <div class="select-all-container" style="display:flex; align-items:center; gap:8px;">
                        <label class="modern-checkbox">
                            <input type="checkbox" id="selectAllRejectedStaffRefresh" onchange="staffManager.toggleSelectAllRejected()">
                            <span class="checkmark"></span>
                            <span class="checkbox-label">Select All</span>
                        </label>
                    </div>
                    <div class="action-buttons" style="display:flex; gap:8px;">
                        <button class="modern-remove-btn" onclick="staffManager.removeSelectedRejected('customers')" disabled>
                        <i class="fas fa-trash"></i> Remove Selected
                    </button>
                    </div>
                `;
                rejectedManagementContainer.appendChild(controls);
            }

            // Add rejected verification items
            rejectedKeys.forEach((id) => {
                const verification = rejectedVerifications[id];
                const item = this.createRejectedVerificationItem(
                    id,
                    verification,
                    "customers"
                );
                rejectedManagementContainer.appendChild(item);
            });
        }
    }
    async processCustomerRemoval(id, reason) {
        try {
            const confirm = window.confirm(
                "Are you sure you want to permanently remove this customer? This action cannot be undone and will delete their authentication account."
            );
            if (!confirm) return;

            // Get customer data to delete ID photos and store removed account info
            const customerSnapshot = await dbRefs.customers.child(id).once("value");
            const customer = customerSnapshot.val();

            // Store minimal removed account info for login notifications
            if (customer) {
                const removedAccountInfo = {
                    email: customer.email,
                    username: customer.username,
                    removedAt: Date.now(),
                    removedBy: "staff", // or get current staff info
                    reason: reason,
                };

                console.log("=== STAFF REMOVAL DEBUG ===");
                console.log("Customer data:", customer);
                console.log("Removed account info to store:", removedAccountInfo);

                await database.ref(`removed_accounts/${id}`).set(removedAccountInfo);
                console.log("âœ“ Stored removed account info for login notifications");
                console.log("=== END STAFF REMOVAL DEBUG ===");
            } else {
                console.error("Ã¢ÂÅ’ No customer data found for ID:", id);
            }

            // Delete customer data from database
            await dbRefs.customers.child(id).remove();
            await dbRefs.users.child(id).remove();

            // Also remove from verifications if exists
            try {
                await dbRefs.verifications.child("customers").child(id).remove();
            } catch (error) {
                console.warn("No verification record found for customer:", error);
            }

            // Delete Firebase Auth account to free up email and phone number
            console.log("Deleting Firebase Auth account...");
            try {
                // Use Cloud Function to delete Firebase Auth account with admin privileges
                const deleteUserFunction = firebase
                    .functions()
                    .httpsCallable("deleteUserAccount");
                const result = await deleteUserFunction({ uid: id });

                if (result.data.success) {
                    console.log(
                        "âœ“ Firebase Auth account deleted successfully via Cloud Function"
                    );
                } else {
                    throw new Error(
                        result.data.message || "Failed to delete Firebase Auth account"
                    );
                }
                // Success message already logged above
            } catch (authError) {
                console.error(
                    `Ã¢ÂÅ’ CRITICAL: Could not delete Firebase Auth account for ${id}:`,
                    authError
                );
                console.error("Error code:", authError.code);
                console.error("Error message:", authError.message);
                console.error(
                    "This means the email and phone number will NOT be available for reuse!"
                );
                console.error(
                    "The account will need to be cleaned up manually through Firebase Console"
                );
                // Continue even if auth deletion fails - the database records are already deleted
            }

            this.showSuccessMessage(
                "Customer record and authentication account removed successfully. Email and phone number are now available for new registrations."
            );

            // Reset previous customer data to force refresh on next listener update
            this.previousCustomerData = null;

            // If removing from pending/rejected tabs, switch to customer records tab
            if (this.currentCustomerManagementTab !== "approved-customers") {
                console.log("Customer removed, switching to customer records tab");
                this.switchCustomerManagementTab("approved-customers");
                // Force a refresh after switching tabs to ensure updated data is shown
                setTimeout(() => {
                    console.log("Force refreshing customer data after removal");
                    this.loadCustomersManagementData();
                }, 200);
            } else {
                // Refresh customer data if already on customer records tab
                this.loadCustomersManagementData();
            }

            // Refresh stats
            this.loadStats();
        } catch (error) {
            console.error("Error removing customer:", error);
            alert("Error removing customer: " + error.message);
        }
    }

    async sendCustomerNotification(customerId, notification) {
        try {
            // Use Firebase Database for notifications (migrated from Supabase)
            if (!database) {
                console.error("Firebase Database not available for sending notification");
                return;
            }

            // Generate notification ID (use timestamp if not provided)
            const notificationId = notification.id || `notif_${Date.now()}`;

            // Prepare notification data
            const notificationData = {
                id: notificationId,
                title: notification.title || 'Notification',
                message: notification.message || '',
                type: notification.type || 'notification',
                timestamp: notification.timestamp || Date.now(),
                isRead: notification.isRead !== undefined ? notification.isRead : false,
            };

            // Add orderId if present
            if (notification.orderId) {
                notificationData.orderId = notification.orderId;
            }

            // Save notification to Firebase Database
            const notificationRef = database.ref(`notifications/customers/${customerId}/${notificationId}`);
            await notificationRef.set(notificationData);

            console.log(`âœ… Notification sent to customer ${customerId}: ${notificationId}`);
        } catch (error) {
            console.error("Error sending customer notification:", error);
        }
    }

    /**
     * Send approval email to customer using EmailJS
     * Uses CUSTOMER_APPROVAL_REJECTION_TEMPLATE.html (template_0azg7ul)
     */
    async sendApprovalEmail(customerEmail, customerName, staffName, staffRole, approvalDate) {
        try {
            // Skip invalid or generated fallback emails
            if (
                !customerEmail ||
                customerEmail.trim() === "" ||
                customerEmail.includes("@agricart.local")
            ) {
                console.log(
                    "âš ï¸ Skipping approval email - invalid or default email:",
                    customerEmail
                );
                return;
            }

            if (typeof emailjs === "undefined") {
                console.error("âŒ EmailJS is not available on the page.");
                return;
            }

            console.log("ðŸ“§ Sending approval email to:", customerEmail);

            const templateParams = {
                to_email: customerEmail, // Recipient email address (must be configured in EmailJS template)
                user_email: customerEmail, // Alternative field name
                email: customerEmail, // Another alternative
                customer_name: customerName || "Customer",
                staff_name: staffName || "AgriCart Staff",
                staff_role: staffRole || "Staff",
                approval_date: approvalDate || "",
            };

            console.log("ðŸ“¤ EmailJS template params:", templateParams);

            await emailjs.send(
                "service_pd9ccy8",
                "template_0azg7ul", // Approval template ID
                templateParams
            );

            console.log("âœ… Approval email sent successfully to:", customerEmail);
        } catch (error) {
            console.error("âŒ Failed to send approval email:", error);
            // Do not throw - email failure should not block approval
        }
    }

    /**
     * Send rejection email to customer using EmailJS
     * Uses rejection template (template_9wamzsp)
     */
    async sendRejectionEmail(
        customerEmail,
        customerName,
        staffName,
        staffRole,
        rejectionReason,
        rejectionDate
    ) {
        try {
            // Skip invalid or generated fallback emails
            if (
                !customerEmail ||
                customerEmail.trim() === "" ||
                customerEmail.includes("@agricart.local")
            ) {
                console.log(
                    "âš ï¸ Skipping rejection email - invalid or default email:",
                    customerEmail
                );
                return;
            }

            if (typeof emailjs === "undefined") {
                console.error("âŒ EmailJS is not available on the page.");
                return;
            }

            console.log("ðŸ“§ Sending rejection email to:", customerEmail);

            const templateParams = {
                to_email: customerEmail, // Recipient email address (must be configured in EmailJS template)
                user_email: customerEmail, // Alternative field name
                email: customerEmail, // Another alternative
                customer_name: customerName || "Customer",
                staff_name: staffName || "AgriCart Staff",
                staff_role: staffRole || "Staff",
                rejection_reason:
                    rejectionReason ||
                    "Your AgriCart account verification was not approved.",
                rejection_date: rejectionDate || "",
            };

            console.log("ðŸ“¤ EmailJS template params:", templateParams);

            await emailjs.send(
                "service_pd9ccy8",
                "template_9wamzsp", // Rejection template ID
                templateParams
            );

            console.log("âœ… Rejection email sent successfully to:", customerEmail);
        } catch (error) {
            console.error("âŒ Failed to send rejection email:", error);
            // Do not throw - email failure should not block rejection
        }
    }

    // Simple customer loading function
    async loadCustomersSimple() {
        console.log("Loading customers with simple method...");

        const container = document.getElementById("customerList");
        if (!container) {
            console.error("Customer list container not found");
            return;
        }

        container.innerHTML = '<p class="loading">Loading customers...</p>';

        try {
            // Get Firebase database reference directly
            const database = firebase.database();
            const customersRef = database.ref("customers");

            console.log("Fetching customers from Firebase...");
            const snapshot = await customersRef.once("value");
            const customers = snapshot.val() || {};

            console.log("Raw customers data:", customers);
            console.log("Number of customers:", Object.keys(customers).length);

            // Clear container
            container.innerHTML = "";

            if (Object.keys(customers).length === 0) {
                container.innerHTML =
                    '<p class="no-data">No customers found in database</p>';
                return;
            }

            // Display all customers (for now, regardless of verification status)
            let customerCount = 0;
            for (const [customerId, customer] of Object.entries(customers)) {
                if (customer && customer.fullName) {
                    customerCount++;

                    const customerDiv = document.createElement("div");
                    customerDiv.className = "user-item";
                    customerDiv.innerHTML = `
                        <div class="user-info">
                            <div class="user-avatar">
                                <i class="fas fa-user"></i>
                            </div>
                            <div class="user-details">
                                <h4>${customer.fullName || "Unknown"}</h4>
                                <p>Email: ${customer.email || "No email"}</p>
                                <p>Phone: ${customer.phoneNumber || "No phone"
                        }</p>
                                <p>Status: ${customer.verificationStatus || "Unknown"
                        }</p>
                            </div>
                        </div>
                        <div class="user-actions">
                            <button class="action-btn" onclick="alert('Customer ID: ${customerId}')">
                                <i class="fas fa-eye"></i>
                            </button>
                        </div>
                    `;
                    container.appendChild(customerDiv);
                }
            }

            if (customerCount === 0) {
                container.innerHTML = '<p class="no-data">No valid customers found</p>';
            } else {
                console.log(`Displayed ${customerCount} customers`);
            }
        } catch (error) {
            console.error("Error loading customers:", error);
            container.innerHTML =
                '<p class="no-data">Error loading customers: ' + error.message + "</p>";
        }
    }

    async loadCustomersManagementData() {
        console.log("ðŸ”„ loadCustomersManagementData called");
        try {
            const container = document.getElementById("customerList");
            if (!container) {
                console.error("âŒ Customer list container not found");
                return;
            }

            console.log("âœ… Customer list container found, showing loading state...");
            // Show loading state
            container.innerHTML = '<p class="loading">Loading customers...</p>';

            // Clear existing polling interval if any
            if (this.customersPollInterval) {
                clearInterval(this.customersPollInterval);
            }

            // Load customers from Supabase
            const loadCustomers = async () => {
                try {
                    console.log("Loading customers from Supabase...");
                    const customers = await CustomerHelpers.getAllCustomers();
                    console.log("Customers data received:", customers);
                    await this.updateCustomersList(customers);
                } catch (error) {
                    console.error("Error loading customers from Supabase:", error);
                    const container = document.getElementById("customerList");
                    if (container) {
                        container.innerHTML =
                            '<p class="no-data">Error loading customers data. Please refresh the page.</p>';
                    }
                }
            };

            // Load immediately
            await loadCustomers();

            // Set up polling every 30 seconds for real-time updates
            this.customersPollInterval = setInterval(loadCustomers, 30000);
        } catch (error) {
            console.error("Error loading customers data:", error);
            const container = document.getElementById("customerList");
            if (container) {
                container.innerHTML =
                    '<p class="no-data">Unable to load customers data. Please refresh the page.</p>';
            }
        }
    }

    async updateCustomersList(customers) {
        const container = document.getElementById("customerList");
        if (!container) return;

        console.log("Updating customers list with:", customers);
        container.innerHTML = "";

        // Filter only approved customers for user management (regardless of account status)
        const approvedCustomers = Object.entries(customers).filter(
            ([id, customer]) => {
                return customer && customer.verificationStatus === "approved";
            }
        );

        console.log("Approved customers:", approvedCustomers);

        if (approvedCustomers.length === 0) {
            const noDataDiv = document.createElement("div");
            noDataDiv.innerHTML =
                '<p class="no-data">No approved customers found</p>';
            container.appendChild(noDataDiv);
            return;
        }

        approvedCustomers.forEach(([id, customer]) => {
            const item = this.createCustomerManagementItem(id, customer);
            container.appendChild(item);
        });
    }

    createCustomerManagementItem(id, customer) {
        const div = document.createElement("div");
        const accountStatus = customer.accountStatus || customer.status || "active";
        const isActive = accountStatus === "active";

        // Format approval date
        const approvalDate =
            customer.verificationDate || customer.approvedAt || customer.createdAt;
        const approvalDateStr = approvalDate
            ? new Date(approvalDate).toLocaleString()
            : "N/A";

        // Add visual indicator for deactivated customers
        div.className = `staff-member fade-in ${!isActive ? "deactivated-customer" : ""
            }`;
        div.setAttribute(
            "data-searchable",
            `${customer.fullName} ${customer.email || ""} ${customer.phoneNumber || ""
                }`.toLowerCase()
        );

        div.innerHTML = `
            <div class="staff-info">
                <h4>${customer.fullName}</h4>
                <p><small>Email: ${customer.email || "N/A"}</small></p>
                <p><small>Phone: ${customer.phoneNumber || "N/A"}</small></p>
                <p><small>Approved: ${approvalDateStr}</small></p>
                <span class="status-badge ${isActive ? "status-active" : "status-inactive"
            }">
                    ${isActive ? "Active" : "Deactivated"}
                </span>
            </div>
            <div class="staff-actions">
                <button class="edit-btn" onclick="staffManager.toggleCustomerStatus('${id}', '${accountStatus}')">
                    <i class="fas fa-${isActive ? "ban" : "check"}"></i> 
                    ${isActive ? "Deactivate" : "Activate"}
                </button>
                <button class="secondary-btn" onclick="staffManager.viewCustomerDetailsInManagement('${id}')">
                    <i class="fas fa-eye"></i> View Details
                </button>
                <button class="reject-btn" onclick="staffManager.removeCustomerFromManagement('${id}')">
                    <i class="fas fa-trash"></i> Remove
                </button>
            </div>
        `;

        return div;
    }

    // Get active orders for a customer (pending, confirmed, to_receive, out_for_delivery, pickup_ready)
    async getActiveOrdersForCustomer(customerId) {
        try {
            if (!window.OrderSupabaseAdapter) {
                return [];
            }
            const allOrders = await OrderSupabaseAdapter.fetchOrders();
            if (!allOrders) {
                return [];
            }

            const activeStatuses = [
                "pending",
                "confirmed",
                "to_receive",
                "out_for_delivery",
                "pickup_ready",
            ];

            const activeOrders = [];
            Object.values(allOrders).forEach((order) => {
                if (!order) return;

                const orderCustomerId =
                    order.customerId ||
                    order.customer_id ||
                    order.customerUid ||
                    order.customer_uid;
                if (orderCustomerId !== customerId) return;

                const status = String(order.status || "").toLowerCase();
                if (activeStatuses.includes(status)) {
                    activeOrders.push(order);
                }
            });

            return activeOrders;
        } catch (error) {
            console.error("Error fetching active orders:", error);
            return [];
        }
    }

    // Show active orders modal (for deactivate/remove) with clickable previews and GCash refund button
    async showActiveOrdersModal(customerId, actionType) {
        return new Promise(async (resolve) => {
            try {
                const activeOrders = await this.getActiveOrdersForCustomer(customerId);
                const actionText =
                    actionType === "remove" ? "Remove Customer" : "Deactivate Customer";

                // Track refunded orders in this session
                const refundedOrders = new Set();

                let ordersHTML = "";
                if (activeOrders.length === 0) {
                    ordersHTML = `
            <div style="text-align: center; padding: 40px; color: #666;">
              <i class="fas fa-check-circle" style="font-size: 48px; color: #4caf50; margin-bottom: 16px;"></i>
              <p style="font-size: 16px; margin: 0;">No active orders found. You can proceed with ${actionText.toLowerCase()}.</p>
            </div>
          `;
                } else {
                    ordersHTML = `
            <div style="max-height: 400px; overflow-y: auto; margin-bottom: 20px;">
              ${activeOrders
                            .map((order) => {
                                const orderId = order.id || order.uid;
                                const paymentMethod = String(
                                    order.paymentMethod || order.payment_method || ""
                                ).toLowerCase();
                                const isGCash = paymentMethod === "gcash";
                                const status = String(order.status || "").toLowerCase();
                                const total = order.total || order.total_amount || 0;
                                const orderDate = order.orderDate
                                    ? new Date(order.orderDate).toLocaleString()
                                    : "N/A";

                                return `
                    <div id="order-preview-${orderId}" style="border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px; margin-bottom: 12px; background: #f8fafc; cursor: pointer; transition: all 0.2s;" 
                         onmouseover="this.style.borderColor='#4caf50'; this.style.boxShadow='0 2px 8px rgba(76,175,80,0.2)';" 
                         onmouseout="this.style.borderColor='#e2e8f0'; this.style.boxShadow='none';"
                         onclick="staffManager.viewOrderDetails('${orderId}')">
                      <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
                        <div style="flex: 1;">
                          <div style="font-weight: 600; color: #333; margin-bottom: 4px;">Order #${orderId.substring(orderId.length - 8).toUpperCase()}</div>
                          <div style="font-size: 12px; color: #666;">Status: ${status.toUpperCase()}</div>
                          <div style="font-size: 12px; color: #666;">Date: ${orderDate}</div>
                        </div>
                        <div style="display: flex; gap: 8px; align-items: center;">
                          <span style="padding: 4px 12px; border-radius: 12px; font-size: 11px; font-weight: 600; text-transform: uppercase; 
                            background: ${isGCash ? "#e3f2fd" : "#fff3e0"}; 
                            color: ${isGCash ? "#1976d2" : "#f57c00"};">
                            ${isGCash ? "GCASH" : "CASH"}
                          </span>
                          <span style="font-weight: 600; color: #333;">â‚±${Number(total || 0).toLocaleString()}</span>
                        </div>
                      </div>
                      ${isGCash
                                        ? `
                        <div id="refund-section-${orderId}" style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e2e8f0;">
                          ${refundedOrders.has(orderId)
                                            ? `
                            <div style="display: flex; align-items: center; gap: 8px; color: #4caf50;">
                              <i class="fas fa-check-circle"></i>
                              <span style="font-size: 12px; font-weight: 500;">Refund processed</span>
                            </div>
                          `
                                            : `
                            <button id="refund-btn-${orderId}" 
                                    onclick="event.stopPropagation(); staffManager.showRefundModalForDeactivation('${orderId}', '${customerId}');"
                                    style="background: #4caf50; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 500;">
                              <i class="fas fa-undo"></i> Refund
                            </button>
                          `
                                        }
                        </div>
                      `
                                        : ""
                                    }
                    </div>
                  `;
                            })
                            .join("")}
            </div>
          `;
                }

                const modal = document.createElement("div");
                modal.className = "modal-overlay show";
                modal.id = "active-orders-modal-" + customerId;
                modal.style.cssText = `
          position: fixed !important;
          top: 0 !important;
          left: 0 !important;
          width: 100% !important;
          height: 100% !important;
          background: rgba(0,0,0,0.5) !important;
          display: flex !important;
          justify-content: center !important;
          align-items: center !important;
          z-index: 99999 !important;
        `;

                modal.innerHTML = `
          <div style="background: white; border-radius: 8px; padding: 24px; max-width: 700px; width: 90%; box-shadow: 0 4px 20px rgba(0,0,0,0.15); z-index: 100000; position: relative; max-height: 90vh; overflow-y: auto;">
            <div style="text-align: center; margin-bottom: 20px;">
              <i class="fas fa-exclamation-triangle" style="font-size: 48px; color: #ff9800; margin-bottom: 12px;"></i>
              <h3 style="margin: 0 0 8px 0; color: #333;">Active Orders Detected</h3>
              <p style="margin: 0; color: #666; line-height: 1.4;">
                This customer has ${activeOrders.length} active order(s). Please review and process refunds for GCash orders before proceeding.
              </p>
            </div>
            
            ${ordersHTML}
            
            <div style="display: flex; gap: 12px; justify-content: center; margin-top: 24px; padding-top: 20px; border-top: 1px solid #e2e8f0;">
              <button id="cancel-btn-${customerId}" 
                      style="background: #6c757d; color: white; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer; font-weight: 500;">
                <i class="fas fa-times"></i> Cancel
              </button>
              <button id="proceed-btn-${customerId}" 
                      style="background: #f44336; color: white; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer; font-weight: 500;">
                <i class="fas fa-check"></i> Proceed
              </button>
            </div>
          </div>
        `;

                document.body.appendChild(modal);

                // Event listeners
                const cancelBtn = document.getElementById(`cancel-btn-${customerId}`);
                const proceedBtn = document.getElementById(`proceed-btn-${customerId}`);

                cancelBtn.addEventListener("click", () => {
                    modal.remove();
                    resolve(false);
                });

                proceedBtn.addEventListener("click", async () => {
                    const confirmed = window.confirm(
                        actionType === "remove"
                            ? "Are you sure you want to permanently remove this customer account? This action cannot be undone."
                            : "Are you sure you want to deactivate this customer account? This action cannot be undone."
                    );
                    if (!confirmed) {
                        return;
                    }

                    modal.remove();
                    resolve(true);
                });

                // Close on backdrop click
                modal.addEventListener("click", (e) => {
                    if (e.target === modal) {
                        cancelBtn.click();
                    }
                });
            } catch (error) {
                console.error("Error showing active orders modal:", error);
                alert("Error loading active orders: " + error.message);
                resolve(false);
            }
        });
    }

    // Show refund modal for deactivation context (reuses existing refund modal)
    async showRefundModalForDeactivation(orderId, customerId) {
        if (typeof this.showRefundModal === "function") {
            window._deactivationRefundCustomerId = customerId;
            this.showRefundModal(orderId);
        }
    }

    // View order details modal (restored)
    async viewOrderDetails(id) {
        try {
            if (!window.OrderSupabaseAdapter) {
                alert("Order system not available");
                return;
            }

            const order = await OrderSupabaseAdapter.fetchOrderById(id);
            if (!order) {
                alert("Order not found");
                return;
            }

            const modal = document.createElement("div");
            modal.className = "modal-overlay show";
            modal.style.cssText = `
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
        background: rgba(0,0,0,0.5) !important;
        display: flex !important;
        justify-content: center !important;
        align-items: center !important;
        z-index: 99999 !important;
      `;

            const paymentMethod = String(order.paymentMethod || order.payment_method || "").toLowerCase();
            const isGCash = paymentMethod === "gcash";
            const status = String(order.status || "").toLowerCase();
            const total = order.total || order.total_amount || 0;
            const orderDate = order.orderDate || order.createdAt || order.created_at;
            const customerName = order.customerName || order.customer_name || "N/A";
            const customerPhone = order.customerPhone || order.customer_phone || "N/A";
            const customerAddress = order.customerAddress || order.customer_address || "N/A";
            const items = order.items || [];

            modal.innerHTML = `
        <div style="background: white; border-radius: 8px; padding: 24px; max-width: 800px; width: 90%; box-shadow: 0 4px 20px rgba(0,0,0,0.15); z-index: 100000; position: relative; max-height: 90vh; overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #e2e8f0; padding-bottom: 16px;">
            <h3 style="margin: 0; color: #333;">Order Details</h3>
            <button id="close-order-details-btn" style="background: none; border: none; font-size: 24px; color: #666; cursor: pointer; padding: 0; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center;">&times;</button>
          </div>
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
            <div style="background: #f8fafc; padding: 16px; border-radius: 8px; border: 1px solid #e2e8f0;">
              <h4 style="margin: 0 0 12px 0; font-size: 14px; font-weight: 600; color: #666; text-transform: uppercase;">Order Information</h4>
              <div style="display: flex; flex-direction: column; gap: 8px;">
                <div><strong>Order ID:</strong> ${id.substring(id.length - 8).toUpperCase()}</div>
                <div><strong>Status:</strong> <span style="text-transform: uppercase;">${status}</span></div>
                <div><strong>Payment Method:</strong> <span style="padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; text-transform: uppercase; background: ${isGCash ? "#e3f2fd" : "#fff3e0"}; color: ${isGCash ? "#1976d2" : "#f57c00"};">${isGCash ? "GCASH" : "CASH"}</span></div>
                <div><strong>Order Date:</strong> ${orderDate ? new Date(orderDate).toLocaleString() : "N/A"}</div>
              </div>
            </div>
            
            <div style="background: #f8fafc; padding: 16px; border-radius: 8px; border: 1px solid #e2e8f0;">
              <h4 style="margin: 0 0 12px 0; font-size: 14px; font-weight: 600; color: #666; text-transform: uppercase;">Customer Information</h4>
              <div style="display: flex; flex-direction: column; gap: 8px;">
                <div><strong>Name:</strong> ${customerName}</div>
                <div><strong>Phone:</strong> ${customerPhone}</div>
                <div><strong>Address:</strong> ${customerAddress}</div>
              </div>
            </div>
          </div>

          <div style="margin-bottom: 20px;">
            <h4 style="margin: 0 0 12px 0; font-size: 14px; font-weight: 600; color: #666; text-transform: uppercase;">Order Items</h4>
            <div style="background: #f8fafc; padding: 16px; border-radius: 8px; border: 1px solid #e2e8f0;">
              ${items.length > 0
                    ? `
                    <div style="display:table; width:100%; border-collapse:collapse;">
                        <div style="display:table-row; border-bottom:1px solid #e2e8f0; font-weight:600; color:#666; font-size:13px;">
                            <div style="display:table-cell; padding:10px; border-right:1px solid #e2e8f0;">Product</div>
                            <div style="display:table-cell; padding:10px; border-right:1px solid #e2e8f0; text-align:center;">Kilo Ã— Price</div>
                            <div style="display:table-cell; padding:10px; text-align:right;">Total</div>
                        </div>
                        ${items
                        .map((item) => {
                            const itemName = item.name || item.productName || "Unknown";
                            const itemQty = item.quantity || item.qty || 0;
                            const itemUnit = item.unit || "";
                            const itemPrice = item.price || item.unitPrice || 0;
                            const itemTotal = itemQty * itemPrice;
                            return `
                            <div style="display:table-row; border-bottom:1px solid #e2e8f0;">
                                <div style="display:table-cell; padding:10px; border-right:1px solid #e2e8f0; font-weight:600; color:#333; font-size:14px;">${itemName}</div>
                                <div style="display:table-cell; padding:10px; border-right:1px solid #e2e8f0; text-align:center; color:#666; font-size:13px;">${itemQty} ${itemUnit} Ã— â‚±${Number(itemPrice || 0).toLocaleString()}</div>
                                <div style="display:table-cell; padding:10px; text-align:right; font-weight:600; color:#059669; font-size:15px;">â‚±${Number(itemTotal || 0).toLocaleString()}</div>
                            </div>
                        `;
                        })
                        .join("")}
                    </div>
                    `
                    : "<div style='color: #666;'>No items found</div>"
                }
            </div>
          </div>

          <div style="background: #f8fafc; padding: 16px; border-radius: 8px; border: 1px solid #e2e8f0;">
            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #e2e8f0;">
              <strong>Subtotal:</strong>
              <strong>â‚±${Number(order.subtotal || order.subtotal_amount || 0).toLocaleString()}</strong>
            </div>
            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #e2e8f0;">
              <strong>Delivery Fee:</strong>
              <strong>â‚±${Number(order.deliveryFee || order.delivery_fee || 0).toLocaleString()}</strong>
            </div>
            <div style="display: flex; justify-content: space-between; padding: 8px 0;">
              <strong style="font-size: 18px;">Total:</strong>
              <strong style="font-size: 18px; color: #059669;">â‚±${Number(total || 0).toLocaleString()}</strong>
            </div>
          </div>

          ${(() => {
            const rawNotes = order.order_notes || order.orderNotes || order.deliveryNotes || order.delivery_notes || "";
            const filteredNotes = this.filterCustomerNotes(rawNotes);
            return filteredNotes ? `
          <div style="margin-top: 20px; padding: 16px; background: #fff7ed; border-left: 4px solid #f59e0b; border-radius: 8px;">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
              <i class="fas fa-sticky-note" style="color: #f59e0b; font-size: 16px;"></i>
              <h4 style="margin: 0; font-size: 14px; font-weight: 700; color: #9a3412;">${((order.deliveryOption || "").toLowerCase() === "pickup") ? "Order/Pickup Notes" : "Order/Delivery Notes"}</h4>
            </div>
            <div style="background: #ffffff; padding: 12px; border-radius: 6px; border: 1px solid #fed7aa;">
              <div style="color: #92400e; font-size: 13px; line-height: 1.5; font-style: italic;">
                "${filteredNotes}"
              </div>
            </div>
          </div>
          ` : "";
          })()}

          <div style="margin-top: 20px; text-align: center;">
            <button id="close-order-details-btn-bottom" style="background: #6c757d; color: white; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer; font-weight: 500;">
              Close
            </button>
          </div>
        </div>
      `;

            document.body.appendChild(modal);

            const closeHandler = () => {
                modal.remove();
            };

            const closeBtnTop = document.getElementById("close-order-details-btn");
            const closeBtnBottom = document.getElementById("close-order-details-btn-bottom");
            if (closeBtnTop) closeBtnTop.addEventListener("click", closeHandler);
            if (closeBtnBottom) closeBtnBottom.addEventListener("click", closeHandler);

            modal.addEventListener("click", (e) => {
                if (e.target === modal) {
                    closeHandler();
                }
            });
        } catch (error) {
            console.error("Error viewing order details:", error);
            alert("Error loading order details: " + error.message);
        }
    }

    // Reject active orders and restore stock when customer is deactivated/removed
    async rejectActiveOrdersForCustomer(customerId, indicatorText) {
        try {
            const activeOrders = await this.getActiveOrdersForCustomer(customerId);

            if (activeOrders.length === 0) {
                console.log(`No active orders found for customer ${customerId}`);
                return;
            }

            const supabase = OrderSupabaseAdapter.getSupabaseClient
                ? window.getSupabaseClient?.() ||
                OrderSupabaseAdapter.getSupabaseClient()
                : null;
            if (!supabase) {
                throw new Error("Supabase client not available");
            }

            const nowMs = Date.now();
            const rejectedById = this.userUid || this.getUserUid() || "system";
            const rejectedByName =
                this.userName || this.getUserName() || "Administrator";
            const userRole = sessionStorage.getItem("userRole");
            const rejectedByRole =
                userRole === "admin"
                    ? "Administrator"
                    : userRole === "staff"
                        ? "Staff"
                        : "Staff";

            // Process each active order
            for (const order of activeOrders) {
                const orderId = order.id || order.uid;
                try {
                    const orderStatus = String(order.status || "").toLowerCase();

                    // Restore stock based on order status (same logic as normal rejectOrder)
                    if (orderStatus === "pending") {
                        // Pending orders: release reserved quantities (restores available_quantity AND decreases current_reserved)
                        if (typeof this.releaseReservedQuantities === "function") {
                            await this.releaseReservedQuantities(order);
                            console.log(`âœ… Released reserved quantities for pending order ${orderId}`);
                        }
                    } else if (orderStatus === "confirmed") {
                        // Confirmed orders: restore product quantities (restores available_quantity only)
                        // Note: confirmed orders should have already released reserved stock during confirmation
                        if (typeof this.restoreProductQuantities === "function") {
                            await this.restoreProductQuantities(order);
                            console.log(`âœ… Restored product quantities for confirmed order ${orderId}`);
                        }
                    } else if (orderStatus === "to_receive" || orderStatus === "pickup_ready" || orderStatus === "out_for_delivery") {
                        // Do NOT restore stock for these statuses - orders are already in fulfillment pipeline
                        console.log(`â­ï¸ Skipping stock restoration for ${orderStatus} order ${orderId} - order is already in fulfillment pipeline`);
                    }

                    // Reject the order
                    const supabaseUpdate = {
                        status: "rejected",
                        rejection_reason: indicatorText,
                        rejected_at: nowMs,
                        rejected_by: rejectedById,
                        rejected_by_name: rejectedByName,
                        rejected_by_role: rejectedByRole,
                        updated_at: nowMs,
                        updated_by: rejectedById,
                        updated_by_name: rejectedByName,
                        updated_by_role: rejectedByRole,
                    };

                    const identifier = order.id || order.orderId || order.order_id || orderId;
                    const { error } = await supabase
                        .from("orders")
                        .update(supabaseUpdate)
                        .match({ id: identifier });

                    if (error) {
                        console.error(`âŒ Error rejecting order ${orderId}:`, error);
                        throw error;
                    }

                    console.log(`âœ… Order ${orderId} rejected with indicator: ${indicatorText}`);

                    // Sync order status to Firebase Database for push notifications
                    try {
                        if (window.OrderSupabaseAdapter && typeof window.OrderSupabaseAdapter.syncOrderStatusToFirebase === 'function') {
                            await window.OrderSupabaseAdapter.syncOrderStatusToFirebase(identifier, "rejected", { ...order, ...supabaseUpdate, customer_id: order.customerId || order.customer_id });
                        }
                    } catch (syncError) {
                        console.warn("âš ï¸ Failed to sync rejected order status to Firebase:", syncError);
                    }

                } catch (err) {
                    console.error(`âŒ Error processing order ${orderId}:`, err);
                    // Continue with other orders even if one fails
                }
            }

            // Also add indicator to all other orders (delivered, picked_up, failed, cancelled) without changing status
            if (window.OrderSupabaseAdapter) {
                const allOrders = await OrderSupabaseAdapter.fetchOrders();
                if (allOrders) {
                    const otherStatuses = ["delivered", "picked_up", "failed", "delivery_failed", "failed_pickup", "cancelled"];
                    for (const order of Object.values(allOrders)) {
                        if (!order) continue;

                        const orderCustomerId =
                            order.customerId ||
                            order.customer_id ||
                            order.customerUid ||
                            order.customer_uid;
                        if (orderCustomerId !== customerId) continue;

                        const status = String(order.status || "").toLowerCase();
                        if (otherStatuses.includes(status)) {
                            const orderId = order.id || order.uid;
                            try {
                                // Add indicator without changing status
                                const currentRejectionReason = order.rejectionReason || order.rejection_reason || "";
                                const newRejectionReason = currentRejectionReason
                                    ? `${currentRejectionReason} | ${indicatorText}`
                                    : indicatorText;

                                await OrderSupabaseAdapter.updateOrder(orderId, {
                                    rejectionReason: newRejectionReason,
                                    updatedAt: nowMs,
                                });
                                console.log(`âœ… Added indicator to order ${orderId}: ${indicatorText}`);
                            } catch (err) {
                                console.error(`âŒ Error adding indicator to order ${orderId}:`, err);
                            }
                        }
                    }
                }
            }
        } catch (error) {
            console.error("Error rejecting active orders and adding indicators:", error);
            throw error;
        }
    }

    async toggleCustomerStatus(id, currentStatus) {
        try {
            const newStatus = currentStatus === "active" ? "inactive" : "active";

            // If deactivating, reject active orders and restore stock
            if (newStatus === "inactive") {
                const activeOrders = await this.getActiveOrdersForCustomer(id);
                let proceed = false;
                if (activeOrders.length > 0) {
                    // Modal already handles confirmation, so proceed directly if user confirmed
                    proceed = await this.showActiveOrdersModal(id, "deactivate");
                    if (!proceed) return;
                } else {
                    // No active orders - show confirmation dialog
                    const confirm = window.confirm(`Are you sure you want to deactivate this customer account? This action cannot be undone.`);
                    if (!confirm) return;
                    proceed = true;
                }

                // Reject active orders and restore stock (only if there were active orders)
                if (activeOrders.length > 0) {
                    await this.rejectActiveOrdersForCustomer(id, "Account Deactivated");
                }
            } else {
                // Activating - simple confirmation
                const confirm = window.confirm(
                    `Are you sure you want to activate this customer?`
                );
                if (!confirm) return;
            }

            // Update customer in Supabase
            await CustomerHelpers.updateCustomer(id, {
                accountStatus: newStatus,
                updatedAt: Date.now(),
            });

            this.showSuccessMessage(
                `Customer ${newStatus === "active" ? "activated" : "deactivated"
                } successfully`
            );

            // Reload customers list and refresh orders
            await this.loadCustomersManagementData();
            if (window.OrderSupabaseAdapter && typeof window.OrderSupabaseAdapter.refresh === "function") {
                await window.OrderSupabaseAdapter.refresh();
            }
            if (this.loadRejectedOrders) {
                await this.loadRejectedOrders();
            }
            if (this.loadProducts) {
                await this.loadProducts();
            }
        } catch (error) {
            console.error("Error updating customer status:", error);
            alert("Error updating customer status: " + error.message);
        }
    }

    async viewCustomerDetailsInManagement(id) {
        try {
            const customer = await CustomerHelpers.getCustomer(id);

            if (!customer) {
                alert("Customer not found");
                return;
            }

            // Calculate Total Orders and Total Spent (matching customer app logic)
            // Included: pending (GCash), confirmed, to_receive, out_for_delivery, pickup_ready, delivered, picked_up, failed (GCash only)
            // Excluded: rejected, cancelled (cash and gcash), failed (cash)
            let totalOrdersCount = 0;
            let totalSpentAmount = 0;

            try {
                // Fetch all orders for this customer
                if (window.OrderSupabaseAdapter) {
                    const allOrders = await OrderSupabaseAdapter.fetchOrders();
                    if (allOrders) {
                        Object.values(allOrders).forEach((order) => {
                            if (!order) return;

                            // Check if order belongs to this customer
                            const orderCustomerId =
                                order.customerId ||
                                order.customer_id ||
                                order.customerUid ||
                                order.customer_uid;
                            if (orderCustomerId !== id) return;

                            // Get order status and payment method
                            const status = String(order.status || "").toLowerCase();
                            const paymentMethod = String(
                                order.paymentMethod || order.payment_method || ""
                            ).toLowerCase();

                            // First, check for excluded statuses
                            // Exclude rejected orders
                            if (status === "rejected") {
                                return;
                            }

                            // Exclude cancelled orders (cash and gcash)
                            const isCancellationConfirmed =
                                order.cancellationConfirmed === true ||
                                order.cancellation_confirmed === true ||
                                order.cancellation_confirmed === 1 ||
                                order.cancellation_confirmed === "true";
                            const hasRefundConfirmed =
                                order.refundConfirmedAt ||
                                order.refund_confirmed_at ||
                                order.refundConfirmedAt > 0 ||
                                order.refund_confirmed_at > 0;
                            const hasRefundDenied =
                                order.refundDenied === true ||
                                order.refund_denied === true ||
                                order.refundDenied === 1 ||
                                order.refund_denied === "true";
                            const hasRefundReceipt =
                                order.refundReceiptUrl || order.refund_receipt_url;
                            const isCancelled =
                                status === "cancelled" ||
                                isCancellationConfirmed ||
                                hasRefundConfirmed ||
                                hasRefundDenied ||
                                hasRefundReceipt;

                            if (isCancelled) {
                                return;
                            }

                            // Exclude failed orders if payment method is cash
                            if (
                                status === "failed" ||
                                status === "delivery_failed" ||
                                status === "failed_pickup"
                            ) {
                                if (
                                    paymentMethod === "cash" ||
                                    paymentMethod === "cod" ||
                                    paymentMethod === "cash_on_delivery" ||
                                    paymentMethod === "cash on delivery"
                                ) {
                                    return; // Exclude failed cash orders
                                }
                                // Include failed GCash orders
                                totalOrdersCount++;
                                const amount = Number(order.total || 0);
                                if (amount > 0) {
                                    totalSpentAmount += amount;
                                }
                                return;
                            }

                            // Include pending orders ONLY if payment method is GCash
                            if (status === "pending") {
                                if (paymentMethod === "gcash") {
                                    totalOrdersCount++;
                                    const amount = Number(order.total || 0);
                                    if (amount > 0) {
                                        totalSpentAmount += amount;
                                    }
                                }
                                return;
                            }

                            // Include these statuses regardless of payment method
                            if (
                                status === "confirmed" ||
                                status === "to_receive" ||
                                status === "out_for_delivery" ||
                                status === "pickup_ready" ||
                                status === "delivered" ||
                                status === "picked_up"
                            ) {
                                totalOrdersCount++;
                                const amount = Number(order.total || 0);
                                if (amount > 0) {
                                    totalSpentAmount += amount;
                                }
                                return;
                            }
                        });
                    }
                }
            } catch (error) {
                console.error("Error calculating customer orders and spending:", error);
            }

            // Update customer object with calculated values
            customer.totalOrders = totalOrdersCount;
            customer.totalSpent = totalSpentAmount;

            // Helper function to determine if URL is base64, Supabase URL, or file path
            const SUPABASE_URL = "https://afkwexvvuxwbpioqnelp.supabase.co";
            const SUPABASE_BUCKET = "customerid_image";

            const getImageUrl = (photoUrl) => {
                if (!photoUrl) return null;

                // Trim whitespace
                photoUrl = photoUrl.trim();

                console.log("ðŸ” Processing image URL for approved customer:", photoUrl);

                // Check if it's already a full URL (starts with http/https)
                if (photoUrl.startsWith("http://") || photoUrl.startsWith("https://")) {
                    // If it's already a Supabase public URL, use it directly
                    if (
                        photoUrl.includes("supabase.co") &&
                        photoUrl.includes("/storage/v1/object/public/")
                    ) {
                        console.log("âœ… Using existing Supabase public URL:", photoUrl);
                        // Fix duplicate bucket name if present: /customerid_image/customerid_image/ -> /customerid_image/
                        let cleanUrl = photoUrl.replace(
                            `/${SUPABASE_BUCKET}/${SUPABASE_BUCKET}/`,
                            `/${SUPABASE_BUCKET}/`
                        );
                        // Ensure URL is properly formatted - make sure there are no double slashes except after http(s):/
                        cleanUrl = cleanUrl.replace(/([^:]\/)\/+/g, "$1");
                        if (cleanUrl !== photoUrl) {
                            console.log("ðŸ”§ Fixed duplicate bucket name in URL:", cleanUrl);
                        }
                        return cleanUrl;
                    }
                    // If it's a Supabase URL but not in public format, try to fix it
                    if (
                        photoUrl.includes("supabase.co") &&
                        !photoUrl.includes("/storage/v1/object/public/")
                    ) {
                        // Extract file path from existing URL and reconstruct
                        const pathMatch = photoUrl.match(/customerid_image\/(.+)$/);
                        if (pathMatch) {
                            const filePath = pathMatch[1];
                            const publicUrl = `${SUPABASE_URL}/storage/v1/object/public/${SUPABASE_BUCKET}/${filePath}`;
                            console.log("ðŸ”§ Reconstructed Supabase public URL:", publicUrl);
                            return publicUrl;
                        }
                    }
                    console.log("âœ… Using existing full URL:", photoUrl);
                    return photoUrl;
                }

                // Check if it's base64 (starts with data:)
                if (photoUrl.startsWith("data:image/")) {
                    console.log("âœ… Using base64 data URL");
                    return photoUrl;
                }

                // Check if it looks like a file path (contains / but no ://)
                // Example: "customerId/front_1234567890.jpg" or "customerid_image/customerId/front_1234567890.jpg"
                if (photoUrl.includes("/") && !photoUrl.includes("://")) {
                    // Remove bucket name from path if it's already there (multiple times if needed)
                    let filePath = photoUrl;
                    while (filePath.startsWith(`${SUPABASE_BUCKET}/`)) {
                        filePath = filePath.substring(SUPABASE_BUCKET.length + 1);
                        console.log(
                            "ðŸ”§ Removed bucket prefix from path, remaining:",
                            filePath
                        );
                    }

                    // Remove storage/v1/object/public/customerid_image/ if somehow present
                    const storagePrefix = "storage/v1/object/public/customerid_image/";
                    if (filePath.includes(storagePrefix)) {
                        filePath = filePath.substring(
                            filePath.indexOf(storagePrefix) + storagePrefix.length
                        );
                        console.log("ðŸ”§ Removed storage prefix, remaining:", filePath);
                    }

                    // Construct Supabase public URL
                    // Split path and encode each segment separately, then join with /
                    const pathSegments = filePath.split("/");
                    const encodedSegments = pathSegments.map((segment) =>
                        encodeURIComponent(segment)
                    );
                    const encodedPath = encodedSegments.join("/");
                    const publicUrl = `${SUPABASE_URL}/storage/v1/object/public/${SUPABASE_BUCKET}/${encodedPath}`;
                    console.log("ðŸ”§ Constructed Supabase URL from path:", publicUrl);
                    return publicUrl;
                }

                // Check if it's a long base64 string (no http, no slashes, long length)
                if (
                    photoUrl.length > 100 &&
                    !photoUrl.includes("://") &&
                    !photoUrl.includes("/")
                ) {
                    console.log("âœ… Detected base64 string");
                    return `data:image/jpeg;base64,${photoUrl}`;
                }

                // If it's a simple filename without path, construct URL
                // Example: "front_123.jpg"
                const publicUrl = `${SUPABASE_URL}/storage/v1/object/public/${SUPABASE_BUCKET}/${photoUrl}`;
                console.log("ðŸ”§ Constructed Supabase URL from filename:", publicUrl);
                return publicUrl;
            };

            // Format dates
            let createdAt = "N/A";
            if (customer.createdAt) {
                const createdDate =
                    typeof customer.createdAt === "number"
                        ? new Date(customer.createdAt)
                        : new Date(customer.createdAt);
                createdAt = createdDate.toLocaleString();
            }

            let registrationDate = "N/A";
            if (customer.registrationDate || customer.createdAt) {
                const regDate =
                    typeof (customer.registrationDate || customer.createdAt) === "number"
                        ? new Date(customer.registrationDate || customer.createdAt)
                        : new Date(customer.registrationDate || customer.createdAt);
                registrationDate = regDate.toLocaleString();
            }

            let approvalDate = "N/A";
            if (customer.verificationDate || customer.approvedAt) {
                const appDate =
                    typeof (customer.verificationDate || customer.approvedAt) === "number"
                        ? new Date(customer.verificationDate || customer.approvedAt)
                        : new Date(customer.verificationDate || customer.approvedAt);
                approvalDate = appDate.toLocaleString();
            }

            let lastLogin = "N/A";
            if (customer.lastLogin) {
                const loginDate =
                    typeof customer.lastLogin === "number"
                        ? new Date(customer.lastLogin)
                        : new Date(customer.lastLogin);
                lastLogin = loginDate.toLocaleString();
            }

            let customerLastUpdated = null;
            if (customer.customerLastUpdatedAt || customer.customer_last_updated_at) {
                const lastUpdatedValue = customer.customerLastUpdatedAt || customer.customer_last_updated_at;
                const lastUpdatedDate =
                    typeof lastUpdatedValue === "number"
                        ? new Date(lastUpdatedValue)
                        : new Date(lastUpdatedValue);
                if (!isNaN(lastUpdatedDate.getTime())) {
                    customerLastUpdated = lastUpdatedDate.toLocaleString();
                }
            }

            let birthday = "N/A";
            if (customer.birthday || customer.birthDate || customer.birth_date) {
                const birthdayValue =
                    customer.birthday || customer.birthDate || customer.birth_date;
                let birthdayDate;

                // Handle different date formats
                if (typeof birthdayValue === "number") {
                    // Unix timestamp (milliseconds or seconds)
                    birthdayDate = new Date(
                        birthdayValue > 1000000000000 ? birthdayValue : birthdayValue * 1000
                    );
                } else if (typeof birthdayValue === "string") {
                    // Date string (YYYY-MM-DD or ISO format)
                    if (birthdayValue.includes("-")) {
                        birthdayDate = new Date(birthdayValue);
                    } else {
                        // Try parsing as timestamp
                        const timestamp = parseInt(birthdayValue);
                        if (!isNaN(timestamp)) {
                            birthdayDate = new Date(
                                timestamp > 1000000000000 ? timestamp : timestamp * 1000
                            );
                        } else {
                            birthdayDate = new Date(birthdayValue);
                        }
                    }
                } else {
                    birthdayDate = new Date(birthdayValue);
                }

                if (!isNaN(birthdayDate.getTime())) {
                    birthday = birthdayDate.toLocaleDateString("en-US", {
                        year: "numeric",
                        month: "long",
                        day: "numeric",
                    });
                }
            }

            // Build full address string
            const fullAddressDisplay = formatCustomerFullAddress(customer);

            // Status badge colors
            const accountStatus =
                customer.accountStatus || customer.status || "active";
            const isActive = accountStatus === "active";
            const statusText = isActive ? "Active" : "Inactive";
            const statusColor = isActive ? "#4caf50" : "#f44336";
            const statusBg = isActive ? "#e8f5e9" : "#ffebee";

            // Get ID photo URLs
            const frontImageUrl = customer.idFrontPhoto
                ? getImageUrl(customer.idFrontPhoto)
                : null;
            const backImageUrl = customer.idBackPhoto
                ? getImageUrl(customer.idBackPhoto)
                : null;
            const frontEscapedUrl = frontImageUrl
                ? frontImageUrl.replace(/'/g, "\\'").replace(/"/g, "&quot;")
                : "";
            const backEscapedUrl = backImageUrl
                ? backImageUrl.replace(/'/g, "\\'").replace(/"/g, "&quot;")
                : "";

            const isRejectedCustomer =
                (
                    customer.verificationStatus ||
                    customer.accountStatus ||
                    ""
                ).toLowerCase() === "rejected";
            let rejectionDateDisplay = "Not recorded";
            if (customer.rejectedAt) {
                const rejectionTs =
                    typeof customer.rejectedAt === "number"
                        ? customer.rejectedAt
                        : Date.parse(customer.rejectedAt);
                if (!Number.isNaN(rejectionTs)) {
                    rejectionDateDisplay = new Date(rejectionTs).toLocaleString();
                }
            }
            const rejectedByName =
                customer.rejectedByName || customer.rejectedBy || "Unknown reviewer";
            const rejectedByRole = customer.rejectedByRole || "";
            const rejectedByDisplay = rejectedByRole
                ? `${rejectedByName} Â· ${rejectedByRole}`
                : rejectedByName;
            const rejectionReasonDisplay =
                customer.rejectionReason || "No reason provided";
            const rejectionBanner = isRejectedCustomer
                ? `
                        <div style="border:1px solid #f44336; background:#ffebee; padding:16px; border-radius:8px; margin-bottom:24px;">
                            <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
                                <i class="fas fa-exclamation-triangle" style="color:#d32f2f;"></i>
                                <strong style="color:#b71c1c; font-size:15px;">Rejected Account</strong>
                            </div>
                            <p style="margin:4px 0;"><strong>Rejection Date:</strong> ${rejectionDateDisplay}</p>
                            <p style="margin:4px 0;"><strong>Rejected By:</strong> ${rejectedByDisplay}</p>
                            <p style="margin:4px 0;"><strong>Reason:</strong> <span style="color:#b71c1c;">${rejectionReasonDisplay}</span></p>
                        </div>
            `
                : "";
            const verifiedByName =
                customer.verifiedByName || customer.verifiedBy || "Not recorded";
            const verifiedByRole = customer.verifiedByRole || "";
            const verifiedByDisplay = verifiedByRole
                ? `${verifiedByName} Â· ${verifiedByRole}`
                : verifiedByName;
            const hasVerifier = Boolean(
                customer.verifiedByName || customer.verifiedBy
            );

            const modalContent = `
                <div class="modal-content scrollable-modal">
                    <div class="modal-header">
                        <h3>Customer Details</h3>
                        <button class="close-modal" onclick="staffManager.closeModal()">&times;</button>
                    </div>
                    <div style="padding: 24px; overflow-y: auto;">
                        ${rejectionBanner}
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px;">
                            <!-- Left Column - Personal & Account Information -->
                            <div>
                                <!-- Personal Information -->
                                <div style="margin-bottom: 24px;">
                                    <h4 style="margin: 0 0 16px 0; font-size: 16px; font-weight: 600; color: #333; border-bottom: 2px solid #e2e8f0; padding-bottom: 8px;">
                                        <i class="fas fa-user"></i> Personal Information
                                    </h4>
                                    <div style="display: flex; flex-direction: column; gap: 16px;">
                                        <div style="display: flex; flex-direction: column; gap: 4px;">
                                            <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Full Name</label>
                                            <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0; font-weight: 600;">${customer.fullName ||
                "Not specified"
                }</div>
                                        </div>
                                        <div style="display: flex; flex-direction: column; gap: 4px;">
                                            <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Email</label>
                                            <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0;">${customer.email || "Not specified"
                }</div>
                                        </div>
                                        <div style="display: flex; flex-direction: column; gap: 4px;">
                                            <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Username</label>
                                            <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0;">${customer.username || "Not set"
                }</div>
                                        </div>
                                        <div style="display: flex; flex-direction: column; gap: 4px;">
                                            <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Phone Number</label>
                                            <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0;">${customer.phoneNumber ||
                customer.phone ||
                "Not specified"
                }</div>
                                        </div>
                                        <div style="display: flex; flex-direction: column; gap: 4px;">
                                            <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Birthday</label>
                                            <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0;">${birthday}</div>
                                        </div>
                                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                                            <div style="display: flex; flex-direction: column; gap: 4px;">
                                                <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Age</label>
                                                <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0;">${customer.age ||
                "Not specified"
                }</div>
                                            </div>
                                            <div style="display: flex; flex-direction: column; gap: 4px;">
                                                <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Gender</label>
                                                <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0;">${customer.gender ||
                "Not specified"
                }</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Address Information -->
                                <div style="margin-bottom: 24px;">
                                    <h4 style="margin: 0 0 16px 0; font-size: 16px; font-weight: 600; color: #333; border-bottom: 2px solid #e2e8f0; padding-bottom: 8px;">
                                        <i class="fas fa-map-marker-alt"></i> Address Information
                                    </h4>
                                    <div style="display: flex; flex-direction: column; gap: 16px;">
                                        <div style="display: flex; flex-direction: column; gap: 4px;">
                                            <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Full Address</label>
                                            <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0; min-height: 60px; white-space: pre-wrap;">${fullAddressDisplay}</div>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Account Information -->
                                <div>
                                    <h4 style="margin: 0 0 16px 0; font-size: 16px; font-weight: 600; color: #333; border-bottom: 2px solid #e2e8f0; padding-bottom: 8px;">
                                        <i class="fas fa-info-circle"></i> Account Information
                                    </h4>
                                    <div style="display: flex; flex-direction: column; gap: 16px;">
                                        <div style="display: flex; flex-direction: column; gap: 4px;">
                                            <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Status</label>
                                            <div style="display: inline-flex; align-items: center; gap: 8px; padding: 6px 12px; background: ${statusBg}; color: ${statusColor}; border-radius: 6px; font-weight: 600; width: fit-content;">
                                                <i class="fas fa-circle" style="font-size: 8px;"></i>
                                                ${statusText.toUpperCase()}
                                            </div>
                                        </div>
                                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                                            <div style="display: flex; flex-direction: column; gap: 4px;">
                                                <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Total Orders</label>
                                                <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0; font-weight: 600;">${customer.totalOrders || 0
                }</div>
                                            </div>
                                            <div style="display: flex; flex-direction: column; gap: 4px;">
                                                <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Total Spent</label>
                                                <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0; font-weight: 600;">â‚±${Number(
                    customer.totalSpent || 0
                ).toLocaleString(undefined, {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2,
                })}</div>
                                            </div>
                                        </div>
                                        <div style="display: flex; flex-direction: column; gap: 4px;">
                                            <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Registration Date</label>
                                            <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0;">${registrationDate}</div>
                                        </div>
                                        ${customerLastUpdated !== null
                    ? `
                                        <div style="display: flex; flex-direction: column; gap: 4px;">
                                            <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Last Updated At</label>
                                            <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0;">${customerLastUpdated}</div>
                                        </div>
                                        `
                    : ""
                }
                                        ${approvalDate !== "N/A"
                    ? `
                                        <div style="display: flex; flex-direction: column; gap: 4px;">
                                            <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Approval Date</label>
                                            <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #d4e8d4; border-radius: 6px; border: 1px solid #4caf50; font-weight: 600; color: #2d4a2d;">${approvalDate}</div>
                                        </div>
                                        `
                    : ""
                }
                                        ${approvalDate !== "N/A" && hasVerifier
                    ? `
                                        <div style="display: flex; flex-direction: column; gap: 4px;">
                                            <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Approved By</label>
                                            <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #d4e8d4; border-radius: 6px; border: 1px solid #4caf50; font-weight: 600; color: #2d4a2d;">${verifiedByDisplay}</div>
                                        </div>
                                        `
                    : ""
                }
                                        ${lastLogin !== "N/A"
                    ? `
                                        <div style="display: flex; flex-direction: column; gap: 4px;">
                                            <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Last Login</label>
                                            <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0;">${lastLogin}</div>
                                        </div>
                                        `
                    : ""
                }
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Right Column - ID Information -->
                            <div>
                                <!-- ID Information -->
                                <div style="margin-bottom: 24px;">
                                    <h4 style="margin: 0 0 16px 0; font-size: 16px; font-weight: 600; color: #333; border-bottom: 2px solid #e2e8f0; padding-bottom: 8px;">
                                        <i class="fas fa-id-card"></i> ID Information
                                    </h4>
                                    <div style="display: flex; flex-direction: column; gap: 16px;">
                                        <div style="display: flex; flex-direction: column; gap: 4px;">
                                            <label style="font-size: 12px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">ID Type</label>
                                            <div style="font-size: 15px; color: #333; padding: 8px 12px; background: #f8fafc; border-radius: 6px; border: 1px solid #e2e8f0;">${customer.idType || "Not specified"
                }</div>
                                        </div>
                                        <div>
                                            <label style="display: block; font-size: 12px; font-weight: 600; color: #666; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">ID Front Photo</label>
                                            ${frontImageUrl
                    ? `<img src="${frontImageUrl}" 
                                                     alt="ID Front" 
                                                     class="customer-id-photo" 
                                                     data-image-src="${frontImageUrl}" 
                                                     style="width: 100%; max-width: 100%; max-height: 300px; object-fit: contain; border-radius: 8px; border: 2px solid #e2e8f0; cursor: pointer; transition: transform 0.2s ease; background: #f8fafc;" 
                                                     onmouseover="this.style.transform='scale(1.02)'" 
                                                     onmouseout="this.style.transform='scale(1)'"
                                                     onclick="if(window.staffManager && typeof window.staffManager.showEnlargedImage === 'function') { window.staffManager.showEnlargedImage('${frontEscapedUrl}', 'ID Front Photo'); }"
                                                     onerror="(function(img, url) {
                                                         console.error('âŒ Failed to load front ID photo');
                                                         img.onerror = null;
                                                         img.style.display = 'none';
                                                         const errorDiv = img.parentNode.querySelector('.image-error') || document.createElement('div');
                                                         errorDiv.className = 'image-error';
                                                         errorDiv.innerHTML = '<div style=\\'padding: 40px; text-align: center; background: #f8fafc; border: 2px dashed #e2e8f0; border-radius: 8px; color: #999;\\'><i class=\\'fas fa-image\\' style=\\'font-size: 32px; margin-bottom: 8px; display: block;\\'></i>Image failed to load</div>';
                                                         if (!img.parentNode.querySelector('.image-error')) {
                                                             img.parentNode.appendChild(errorDiv);
                                                         }
                                                     })(this, '${frontEscapedUrl}');" />`
                    : '<div style="padding: 40px; text-align: center; background: #f8fafc; border: 2px dashed #e2e8f0; border-radius: 8px; color: #999;"><i class="fas fa-image" style="font-size: 32px; margin-bottom: 8px; display: block;"></i>No photo available</div>'
                }
                                        </div>
                                        <div>
                                            <label style="display: block; font-size: 12px; font-weight: 600; color: #666; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">ID Back Photo</label>
                                            ${backImageUrl
                    ? `<img src="${backImageUrl}" 
                                                     alt="ID Back" 
                                                     class="customer-id-photo" 
                                                     data-image-src="${backImageUrl}" 
                                                     style="width: 100%; max-width: 100%; max-height: 300px; object-fit: contain; border-radius: 8px; border: 2px solid #e2e8f0; cursor: pointer; transition: transform 0.2s ease; background: #f8fafc;" 
                                                     onmouseover="this.style.transform='scale(1.02)'" 
                                                     onmouseout="this.style.transform='scale(1)'"
                                                     onclick="if(window.staffManager && typeof window.staffManager.showEnlargedImage === 'function') { window.staffManager.showEnlargedImage('${backEscapedUrl}', 'ID Back Photo'); }"
                                                     onerror="(function(img, url) {
                                                         console.error('âŒ Failed to load back ID photo');
                                                         img.onerror = null;
                                                         img.style.display = 'none';
                                                         const errorDiv = img.parentNode.querySelector('.image-error') || document.createElement('div');
                                                         errorDiv.className = 'image-error';
                                                         errorDiv.innerHTML = '<div style=\\'padding: 40px; text-align: center; background: #f8fafc; border: 2px dashed #e2e8f0; border-radius: 8px; color: #999;\\'><i class=\\'fas fa-image\\' style=\\'font-size: 32px; margin-bottom: 8px; display: block;\\'></i>Image failed to load</div>';
                                                         if (!img.parentNode.querySelector('.image-error')) {
                                                             img.parentNode.appendChild(errorDiv);
                                                         }
                                                     })(this, '${backEscapedUrl}');" />`
                    : '<div style="padding: 40px; text-align: center; background: #f8fafc; border: 2px dashed #e2e8f0; border-radius: 8px; color: #999;"><i class="fas fa-image" style="font-size: 32px; margin-bottom: 8px; display: block;"></i>No photo available</div>'
                }
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Action Buttons -->
                        <div style="margin-top: 24px; padding-top: 20px; border-top: 1px solid #e2e8f0; display: flex; gap: 12px; justify-content: flex-end;">
                            <button type="button" class="secondary-btn" onclick="staffManager.closeModal()">Close</button>
                        </div>
                    </div>
                </div>
            `;

            this.showModal(modalContent);

            // Set up image click handlers for lightbox
            setTimeout(() => {
                const idPhotos = document.querySelectorAll(".customer-id-photo");
                idPhotos.forEach((img) => {
                    img.addEventListener("click", (e) => {
                        e.stopPropagation();
                        const imageSrc = img.getAttribute("data-image-src");
                        if (
                            imageSrc &&
                            window.staffManager &&
                            typeof window.staffManager.showEnlargedImage === "function"
                        ) {
                            window.staffManager.showEnlargedImage(
                                imageSrc,
                                img.alt || "Customer ID Photo"
                            );
                        }
                    });
                });
            }, 100);
        } catch (error) {
            console.error("Error loading customer details:", error);
            alert("Error loading customer details: " + error.message);
        }
    }

    removeCustomerFromManagement(id) {
        this.removeCustomer(id); // Use existing removeCustomer method
        // The real-time listeners will automatically update the UI
    }

    async removeCustomer(id) {
        try {
            const activeOrders = await this.getActiveOrdersForCustomer(id);
            let proceed = false;
            if (activeOrders.length > 0) {
                // Modal already handles confirmation, so proceed directly if user confirmed
                proceed = await this.showActiveOrdersModal(id, "remove");
                if (!proceed) return;
            } else {
                // No active orders - show confirmation dialog
                const confirm = window.confirm("Are you sure you want to permanently remove this customer account? This action cannot be undone and will delete their authentication account. An email notification will be sent to the customer.");
                if (!confirm) return;
                proceed = true;
            }

            // Reject active orders and restore stock (only if there were active orders)
            if (activeOrders.length > 0) {
                await this.rejectActiveOrdersForCustomer(id, "Account Removed");
            }

            // Get current staff info
            const staffInfo = {
                uid: this.userUid || null,
                name: this.userName || 'AgriCart Staff',
                role: this.userRole || 'Staff'
            };

            // Use customerRejectionHandler to remove customer
            // This will:
            // 1. Get customer email
            // 2. Send email using Supabase invite format
            // 3. Delete from customer table
            // 4. Delete from Supabase auth.users
            if (window.customerRejectionHandler) {
                const result = await window.customerRejectionHandler.removeCustomer(
                    id,
                    'Your account has been removed by staff.',
                    staffInfo
                );

                this.showSuccessMessage(result.message || "Customer Successfully removed!");

                // Reload customers list and refresh orders
                await this.loadCustomersManagementData();
                if (window.OrderSupabaseAdapter && typeof window.OrderSupabaseAdapter.refresh === "function") {
                    await window.OrderSupabaseAdapter.refresh();
                }
                if (this.loadRejectedOrders) {
                    await this.loadRejectedOrders();
                }
                if (this.loadProducts) {
                    await this.loadProducts();
                }
            } else {
                // Fallback to old method if handler not available
                console.warn("customerRejectionHandler not available, using fallback method");

                // Get customer data to delete ID photos
                const customer = await CustomerHelpers.getCustomer(id);

                // Delete customer data from Supabase
                await CustomerHelpers.deleteCustomer(id);

                // Delete Firebase Auth account to free up email and phone number
                console.log("Deleting Firebase Auth account...");
                try {
                    await firebase.auth().deleteUser(id);
                    console.log("Successfully deleted Firebase Auth account");
                } catch (authError) {
                    console.warn(
                        `Could not delete Firebase Auth account for ${id}:`,
                        authError
                    );
                    // Continue even if auth deletion fails - the database records are already deleted
                }

                this.showSuccessMessage(
                    "Customer record and authentication account removed successfully. Email and phone number are now available for new registrations."
                );

                // Reload customers list and refresh orders
                await this.loadCustomersManagementData();
                if (window.OrderSupabaseAdapter && typeof window.OrderSupabaseAdapter.refresh === "function") {
                    await window.OrderSupabaseAdapter.refresh();
                }
                if (this.loadRejectedOrders) {
                    await this.loadRejectedOrders();
                }
                if (this.loadProducts) {
                    await this.loadProducts();
                }
            }
        } catch (error) {
            console.error("Error removing customer:", error);
            alert("Error removing customer: " + error.message);
        }
    }

    async fixCustomerEmails() {
        try {
            console.log("Starting to fix customers with missing emails...");

            // Get all customers from Supabase
            const customers = await CustomerHelpers.getAllCustomers();

            let fixedCount = 0;
            let skippedCount = 0;

            for (const [uid, customer] of Object.entries(customers)) {
                if (!customer.email || customer.email.trim() === "") {
                    console.log(
                        `Fixing customer ${customer.fullName} (${uid}) - missing email`
                    );

                    // Generate default email
                    let newEmail = "";
                    if (customer.phoneNumber && customer.phoneNumber.trim() !== "") {
                        newEmail = `${customer.phoneNumber}@agricart.local`;
                    } else if (customer.username && customer.username.trim() !== "") {
                        newEmail = `${customer.username}@agricart.local`;
                    } else {
                        newEmail = `${uid}@agricart.local`;
                    }

                    // Update customer record in Supabase
                    await CustomerHelpers.updateCustomer(uid, {
                        email: newEmail,
                        updatedAt: Date.now(),
                    });

                    console.log(`Fixed customer ${customer.fullName}: ${newEmail}`);
                    fixedCount++;
                } else {
                    skippedCount++;
                }
            }

            console.log(`\n=== Email Fix Complete ===`);
            console.log(`Fixed customers: ${fixedCount}`);
            console.log(`Skipped customers: ${skippedCount}`);
            console.log(
                `Total customers processed: ${Object.keys(customers).length}`
            );

            if (fixedCount > 0) {
                this.showSuccessMessage(
                    `Successfully fixed ${fixedCount} customers with missing emails!`
                );
                // Refresh the customer management data to show updated information
                await this.loadCustomersManagementData();
            } else {
                this.showSuccessMessage("No customers with missing emails found.");
            }
        } catch (error) {
            console.error("Error fixing customer emails:", error);
            this.showErrorMessage("Error fixing customer emails: " + error.message);
        }
    }

    // ============================================================================
    // STAFF ORDER NOTES FUNCTIONS
    // ============================================================================

    /**
     * Get current staff/admin name and role from session
     */
    getCurrentStaffInfo() {
        const name = sessionStorage.getItem('staffName') || 
                     sessionStorage.getItem('username') || 
                     sessionStorage.getItem('adminName') ||
                     'Staff';
        const role = sessionStorage.getItem('staffRole') || 
                     sessionStorage.getItem('role') || 
                     sessionStorage.getItem('adminRole') ||
                     'Staff';
        return { name, role };
    }

    /**
     * Get Supabase client
     */
    getSupabaseClient() {
        return window.getSupabaseClient
            ? window.getSupabaseClient()
            : window.supabaseClient || null;
    }

    /**
     * Fetch all staff notes for an order
     */
    async fetchStaffNotes(orderId) {
        try {
            const supabase = this.getSupabaseClient();
            if (!supabase) {
                console.warn("Supabase client not available");
                return [];
            }

            const { data, error } = await supabase
                .from('order_staff_notes')
                .select('*')
                .eq('order_id', orderId)
                .order('noted_at', { ascending: false });

            if (error) {
                console.error("Error fetching staff notes:", error);
                return [];
            }

            return data || [];
        } catch (error) {
            console.error("Error fetching staff notes:", error);
            return [];
        }
    }

    /**
     * Add a new staff note to an order
     */
    async addStaffNote(orderId, noteText) {
        try {
            if (!noteText || !noteText.trim()) {
                this.showErrorMessage("Note cannot be empty");
                return null;
            }

            const supabase = this.getSupabaseClient();
            if (!supabase) {
                this.showErrorMessage("Database connection error. Please refresh the page.");
                return null;
            }

            const { name, role } = this.getCurrentStaffInfo();
            const notedAt = Date.now();

            const { data, error } = await supabase
                .from('order_staff_notes')
                .insert({
                    order_id: orderId,
                    note_text: noteText.trim(),
                    noted_by_name: name,
                    noted_by_role: role,
                    noted_at: notedAt,
                    note_updated_by_name: null,
                    note_updated_by_role: null,
                    note_updated_at: null
                })
                .select()
                .single();

            if (error) {
                console.error("Error adding staff note:", error);
                this.showErrorMessage("Failed to add note: " + error.message);
                return null;
            }

            this.showSuccessMessage("Note added successfully");
            return data;
        } catch (error) {
            console.error("Error adding staff note:", error);
            this.showErrorMessage("Failed to add note: " + error.message);
            return null;
        }
    }

    /**
     * Update an existing staff note
     */
    async updateStaffNote(noteId, noteText) {
        try {
            if (!noteText || !noteText.trim()) {
                this.showErrorMessage("Note cannot be empty");
                return null;
            }

            const supabase = this.getSupabaseClient();
            if (!supabase) {
                this.showErrorMessage("Database connection error. Please refresh the page.");
                return null;
            }

            const { name, role } = this.getCurrentStaffInfo();
            const updatedAt = Date.now();

            const { data, error } = await supabase
                .from('order_staff_notes')
                .update({
                    note_text: noteText.trim(),
                    note_updated_by_name: name,
                    note_updated_by_role: role,
                    note_updated_at: updatedAt
                })
                .eq('id', noteId)
                .select()
                .single();

            if (error) {
                console.error("Error updating staff note:", error);
                this.showErrorMessage("Failed to update note: " + error.message);
                return null;
            }

            this.showSuccessMessage("Note updated successfully");
            return data;
        } catch (error) {
            console.error("Error updating staff note:", error);
            this.showErrorMessage("Failed to update note: " + error.message);
            return null;
        }
    }

    /**
     * Delete a staff note
     */
    async deleteStaffNote(noteId) {
        try {
            const supabase = this.getSupabaseClient();
            if (!supabase) {
                this.showErrorMessage("Database connection error. Please refresh the page.");
                return false;
            }

            const { error } = await supabase
                .from('order_staff_notes')
                .delete()
                .eq('id', noteId);

            if (error) {
                console.error("Error deleting staff note:", error);
                this.showErrorMessage("Failed to delete note: " + error.message);
                return false;
            }

            this.showSuccessMessage("Note deleted successfully");
            return true;
        } catch (error) {
            console.error("Error deleting staff note:", error);
            this.showErrorMessage("Failed to delete note: " + error.message);
            return false;
        }
    }

    /**
     * Format timestamp to readable date/time string
     */
    formatNoteTimestamp(timestamp) {
        if (!timestamp) return "N/A";
        try {
            const date = new Date(timestamp);
            return date.toLocaleString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                hour12: true
            });
        } catch (error) {
            return "N/A";
        }
    }

    /**
     * Show modal for adding/editing staff note
     */
    async showStaffNoteModal(orderId, noteId = null, existingText = '') {
        const isEdit = !!noteId;
        const modalContent = `
            <div class="modal-header">
                <h3><i class="fas fa-sticky-note"></i> ${isEdit ? 'Edit' : 'Add'} Staff Note</h3>
                <button class="close-modal">&times;</button>
            </div>
            <div class="modern-customer-details" style="padding: 20px;">
                <div class="form-field full-width">
                    <label class="required">Note</label>
                    <textarea id="staff-note-text" rows="5" style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; resize: vertical;">${this.esc(existingText)}</textarea>
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                    <button class="secondary-btn" onclick="this.closest('.modal').querySelector('.close-modal').click();" style="padding: 10px 20px;">
                        Cancel
                    </button>
                    <button class="primary-btn" id="save-staff-note-btn" style="padding: 10px 20px;">
                        <i class="fas fa-save"></i> ${isEdit ? 'Update' : 'Add'} Note
                    </button>
                </div>
            </div>
        `;

        this.showModal(modalContent);

        // Attach event listener
        const saveBtn = document.getElementById('save-staff-note-btn');
        if (saveBtn) {
            saveBtn.onclick = async () => {
                const noteText = document.getElementById('staff-note-text')?.value || '';
                if (isEdit) {
                    const success = await this.updateStaffNote(noteId, noteText);
                    if (success) {
                        this.closeModal();
                        // Refresh the order card to show updated notes
                        await this.refreshOrderCard(orderId);
                    }
                } else {
                    const success = await this.addStaffNote(orderId, noteText);
                    if (success) {
                        this.closeModal();
                        // Refresh the order card to show new note
                        await this.refreshOrderCard(orderId);
                    }
                }
            };
        }
    }

    /**
     * Refresh order card after note changes
     */
    async refreshOrderCard(orderId) {
        // Reload staff notes for this specific order card (more efficient than reloading entire list)
        await this.loadStaffNotesIntoCard(orderId);
    }

    /**
     * Load and inject staff notes into modal (for customer details modal)
     */
    async loadStaffNotesIntoModal(orderId) {
        try {
            const container = document.getElementById(`staff-notes-modal-container-${orderId}`);
            if (!container) return;

            const staffNotes = await this.fetchStaffNotes(orderId);
            const order = this._ordersCache && this._ordersCache[orderId] ? 
                         this._ordersCache[orderId] : 
                         (window.OrderSupabaseAdapter ? await window.OrderSupabaseAdapter.fetchOrderById(orderId) : null);
            
            if (!order) return;

            const deliveryOption = (order.deliveryOption || "").toLowerCase();
            const notesLabel = deliveryOption === "pickup" ? "Order/Pickup Notes" : "Order/Delivery Notes";

            let html = '';

            // Separator if customer notes exist
            const hasCustomerNotes = container.previousElementSibling && 
                                     container.previousElementSibling.querySelector('textarea[readonly]') &&
                                     container.previousElementSibling.querySelector('textarea[readonly]').value.trim();
            
            if (hasCustomerNotes && staffNotes.length > 0) {
                html += `
                    <div style="margin: 20px 0; border-top: 2px solid #e5e7eb; position: relative;">
                        <div style="position: absolute; top: -10px; left: 50%; transform: translateX(-50%); background: white; padding: 0 12px; color: #6b7280; font-size: 12px; font-weight: 600;">
                            Staff/Admin Notes
                        </div>
                    </div>
                `;
            }

            // Staff notes section
            html += `
                <div style="padding:16px; background:#f0f9ff; border-left:4px solid #3b82f6; border-radius:8px;">
                    <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:12px;">
                        <div style="display:flex; align-items:center; gap:10px;">
                            <i class="fas fa-user-tie" style="color:#3b82f6; font-size:16px;"></i>
                            <label style="margin:0; font-size:14px; font-weight:700; color:#1e40af;">${staffNotes.length > 0 ? notesLabel + ' (Staff/Admin)' : notesLabel}</label>
                        </div>
                        <button onclick="staffManager.showStaffNoteModal('${orderId}')" 
                                style="background:#3b82f6; color:white; border:none; padding:6px 12px; border-radius:6px; font-size:12px; font-weight:500; cursor:pointer; display:flex; align-items:center; gap:6px;">
                            <i class="fas fa-plus"></i> Add Note
                        </button>
                    </div>
            `;

            if (staffNotes.length > 0) {
                html += '<div style="display:flex; flex-direction:column; gap:12px;">';
                staffNotes.forEach((note) => {
                    const notedAt = this.formatNoteTimestamp(note.noted_at);
                    const updatedAt = note.note_updated_at ? this.formatNoteTimestamp(note.note_updated_at) : null;
                    const escapedNote = this.esc(note.note_text);
                    const escapedNotedBy = this.esc(note.noted_by_name);
                    const escapedNotedRole = this.esc(note.noted_by_role);
                    const escapedUpdatedBy = note.note_updated_by_name ? this.esc(note.note_updated_by_name) : '';
                    const escapedUpdatedRole = note.note_updated_by_role ? this.esc(note.note_updated_by_role) : '';
                    
                    html += `
                        <div style="background:#ffffff; padding:12px; border-radius:6px; border:1px solid #bfdbfe; position:relative;">
                            <div style="display:flex; justify-content:space-between; align-items:flex-start; gap:12px;">
                                <div style="flex:1;">
                                    <div style="color:#1e3a8a; font-size:13px; line-height:1.6; margin-bottom:8px;">
                                        ${escapedNote}
                                    </div>
                                    <div style="display:flex; flex-direction:column; gap:4px; font-size:11px; color:#64748b;">
                                        <div>
                                            <span style="font-weight:600;">Noted by:</span> ${escapedNotedBy} (${escapedNotedRole})
                                            <span style="margin-left:12px; font-weight:600;">Noted at:</span> ${notedAt}
                                        </div>
                                        ${updatedAt ? `
                                            <div>
                                                <span style="font-weight:600;">Updated by:</span> ${escapedUpdatedBy} (${escapedUpdatedRole})
                                                <span style="margin-left:12px; font-weight:600;">Updated at:</span> ${updatedAt}
                                            </div>
                                        ` : ''}
                                    </div>
                                </div>
                                <div style="display:flex; gap:6px;">
                                    <button onclick="staffManager.showStaffNoteModal('${orderId}', ${note.id}, ${JSON.stringify(note.note_text).replace(/"/g, '&quot;')})" 
                                            style="background:#10b981; color:white; border:none; padding:6px 10px; border-radius:4px; font-size:11px; cursor:pointer;" 
                                            title="Edit note">
                                        <i class="fas fa-edit"></i>
                                    </button>
                                    <button onclick="if(confirm('Are you sure you want to delete this note?')) { staffManager.deleteStaffNote(${note.id}).then(() => { staffManager.closeModal(); staffManager.viewOrderCustomerDetails('${orderId}', '${this.esc(order.customerName || "")}', '${this.esc(order.customerPhone || "")}', '${this.esc(order.deliveryAddress || "")}'); }); }" 
                                            style="background:#ef4444; color:white; border:none; padding:6px 10px; border-radius:4px; font-size:11px; cursor:pointer;" 
                                            title="Delete note">
                                        <i class="fas fa-trash"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                    `;
                });
                html += '</div>';
            } else {
                html += `
                    <div style="text-align:center; padding:20px; color:#64748b; font-size:13px;">
                        No staff notes yet. Click "Add Note" to add one.
                    </div>
                `;
            }

            html += '</div>';
            container.innerHTML = html;
        } catch (error) {
            console.error("Error loading staff notes into modal:", error);
        }
    }

    /**
     * Load and inject staff notes into order card after creation
     */
    async loadStaffNotesIntoCard(orderId) {
        try {
            const container = document.getElementById(`staff-notes-container-${orderId}`);
            if (!container) return; // Container doesn't exist (pickup orders don't have it)

            const staffNotes = await this.fetchStaffNotes(orderId);
            const orderCard = container.closest('[data-order-id]') || container.closest('.order-card');
            if (!orderCard) return;

            // Get order data from the card or fetch it
            const orderDataAttr = orderCard.getAttribute('data-order-data');
            let order = null;
            if (orderDataAttr) {
                try {
                    order = JSON.parse(orderDataAttr);
                } catch (e) {
                    console.warn("Could not parse order data from card");
                }
            }

            if (!order) {
                // Try to get from cache or fetch
                if (this._ordersCache && this._ordersCache[orderId]) {
                    order = this._ordersCache[orderId];
                } else if (window.OrderSupabaseAdapter) {
                    order = await window.OrderSupabaseAdapter.fetchOrderById(orderId);
                }
            }

            if (!order) return;

            const deliveryOption = (order.deliveryOption || "").toLowerCase();
            const isPickup = deliveryOption === "pickup";
            
            // Don't load staff notes for pickup orders
            if (isPickup) {
                container.innerHTML = '';
                return;
            }

            // Staff notes are always displayed for delivery orders, regardless of rider assignment or order status
            const hasRider = !!(order.riderId || order.rider_id || order.riderName || order.rider_name);

            // Only for delivery orders with assigned rider
            const notesLabel = "Order/Delivery Notes";
            const orderStatus = String(order.status || "").toLowerCase();
            const isToReceiveTab = orderStatus === "to_receive" || orderStatus === "out_for_delivery";
            
            // Check if order is completed (delivered or failed) - no add/edit/delete buttons for completed orders
            const isCompleted = orderStatus === "delivered" || orderStatus === "picked_up" || 
                               orderStatus === "failed" || orderStatus === "delivery_failed" || 
                               orderStatus === "failed_pickup";
            
            // Check if we should show Add Note button (only on To Receive tab, not for completed orders)
            const shouldShowAddButton = isToReceiveTab && !isCompleted;

            let html = '';

            // Check if customer notes exist (can be empty - staff can still add notes even if customer hasn't)
            const customerNotesContainer = document.getElementById(`order-notes-container-${orderId}`);
            const hasCustomerNotes = customerNotesContainer && (
                customerNotesContainer.querySelector('div[style*="background:#ffffff"]') ||
                customerNotesContainer.querySelector('div[style*="background:#fff7ed"]')
            );
            
            // Only show separator if both customer notes and staff notes exist
            if (hasCustomerNotes && staffNotes.length > 0) {
                html += `
                    <div style="margin-top:12px;"></div>
                `;
            }

            // Staff notes section - ALWAYS display if notes exist, regardless of order status
            // Notes are always shown for delivery orders (pending, successful/delivered, or failed)
            // Show section if notes exist OR if we can add notes (to_receive/out_for_delivery and not completed)
            if (staffNotes.length > 0 || shouldShowAddButton) {
                html += `
                    <div style="padding:12px; background:#ffffff; border:1px solid #e5e7eb; border-radius:6px; ${hasCustomerNotes ? 'margin-top:12px;' : ''}">
                        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:${staffNotes.length > 0 ? '12px' : '0'};">
                            <div style="font-size:13px; font-weight:600; color:#374151; display:flex; align-items:center; gap:6px;">
                                <i class="fas fa-user-tie" style="color:#6b7280; font-size:12px;"></i>
                                ${notesLabel} ${staffNotes.length > 0 ? '(Staff/Admin)' : ''}
                            </div>
                            ${shouldShowAddButton ? `
                                <button onclick="staffManager.showStaffNoteModal('${orderId}')" 
                                        style="background:#3b82f6; color:white; border:none; padding:6px 12px; border-radius:6px; font-size:12px; font-weight:500; cursor:pointer; display:flex; align-items:center; gap:6px;">
                                    <i class="fas fa-plus"></i> Add Note
                                </button>
                            ` : ''}
                        </div>
                `;

                if (staffNotes.length > 0) {
                    html += '<div style="display:flex; flex-direction:column; gap:12px;">';
                    staffNotes.forEach((note) => {
                        const notedAt = this.formatNoteTimestamp(note.noted_at);
                        const updatedAt = note.note_updated_at ? this.formatNoteTimestamp(note.note_updated_at) : null;
                        const escapedNote = this.esc(note.note_text);
                        const escapedNotedBy = this.esc(note.noted_by_name);
                        const escapedNotedRole = this.esc(note.noted_by_role);
                        const escapedUpdatedBy = note.note_updated_by_name ? this.esc(note.note_updated_by_name) : '';
                        const escapedUpdatedRole = note.note_updated_by_role ? this.esc(note.note_updated_by_role) : '';
                        
                        // Show edit/delete buttons only on To Receive tab and not for completed orders
                        const showEditDeleteButtons = isToReceiveTab && !isCompleted;
                        
                        html += `
                            <div style="background:#f9fafb; padding:12px; border-radius:6px; border:1px solid #e5e7eb; position:relative;">
                                <div style="display:flex; justify-content:space-between; align-items:flex-start; gap:12px;">
                                    <div style="flex:1;">
                                        <div style="color:#111827; font-size:13px; line-height:1.6; margin-bottom:8px; font-style:italic;">
                                            "${escapedNote}"
                                        </div>
                                        <div style="display:flex; flex-direction:column; gap:4px; font-size:11px; color:#64748b;">
                                            <div>
                                                <span style="font-weight:600;">Noted by:</span> ${escapedNotedBy} (${escapedNotedRole})
                                                <span style="margin-left:12px; font-weight:600;">Noted at:</span> ${notedAt}
                                            </div>
                                            ${updatedAt ? `
                                                <div>
                                                    <span style="font-weight:600;">Updated by:</span> ${escapedUpdatedBy} (${escapedUpdatedRole})
                                                    <span style="margin-left:12px; font-weight:600;">Updated at:</span> ${updatedAt}
                                                </div>
                                            ` : ''}
                                        </div>
                                    </div>
                                    ${showEditDeleteButtons ? `
                                        <div style="display:flex; gap:6px;">
                                            <button onclick="staffManager.showStaffNoteModal('${orderId}', ${note.id}, ${JSON.stringify(note.note_text).replace(/"/g, '&quot;')})" 
                                                    style="background:#10b981; color:white; border:none; padding:6px 10px; border-radius:4px; font-size:11px; cursor:pointer;" 
                                                    title="Edit note">
                                                <i class="fas fa-edit"></i>
                                            </button>
                                            <button onclick="if(confirm('Are you sure you want to delete this note?')) { staffManager.deleteStaffNote(${note.id}).then(() => staffManager.refreshOrderCard('${orderId}')); }" 
                                                    style="background:#ef4444; color:white; border:none; padding:6px 10px; border-radius:4px; font-size:11px; cursor:pointer;" 
                                                    title="Delete note">
                                                <i class="fas fa-trash"></i>
                                            </button>
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        `;
                    });
                    html += '</div>';
                } else if (shouldShowAddButton) {
                    html += `
                        <div style="text-align:center; padding:20px; color:#64748b; font-size:13px;">
                            No staff notes yet. Click "Add Note" to add one.
                        </div>
                    `;
                }
                
                html += '</div>';
            }

            container.innerHTML = html;
        } catch (error) {
            console.error("Error loading staff notes into card:", error);
        }
    }

    /**
     * Render order notes section (customer notes + staff notes)
     * Returns HTML string for the notes section
     * NOTE: This is kept for backward compatibility but staff notes are loaded separately
     */
    async renderOrderNotesSection(order, orderId) {
        const deliveryOption = (order.deliveryOption || "").toLowerCase();
        const notesLabel = deliveryOption === "pickup" ? "Order/Pickup Notes" : "Order/Delivery Notes";
        
        // Get customer notes (read-only)
        const rawCustomerNotes = order.order_notes || order.orderNotes || order.deliveryNotes || order.delivery_notes || "";
        const filteredCustomerNotes = this.filterCustomerNotes(rawCustomerNotes);
        
        // Fetch staff notes
        const staffNotes = await this.fetchStaffNotes(orderId);
        
        let html = '';
        
        // Customer notes section (if exists)
        if (filteredCustomerNotes) {
            html += `
                <div style="margin-bottom:20px; padding:16px; background:#fff7ed; border-left:4px solid #f59e0b; border-radius:8px;">
                    <div style="display:flex; align-items:center; gap:10px; margin-bottom:12px;">
                        <i class="fas fa-sticky-note" style="color:#f59e0b; font-size:16px;"></i>
                        <h5 style="margin:0; font-size:14px; font-weight:700; color:#9a3412;">${notesLabel} (Customer)</h5>
                    </div>
                    <div style="background:#ffffff; padding:12px; border-radius:6px; border:1px solid #fed7aa;">
                        <div style="color:#92400e; font-size:13px; line-height:1.5; font-style:italic;">
                            "${this.esc(filteredCustomerNotes)}"
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Separator if both customer and staff notes exist
        if (filteredCustomerNotes && staffNotes.length > 0) {
            html += `
                <div style="margin: 20px 0; border-top: 2px solid #e5e7eb; position: relative;">
                    <div style="position: absolute; top: -10px; left: 50%; transform: translateX(-50%); background: #f9fafb; padding: 0 12px; color: #6b7280; font-size: 12px; font-weight: 600;">
                        Staff/Admin Notes
                    </div>
                </div>
            `;
        }
        
        // Staff notes section
        if (staffNotes.length > 0 || !filteredCustomerNotes) {
            html += `
                <div style="margin-bottom:20px; padding:16px; background:#f0f9ff; border-left:4px solid #3b82f6; border-radius:8px;">
                    <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:12px;">
                        <div style="display:flex; align-items:center; gap:10px;">
                            <i class="fas fa-user-tie" style="color:#3b82f6; font-size:16px;"></i>
                            <h5 style="margin:0; font-size:14px; font-weight:700; color:#1e40af;">${staffNotes.length > 0 ? notesLabel + ' (Staff/Admin)' : notesLabel}</h5>
                        </div>
                        <button onclick="staffManager.showStaffNoteModal('${orderId}')" 
                                style="background:#3b82f6; color:white; border:none; padding:6px 12px; border-radius:6px; font-size:12px; font-weight:500; cursor:pointer; display:flex; align-items:center; gap:6px;">
                            <i class="fas fa-plus"></i> Add Note
                        </button>
                    </div>
            `;
            
            if (staffNotes.length > 0) {
                html += '<div style="display:flex; flex-direction:column; gap:12px;">';
                staffNotes.forEach((note) => {
                    const notedAt = this.formatNoteTimestamp(note.noted_at);
                    const updatedAt = note.note_updated_at ? this.formatNoteTimestamp(note.note_updated_at) : null;
                    
                    html += `
                        <div style="background:#ffffff; padding:12px; border-radius:6px; border:1px solid #bfdbfe; position:relative;">
                            <div style="display:flex; justify-content:space-between; align-items:flex-start; gap:12px;">
                                <div style="flex:1;">
                                    <div style="color:#1e3a8a; font-size:13px; line-height:1.6; margin-bottom:8px;">
                                        ${this.esc(note.note_text)}
                                    </div>
                                    <div style="display:flex; flex-direction:column; gap:4px; font-size:11px; color:#64748b;">
                                        <div>
                                            <span style="font-weight:600;">Noted by:</span> ${this.esc(note.noted_by_name)} (${this.esc(note.noted_by_role)})
                                            <span style="margin-left:12px; font-weight:600;">Noted at:</span> ${notedAt}
                                        </div>
                                        ${updatedAt ? `
                                            <div>
                                                <span style="font-weight:600;">Updated by:</span> ${this.esc(note.note_updated_by_name)} (${this.esc(note.note_updated_by_role)})
                                                <span style="margin-left:12px; font-weight:600;">Updated at:</span> ${updatedAt}
                                            </div>
                                        ` : ''}
                                    </div>
                                </div>
                                <div style="display:flex; gap:6px;">
                                    <button onclick="staffManager.showStaffNoteModal('${orderId}', ${note.id}, ${JSON.stringify(note.note_text).replace(/"/g, '&quot;')})" 
                                            style="background:#10b981; color:white; border:none; padding:6px 10px; border-radius:4px; font-size:11px; cursor:pointer;" 
                                            title="Edit note">
                                        <i class="fas fa-edit"></i>
                                    </button>
                                    <button onclick="if(confirm('Are you sure you want to delete this note?')) { staffManager.deleteStaffNote(${note.id}).then(() => staffManager.refreshOrderCard('${orderId}')); }" 
                                            style="background:#ef4444; color:white; border:none; padding:6px 10px; border-radius:4px; font-size:11px; cursor:pointer;" 
                                            title="Delete note">
                                        <i class="fas fa-trash"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                    `;
                });
                html += '</div>';
            } else {
                html += `
                    <div style="text-align:center; padding:20px; color:#64748b; font-size:13px;">
                        No staff notes yet. Click "Add Note" to add one.
                    </div>
                `;
            }
            
            html += '</div>';
        }
        
        return html;
    }
}

// Expose refreshSystemHealth globally for onclick handlers
window.refreshSystemHealth = function () {
    if (
        window.staffManager &&
        typeof window.staffManager.refreshSystemHealth === "function"
    ) {
        return window.staffManager.refreshSystemHealth();
    } else {
        console.warn("staffManager.refreshSystemHealth not available");
    }
};

// Initialize Staff Manager
const staffManager = new StaffManager();
window.staffManager = staffManager;

// Set up automatic harvest date updates
if (typeof staffManager.setupHarvestDateAutoUpdate === "function") {
    staffManager.setupHarvestDateAutoUpdate();
}

// Event delegation for QR buttons (works even when buttons are dynamically created)
document.addEventListener(
    "click",
    function (e) {
        const qrBtn = e.target.closest(".qr-generate-btn");
        if (qrBtn && qrBtn.dataset.orderId) {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            const orderId = qrBtn.dataset.orderId;
            console.log("QR button clicked for order:", orderId);
            if (
                window.staffManager &&
                typeof window.staffManager.openQrModal === "function"
            ) {
                try {
                    window.staffManager.openQrModal(orderId);
                } catch (error) {
                    console.error("Error opening QR modal:", error);
                    alert("Error opening QR modal: " + error.message);
                }
            } else {
                console.error("staffManager.openQrModal not available");
                alert("QR modal function not available. Please refresh the page.");
            }
        }
    },
    true
); // Use capture phase to ensure it fires before other handlers

// Initialize when DOM is ready
document.addEventListener("DOMContentLoaded", function () {
    if (window.staffManager) {
        window.staffManager.initialize();
        // Start the automatic transition scheduler
        window.staffManager.startAutoTransitionScheduler();

        // Initialize Firebase chat functionality
        if (typeof firebase !== "undefined" && firebase.database) {
            initializeFirebaseChat();
            loadConversationsFromFirebase();
        }
    }
});
// Render helper: paint pending orders list from an object of orders
function renderPendingOrdersFromObject(orders) {
    try {
        // Only render when Orders section is active to avoid off-screen races
        if (
            !(
                window.staffManager &&
                window.staffManager.currentSection === "order-management"
            )
        ) {
            return;
        }
        const container = document.getElementById("ordersContainer");
        if (!container) return;
        container.innerHTML = "";

        if (!orders || Object.keys(orders).length === 0) {
            container.innerHTML = '<p class="no-data">No orders found</p>';
            return;
        }

        const filteredOrders = Object.entries(orders).filter(([id, order]) => {
            if (!order) return false;
            const status = String(order.status || "").toLowerCase();
            // Strictly pending only
            return status === "pending";
        });

        if (filteredOrders.length === 0) {
            container.innerHTML = `
                <div style="text-align: center; padding: 40px 20px; color: #666;">
                    <i class="fas fa-inbox" style="font-size: 3rem; color: #ddd; margin-bottom: 16px;"></i>
                    <h3 style="margin-bottom: 8px; color: #999;">No Pending Orders</h3>
                    <p style="margin-bottom: 16px; color: #bbb;">All orders are either pending, confirmed, rejected, or cleared.</p>
                    <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; border-left: 4px solid #4CAF50;">
                        <p style="margin: 0; font-size: 0.9rem; color: #666;">
                            <i class="fas fa-info-circle"></i>
                            <strong>Note:</strong> Confirmed orders are managed in the \"Confirmed Orders\" module. Rejected orders are managed in the \"Order Records\" module.
                        </p>
                    </div>
                </div>
            `;
            return;
        }

        const infoNote = document.createElement("div");
        infoNote.style.cssText = `
            background: #e8f5e8;
            border: 1px solid #4CAF50;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 0.9rem;
            color: #2e7d32;
        `;
        infoNote.innerHTML = `
            <i class=\"fas fa-info-circle\"></i>
            <strong>Orders Module:</strong> This module handles pending orders only.
            Flow: Pending â†’ Confirm.
            After confirmation, orders move to the \"Confirmed Orders\" module for farmer assignment and delivery.
            Rejected orders are handled in the \"Order Records\" module.
        `;
        container.appendChild(infoNote);

        const sortedOrders = filteredOrders.sort(
            (a, b) => (b[1]?.createdAt || 0) - (a[1]?.createdAt || 0)
        );
        sortedOrders.forEach(([id, order]) => {
            if (
                window.staffManager &&
                typeof window.staffManager.createOrderCard === "function"
            ) {
                const item = window.staffManager.createOrderCard(id, order);
                container.appendChild(item);
            }
        });

        // Ensure QR codes are loaded for all rendered orders
        setTimeout(() => {
            sortedOrders.forEach(([id, order]) => {
                if (
                    window.staffManager &&
                    typeof window.staffManager.loadSavedQrForOrderCard === "function"
                ) {
                    window.staffManager.loadSavedQrForOrderCard(id);
                }
            });
        }, 300); // Small delay to ensure all DOM elements are ready
    } catch (e) {
        console.error("Error rendering pending orders:", e);
    }
}
// Real auto-refresh function that listens for new orders
function setupOrderAutoRefresh() {
    console.log("ðŸ”„ Setting up order auto-refresh...");

    if (!window.dbRefs || !window.dbRefs.orders) {
        console.error("Ã¢Å’ dbRefs.orders not available; will retry in 1s");
        if (!window.__ordersRetryTimer) {
            window.__ordersRetryTimer = setInterval(() => {
                if (window.dbRefs && window.dbRefs.orders) {
                    clearInterval(window.__ordersRetryTimer);
                    window.__ordersRetryTimer = null;
                    setupOrderAutoRefresh();
                }
            }, 1000);
        }
        return;
    }

    const seenOrderKeys = new Set();
    const lastKnownStatusByKey = {};

    let refreshTimeoutId = null;
    const scheduleRefresh = () => {
        if (refreshTimeoutId !== null) return;
        refreshTimeoutId = setTimeout(() => {
            refreshTimeoutId = null;
            if (window.staffManager?.loadOrders) {
                console.log("ðŸ”„ Orders changed â†’ refreshing pending list");
                window.staffManager.loadPendingOrders();
            }
        }, 200);
    };

    const pendingQuery = window.dbRefs.orders
        .orderByChild("status")
        .equalTo("pending");

    // Detach any previous listeners before attaching new ones
    if (window.__ordersChildAddedHandler && window.__ordersPendingQuery) {
        try {
            window.__ordersPendingQuery.off(
                "child_added",
                window.__ordersChildAddedHandler
            );
        } catch (_) { }
    }
    if (window.__ordersChildRemovedHandler && window.__ordersPendingQuery) {
        try {
            window.__ordersPendingQuery.off(
                "child_removed",
                window.__ordersChildRemovedHandler
            );
        } catch (_) { }
    }
    if (window.__ordersChildChangedHandler) {
        try {
            window.dbRefs.orders.off(
                "child_changed",
                window.__ordersChildChangedHandler
            );
        } catch (_) { }
    }
    if (window.__ordersAllAddedHandler) {
        try {
            window.dbRefs.orders.off("child_added", window.__ordersAllAddedHandler);
        } catch (_) { }
    }
    if (window.__ordersValueHandler) {
        try {
            window.dbRefs.orders.off("value", window.__ordersValueHandler);
        } catch (_) { }
    }

    const onChildAdded = (snapshot) => {
        const orderKey = snapshot.key;
        const order = snapshot.val() || {};
        if (seenOrderKeys.has(orderKey)) return;
        seenOrderKeys.add(orderKey);
        lastKnownStatusByKey[orderKey] = order.status;
        if (order && order.status === "pending") {
            scheduleRefresh();
        }
    };

    const onChildChanged = (snapshot) => {
        const orderKey = snapshot.key;
        const order = snapshot.val() || {};
        const previousStatus = lastKnownStatusByKey[orderKey];
        lastKnownStatusByKey[orderKey] = order.status;
        // Refresh when an order transitions into or out of 'pending'
        const isNowPending =
            !!order && String(order.status || "").toLowerCase() === "pending";
        const wasPending = previousStatus === "pending";
        if ((isNowPending && !wasPending) || (!isNowPending && wasPending)) {
            scheduleRefresh();
        }
    };

    // If a pending order node is removed, refresh the list
    const onChildRemoved = (snapshot) => {
        const orderKey = snapshot.key;
        if (seenOrderKeys.has(orderKey)) {
            seenOrderKeys.delete(orderKey);
        }
        delete lastKnownStatusByKey[orderKey];
        scheduleRefresh();
    };

    // Value listener on filtered pending orders to render immediately on any change
    const onPendingValue = (snapshot) => {
        try {
            const orders = snapshot && snapshot.val ? snapshot.val() || {} : {};
            if (typeof renderPendingOrdersFromObject === "function") {
                renderPendingOrdersFromObject(orders);
            } else if (
                window.staffManager &&
                typeof window.staffManager.loadOrders === "function"
            ) {
                // Fallback to throttled refresh if render helper is not defined
                scheduleRefresh();
            }
        } catch (_) {
            scheduleRefresh();
        }
    };

    pendingQuery
        .once("value")
        .then((snap) => {
            snap.forEach((child) => {
                seenOrderKeys.add(child.key);
                const val = child.val() || {};
                lastKnownStatusByKey[child.key] = val.status;
            });
            pendingQuery.on("child_added", onChildAdded);
            pendingQuery.on("child_removed", onChildRemoved);
            window.dbRefs.orders.on("child_changed", onChildChanged);
            // Also listen to value changes under the pending query for comprehensive updates
            pendingQuery.on("value", onPendingValue);
            // Fallback: listen to any new orders added (in case initial write lacks status)
            const onAllAdded = (snapshot) => {
                const val = snapshot.val() || {};
                if (val.status === "pending") {
                    scheduleRefresh();
                }
            };
            window.dbRefs.orders.on("child_added", onAllAdded);
            // Fallback 2: broad value listener (throttled) for any change under orders
            let lastValueEventAt = 0;
            const onValueAny = () => {
                const now = Date.now();
                if (now - lastValueEventAt < 500) return; // throttle
                lastValueEventAt = now;
                console.log("ðŸ”” orders/value change detected â†’ scheduling refresh");
                scheduleRefresh();
            };
            window.dbRefs.orders.on("value", onValueAny);
            window.__ordersChildAddedHandler = onChildAdded;
            window.__ordersChildChangedHandler = onChildChanged;
            window.__ordersChildRemovedHandler = onChildRemoved;
            window.__ordersAllAddedHandler = onAllAdded;
            window.__ordersValueHandler = onValueAny;
            window.__ordersPendingValueHandler = onPendingValue;
            window.__ordersPendingQuery = pendingQuery;
            console.log("âœ“ Pending orders listeners attached");
        })
        .catch((err) => {
            console.error("Ã¢Å’ Failed to prime pending orders keys:", err);
        });

    window.teardownOrderAutoRefresh = function teardownOrderAutoRefresh() {
        try {
            if (window.__ordersPendingQuery && window.__ordersChildAddedHandler) {
                window.__ordersPendingQuery.off(
                    "child_added",
                    window.__ordersChildAddedHandler
                );
            }
            if (window.__ordersChildChangedHandler) {
                window.dbRefs.orders.off(
                    "child_changed",
                    window.__ordersChildChangedHandler
                );
            }
            if (window.__ordersPendingQuery && window.__ordersChildRemovedHandler) {
                window.__ordersPendingQuery.off(
                    "child_removed",
                    window.__ordersChildRemovedHandler
                );
            }
            if (window.__ordersAllAddedHandler) {
                window.dbRefs.orders.off("child_added", window.__ordersAllAddedHandler);
            }
            if (window.__ordersValueHandler) {
                window.dbRefs.orders.off("value", window.__ordersValueHandler);
            }
            if (window.__ordersPendingQuery && window.__ordersPendingValueHandler) {
                window.__ordersPendingQuery.off(
                    "value",
                    window.__ordersPendingValueHandler
                );
            }
        } finally {
            window.__ordersPendingQuery = null;
            window.__ordersChildAddedHandler = null;
            window.__ordersChildChangedHandler = null;
            window.__ordersChildRemovedHandler = null;
            window.__ordersAllAddedHandler = null;
            window.__ordersValueHandler = null;
            window.__ordersPendingValueHandler = null;
            for (const key in lastKnownStatusByKey) {
                delete lastKnownStatusByKey[key];
            }
            seenOrderKeys.clear();
            if (refreshTimeoutId) {
                clearTimeout(refreshTimeoutId);
                refreshTimeoutId = null;
            }
        }
    };
}

// Manual refresh function for testing
window.manualRefresh = function () {
    console.log("ðŸ”„ Manual refresh triggered...");
    if (window.staffManager && window.staffManager.loadOrders) {
        window.staffManager.loadPendingOrders();
        console.log("âœ“ Manual refresh completed");
    } else {
        console.log("Ã¢Å’ StaffManager or loadOrders not available");
    }
};
window.testEverything = function () {
    console.log("ðŸ§ª Testing everything...");
    console.log("1. StaffManager:", !!window.staffManager);
    console.log("2. loadOrders:", !!window.staffManager?.loadOrders);
    console.log("3. dbRefs:", typeof dbRefs);
    console.log("4. dbRefs.orders:", !!dbRefs?.orders);
    console.log("5. simpleRefreshInterval:", !!window.simpleRefreshInterval);

    // Test database connection
    if (dbRefs?.orders) {
        dbRefs.orders
            .once("value")
            .then((snapshot) => {
                const orders = snapshot.val() || {};
                console.log("6. Database orders count:", Object.keys(orders).length);
                console.log("7. Sample order:", Object.values(orders)[0]);
            })
            .catch((error) => {
                console.error("6. Database error:", error);
            });
    }

    // Test loadOrders function
    if (window.staffManager?.loadOrders) {
        console.log("8. Testing loadOrders function...");
        try {
            window.staffManager.loadPendingOrders();
            console.log("8. loadOrders function works!");
        } catch (error) {
            console.error("8. loadOrders function error:", error);
        }
    }
};
// SUPER SIMPLE test - just try to refresh orders
window.simpleTest = function () {
    console.log("ðŸ§ª SUPER SIMPLE TEST: Just refreshing orders...");

    if (window.staffManager && window.staffManager.loadOrders) {
        console.log("âœ“ StaffManager and loadOrders exist, calling loadOrders...");
        window.staffManager.loadPendingOrders();
        console.log("âœ“ loadOrders called!");
    } else {
        console.log("Ã¢Å’ StaffManager or loadOrders not available");
        console.log("StaffManager:", !!window.staffManager);
        console.log("loadOrders:", !!window.staffManager?.loadOrders);
    }
};
// ULTRA BASIC test - just show a message
window.basicTest = function () {
    console.log("ðŸ§ª ULTRA BASIC TEST: This function works!");
    console.log("ðŸ§ª ULTRA BASIC TEST: Trying to refresh orders...");

    if (window.staffManager && window.staffManager.loadOrders) {
        console.log("ðŸ§ª ULTRA BASIC TEST: Calling loadOrders...");
        window.staffManager.loadPendingOrders();
        console.log("ðŸ§ª ULTRA BASIC TEST: loadOrders called successfully!");
    } else {
        console.log("ðŸ§ª ULTRA BASIC TEST: loadOrders not available");
    }
};
// Force start basic test function
window.startAutoRefresh = function () {
    console.log("ðŸš€ FORCE STARTING basic test...");

    // Clear any existing interval
    if (window.basicTestInterval) {
        clearInterval(window.basicTestInterval);
        console.log("ðŸ—‘ï¸ Cleared existing basic test interval");
    }

    // Start new basic test
    setupBasicTest();
    console.log("âœ“ Basic test force started");
};

// Stop basic test function
window.stopAutoRefresh = function () {
    console.log("â¹ï¸ STOPPING basic test...");
    if (window.basicTestInterval) {
        clearInterval(window.basicTestInterval);
        window.basicTestInterval = null;
        console.log("âœ“ Basic test stopped");
    } else {
        console.log(" No basic test interval to stop");
    }
};
// Add a simple refresh button to the orders page
function addRefreshButton() {
    console.log("ðŸ”˜ Adding refresh button...");

    // Create refresh button immediately - don't wait for containers
    const refreshButton = document.createElement("button");
    refreshButton.innerHTML = "ðŸ”„ Refresh Orders";
    refreshButton.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #4CAF50;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        z-index: 1000;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    `;

    refreshButton.onclick = () => {
        console.log("ðŸ”„ Manual refresh button clicked");
        if (window.staffManager && window.staffManager.loadOrders) {
            window.staffManager.loadPendingOrders();
            console.log("âœ… Manual refresh completed");
        } else {
            console.error("âŒ StaffManager or loadOrders not available");
        }
    };

    document.body.appendChild(refreshButton);
    console.log("âœ… Refresh button added IMMEDIATELY");
}

// Add demo user creation function for testing
window.createDemoStaffUser = async () => {
    try {
        console.log("Creating demo staff user...");

        // Create Firebase Auth user for staff
        const staffCredential = await firebase
            .auth()
            .createUserWithEmailAndPassword("staff@agricart.com", "staff123");

        console.log("Firebase Auth user created:", staffCredential.user.uid);

        // Create staff profile in database
        const staffData = {
            uid: staffCredential.user.uid,
            email: "staff@agricart.com",
            fullName: "Demo Staff Member",
            phone: "+1234567890",
            status: "active",
            accountStatus: "active",
            role: "staff",
            createdAt: firebase.database.ServerValue.TIMESTAMP,
            employeeId: "EMP001",
            department: "Operations",
        };

        await dbRefs.staff.child(staffCredential.user.uid).set(staffData);

        console.log("Staff profile created in database");
        alert(
            "Demo staff user created successfully!\nEmail: staff@agricart.com\nPassword: staff123"
        );
    } catch (error) {
        console.error("Error creating demo staff user:", error);
        if (error.code === "auth/email-already-in-use") {
            alert(
                "Demo staff user already exists!\nEmail: staff@agricart.com\nPassword: staff123"
            );
        } else {
            alert("Error creating demo staff user: " + error.message);
        }
    }
};
// Add the function to the console for easy access
console.log(
    "Demo staff user creation function available: createDemoStaffUser()"
);

// Add debug function for authentication status
window.checkAuthStatus = () => {
    console.log("=== Authentication Status Check ===");
    console.log("Firebase Auth current user:", firebase.auth().currentUser);
    console.log("Session storage staffUid:", sessionStorage.getItem("staffUid"));
    console.log(
        "Session storage staffName:",
        sessionStorage.getItem("staffName")
    );
    console.log(
        "Session storage authMethod:",
        sessionStorage.getItem("authMethod")
    );
    console.log("Session storage userRole:", sessionStorage.getItem("userRole"));

    // Check if staff exists in database
    const staffUid = sessionStorage.getItem("staffUid");
    if (staffUid) {
        dbRefs.staff
            .child(staffUid)
            .once("value")
            .then((snapshot) => {
                const staffData = snapshot.val();
                console.log("Staff data in database:", staffData);
            })
            .catch((error) => {
                console.error("Error fetching staff data:", error);
            });
    }

    console.log("=== End Authentication Status Check ===");
};
console.log(
    "Authentication status check function available: checkAuthStatus()"
);
// Add test function for farmer removal
window.testFarmerRemoval = async (farmerId) => {
    console.log("=== Testing Farmer Removal ===");
    console.log("Testing removal for farmer ID:", farmerId);

    try {
        // First, check if farmer exists
        const snapshot = await dbRefs.farmers.child(farmerId).once("value");
        const farmer = snapshot.val();
        console.log("Current farmer data:", farmer);

        if (!farmer) {
            console.error("Farmer not found");
            return;
        }

        // Try to update the farmer
        const updateData = {
            status: "removed",
            removedAt: FirebaseUtils.getTimestamp(),
            removedBy: sessionStorage.getItem("staffUid") || "staff",
        };

        console.log("Attempting update with data:", updateData);

        await dbRefs.farmers.child(farmerId).update(updateData);
        console.log("Update successful");

        // Verify the update
        const updatedSnapshot = await dbRefs.farmers.child(farmerId).once("value");
        const updatedFarmer = updatedSnapshot.val();
        console.log("Updated farmer data:", updatedFarmer);

        if (updatedFarmer && updatedFarmer.status === "removed") {
            console.log("âœ… Farmer removal test successful");
        } else {
            console.log("âŒ Farmer removal test failed - status not updated");
        }
    } catch (error) {
        console.error("âŒ Farmer removal test failed:", error);
    }

    console.log("=== End Testing Farmer Removal ===");
};

console.log(
    "Farmer removal test function available: testFarmerRemoval(farmerId)"
);
// Add function to show all farmers in database
window.showAllFarmers = async () => {
    console.log("=== All Farmers in Database ===");

    try {
        const snapshot = await dbRefs.farmers.once("value");
        const farmers = snapshot.val() || {};

        console.log("Total farmers in database:", Object.keys(farmers).length);

        Object.entries(farmers).forEach(([id, farmer]) => {
            console.log(`Farmer ID: ${id}`);
            console.log(`  Name: ${farmer.fullName}`);
            console.log(`  Status: ${farmer.status || "no status"}`);
            console.log(
                `  Verification Status: ${farmer.verificationStatus || "no verification status"
                }`
            );
            console.log(`  Created By: ${farmer.createdBy || "unknown"}`);
            console.log("  ---");
        });
    } catch (error) {
        console.error("Error fetching farmers:", error);
    }

    console.log("=== End All Farmers ===");
};

console.log("Show all farmers function available: showAllFarmers()");

// Add cleanup function for orphaned user records
window.cleanupOrphanedUserRecords = async () => {
    console.log("=== Starting Cleanup of Orphaned User Records ===");

    try {
        // Get all users
        const usersSnapshot = await dbRefs.users.once("value");
        const users = usersSnapshot.val() || {};

        let cleanedCount = 0;

        for (const [userId, userData] of Object.entries(users)) {
            // Skip admin account
            if (userId === "admin_001" || userData.role === "admin") {
                continue;
            }

            let shouldDelete = false;

            // Check if user is a staff member
            if (userData.role === "staff") {
                const staffSnapshot = await dbRefs.staff.child(userId).once("value");
                if (!staffSnapshot.exists()) {
                    shouldDelete = true;
                    console.log(`Orphaned staff user found: ${userId}`);
                }
            }
            // Check if user is a farmer
            else if (userData.role === "farmer") {
                const farmerSnapshot = await dbRefs.farmers.child(userId).once("value");
                if (!farmerSnapshot.exists()) {
                    shouldDelete = true;
                    console.log(`Orphaned farmer user found: ${userId}`);
                }
            }
            // Check if user is a customer
            else if (userData.role === "customer") {
                const customer = await CustomerHelpers.getCustomer(userId);
                if (!customer) {
                    shouldDelete = true;
                    console.log(`Orphaned customer user found: ${userId}`);
                }
            }

            if (shouldDelete) {
                await dbRefs.users.child(userId).remove();
                cleanedCount++;
                console.log(`Deleted orphaned user: ${userId}`);
            }
        }

        console.log(
            `Cleanup completed. Removed ${cleanedCount} orphaned user records.`
        );
        alert(`Cleanup completed. Removed ${cleanedCount} orphaned user records.`);
    } catch (error) {
        console.error("Error during cleanup:", error);
        alert("Error during cleanup: " + error.message);
    }

    console.log("=== End Cleanup ===");
};

console.log("Cleanup function available: cleanupOrphanedUserRecords()");

// Test function to check real-time listeners
window.testRealtimeListeners = function () {
    console.log("ðŸ§ª Testing real-time listeners...");
    console.log("ðŸ“Š Listeners count:", staffManager.listeners.length);
    console.log("ðŸ“ Current section:", staffManager.currentSection);

    // Test database connection
    dbRefs.orders
        .once("value")
        .then((snapshot) => {
            console.log("âœ… Database connection OK");
            console.log(
                "ðŸ“Š Orders in database:",
                Object.keys(snapshot.val() || {}).length
            );
        })
        .catch((error) => {
            console.error("âŒ Database connection failed:", error);
        });

    // Test manual loading
    console.log("ðŸ”„ Testing manual order loading...");
    staffManager.loadPendingOrders();

    console.log("âœ… Test completed. Check console for results.");
};

// Simple test function to manually refresh orders
window.refreshOrders = function () {
    console.log("ðŸ”„ Manual refresh triggered...");
    if (window.staffManager) {
        console.log("ðŸ“‹ Manually refreshing pending orders...");
        staffManager.loadPendingOrders();
        console.log("âœ… Manual refresh completed");
    } else {
        console.error("âŒ StaffManager not found");
    }
};

// Test function to simulate an order being placed
window.testInstantUpdate = function () {
    console.log("ðŸ§ª Testing instant update...");
    console.log("ðŸ“‹ Manually triggering order refresh...");
    if (window.staffManager) {
        staffManager.loadPendingOrders();
        console.log("âœ… Test completed - check if orders refreshed");
    } else {
        console.error("âŒ StaffManager not found");
    }
};

// Test function to simulate a new order being added to database
window.testNewOrder = function () {
    console.log("ðŸ§ª Testing new order simulation...");

    const testOrderId = "test_order_" + Date.now();
    const testOrder = {
        customerId: "test_customer",
        customerName: "Test Customer",
        customerPhone: "+1234567890",
        items: [{ name: "Test Product", quantity: 1, price: 10 }],
        total: 10,
        status: "pending",
        timestamp: firebase.database.ServerValue.TIMESTAMP,
        deliveryAddress: "Test Address",
    };

    console.log("ðŸ“ Creating test order:", testOrderId);
    dbRefs.orders
        .child(testOrderId)
        .set(testOrder)
        .then(() => {
            console.log("âœ… Test order created - watch for auto-refresh...");

            // Remove test order after 10 seconds
            setTimeout(() => {
                dbRefs.orders
                    .child(testOrderId)
                    .remove()
                    .then(() => {
                        console.log("ðŸ—‘ï¸ Test order removed");
                    });
            }, 10000);
        })
        .catch((error) => {
            console.error("âŒ Error creating test order:", error);
        });
};

// Debug function to check auto-refresh status
window.checkAutoRefreshStatus = function () {
    console.log("ðŸ” Checking auto-refresh status...");
    console.log("Firebase available:", typeof firebase !== "undefined");
    console.log("dbRefs available:", typeof dbRefs !== "undefined");
    console.log("dbRefs.orders:", dbRefs?.orders);
    console.log("Auto-refresh interval:", window.autoRefreshInterval);
    console.log("StaffManager:", window.staffManager);
    console.log("loadOrders function:", window.staffManager?.loadOrders);

    // Check current page
    const orderManagementSection = document.getElementById("order-management");
    const staffOverviewSection = document.getElementById("staff-overview");
    const isOnOrderPage =
        (orderManagementSection &&
            orderManagementSection.classList.contains("active")) ||
        (staffOverviewSection && staffOverviewSection.classList.contains("active"));
    console.log("Currently on order page:", isOnOrderPage);

    // Test database connection
    if (dbRefs?.orders) {
        dbRefs.orders
            .once("value")
            .then((snapshot) => {
                const orders = snapshot.val() || {};
                console.log("Current orders count:", Object.keys(orders).length);
                console.log("Sample order:", Object.values(orders)[0]);
            })
            .catch((error) => {
                console.error("Database connection error:", error);
            });
    }
};

// Force setup auto-refresh function
window.forceSetupAutoRefresh = function () {
    console.log("ðŸ”„ Force setting up auto-refresh...");

    // Clear existing auto-refresh if any
    if (window.autoRefreshInterval) {
        clearInterval(window.autoRefreshInterval);
        console.log("ðŸ—‘ï¸ Cleared existing auto-refresh interval");
    }

    // Set up new auto-refresh
    setupSimpleAutoRefresh();
    console.log("âœ… Auto-refresh force-setup completed");
};
// TEST FUNCTION - Call this from browser console to test real-time updates
window.testRealtimeUpdates = () => {
    console.log("ðŸ§ª Testing real-time updates...");

    // Test 1: Check if StaffManager exists
    console.log(
        "1. StaffManager exists:",
        typeof window.staffManager !== "undefined"
    );

    // Test 2: Check if dbRefs exists
    console.log("2. dbRefs exists:", typeof dbRefs !== "undefined");
    console.log("3. dbRefs.orders:", dbRefs.orders);

    // Test 3: Check current section
    console.log(
        "4. Current section:",
        window.staffManager
            ? window.staffManager.currentSection
            : "StaffManager not found"
    );

    // Test 4: Check listeners
    console.log(
        "5. Active listeners:",
        window.staffManager
            ? window.staffManager.listeners.length
            : "StaffManager not found"
    );

    // Test 5: Try to create a test order
    console.log("6. Creating test order...");
    const testOrderId = "test_" + Date.now();
    const testOrder = {
        id: testOrderId,
        customerEmail: "test@test.com",
        customerName: "Test Customer",
        status: "pending",
        items: [{ name: "Test Product", quantity: 1, price: 10 }],
        total: 10,
        timestamp: firebase.database.ServerValue.TIMESTAMP,
    };

    dbRefs.orders
        .child(testOrderId)
        .set(testOrder)
        .then(() => {
            console.log("âœ… Test order created:", testOrderId);
            console.log("ðŸ” Watch console for real-time updates...");

            // Remove test order after 5 seconds
            setTimeout(() => {
                dbRefs.orders
                    .child(testOrderId)
                    .remove()
                    .then(() => {
                        console.log("ðŸ—‘ï¸ Test order removed");
                    });
            }, 5000);
        })
        .catch((error) => {
            console.error("âŒ Error creating test order:", error);
        });

    return "Test initiated - check console for results";
};

// MANUAL REFRESH FUNCTION - Use this to manually refresh orders
window.manualRefreshOrders = () => {
    console.log("ðŸ”„ Manual refresh orders...");
    if (window.staffManager) {
        window.staffManager.loadPendingOrders();
        console.log("âœ… Manual refresh completed");
    } else {
        console.error("âŒ StaffManager not found");
    }
};

// GLOBAL FUNCTION - Called from HTML onclick
window.switchToSection = (sectionId) => {
    console.log("ðŸŒ switchToSection called with:", sectionId);
    if (window.staffManager) {
        window.staffManager.switchSection(sectionId);
    } else {
        console.error("âŒ StaffManager not found");
    }
};
// EMERGENCY REFRESH BUTTON - Add this to the page
window.addEmergencyRefreshButton = () => {
    // Create refresh button
    const refreshBtn = document.createElement("button");
    refreshBtn.innerHTML = "ðŸ”„ REFRESH ORDERS NOW";
    refreshBtn.style.cssText = `
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 9999;
        background: #ff4444;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    `;

    refreshBtn.onclick = () => {
        console.log("ðŸš¨ EMERGENCY REFRESH BUTTON CLICKED");
        if (window.staffManager && window.staffManager.loadOrders) {
            window.staffManager.loadPendingOrders();
        } else {
            window.location.reload();
        }
    };

    document.body.appendChild(refreshBtn);
    console.log("âœ… Emergency refresh button added to top-right corner");
};

// TEST AUTO-REFRESH - Call this to test if auto-refresh is working
window.testAutoRefresh = () => {
    console.log("ðŸ§ª Testing auto-refresh...");
    if (window.staffManager) {
        console.log("Current section:", window.staffManager.currentSection);
        console.log(
            "Auto-refresh interval:",
            window.staffManager.autoRefreshInterval ? "Running" : "Not running"
        );

        // Force start auto-refresh
        window.staffManager.startAutoRefresh();
        console.log("âœ… Auto-refresh started manually");
    } else {
        console.error("âŒ StaffManager not found");
    }
};

